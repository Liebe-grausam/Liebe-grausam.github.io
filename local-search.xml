<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>函数依赖最小覆盖</title>
    <link href="/2024/05/15/%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86/"/>
    <url>/2024/05/15/%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/icurious/article/details/51240114">csdn链接</a><br><strong>计算最小函数依赖集步骤：</strong><br>① 用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；<br>② 去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，看X+是否包含Y，若是，则去掉X→Y；否则不能去掉，依次做下去。直到找不到冗余的函数依赖；<br>③去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。例如XY→A，若要判Y为多余的，则以X→A代替XY→A是否等价？若A∈(X)+，则Y是多余属性，可以去掉。<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.jpg" alt="最小覆盖"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3NF分解</title>
    <link href="/2024/05/15/3NF%E5%88%86%E8%A7%A3/"/>
    <url>/2024/05/15/3NF%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/538080461">知乎链接</a><br><strong>3NF分解步骤</strong>：</p><ol><li>先求出正则覆盖Fc</li><li>对于Fc里面的所有函数依赖a-&gt;b,均转化为Ri&#x3D;ab</li><li>对于所有的模式Ri<br> ①如果包含候选码，进行4.<br> ②如果都不包含候选码， 将任意一个候选码添加到模式Ri里面</li><li>如果一个模式被另一个模式包含，则去掉此被包含的模式。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BCNF分解</title>
    <link href="/2024/05/15/%E7%BB%99%E5%87%BA%E4%BF%9D%E6%8C%81%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E5%88%86%E8%A7%A3/"/>
    <url>/2024/05/15/%E7%BB%99%E5%87%BA%E4%BF%9D%E6%8C%81%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>输入：关系R0和其上的函数依赖集S0<br>输出：由R0分解出的关系集合，其中每个关系均属于BCNF<br>方法：下列步骤可以被递归地用于任意关系R和FD集合S。初始时，R&#x3D;R0，S&#x3D;S0。</p><p>检验R是否属于BCNF。如果是，不需要做任何事，返回{R}作为结果。<br>如果存在BCNF违例，假设为X→Y。计算X+。选择R1&#x3D;X+作为一个关系模式，并使另一个关系模式R2包含属性X以及那些不在X+中的属性。<br>（对于R2，它将包含所有不在X+中的属性，因此X → Y 的函数依赖不会存在于R2中，因为X已经被分解到了R1中。所以，R2一定是满足BCNF的。）<br>计算R1和R2的FD集，分别记为S1和S2。<br>递归地分解R1和R2。返回这些分解得到的结果集合。</p><h3 id="通俗的描述"><a href="#通俗的描述" class="headerlink" title="通俗的描述"></a>通俗的描述</h3><p>当一个关系模式违反BCNF时，意味着存在非平凡的函数依赖，其左侧不是任何候选键的超键。</p><p>具体来说，一个关系模式违反BCNF的条件是：</p><p>存在一个非平凡的函数依赖X → Y。<br>X 不是任何候选键的超键。<br>如果存在这样的函数依赖，那么该关系模式就违反了BCNF。</p><h3 id="什么是超键"><a href="#什么是超键" class="headerlink" title="什么是超键"></a>什么是超键</h3><p>候选键的超键是以候选键为子集的超键。</p><p>一个候选键是能够唯一标识关系中的每个元组的最小属性集合。而一个超键是能够唯一标识关系中的每个元组的任意属性集合。</p><p>因此，候选键的超键必然包含了候选键本身，以及候选键的任何真子集。因为候选键本身已经能够唯一标识关系中的每个元组，所以任何包含候选键的超键也能够唯一标识关系中的每个元组。</p><p>举个例子，如果 {A, B} 是一个候选键，那么 {A, B} 和 {A, B, C} 都是候选键的超键，因为它们包含了候选键 {A, B}。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://blog.csdn.net/weixin_42319408/article/details/92066595">例题链接跳转</a><br>如：R(A,B,C,D,E) FD{AB→C,DE→C,B→D}<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/BCNF%E5%88%86%E8%A7%A3%E4%BE%8B%E9%A2%98.jpg" alt="BCNF分解例题"><br>R(ABCDE), F &#x3D; { AB → C, B → D, CD →  E , CE → B , AC → B }<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BD%9C%E4%B8%9A%E4%BE%8B%E9%A2%98.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二战xhs笔试</title>
    <link href="/2024/05/14/%E4%BA%8C%E6%88%98xhs%E7%AC%94%E8%AF%95/"/>
    <url>/2024/05/14/%E4%BA%8C%E6%88%98xhs%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>后续：三道编程题，第一道是签到题（和上次考的第一道一模一样，就是给一堆浏览记录，然后去重，根据第一次浏览的顺序打印，100%AK</p><p>第二道是新书推广计划（漏看的条件和上次考的时候一模一样，，也是最后15分钟突然发现，<br>【最好笑的是除了第一个样例以外其他的都过了，幸好克服了心态问题，试着提交了，91%，下次记得多留存档】<br>【甚至下面写的代码样例也是审题审错了的版本</p><p>第三道是遗失的记忆（回溯，没复习到，考前仓促看了一点思路，现写的，正确率15%以下</p><h3 id="1-博主送礼物"><a href="#1-博主送礼物" class="headerlink" title="1. 博主送礼物"></a>1. 博主送礼物</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E5%8D%9A%E4%B8%BB%E9%80%81%E7%A4%BC%E7%89%A9.png" alt="博主送礼物"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 定义一个类，比结构体好用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fan</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-comment">// sum=like+star*2</span><br>    <span class="hljs-type">int</span> like;<br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-comment">// 定义一个fan的构造函数</span><br>    <span class="hljs-built_in">fan</span>(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> i)&#123;<br>        sum = s;<br>        like = l;<br>        index = i;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(fan a, fan b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.sum != b.sum)&#123;<br>        <span class="hljs-keyword">return</span> a.sum&gt;b.sum;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a.like != b.like)&#123;<br>        <span class="hljs-keyword">return</span> a.like&gt;b.like;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.index&lt;b.index;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    <span class="hljs-type">int</span> like,star,sum;<br>    <span class="hljs-comment">// n=4;</span><br>    <span class="hljs-comment">// k=2;</span><br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-comment">// vector&lt;fan&gt;fans(n);</span><br>    <span class="hljs-comment">// 采用这一条会报错是因为没有对于空值的构造函数，所以慢慢push_back就好</span><br>    vector&lt;fan&gt;fans;<br>    vector&lt;<span class="hljs-type">int</span>&gt;num;<br><br>    <span class="hljs-comment">// fans[1]=fan(1+2*2,1,1);</span><br>    <span class="hljs-comment">// fans[2]=fan(2+1*2,2,2);</span><br>    <span class="hljs-comment">// fans[3]=fan(3,3,3);</span><br>    <span class="hljs-comment">// fans[4]=fan(1+2*3,1,4);</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;like&gt;&gt;star;<br>        sum = like+star*<span class="hljs-number">2</span>;<br>        fans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">fan</span>(sum,like,i+<span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(fans.<span class="hljs-built_in">begin</span>(),fans.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-comment">// 记得sort的时候要写begin end</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-comment">// 最后编号也要按升序输出，所以要再处理一下</span><br>        <span class="hljs-comment">// cout&lt;&lt;fans[i].index&lt;&lt;endl;</span><br>        num.<span class="hljs-built_in">push_back</span>(fans[i].index);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(),num.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        cout&lt;&lt;num[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-H小姐的新书推广计划"><a href="#2-H小姐的新书推广计划" class="headerlink" title="2. H小姐的新书推广计划"></a>2. H小姐的新书推广计划</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E6%96%B0%E4%B9%A6%E6%8E%A8%E5%B9%BF%E8%AE%A1%E5%88%92.png" alt="新书推广计划"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">a</span>(n);<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">t</span>(n);<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(x+<span class="hljs-number">1</span>,INT_MAX);<br>    <span class="hljs-comment">// vector数组在定义的时候就可以初始化</span><br>    <br>    <span class="hljs-comment">// 调试数据</span><br>    <span class="hljs-comment">// n=5;</span><br>    <span class="hljs-comment">// x=8;</span><br>    <span class="hljs-comment">// vector&lt;int&gt;a=&#123;1,2,3,4,10&#125;;</span><br>    <span class="hljs-comment">// vector&lt;int&gt;t=&#123;0,1,1,2,5&#125;;</span><br>    <br>    <br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 达到0粉丝数成本为0</span><br>    <span class="hljs-comment">// 不需要赋值dp[a[i]],dp[t[i]]，让他们全都回归初心就行 </span><br>    <span class="hljs-comment">// 我们不需要给a[i]、t[i]排序，只需要减一下就行，而且只减一遍！！！</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">// 逆序遍历即可，记得加前置条件，否则会计算溢出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y=x;y&gt;=t[i];y--)&#123;<br>            <span class="hljs-keyword">if</span> (dp[y - t[i]] != INT_MAX) dp[y]=<span class="hljs-built_in">min</span>(dp[y],dp[y-t[i]]+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y=x;y&gt;=a[i];y--)&#123;<br>            <span class="hljs-comment">// 记得循环遍历的边界条件要等于a[i]，，太好笑了</span><br>             <span class="hljs-keyword">if</span> (dp[y - a[i]] != INT_MAX) dp[y]=<span class="hljs-built_in">min</span>(dp[y],dp[y-a[i]]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>    &#125;<br>    cout&lt;&lt;dp[x]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-H小姐的旅行笔记"><a href="#3-H小姐的旅行笔记" class="headerlink" title="3. H小姐的旅行笔记"></a>3. H小姐的旅行笔记</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E6%97%85%E8%A1%8C%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%89.png" alt="旅行笔记精选"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-comment">// 记得priorityqueue头文件</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">article</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 记得写public</span><br>    <span class="hljs-type">int</span> like;<br>    <span class="hljs-type">int</span> comment;<br>    <span class="hljs-built_in">article</span>(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> c)&#123;<br>        like=l;<br>        comment=c;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(article a,article b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.comment&gt;b.comment;<br>    <span class="hljs-comment">// 记得降序</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">likes</span>(n);<br>    <span class="hljs-type">int</span> comment;<br>    vector&lt;article&gt;articles;<br>    <span class="hljs-comment">// 记得不要直接声明大小，没有空值的构造函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;likes[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;comment;<br>        articles.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">article</span>(likes[i],comment));<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(articles.<span class="hljs-built_in">begin</span>(),articles.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-comment">// 记得格式</span><br>    priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt;pq;<br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> best = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>()&lt;k)&#123;<br>            pq.<span class="hljs-built_in">push</span>(articles[i].like);<br>            total+=articles[i].like;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">top</span>()&lt;articles[i].like)&#123;<br>            total+=articles[i].like-pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(articles[i].like);<br>            best = <span class="hljs-built_in">max</span>(best,total*articles[i].comment);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;best&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-点赞数之和最小"><a href="#4-点赞数之和最小" class="headerlink" title="4. 点赞数之和最小"></a>4. 点赞数之和最小</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E7%82%B9%E8%B5%9E%E6%95%B0%E4%B9%8B%E5%92%8C.png" alt="点赞数之和"><br>来不及写了，看一下二分思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> total_likes = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max_likes = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">likes</span><span class="hljs-params">(n)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; likes[i];<br>        total_likes += likes[i];<br>        max_likes = <span class="hljs-built_in">max</span>(max_likes, likes[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> like : likes) &#123;<br>            <span class="hljs-keyword">if</span> (like != max_likes)<br>                cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; like &lt;&lt; endl;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (likes[i] == max_likes)<br>                <span class="hljs-comment">// 有一篇和他一样也行，也算最大</span><br>                cout &lt;&lt; total_likes &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> L = max_likes;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> R = <span class="hljs-number">1e12</span>;<br>                <span class="hljs-comment">// mid值是该博客最后要达到的点赞值</span><br>                <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = (L + R) / <span class="hljs-number">2</span>;<br>                    <span class="hljs-comment">// 这个条件是说 博客还需要点赞的次数是点赞其他博客总次数+1</span><br>                    <span class="hljs-comment">// 而点赞其他博客的总次数肯定小于等于（记得这里有等于）把每篇都点到mid（最大值）的次数</span><br>                    <span class="hljs-keyword">if</span> (mid - likes[i] &lt;= mid * (n - <span class="hljs-number">1</span>) - (total_likes - likes[i]) + <span class="hljs-number">1</span>)<br>                        R = mid;<br>                    <span class="hljs-keyword">else</span><br>                        L = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>                cout &lt;&lt; total_likes + (L - likes[i]) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>xhs笔试复盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>停水时间到</title>
    <link href="/2024/05/12/%E5%81%9C%E6%B0%B4%E6%97%B6%E9%97%B4%E5%88%B0/"/>
    <url>/2024/05/12/%E5%81%9C%E6%B0%B4%E6%97%B6%E9%97%B4%E5%88%B0/</url>
    
    <content type="html"><![CDATA[<p>一天中最喜欢的就是洗澡的时间<br>和等待洗澡的时间<br>我躲在帘子后面轻声哼唱<br>（空荡的易碎品）<br>脑袋空空循环播放着旋律<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>要多少才叫足够<br>怎样才能真正满意<br>我追逐着一些很重要的东西<br>也有一些没有那么重要的东西<br>“菜就多练”  他们是这么讲的<br>明明那些都属于我<br>我讨厌夺走 夺走<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>我追逐着他们的背影<br>他们告诉我该这样做该那样做<br>什么时候才可以不用撒谎呢<br>什么时候才可以分享快乐呢<br>什么时候才能不孤独呢<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>无比渴望存在证明<br>我的耳朵停止了吼叫<br>也许这样已经足够了吧<br>（呀 停水时间到）</p>]]></content>
    
    
    
    <tags>
      
      <tag>写点歌词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载知乎-kafka面试题</title>
    <link href="/2024/05/10/%E8%BD%AC%E8%BD%BD%E7%9F%A5%E4%B9%8E-kafka%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/05/10/%E8%BD%AC%E8%BD%BD%E7%9F%A5%E4%B9%8E-kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-为什么要使用-kafka，为什么要使用消息队列？"><a href="#1-为什么要使用-kafka，为什么要使用消息队列？" class="headerlink" title="1. 为什么要使用 kafka，为什么要使用消息队列？"></a>1. 为什么要使用 kafka，为什么要使用消息队列？</h3><p>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。<br>解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。<br>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。<br>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。<br>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h3 id="2-Kafka的常用组件有哪些？"><a href="#2-Kafka的常用组件有哪些？" class="headerlink" title="2. Kafka的常用组件有哪些？"></a>2. Kafka的常用组件有哪些？</h3><p>producer：消息的生产者, 自己决定哪个 partions 中生产消息, 两种机制:hash 与 轮询。<br>consumer：通过 zookeeper 进行维护消费者偏移量, consumer有自己的消费组,不同组之间维护同一个 topic 数据,互不影响.相同组的不同 consumer消费同一个 topic,这个 topic相同的数据只被消费一次。<br>broker：broker 组成 kafka 集群的节点,之间没有主从关系, 依赖 zookeeper进行协调, broker 负责消息的读写与存储, 一个 broker可以管理读个 partionstopic：一类消息的总称&#x2F;消息队里, topic是由 partions组成, 一个 topic 由多台 server 里的 partions 组成。zookeeper 协调 kafka broker,存储元数据, consumer的 offset+ broker 信息 +topic信息+ partions信息partions 组成 topic 的单元, 每个 topic有副本(创建 topic 指定), 每个 partions 只能有有个 broker管理</p><h3 id="3-数据传输的事物定义有哪三种"><a href="#3-数据传输的事物定义有哪三种" class="headerlink" title="3. 数据传输的事物定义有哪三种?"></a>3. 数据传输的事物定义有哪三种?</h3><p>数据传输的事务定义通常有以下三种级别：</p><p>最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输。<br>最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输。<br>精确的一次(Exactly once): 不会漏传输也不会重复传输,每个消息都传输被一次而 且仅仅被传输一次，这是大家所期望的。</p><h3 id="4-ZooKeeper在Kafka中的作用是什么？"><a href="#4-ZooKeeper在Kafka中的作用是什么？" class="headerlink" title="4. ZooKeeper在Kafka中的作用是什么？"></a>4. ZooKeeper在Kafka中的作用是什么？</h3><p>Apache Kafka是一个使用Zookeeper构建的分布式系统。虽然，Zookeeper的主要作用是在集群中的不同节点之间建立协调。但是，如果任何节点失败，我们还使用Zookeeper从先前提交的偏移量中恢复，因为它做周期性提交偏移量工作。</p><h3 id="5-没有ZooKeeper可以使用Kafka吗？"><a href="#5-没有ZooKeeper可以使用Kafka吗？" class="headerlink" title="5. 没有ZooKeeper可以使用Kafka吗？"></a>5. 没有ZooKeeper可以使用Kafka吗？</h3><p>zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖。但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等。</p><h3 id="6-Kafka-判断一个节点是否还活着有那两个条件"><a href="#6-Kafka-判断一个节点是否还活着有那两个条件" class="headerlink" title="6. Kafka 判断一个节点是否还活着有那两个条件?"></a>6. Kafka 判断一个节点是否还活着有那两个条件?</h3><p>节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接。<br>如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太久。</p><h3 id="7-解释偏移的作用。"><a href="#7-解释偏移的作用。" class="headerlink" title="7. 解释偏移的作用。"></a>7. 解释偏移的作用。</h3><p>给分区中的消息提供了一个顺序ID号，我们称之为偏移量。因此，为了唯一地识别分区中的每条消息，我们使用这些偏移量。</p><h3 id="8-producer-是否直接将数据发送到-broker-的-leader-主节点"><a href="#8-producer-是否直接将数据发送到-broker-的-leader-主节点" class="headerlink" title="8. producer 是否直接将数据发送到 broker 的 leader(主节点)?"></a>8. producer 是否直接将数据发送到 broker 的 leader(主节点)?</h3><p>producer 直接将数据发送到 broker 的 leader(主节点)，不需要在多个节点进行分发，为了 帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知:哪些节点是活动的，目标topic 目标分区的 leader 在哪。这样 producer 就可以直接将消息发送到目的地了。</p><h3 id="9-Kafa-consumer-是否可以消费指定分区消息"><a href="#9-Kafa-consumer-是否可以消费指定分区消息" class="headerlink" title="9. Kafa consumer 是否可以消费指定分区消息?"></a>9. Kafa consumer 是否可以消费指定分区消息?</h3><p>Kafa consumer 消费消息时，向 broker 发出”fetch”请求去消费特定分区的消息，consumer指定消息在日志中的偏移量(offset)，就可以消费从这个位置开始的消息，customer 拥有 了 offset 的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的。</p><h3 id="10-Kafka-存储在硬盘上的消息格式是什么"><a href="#10-Kafka-存储在硬盘上的消息格式是什么" class="headerlink" title="10. Kafka 存储在硬盘上的消息格式是什么?"></a>10. Kafka 存储在硬盘上的消息格式是什么?</h3><p>消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和 CRC32校验码。</p><p>消息长度: 4 bytes (value: 1+4+n)<br>版本号: 1 byte<br>CRC 校验码: 4 bytes<br>具体的消息: n bytes<br>11. kafka follower如何与leader同步数据？<br>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。<br>12. Kafka 高效文件存储设计特点:</p><p>Kafka 把 topic 中一个 parition 大文件分成多个小文件段，通过多个小文件段，就容易定 期清除或删除已经消费完文件，减少磁盘占用。<br>通过索引信息可以快速定位 message 和确定 response 的最大大小。<br>通过 index 元数据全部映射到 memory，可以避免 segment file 的 IO 磁盘操作。<br>通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小。<br>13. Kafka 与传统消息系统之间有三个关键区别</p><p>Kafka 持久化日志，这些日志可以被重复读取和无限期保留<br>Kafka 是一个分布式系统:它以集群的方式运行，可以灵活伸缩，在内部通过复制数据 提升容错能力和高可用性<br>Kafka 支持实时的流式处理<br>14. Kafka为什么那么快？</p><p>Cache Filesystem Cache PageCache缓存<br>顺序写 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。<br>Zero-copy 零拷技术减少拷贝次数<br>Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。<br>Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符。<br>15. 什么情况下一个 broker 会从 isr中踢出去？<br>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除 。<br>16. kafka producer如何优化打入速度？</p><p>增加线程<br>提高 batch.size<br>增加更多 producer 实例<br>增加 partition 数<br>设置 acks&#x3D;-1 时，如果延迟增大：可以增大 num.replica.fetchers（follower 同步数据的线程数）来调解；<br>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。</p><ol start="17"><li>kafka producer 打数据，ack 为 0， 1， -1 的时候代表啥（ack机制）， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了？</li></ol><p>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。<br>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的。<br>-1 producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。<br>18. Kafka中的消息是否会丢失和重复消费？<br>要确定Kafka的消息是否丢失或重复，从两个方面分析入手：消息发送和消息消费。</p><ol><li>消息发送<br>Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。Kafka通过配置request.required.acks属性来确认消息的生产：</li></ol><p>0—表示不进行消息接收是否成功的确认；<br>1—表示当Leader接收成功时确认；<br>-1—表示Leader和Follower都接收成功时确认；<br>综上所述，有6种消息生产的情况，下面分情况来分析消息丢失的场景：<br>（1）acks&#x3D;0，不和Kafka集群进行消息接收确认，则当网络异常. 缓冲区满了等情况时，消息可能丢失；<br>（2）acks&#x3D;1. 同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失；<br>2. 消息消费<br>Kafka消息消费有两个consumer接口，Low-level API和High-level API：</p><p>Low-level API：消费者自己维护offset等值，可以实现对Kafka的完全控制；<br>High-level API：封装了对parition和offset的管理，使用简单；<br>如果使用高级接口High-level API，可能存在一个问题就是当消息消费者从集群中把消息取出来. 并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就“诡异”的消失了；<br>解决办法：</p><p>针对消息丢失：同步模式下，确认机制设置为-1，即让消息写入Leader和Follower之后再确认消息发送成功；异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时让生产者一直处于阻塞状态；<br>针对消息重复：将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可。<br>消息重复消费及解决参考：<a href="https://www.javazhiyin.com/22910.html">https://www.javazhiyin.com/22910.html</a></p><ol start="19"><li>为什么Kafka不支持读写分离？<br>在 Kafka 中，生产者写入消息. 消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。<br>Kafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:</li></ol><p>数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。<br>延时问题。类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经 历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。<br>20. Kafka中是怎么体现消息顺序性的？<br>kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。<br>整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.<br>21. 消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?<br>offset+1<br>22. kafka如何实现延迟队列？<br>Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty. Akka. Quartz. Zookeeper等组件中都存在时间轮的踪影。<br>底层使用数组实现，数组中的每个元素可以存放一个TimerTaskList对象。TimerTaskList是一个环形双向链表，在其中的链表项TimerTaskEntry中封装了真正的定时任务TimerTask.<br>Kafka中到底是怎么推进时间的呢？Kafka中的定时器借助了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList都会加入到DelayQueue中。<br>Kafka中的TimingWheel专门用来执行插入和删除TimerTaskEntry的操作，而DelayQueue专门负责时间推进的任务。再试想一下，DelayQueue中的第一个超时任务列表的expiration为200ms，第二个超时任务为840ms，这里获取DelayQueue的队头只需要O(1)的时间复杂度。<br>如果采用每秒定时推进，那么获取到第一个超时的任务列表时执行的200次推进中有199次属于“空推进”，而获取到第二个超时任务时有需要执行639次“空推进”，这样会无故空耗机器的性能资源，这里采用DelayQueue来辅助以少量空间换时间，从而做到了“精准推进”。Kafka中的定时器真可谓是“知人善用”，用TimingWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，相辅相成。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>myftp项目介绍</title>
    <link href="/2024/05/10/myftp%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/05/10/myftp%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>计算机网络的课程项目：基于tcp协议，实现了一个简单的 FTP Server 和 FTP Client CLI (CLI指命令行界面)。</p><p>支持的命令有：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">open</span> <span class="hljs-symbol">&lt;IP&gt;</span> <span class="hljs-symbol">&lt;port&gt;</span>: 建立一个到 <span class="hljs-symbol">&lt;IP&gt;</span>:<span class="hljs-symbol">&lt;port&gt;</span> 的连接<br><span class="hljs-keyword">ls</span>: 通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，获取server当前运行目录下的文件列表。<br><span class="hljs-built_in">get</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Server 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Client 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中。<br><span class="hljs-keyword">put</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Client 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Server 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中。<br><span class="hljs-built_in">sha256</span> <span class="hljs-symbol">&lt;filename&gt;</span>：通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，在 Server 运行目录中查询某个文件的 <span class="hljs-built_in">sha256</span> 值，若不存在则返回不存在。<br><span class="hljs-keyword">quit</span>: 如有连接则断开连接，回到 <span class="hljs-keyword">open</span> 前的状态；如果已经是 <span class="hljs-keyword">open</span> 前的状态，则关闭 Client。<br></code></pre></td></tr></table></figure><p>（如果问到popen函数和system函数的区别，就说system函数的返回值五花八门，而popen返回值只有非空和空值，更好处理；而且调用system函数会阻塞进程，调用popen函数不会阻塞进程，也就是说用户可以继续运行主进程）</p><p>我觉得我的项目主要的亮点在于实现大文件的传输。其中有一个测试点是要实现1MB的文件的上传与下载。我一开始想通过开一个数组来实现，但是发现这样行不通，最后经过修改之后决定通过malloc分配出一段空间，然后将文件分片后传输，最后在另一端重新组合起来。</p><p>在这段代码中，文件的传输是按照一块一块来发送的，但是只有第一块设置了头部信息。头部信息包含了整个文件的长度，所以只需要在第一块传输时发送文件的长度信息即可，后续的块不需要再发送头部信息。</p><p>在GET_REQUEST中，第一块数据发送前，服务器端会发送一个含有文件长度信息的头部信息给客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置文件传输的头部信息</span><br>set_header(&amp;header, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, HEADER_LENGTH + statbuf.st_size);<br>send(client, &amp;header, HEADER_LENGTH, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>接着，服务器端开始逐块发送文件内容，后续的块不需要再发送头部信息，只需要发送文件内容即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 打开文件并逐块发送文件内容</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> temp[<span class="hljs-number">1024</span>];<br>FILE *fp = fopen(filename,<span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    length = fread(temp,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>),<span class="hljs-number">1024</span>,fp);<br>    <span class="hljs-keyword">if</span>(length == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    send(client,temp,length,<span class="hljs-number">0</span>);<br>&#125;<br>fclose(fp);<br></code></pre></td></tr></table></figure><p>因此，只有第一块设置了头部信息，后续的块不需要再设置头部信息。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字节面试准备</title>
    <link href="/2024/05/10/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2024/05/10/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<p>看了同岗位别人的一些面经x</p><p>字节国际电商后端一面<br>写在前面：八股很少，更多的是考察我们对八股文理解能力</p><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><h3 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h3><p>（1）给你一个表，(id, userid, amount, month, day)，筛选出所有的日期在3.1-3.10且累计金额大于等于100w的数据<br>（2）select * from table where b&#x3D;xx 和 select id from table where b&#x3D;xx的区别是什么</p><h3 id="3-C-访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？"><a href="#3-C-访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？" class="headerlink" title="3. C++访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？"></a>3. C++访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？</h3><p>当你尝试在C++中访问空指针时，实际上你在尝试访问一个未分配给你的内存地址。操作系统为每个进程分配一定范围的虚拟内存空间，并且对这些内存地址进行了合理的管理。然而，当你尝试使用空指针时，你实际上是在尝试访问地址0附近的内存，这是一个特殊的情况，通常是由操作系统所保留的，以防止应用程序错误地引用未分配的内存。</p><p>当你尝试访问空指针时，操作系统会检测到这个非法的内存访问，因为它监视着进程的内存访问情况。操作系统会触发一个信号，通常是称为”<strong>Segmentation Fault</strong>“（段错误）或”Access Violation”（访问违规），表示程序试图访问未分配的内存。</p><p>这时，操作系统会终止该进程，并生成一个核心转储文件（core dump），其中包含了导致程序崩溃的内存和程序状态信息。核心转储文件对于调试应用程序非常有用，因为它可以帮助开发人员追踪程序崩溃的原因。</p><p>终止进程的方法通常是通过发送一个<strong>信号</strong>来实现。在发生段错误时，操作系统会向进程发送一个信号，通常是<strong>SIGSEGV</strong>。操作系统会在接收到这个信号后，终止该进程的执行。</p><p>操作系统知道这段地址不合理是因为在内存管理中，<strong>每个页面都有自己的状态，操作系统会跟踪哪些页面是已分配的，哪些是空闲的，以及哪些是保留的。</strong>当程序访问一个未分配的或者无效的地址时，操作系统会检测到这个异常情况，并采取适当的措施，例如终止进程。</p><h3 id="4-C-内存分区是怎样的"><a href="#4-C-内存分区是怎样的" class="headerlink" title="4. C++内存分区是怎样的"></a>4. C++内存分区是怎样的</h3><p>在C++中，内存通常被划分为以下几个主要区域：</p><ol><li><p><strong>栈（Stack）</strong>：</p><ul><li>栈是用于存储函数调用的局部变量和函数参数的内存区域。</li><li>当一个函数被调用时，其局部变量和参数会被存储在栈上，并在函数返回时被自动释放。</li><li>栈是一种后进先出（LIFO）的数据结构，它的大小是固定的。</li></ul></li><li><p><strong>堆（Heap）</strong>：</p><ul><li>堆是动态分配内存的区域，用于存储程序运行时动态分配的对象。</li><li>堆的大小没有固定限制，它的大小取决于程序运行时的需求和系统资源。</li><li>堆上分配的内存需要手动释放，否则会导致内存泄漏。</li></ul></li><li><p><strong>全局&#x2F;静态存储区（Global&#x2F;Static Storage Area）</strong>：</p><ul><li>全局存储区用于存储全局变量和静态变量。</li><li>全局变量在程序的整个生命周期内都存在，静态变量在声明时初始化，在程序的整个生命周期内存在。</li><li>全局&#x2F;静态存储区在程序启动时被分配，在程序结束时被释放。</li></ul></li><li><p><strong>常量存储区（Constant Storage Area）</strong>：</p><ul><li>常量存储区用于存储常量值，例如字符串常量。</li><li>这部分内存通常是只读的，不能被修改。</li></ul></li><li><p><strong>代码区（Code Area）</strong>：</p><ul><li>代码区存储程序的可执行代码。</li><li>这部分内存通常是只读的，存储程序的指令。</li></ul></li></ol><p>这些内存区域在程序运行时起着不同的作用，并且由编译器和操作系统进行管理。程序员需要了解这些内存区域的特点和使用方式，以便正确地分配和管理内存，避免内存泄漏和其他内存相关的问题。</p><h3 id="5-linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用"><a href="#5-linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用" class="headerlink" title="5. linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用"></a>5. linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用</h3><p>当你在Linux终端输入一个命令时，操作系统会执行以下步骤来处理：</p><ol><li><p><strong>解析命令</strong>：</p><ul><li>操作系统首先会解析你输入的命令，确定你想要执行的程序或者脚本的路径。</li><li>如果输入的命令是一个内置命令（例如<code>cd</code>、<code>echo</code>等），则不需要进一步解析，而是直接调用相应的内置功能。</li></ul></li><li><p><strong>查找可执行文件</strong>：</p><ul><li>操作系统会搜索环境变量 <code>$PATH</code> 中列出的目录，以查找你输入的命令对应的可执行文件。</li><li>如果找到了对应的可执行文件，操作系统会准备执行它。</li></ul></li><li><p><strong>创建进程</strong>：</p><ul><li>操作系统会创建一个新的进程来执行你输入的命令。这个新进程是通过 <code>fork()</code> 系统调用创建的，然后调用 <code>exec()</code> 系统调用来加载并执行命令对应的可执行文件。</li></ul></li><li><p><strong>加载程序</strong>：</p><ul><li>在创建的新进程中，操作系统会加载你输入的命令对应的可执行文件到进程的内存空间中。</li></ul></li><li><p><strong>执行程序</strong>：</p><ul><li>一旦程序被加载到内存中，操作系统会开始执行它。程序的执行可能涉及到多个系统调用，具体取决于程序的功能和实现。</li></ul></li><li><p><strong>等待程序执行完成</strong>：</p><ul><li>操作系统会等待程序执行完成。如果程序是一个交互式程序，操作系统会将终端的输入输出连接到程序的标准输入输出上，以便你与程序进行交互。</li><li>如果程序执行完成并退出，操作系统会关闭该进程，并返回控制权给终端。</li></ul></li></ol><p>在这个过程中，涉及到的系统调用可能包括：</p><ul><li><code>fork()</code>：用于创建新的进程。</li><li><code>exec()</code>：用于加载并执行新的程序。</li><li><code>wait()</code> 或 <code>waitpid()</code>：用于等待子进程的退出。</li><li><code>open()</code>、<code>close()</code>、<code>read()</code> 和 <code>write()</code>：用于打开文件、关闭文件以及读写文件描述符，这些系统调用用于标准输入、输出和错误的重定向。</li><li>其他可能涉及到的系统调用，具体取决于命令执行过程中涉及的具体操作和功能。</li></ul><h3 id="6-讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？"><a href="#6-讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？" class="headerlink" title="6. 讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？"></a>6. 讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？</h3><p>内存管理是操作系统的重要功能之一，它负责管理计算机系统的物理内存，以便有效地分配和利用内存资源。内存管理的主要目的包括：</p><ol><li><strong>内存分配与回收</strong>：分配内存给进程使用，并在进程终止时回收已使用的内存，以便其他进程使用。</li><li><strong>内存保护</strong>：确保进程只能访问自己分配的内存空间，防止程序越界访问和恶意代码攻击。</li><li><strong>内存共享</strong>：允许多个进程共享内存区域，以提高系统性能和节省内存空间。</li><li><strong>内存虚拟化</strong>：提供每个进程独立的虚拟地址空间，使每个进程都认为自己在使用整个计算机的内存。</li></ol><p>不同的操作系统采用不同的内存管理方式，以下是主流操作系统的内存管理方式：</p><ol><li><p><strong>单一连续内存管理</strong>（Single Contiguous Memory Management）：</p><ul><li>在早期的操作系统中，使用了单一连续内存管理方式。在这种方式下，整个物理内存被视为一个连续的字节序列，进程被分配到内存的连续区域中。</li><li><strong>MS-DOS 是一个使用单一连续内存管理方式的操作系统的例子</strong>。</li></ul></li><li><p><strong>分页式内存管理</strong>（Paging）：</p><ul><li>在分页式内存管理中，物理内存被分割成固定大小的页面（page），通常为4KB或者更大。</li><li>进程的虚拟地址空间也被分成相同大小的页面。操作系统负责将虚拟页面映射到物理页面，从而实现了内存虚拟化。</li><li>当进程访问一个尚未加载到内存的虚拟页面时，操作系统会触发页面错误（page fault），将对应的页面从磁盘加载到内存中。</li><li>UNIX、Linux 和 Windows 等操作系统采用了分页式内存管理。</li></ul></li><li><p><strong>段式内存管理</strong>（Segmentation）：</p><ul><li>在段式内存管理中，虚拟地址空间被分成不同大小的段（segment），<strong>每个段代表一个逻辑单位，如代码段、数据段等</strong>。</li><li>物理内存也被分成相应的段，每个段可以有不同的大小和属性。</li><li>段式内存管理可以更灵活地管理内存，但也更复杂。现代操作系统往往结合分页和分段的方式来管理内存，称为分页分段式内存管理。</li></ul></li><li><p><strong>分页分段式内存管理</strong>（Paging and Segmentation）：</p><ul><li>分页分段式内存管理结合了分页和分段的优点，将<strong>虚拟地址空间划分为多个段，每个段再分成多个页面</strong>，实现了灵活性和效率的平衡。</li><li>这种方式在现代操作系统中被广泛采用，例如，Intel x86 架构的操作系统（如 Windows 和 Linux）使用了分页分段式内存管理。</li></ul></li></ol><h3 id="7-printf-“-d”-amp-a-，输出的地址是物理地址还是虚拟地址？为什么？"><a href="#7-printf-“-d”-amp-a-，输出的地址是物理地址还是虚拟地址？为什么？" class="headerlink" title="7. printf(“%d”, &amp;a)，输出的地址是物理地址还是虚拟地址？为什么？"></a>7. printf(“%d”, &amp;a)，输出的地址是物理地址还是虚拟地址？为什么？</h3><p>在C语言中，<code>printf(&quot;%d&quot;, &amp;a)</code> 中的 <code>&amp;a</code> 表示取变量 <code>a</code> 的地址。然而，C语言本身并不关心地址是物理地址还是虚拟地址，它只是返回变量 <code>a</code> 在内存中的地址值。</p><p>具体来说，在大多数现代操作系统中，包括 Linux 和 Windows，在用户空间程序中，<code>&amp;a</code> 返回的是虚拟地址，而不是物理地址。这是因为操作系统为每个进程提供了一个独立的虚拟地址空间，每个进程的虚拟地址空间都从零开始，与物理内存地址是分离的。</p><p>当你在C语言中使用 <code>&amp;a</code> 获取变量 <code>a</code> 的地址时，实际上是获取了该变量在当前进程的虚拟地址空间中的地址。这个地址是相对于进程而言的，而不是物理内存的地址。操作系统会负责将这个虚拟地址映射到物理内存的相应位置。</p><p>你说得对，我明白你的疑问了。**<code>printf</code> 是C语言的标准库函数，它用于将格式化的数据输出到标准输出流（通常是终端）。而C语言的标准库函数 <code>printf</code> 并不是操作系统级别的函数，它实际上是在用户空间运行的，而不是在操作系统内核中运行。**</p><p>当你在C程序中调用 <code>printf</code> 函数时，这个函数是由C编译器编译生成的用户态代码。这个用户态的 <code>printf</code> 函数接收参数，执行输出操作，并将输出发送到标准输出流。这个过程并不涉及操作系统的内核代码。</p><p>因此，当你在C语言程序中使用 <code>printf(&quot;%d&quot;, &amp;a)</code> 来输出变量 <code>a</code> 的地址时，<code>printf</code> 函数实际上是直接输出了变量 <code>a</code> 在当前进程的虚拟地址空间中的地址，而不是物理地址。这个地址是在用户态计算得到的，与操作系统的内核代码无关。</p><p>因此，<code>printf(&quot;%d&quot;, &amp;a)</code> 输出的地址是<strong>相对于进程的虚拟地址</strong>，而不是物理地址。</p><h3 id="8-虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）"><a href="#8-虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）" class="headerlink" title="8. 虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）"></a>8. 虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）</h3><p>页表是一种数据结构，用于存储虚拟地址空间中每个页面（page）的映射信息，以便操作系统将虚拟地址映射到物理地址。</p><p>在常见的分页式内存管理中，页表的主要作用是实现虚拟内存到物理内存的地址映射。当程序访问虚拟地址时，操作系统会使用页表来确定对应的物理地址。</p><p>页表通常包含以下信息：</p><ol><li><p><strong>页号（Page Number）</strong>：用于表示虚拟地址中的页面号码。在页表中，每个页号都对应着一个页表项（Page Table Entry）。</p></li><li><p><strong>页框号（Frame Number）</strong>：用于表示物理地址中的页框号码。页表中的每个页表项都包含了对应的页框号码，用于将虚拟地址映射到物理地址。</p></li><li><p><strong>访问权限（Access Rights）</strong>：用于表示页面的访问权限，包括读、写、执行等权限。这些权限信息通常存储在页表项中，并且可以用于实现内存保护机制。</p></li><li><p><strong>其他控制位（Control Bits）</strong>：包括是否被访问过、是否被修改过等控制信息，用于实现页面置换算法等功能。</p></li><li><p><strong>其他辅助信息</strong>：可能包括页面的有效位、驻留位、脏位等，用于帮助操作系统实现内存管理和页面置换算法。</p></li></ol><p>页表的结构和内容可能因操作系统的不同而有所不同，但它的基本功能是将虚拟地址映射到物理地址，从而实现虚拟内存的管理。</p><h3 id="9-计算机网络："><a href="#9-计算机网络：" class="headerlink" title="9. 计算机网络："></a>9. 计算机网络：</h3><h4 id="浏览器输入网址的完整流程（重要）"><a href="#浏览器输入网址的完整流程（重要）" class="headerlink" title="浏览器输入网址的完整流程（重要）"></a>浏览器输入网址的完整流程（重要）</h4><p>（操作系统级别和网络级别的都可以讲）<br>别忘了dns解析（先看缓存再请求） socket连接 http请求 html渲染</p><h4 id="HTTP请求的类型有哪些，有什么作用？"><a href="#HTTP请求的类型有哪些，有什么作用？" class="headerlink" title="HTTP请求的类型有哪些，有什么作用？"></a>HTTP请求的类型有哪些，有什么作用？</h4><p>HTTP请求的类型主要包括以下几种：</p><ol><li><p><strong>GET</strong>：</p><ul><li>GET 请求用于从服务器获取数据，通常用于请求一个资源的内容。</li><li>GET 请求的参数通常包含在URL的查询字符串中，例如 <code>http://example.com/resource?id=123</code>。</li><li>GET 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>POST 请求用于向服务器提交数据，通常用于创建新资源或者向服务器提交表单数据。</li><li>POST 请求的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>POST 请求可以用于执行各种操作，例如创建、更新、删除等，具体取决于服务器的实现。</li></ul></li><li><p><strong>PUT</strong>：</p><ul><li>PUT 请求用于向服务器上传数据，通常用于更新已有资源。</li><li>PUT 请求的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>PUT 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>DELETE</strong>：</p><ul><li>DELETE 请求用于从服务器删除资源。</li><li>DELETE 请求通常不包含数据，而是用于删除服务器上指定的资源。</li><li>DELETE 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>PATCH</strong>：</p><ul><li>PATCH 请求用于对资源进行局部更新，即只更新资源的一部分内容。</li><li>PATCH 请求的数据通常包含在请求的主体（body）中，指定要更新的部分内容。</li><li>PATCH 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>HEAD</strong>：</p><ul><li>HEAD 请求用于获取资源的头部信息，即获取资源的元数据而不获取实际内容。</li><li>HEAD 请求与 GET 请求类似，但不会返回资源的主体内容，只返回头部信息。</li></ul></li><li><p><strong>OPTIONS</strong>：</p><ul><li>OPTIONS 请求用于获取服务器支持的HTTP方法列表，以及服务器支持的其他功能。</li><li>OPTIONS 请求通常用于跨域资源共享（CORS）等场景下，以确定是否允许跨域请求。</li></ul></li></ol><p>这些HTTP请求类型具有不同的功能和语义，使得客户端和服务器可以进行各种类型的交互，实现数据的获取、创建、更新和删除等操作。</p><h4 id="post和put和区别？"><a href="#post和put和区别？" class="headerlink" title="post和put和区别？"></a>post和put和区别？</h4><p>在HTTP协议中，POST和PUT都是用于向服务器提交数据的方法，但它们有一些重要的区别：</p><ol><li><p><strong>POST</strong>：</p><ul><li>POST 方法用于向服务器提交数据，通常用于创建新资源或者在服务器上执行某种操作。</li><li>POST 请求提交的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>POST 请求没有严格的语义，它可以用于多种用途，包括创建、更新、删除等操作。</li><li>POST 请求通常用于在服务器上创建新资源，因此，重复提交相同的POST请求可能会导致服务器创建多个相同的资源。</li></ul></li><li><p><strong>PUT</strong>：</p><ul><li>PUT 方法用于向服务器提交数据，通常用于更新现有资源。</li><li>PUT 请求提交的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>PUT 请求有严格的语义，它用于在服务器上更新指定的资源。PUT 请求应该是幂等的，即重复提交相同的PUT请求不应该产生不同的结果。</li><li>如果服务器上不存在指定的资源，PUT 请求通常会创建一个新的资源，但也可能返回错误，取决于服务器的实现和配置。</li></ul></li></ol><p>总之，POST 和 PUT 都是用于向服务器提交数据的方法，但它们在语义和用途上有所不同。POST 通常用于创建新资源或执行一些操作，而 PUT 通常用于更新现有资源。</p><h4 id="讲一下TCP报文有哪些关键字段"><a href="#讲一下TCP报文有哪些关键字段" class="headerlink" title="讲一下TCP报文有哪些关键字段"></a>讲一下TCP报文有哪些关键字段</h4><p>四元组 ack seq 控制位 滑动窗口 header_length crc content</p><h4 id="TCP如何做到可靠传输（重要）"><a href="#TCP如何做到可靠传输（重要）" class="headerlink" title="TCP如何做到可靠传输（重要）"></a>TCP如何做到可靠传输（重要）</h4><p>超时重传 crc校验 ackseq 握手连接 流量控制 拥塞控制</p><h3 id="10-100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp-100-x3D-dp-97-x3D-dp-94-…-x3D-dp-1-，所以一开始就拿一个"><a href="#10-100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp-100-x3D-dp-97-x3D-dp-94-…-x3D-dp-1-，所以一开始就拿一个" class="headerlink" title="10. 100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp[100]&#x3D;dp[97]&#x3D;dp[94]…&#x3D;dp[1]，所以一开始就拿一个"></a>10. 100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp[100]&#x3D;dp[97]&#x3D;dp[94]…&#x3D;dp[1]，所以一开始就拿一个</h3><h3 id="11-分糖果（leetcode135原题）"><a href="#11-分糖果（leetcode135原题）" class="headerlink" title="11. 分糖果（leetcode135原题）"></a>11. 分糖果（leetcode135原题）</h3><h3 id="12-如何学习新事物"><a href="#12-如何学习新事物" class="headerlink" title="12. 如何学习新事物"></a>12. 如何学习新事物</h3>]]></content>
    
    
    
    <tags>
      
      <tag>国际电商</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐一个抄mooc/智慧树答案的网站</title>
    <link href="/2024/05/10/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E6%8A%84mooc-%E6%99%BA%E6%85%A7%E6%A0%91%E7%AD%94%E6%A1%88%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <url>/2024/05/10/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E6%8A%84mooc-%E6%99%BA%E6%85%A7%E6%A0%91%E7%AD%94%E6%A1%88%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jhq8.cn/s/">https://www.jhq8.cn/s/</a><br>有时候网站会抽风找不到搜索框，这个时候只要修改网址栏就可以力</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jhq8.cn<span class="hljs-regexp">/s/</span>你要搜索的连续内容/<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试搬运-SQL面试五十题</title>
    <link href="/2024/05/10/%E9%9D%A2%E8%AF%95%E6%90%AC%E8%BF%90-SQL%E9%9D%A2%E8%AF%95%E4%BA%94%E5%8D%81%E9%A2%98/"/>
    <url>/2024/05/10/%E9%9D%A2%E8%AF%95%E6%90%AC%E8%BF%90-SQL%E9%9D%A2%E8%AF%95%E4%BA%94%E5%8D%81%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>字号太小了就搬过来了。<br>原地址：<a href="https://blog.csdn.net/qiqi123i/article/details/108455130">https://blog.csdn.net/qiqi123i/article/details/108455130</a></p><ol><li>查询课程编号为“01”的课程比“02”的课程成绩高的所有学生的学号（难）</li><li>查询平均成绩大于60分的学生的学号和平均成绩</li><li>查询所有学生的学号、姓名、选课数、总成绩</li><li>查询姓“猴”的老师的个数</li><li>查询没学过“张三”老师课的学生的学号、姓名</li><li>查询学过“张三”老师所教的所有课的同学的学号、姓名</li><li>查询学过编号为“01”的课程并且也学过编号为“02”的课程的学生的学号、姓名</li><li>查询课程编号为“02”的总成绩</li><li>查询所有课程成绩小于60分的学生的学号、姓名</li><li>查询没有学全所有课的学生的学号、姓名</li><li>查询至少有一门课与学号为“01”的学生所学课程相同的学生的学号和姓名 （难）</li><li>查询和“01”号同学所学课程完全相同的其他同学的学号（难）</li><li>查询没学过”张三”老师讲授的任一门课程的学生姓名 和47题一样</li><li>查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</li><li>检索”01”课程分数小于60，按分数降序排列的学生信息</li><li>按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩(难)</li><li>查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率</li><li>按各科成绩进行排序，并显示排名(难)</li><li>查询学生的总成绩并进行排名</li><li>查询不同老师所教不同课程平均分从高到低显示</li><li>查询所有课程的成绩第2名到第3名的学生信息及该课程成绩（重要 25类似）</li><li>使用分段[100-85],[85-70],[70-60],[&lt;60]来统计各科成绩，分别统计各分数段人数：课程ID和课程名称</li><li>查询学生平均成绩及其名次</li><li>查询各科成绩前三名的记录（不考虑成绩并列情况）</li><li>查询每门课程被选修的学生数</li><li>查询出只有两门课程的全部学生的学号和姓名</li><li>查询男生、女生人数</li><li>查询名字中含有”风”字的学生信息</li><li>查询1990年出生的学生名单</li><li>查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩</li><li>查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列</li><li>查询课程名称为”数学”，且分数低于60的学生姓名和分数</li><li>查询所有学生的课程及分数情况</li><li>查询任何一门课程成绩在70分以上的姓名、课程名称和分数</li><li>查询不及格的课程并按课程号从大到小排列</li><li>查询课程编号为03且课程成绩在80分以上的学生的学号和姓名</li><li>求每门课程的学生人数</li><li>查询选修“张三”老师所授课程的学生中成绩最高的学生姓名及其成绩</li><li>查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 （难）</li><li>查询每门功成绩最好的前两名</li><li>统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</li><li>检索至少选修两门课程的学生学号</li><li>查询选修了全部课程的学生信息</li><li>查询各学生的年龄</li><li>查询没学过“张三”老师讲授的任一门课程的学生姓名</li><li>查询两门以上不及格课程的同学的学号及其平均成绩</li><li>查询本月过生日的学生</li><li>查询下一个月过生日的学生</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼编码</title>
    <link href="/2024/05/09/%E7%AE%97%E6%B3%95%E6%81%B6%E8%A1%A5/"/>
    <url>/2024/05/09/%E7%AE%97%E6%B3%95%E6%81%B6%E8%A1%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" alt="huffman"><br>我的想法：用最小堆维护一个根节点，然后开辟额外的空间O(N)去维护最终的树<br>（带权最短路径</p><p>向左子树移动就是0，向右子树移动就是1，到叶子结点就是要访问的节点，每个节点都有自己的哈夫曼编码</p><p>xiaolincoding.com的计算机网络讲得真的很细（感觉是面试官会问到的级别</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL测验</title>
    <link href="/2024/05/08/SQL%E6%B5%8B%E9%AA%8C/"/>
    <url>/2024/05/08/SQL%E6%B5%8B%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>不想成为那个八股背的非常流利但是sql一道都不会写的人于是开始恶补啊啊啊啊啊</p><p>一个选择题测验网站：<a href="https://www.w3school.com.cn/quiz/quiz.asp?quiz=sql">https://www.w3school.com.cn/quiz/quiz.asp?quiz=sql</a></p><p>注：“您的回答”下没有“正确答案”的就是答对了</p><p>1.SQL 指的是？<br>您的回答：Structured Query Language</p><p>2.哪个 SQL 语句用于从数据库中提取数据？<br>您的回答：SELECT</p><p>3.哪条 SQL 语句用于更新数据库中的数据？<br>您的回答：UPDATE</p><p>4.哪条 SQL 语句用于删除数据库中的数据？<br>您的回答：DELETE</p><p>5.哪条 SQL 语句用于在数据库中插入新的数据？<br>您的回答：INSERT INTO</p><p>6.通过 SQL，您如何从 “Persons” 表中选取 “FirstName” 列？<br>您的回答：SELECT FirstName FROM Persons</p><p>7.通过 SQL，您如何从 “Persons” 表中选取所有的列？<br>您的回答：SELECT * FROM Persons</p><p>8.通过 SQL，您如何从 “Persons” 表中选取 “FirstName” 列的值等于”Peter” 的所有记录？<br>您的回答：SELECT * FROM Persons WHERE FirstName&#x3D;’Peter’</p><p>9.通过 SQL，您如何从 “Persons” 表中选取 “FirstName” 列的值以 “a” <strong>开头</strong>的所有记录？<br>您的回答：SELECT * FROM Persons WHERE FirstName LIKE ‘%a’<br><strong>正确答案：SELECT * FROM Persons WHERE FirstName LIKE ‘a%’</strong></p><p>10.请判断下列说法是否正确：当所列出的某个条件为 true 时，OR 运算符会显示记录。当列出的所有条件为 true 时，AND 运算符会显示记录。<br>您的回答：正确</p><p>11.通过 SQL，您如何在表 Persons 中选择 FirstName 等于 Thomas 而 LastName 等于 Carter 的所有记录？<br>您的回答：SELECT * FROM Persons WHERE FirstName&#x3D;’Thomas’ AND LastName&#x3D;’Carter’</p><p>12.通过 SQL，您如何按字母顺序选取 Persons 表中 LastName 介于 Adams 和 Carter 的所有记录？<br>您的回答：SELECT * FROM Persons WHERE LastName&gt;’Adams’ AND LastName&lt;’Carter’<br><strong>正确答案：SELECT * FROM Persons WHERE LastName BETWEEN ‘Adams’ AND ‘Carter’</strong></p><p>13.哪条 SQL 语句可返回唯一不同的值？<br>您的回答：SELECT DISTINCT</p><p>14.哪个 SQL 关键词用于对<strong>结果集</strong>进行排序？<br>您的回答：SORT BY<br><strong>正确答案：ORDER BY</strong></p><p>15.通过 SQL，您如何根据 “FirstName” 列降序地从 “Persons” 表返回所有记录？<br>您的回答：SELECT * FROM Persons ORDER BY FirstName DESC</p><p>16.通过 SQL，您如何向 “Persons” 表插入新的记录？<br>您的回答：INSERT INTO Persons VALUES (‘Jimmy’, ‘Jackson’)</p><p>17.通过 SQL，您如何向 “Persons” 表中的 “LastName” 列插入 “Wilson” ？<br>您的回答：INSERT INTO Persons (LastName) VALUES (‘Wilson’)</p><p>18.您如何把 “Persons” 表中 “LastName” 列的 “Gates” 改为 “Wilson” ？<br>您的回答：UPDATE Persons SET LastName&#x3D;’Wilson’ WHERE LastName&#x3D;’Gates’</p><p>19.通过 SQL，您如何在 “Persons” 表中删除 “FirstName” 等于 “Fred” 的纪录？<br>您的回答：DELETE ROW FirstName&#x3D;’Fred’ FROM Persons<br><strong>正确答案：DELETE FROM Persons WHERE FirstName &#x3D; ‘Fred’</strong></p><p>20.通过 SQL，您如何返回 “Persons” 表中记录的数目？<br>您的回答：SELECT COUNT(*) FROM Persons</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>搬运自用-MySQL面试题合集</title>
    <link href="/2024/05/08/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2024/05/08/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>题目合集：</p><ol><li>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15？</li><li>Mysql的技术特点是什么？</li><li>Heap表是什么？</li><li>Mysql服务器默认端口是什么？</li><li>与Oracle相比，Mysql有什么优势？</li><li>如何区分FLOAT和DOUBLE？</li><li>区分CHAR_LENGTH和LENGTH？</li><li>请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</li><li>在Mysql中ENUM的用法是什么？</li><li>如何定义REGEXP？</li><li>CHAR和VARCHAR的区别？</li><li>列的字符串类型可以是什么？</li><li>如何获取当前的Mysql版本？</li><li>Mysql中使用什么存储引擎？</li><li>Mysql驱动程序是什么？</li><li>TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？</li><li>主键和候选键有什么区别？</li><li>如何使用Unix shell登录Mysql？</li><li>myisamchk是用来做什么的？</li><li>MYSQL数据库服务器性能分析的方法命令有哪些?</li><li>如何控制HEAP表的最大尺寸？</li><li>MyISAM Static和MyISAM Dynamic有什么区别？</li><li>federated表是什么？</li><li>如果一个表有一列定义为TIMESTAMP，将发生什么？</li><li>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</li><li>怎样才能找出最后一次插入时分配了哪个自动增量？</li><li>你怎么看到为表格定义的所有索引？</li><li>LIKE声明中的％和_是什么意思？</li><li>如何在Unix和Mysql时间戳之间进行转换？</li><li>列对比运算符是什么？</li><li>我们如何得到受查询影响的行数？</li><li>Mysql查询是否区分大小写？</li><li>LIKE和REGEXP操作有什么区别？</li><li>BLOB和TEXT有什么区别？</li><li>mysql_fetch_array和mysql_fetch_object的区别是什么？</li><li>我们如何在mysql中运行批处理模式？</li><li>MyISAM表格将在哪里存储，并且还提供其存储格式？</li><li>Mysql中有哪些不同的表格？</li><li>ISAM是什么？</li><li>InnoDB是什么？</li><li>Mysql如何优化DISTINCT？</li><li>如何输入字符为十六进制数字？</li><li>如何显示前50行？</li><li>可以使用多少列创建索引？</li><li>NOW（）和CURRENT_DATE（）有什么区别？</li><li>什么样的对象可以使用CREATE语句创建？</li><li>Mysql表中允许有多少个TRIGGERS？</li><li>什么是非标准字符串类型？</li><li>什么是通用SQL函数？</li><li>解释访问控制列表</li><li>MYSQL支持事务吗？</li><li>mysql里记录货币用什么字段类型好</li><li>MYSQL数据表在什么情况下容易损坏？</li><li>mysql有关权限的表都有哪几个？</li><li>Mysql中有哪几种锁？</li></ol><h3 id="1-一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？"><a href="#1-一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？" class="headerlink" title="1. 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？"></a>1. 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</h3><p>1.如果表的类型是MyISAM，那么是18.因为MyISAM会把自己增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。<br>2.如果表的类型是InnoDB，那么是15.InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。</p><h3 id="2-Mysql的技术特点是什么？"><a href="#2-Mysql的技术特点是什么？" class="headerlink" title="2. Mysql的技术特点是什么？"></a>2. Mysql的技术特点是什么？</h3><p>Mysql数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程SQL服务器. 不同的后端. 广泛的应用程序编程接口和管理工具。</p><h3 id="3-Heap表是什么？"><a href="#3-Heap表是什么？" class="headerlink" title="3. Heap表是什么？"></a>3. Heap表是什么？</h3><p>HEAP表存在于内存中，用于临时高速存储。</p><p>BLOB或TEXT字段是不允许的</p><p>只能使用比较运算符&#x3D;，&lt;，&gt;，&#x3D;&gt;，&#x3D; &lt;</p><p>HEAP表不支持AUTO_INCREMENT</p><p>索引不可为NULL</p><h3 id="4-Mysql服务器默认端口是什么？"><a href="#4-Mysql服务器默认端口是什么？" class="headerlink" title="4. Mysql服务器默认端口是什么？"></a>4. Mysql服务器默认端口是什么？</h3><p>Mysql服务器的默认端口是3306。</p><h3 id="5-与Oracle相比，Mysql有什么优势？"><a href="#5-与Oracle相比，Mysql有什么优势？" class="headerlink" title="5. 与Oracle相比，Mysql有什么优势？"></a>5. 与Oracle相比，Mysql有什么优势？</h3><p>Mysql是开源软件，随时可用，无需付费。</p><p>Mysql是便携式的</p><p>带有命令提示符的GUI。</p><p>使用Mysql查询浏览器支持管理</p><h3 id="6-如何区分FLOAT和DOUBLE？"><a href="#6-如何区分FLOAT和DOUBLE？" class="headerlink" title="6. 如何区分FLOAT和DOUBLE？"></a>6. 如何区分FLOAT和DOUBLE？</h3><p>以下是FLOAT和DOUBLE的区别：</p><p>浮点数以8位精度存储在FLOAT中，并且有四个字节。</p><p>浮点数存储在DOUBLE中，精度为18位，有八个字节。</p><h3 id="7-区分CHAR-LENGTH和LENGTH？"><a href="#7-区分CHAR-LENGTH和LENGTH？" class="headerlink" title="7. 区分CHAR_LENGTH和LENGTH？"></a>7. 区分CHAR_LENGTH和LENGTH？</h3><p>CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。</p><h3 id="8-请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#8-请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="8. 请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>8. 请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>未解决</td><td>未解决</td><td>未解决</td></tr><tr><td>读提交</td><td>解决</td><td>未解决</td><td>未解决</td></tr><tr><td>可重复读</td><td>解决</td><td>解决</td><td>未解决</td></tr><tr><td>串行化</td><td>解决</td><td>解决</td><td>解决</td></tr></tbody></table><p>SQL标准定义的四个隔离级别为：</p><p>read uncommited ：读到未提交数据</p><p>read committed：脏读，不可重复读</p><p>repeatable read：可重读</p><p>serializable ：串行事物<br>详细解释如下：<br>Read Uncommitted（读取未提交内容）<br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br>Read Committed（读取提交内容）<br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br>Repeatable Read（可重读）<br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。<br>Serializable（可串行化）<br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。<br>对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在：</p><ol><li>脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。</li><li>非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。</li><li>幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。<br>不同的隔离级别有不同的现象，并有不同的锁定&#x2F;并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：</li></ol><h3 id="9-在Mysql中ENUM的用法是什么？"><a href="#9-在Mysql中ENUM的用法是什么？" class="headerlink" title="9. 在Mysql中ENUM的用法是什么？"></a>9. 在Mysql中ENUM的用法是什么？</h3><p>ENUM是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。</p><p>Create table size(name ENUM(‘Smail,’Medium’,’Large’));</p><h3 id="10-如何定义REGEXP？"><a href="#10-如何定义REGEXP？" class="headerlink" title="10. 如何定义REGEXP？"></a>10. 如何定义REGEXP？</h3><p>REGEXP是模式匹配，其中匹配模式在搜索值的任何位置。</p><p>REGEXP是一个用于在MySQL中执行正则表达式匹配的操作符。通过使用REGEXP操作符，可以在MySQL查询中使用正则表达式来进行模式匹配和过滤数据。</p><p>下面是REGEXP操作符的基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">expr REGEXP <span class="hljs-keyword">pattern</span><br></code></pre></td></tr></table></figure><ul><li><code>expr</code>：要匹配的表达式或字段。</li><li><code>pattern</code>：正则表达式模式。</li></ul><p>例如，要查找名字以字母”A”开头的所有用户，可以使用如下的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name REGEXP <span class="hljs-string">&#x27;^A&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个查询将返回所有名字以字母”A”开头的用户数据。</p><p>正则表达式提供了强大的模式匹配功能，可以用于各种情况下的数据过滤和匹配操作。MySQL中的REGEXP操作符使得我们可以在查询中利用这些功能来实现更加灵活和复杂的数据查询和处理。</p><h3 id="11-CHAR和VARCHAR的区别？"><a href="#11-CHAR和VARCHAR的区别？" class="headerlink" title="11. CHAR和VARCHAR的区别？"></a>11. CHAR和VARCHAR的区别？</h3><p>以下是CHAR和VARCHAR的区别：</p><p>CHAR和VARCHAR类型在存储和检索方面有所不同</p><p>CHAR列长度固定为创建表时声明的长度，长度值范围是1到255</p><p>当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</p><h3 id="12-列的字符串类型可以是什么？"><a href="#12-列的字符串类型可以是什么？" class="headerlink" title="12. 列的字符串类型可以是什么？"></a>12. 列的字符串类型可以是什么？</h3><p>字符串类型是：</p><p>SET</p><p>BLOB</p><p>ENUM</p><p>CHAR</p><p>TEXT</p><p>VARCHAR</p><h3 id="13-如何获取当前的Mysql版本？"><a href="#13-如何获取当前的Mysql版本？" class="headerlink" title="13. 如何获取当前的Mysql版本？"></a>13. 如何获取当前的Mysql版本？</h3><p>SELECT VERSION();用于获取当前Mysql的版本。</p><h3 id="14-Mysql中使用什么存储引擎？"><a href="#14-Mysql中使用什么存储引擎？" class="headerlink" title="14. Mysql中使用什么存储引擎？"></a>14. Mysql中使用什么存储引擎？</h3><p>存储引擎称为表类型，数据使用各种技术存储在文件中。<br>MySQL支持多种存储引擎，每种引擎都有其自身的特点和用途。在MySQL中，默认的存储引擎是InnoDB，但也支持其他存储引擎，例如MyISAM、MEMORY、CSV等。</p><p>常用的MySQL存储引擎包括：</p><ol><li><p><strong>InnoDB</strong>：支持事务处理和行级锁定，是MySQL默认的存储引擎，适用于大多数应用场景。</p></li><li><p><strong>MyISAM</strong>：不支持事务处理，但提供了高速的读取和全文索引功能，适用于读密集型应用。</p></li><li><p><strong>MEMORY</strong>：将数据存储在内存中，速度非常快，但数据不是持久的，适用于缓存和临时表等场景。</p></li><li><p><strong>CSV</strong>：将数据存储在CSV文件中，适用于数据交换和导入导出。</p></li><li><p><strong>ARCHIVE</strong>：用于存储大量归档数据，支持高压缩比和快速插入。</p></li><li><p><strong>NDB</strong>：用于MySQL Cluster，支持分布式存储和高可用性。</p></li></ol><p>不同的存储引擎具有不同的特点和适用场景，选择合适的存储引擎取决于应用的需求和性能要求。</p><p>技术涉及：</p><p>Storage mechanism</p><p>Locking levels</p><p>Indexing</p><p>Capabilities and functions.</p><h3 id="15-Mysql驱动程序是什么？"><a href="#15-Mysql驱动程序是什么？" class="headerlink" title="15. Mysql驱动程序是什么？"></a>15. Mysql驱动程序是什么？</h3><p>以下是Mysql中可用的驱动程序：</p><p>PHP驱动程序</p><p>JDBC驱动程序</p><p>ODBC驱动程序</p><p>CWRAPPER</p><p>PYTHON驱动程序</p><p>PERL驱动程序</p><p>RUBY驱动程序</p><p>CAP11PHP驱动程序</p><p>Ado.net5.mxj</p><h3 id="16-TIMESTAMP在UPDATE-CURRENT-TIMESTAMP数据类型上做什么？"><a href="#16-TIMESTAMP在UPDATE-CURRENT-TIMESTAMP数据类型上做什么？" class="headerlink" title="16. TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？"></a>16. TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？</h3><p>创建表时TIMESTAMP列用Zero更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP修饰符就将时间戳字段更新为当前时间。</p><h3 id="17-主键和候选键有什么区别？"><a href="#17-主键和候选键有什么区别？" class="headerlink" title="17. 主键和候选键有什么区别？"></a>17. 主键和候选键有什么区别？</h3><p>表格的每一行都由主键唯一标识,一个表只有一个主键。</p><p>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</p><h3 id="18-如何使用Unix-shell登录Mysql？"><a href="#18-如何使用Unix-shell登录Mysql？" class="headerlink" title="18. 如何使用Unix shell登录Mysql？"></a>18. 如何使用Unix shell登录Mysql？</h3><p>我们可以通过以下命令登录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"># [mysql dir]<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>mysql <span class="hljs-operator">-</span>h hostname <span class="hljs-operator">-</span>u <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><h3 id="19-myisamchk是用来做什么的？"><a href="#19-myisamchk是用来做什么的？" class="headerlink" title="19.  myisamchk是用来做什么的？"></a>19.  myisamchk是用来做什么的？</h3><p>它用来压缩MyISAM表，这减少了磁盘或内存使用。</p><h3 id="20-MYSQL数据库服务器性能分析的方法命令有哪些"><a href="#20-MYSQL数据库服务器性能分析的方法命令有哪些" class="headerlink" title="20. MYSQL数据库服务器性能分析的方法命令有哪些?"></a>20. MYSQL数据库服务器性能分析的方法命令有哪些?</h3><p>Show status</p><p>一些值得监控的变量值：</p><p>Bytes_received和Bytes_sent</p><p>和服务器之间来往的流量。</p><p>Com_*服务器正在执行的命令。</p><p>Created_*在查询执行期限间创建的临时表和文件。</p><p>Handler_*存储引擎操作。</p><p>Select_*不同类型的联接执行计划。</p><p>Sort_*几种排序信息。</p><p>Show session status like ‘Select’;</p><p>Show profiles</p><p>SET profiling&#x3D;1;</p><p>Show profiles \G</p><p>Show profile;</p><p>在MySQL中，你可以使用多种方法和命令来进行数据库服务器性能分析。以下是一些常用的方法和相关的命令：</p><ol><li><p><strong>SHOW STATUS</strong>：显示当前MySQL服务器的各种状态信息，包括连接数、查询数、缓存命中率等。可以通过查看这些状态信息来了解服务器的整体性能情况。</p></li><li><p><strong>SHOW PROCESSLIST</strong>：显示当前运行的所有MySQL进程，包括查询、连接等信息。通过查看当前进程列表，可以了解哪些查询正在执行，以及它们的状态和执行时间等信息。</p></li><li><p><strong>EXPLAIN</strong>：用于分析查询语句的执行计划。通过执行<code>EXPLAIN</code>命令，可以查看查询语句的执行计划，了解MySQL是如何执行查询的，以及是否使用了索引等信息。</p></li><li><p><strong>MySQL Performance Schema</strong>：MySQL Performance Schema是MySQL提供的一种性能监控和分析工具，可以用于收集和分析MySQL服务器的性能数据。通过分析Performance Schema中的各种性能指标和事件，可以更详细地了解MySQL服务器的性能状况。</p></li><li><p><strong>MySQL Slow Query Log</strong>：MySQL Slow Query Log是MySQL提供的一种记录慢查询的功能。通过启用Slow Query Log，并设置合适的阈值，可以记录下执行时间超过一定阈值的查询语句，从而帮助找出潜在的性能问题。</p></li><li><p><strong>MySQL Workbench Performance Dashboard</strong>：MySQL Workbench是MySQL官方提供的图形化管理工具，其中包含了Performance Dashboard功能，可以用于实时监控和分析MySQL服务器的性能数据，包括连接数、查询执行时间、缓存命中率等。</p></li><li><p><strong>Percona Toolkit</strong>：Percona Toolkit是一个由Percona提供的一组MySQL管理和监控工具，其中包含了一些用于性能分析的工具，例如pt-query-digest、pt-stalk等，可以用于分析慢查询、监控服务器性能等。</p></li></ol><p>这些方法和命令可以帮助你对MySQL数据库服务器的性能进行分析和监控，从而找出潜在的性能问题，并进行优化和调整。</p><h3 id="21-如何控制HEAP表的最大尺寸？"><a href="#21-如何控制HEAP表的最大尺寸？" class="headerlink" title="21. 如何控制HEAP表的最大尺寸？"></a>21. 如何控制HEAP表的最大尺寸？</h3><p>Heal表的大小可通过称为max_heap_table_size的Mysql配置变量来控制。</p><h3 id="22-MyISAM-Static和MyISAM-Dynamic有什么区别？"><a href="#22-MyISAM-Static和MyISAM-Dynamic有什么区别？" class="headerlink" title="22. MyISAM Static和MyISAM Dynamic有什么区别？"></a>22. MyISAM Static和MyISAM Dynamic有什么区别？</h3><p>在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。</p><p>MyISAM Static在受损情况下更容易恢复。</p><h3 id="23-federated表是什么？"><a href="#23-federated表是什么？" class="headerlink" title="23. federated表是什么？"></a>23. federated表是什么？</h3><p>federated表，允许访问位于其他服务器数据库上的表。</p><h3 id="24-如果一个表有一列定义为TIMESTAMP，将发生什么？"><a href="#24-如果一个表有一列定义为TIMESTAMP，将发生什么？" class="headerlink" title="24. 如果一个表有一列定义为TIMESTAMP，将发生什么？"></a>24. 如果一个表有一列定义为TIMESTAMP，将发生什么？</h3><p>每当行被更改时，时间戳字段将获取当前时间戳。</p><h3 id="25-列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#25-列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="25. 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>25. 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h3><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p><h3 id="26-怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#26-怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="26. 怎样才能找出最后一次插入时分配了哪个自动增量？"></a>26. 怎样才能找出最后一次插入时分配了哪个自动增量？</h3><p>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</p><h3 id="27-你怎么看到为表格定义的所有索引？"><a href="#27-你怎么看到为表格定义的所有索引？" class="headerlink" title="27. 你怎么看到为表格定义的所有索引？"></a>27. 你怎么看到为表格定义的所有索引？</h3><p>索引是通过以下方式为表格定义的：</p><p>SHOW INDEX FROM ;</p><h3 id="28-LIKE声明中的％和-是什么意思？"><a href="#28-LIKE声明中的％和-是什么意思？" class="headerlink" title="28.. LIKE声明中的％和_是什么意思？"></a>28.. LIKE声明中的％和_是什么意思？</h3><p>％对应于0个或更多字符，_ 只是LIKE语句中的一个字符。</p><h3 id="29-如何在Unix和Mysql时间戳之间进行转换？"><a href="#29-如何在Unix和Mysql时间戳之间进行转换？" class="headerlink" title="29. 如何在Unix和Mysql时间戳之间进行转换？"></a>29. 如何在Unix和Mysql时间戳之间进行转换？</h3><p>UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令</p><p>FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令</p><h3 id="30-列对比运算符是什么？"><a href="#30-列对比运算符是什么？" class="headerlink" title="30. 列对比运算符是什么？"></a>30. 列对比运算符是什么？</h3><p>在SELECT语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND，OR或LIKE运算符。</p><h3 id="31-我们如何得到受查询影响的行数？"><a href="#31-我们如何得到受查询影响的行数？" class="headerlink" title="31. 我们如何得到受查询影响的行数？"></a>31. 我们如何得到受查询影响的行数？</h3><p>行数可以通过以下代码获得：</p><p>SELECT COUNT(user_id)FROM users;</p><h3 id="32-Mysql查询是否区分大小写？"><a href="#32-Mysql查询是否区分大小写？" class="headerlink" title="32. Mysql查询是否区分大小写？"></a>32. Mysql查询是否区分大小写？</h3><p>不区分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> VERSION(), <span class="hljs-built_in">CURRENT_DATE</span>;<br><br><span class="hljs-keyword">SeLect</span> version(), <span class="hljs-built_in">current_date</span>;<br><br><span class="hljs-keyword">seleCt</span> vErSiOn(), <span class="hljs-built_in">current_DATE</span>;<br></code></pre></td></tr></table></figure><p>所有这些例子都是一样的，Mysql不区分大小写。</p><h3 id="33-LIKE和REGEXP操作有什么区别？"><a href="#33-LIKE和REGEXP操作有什么区别？" class="headerlink" title="33.. LIKE和REGEXP操作有什么区别？"></a>33.. LIKE和REGEXP操作有什么区别？</h3><p>LIKE和REGEXP运算符用于表示^和％。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> emp_name <span class="hljs-keyword">LIKE</span> &quot;%b&quot;;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> emp_name REGEXP &quot;^b&quot;;<br></code></pre></td></tr></table></figure><h3 id="34-BLOB和TEXT有什么区别？"><a href="#34-BLOB和TEXT有什么区别？" class="headerlink" title="34.. BLOB和TEXT有什么区别？"></a>34.. BLOB和TEXT有什么区别？</h3><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB -</p><p>TINYBLOB</p><p>BLOB</p><p>MEDIUMBLOB和</p><p>LONGBLOB</p><p>它们只能在所能容纳价值的最大长度上有所不同。</p><p>TEXT是一个不区分大小写的BLOB。四种TEXT类型</p><p>TINYTEXT</p><p>TEXT</p><p>MEDIUMTEXT和</p><p>LONGTEXT</p><p>它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。</p><p>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</p><h3 id="35-mysql-fetch-array和mysql-fetch-object的区别是什么？"><a href="#35-mysql-fetch-array和mysql-fetch-object的区别是什么？" class="headerlink" title="35. mysql_fetch_array和mysql_fetch_object的区别是什么？"></a>35. mysql_fetch_array和mysql_fetch_object的区别是什么？</h3><p>以下是mysql_fetch_array和mysql_fetch_object的区别：</p><ul><li><p>mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。</p></li><li><p>mysql_fetch_object - 从数据库返回结果行作为对象。</p></li></ul><h3 id="36-我们如何在mysql中运行批处理模式？"><a href="#36-我们如何在mysql中运行批处理模式？" class="headerlink" title="36. 我们如何在mysql中运行批处理模式？"></a>36. 我们如何在mysql中运行批处理模式？</h3><p>以下命令用于在批处理模式下运行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql;<br><br>mysql mysql.out<br></code></pre></td></tr></table></figure><h3 id="37-MyISAM表格将在哪里存储，并且还提供其存储格式？"><a href="#37-MyISAM表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="37. MyISAM表格将在哪里存储，并且还提供其存储格式？"></a>37. MyISAM表格将在哪里存储，并且还提供其存储格式？</h3><p>每个MyISAM表格以三种格式存储在磁盘上：</p><p>·“.frm”文件存储表定义</p><p>·数据文件具有“.MYD”（MYData）扩展名</p><p>索引文件具有“.MYI”（MYIndex）扩展名</p><h3 id="38-Mysql中有哪些不同的表格？"><a href="#38-Mysql中有哪些不同的表格？" class="headerlink" title="38. Mysql中有哪些不同的表格？"></a>38. Mysql中有哪些不同的表格？</h3><p>共有5种类型的表格：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coq">MyISAM<br><br><span class="hljs-keyword">Heap</span><br><br>Merge<br><br>INNODB<br><br>ISAM<br></code></pre></td></tr></table></figure><p>MyISAM是Mysql的默认存储引擎。</p><h3 id="39-ISAM是什么？"><a href="#39-ISAM是什么？" class="headerlink" title="39. ISAM是什么？"></a>39. ISAM是什么？</h3><p>ISAM简称为索引顺序访问方法。它是由IBM开发的，用于在磁带等辅助存储系统上存储和检索数据。</p><h3 id="40-InnoDB是什么？"><a href="#40-InnoDB是什么？" class="headerlink" title="40. InnoDB是什么？"></a>40. InnoDB是什么？</h3><p>lnnoDB是一个由Oracle公司开发的Innobase Oy事务安全存储引擎。</p><h3 id="41-Mysql如何优化DISTINCT？"><a href="#41-Mysql如何优化DISTINCT？" class="headerlink" title="41. Mysql如何优化DISTINCT？"></a>41. Mysql如何优化DISTINCT？</h3><p>DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> t1.a <span class="hljs-keyword">FROM</span> t1,t2 <span class="hljs-keyword">where</span> t1.a<span class="hljs-operator">=</span>t2.a;<br></code></pre></td></tr></table></figure><h3 id="42-如何输入字符为十六进制数字？"><a href="#42-如何输入字符为十六进制数字？" class="headerlink" title="42. 如何输入字符为十六进制数字？"></a>42. 如何输入字符为十六进制数字？</h3><p>如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。</p><p>如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。</p><h3 id="43-如何显示前50行？"><a href="#43-如何显示前50行？" class="headerlink" title="43. 如何显示前50行？"></a>43. 如何显示前50行？</h3><p>在Mysql中，使用以下代码查询显示前50行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span><br><br>LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><h3 id="44-可以使用多少列创建索引？"><a href="#44-可以使用多少列创建索引？" class="headerlink" title="44. 可以使用多少列创建索引？"></a>44. 可以使用多少列创建索引？</h3><p>任何标准表最多可以创建16个索引列。</p><h3 id="45-NOW（）和CURRENT-DATE（）有什么区别？"><a href="#45-NOW（）和CURRENT-DATE（）有什么区别？" class="headerlink" title="45. NOW（）和CURRENT_DATE（）有什么区别？"></a>45. NOW（）和CURRENT_DATE（）有什么区别？</h3><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。</p><p>CURRENT_DATE（）仅显示当前年份，月份和日期。</p><h3 id="46-什么样的对象可以使用CREATE语句创建？"><a href="#46-什么样的对象可以使用CREATE语句创建？" class="headerlink" title="46. 什么样的对象可以使用CREATE语句创建？"></a>46. 什么样的对象可以使用CREATE语句创建？</h3><p>以下对象是使用CREATE语句创建的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DATABASE</span><br><br>EVENT<br><br><span class="hljs-keyword">FUNCTION</span><br><br><span class="hljs-keyword">INDEX</span><br><br><span class="hljs-keyword">PROCEDURE</span><br><br><span class="hljs-keyword">TABLE</span><br><br><span class="hljs-keyword">TRIGGER</span><br><br><span class="hljs-keyword">USER</span><br><br><span class="hljs-keyword">VIEW</span><br></code></pre></td></tr></table></figure><h3 id="47-Mysql表中允许有多少个TRIGGERS？"><a href="#47-Mysql表中允许有多少个TRIGGERS？" class="headerlink" title="47. Mysql表中允许有多少个TRIGGERS？"></a>47. Mysql表中允许有多少个TRIGGERS？</h3><p>在Mysql表中允许有六个触发器，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">INSERT</span><br><br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span><br><br><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">UPDATE</span><br><br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">UPDATE</span><br><br><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">DELETE</span><br><br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">DELETE</span><br></code></pre></td></tr></table></figure><h3 id="48-什么是非标准字符串类型？"><a href="#48-什么是非标准字符串类型？" class="headerlink" title="48. 什么是非标准字符串类型？"></a>48. 什么是非标准字符串类型？</h3><p>以下是非标准字符串类型：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">TINYTEXT<br><br><span class="hljs-built_in">TEXT</span><br><br>MEDIUMTEXT<br><br>LONGTEXT<br></code></pre></td></tr></table></figure><h3 id="49-什么是通用SQL函数？"><a href="#49-什么是通用SQL函数？" class="headerlink" title="49. 什么是通用SQL函数？"></a>49. 什么是通用SQL函数？</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade">CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。<br><br>FORMAT(X, D)- 格式化数字X到D有效数字。<br><br>CURRDATE(), CURRTIME()- 返回当前日期或时间。<br><br><span class="hljs-built_in">NOW</span>（） - 将当前日期和时间作为一个值返回。<br><br><span class="hljs-built_in">MONTH</span>（），<span class="hljs-built_in">DAY</span>（），<span class="hljs-built_in">YEAR</span>（），<span class="hljs-built_in">WEEK</span>（），<span class="hljs-built_in">WEEKDAY</span>（） - 从日期值中提取给定数据。<br><br><span class="hljs-built_in">HOUR</span>（），<span class="hljs-built_in">MINUTE</span>（），<span class="hljs-built_in">SECOND</span>（） - 从时间值中提取给定数据。<br><br><span class="hljs-built_in">DATEDIFF</span>（A，B） - 确定两个日期之间的差异，通常用于计算年龄<br><br>SUBTIMES（A，B） - 确定两次之间的差异。<br><br>FROMDAYS（INT） - 将整数天数转换为日期值。<br></code></pre></td></tr></table></figure><h3 id="50-解释访问控制列表"><a href="#50-解释访问控制列表" class="headerlink" title="50. 解释访问控制列表"></a>50. 解释访问控制列表</h3><p>ACL（访问控制列表）是与对象关联的权限列表。这个列表是Mysql服务器安全模型的基础，它有助于排除用户无法连接的问题。</p><p>Mysql将ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql会按照预定的顺序检查ACL的认证信息和权限。</p><h3 id="51-MYSQL支持事务吗？"><a href="#51-MYSQL支持事务吗？" class="headerlink" title="51. MYSQL支持事务吗？"></a>51. MYSQL支持事务吗？</h3><p>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。</p><p>但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT&#x3D;0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。</p><p>示例如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">一<br><br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><br><span class="hljs-keyword">SELECT</span> @A:=SUM(salary) <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span>=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">UPDATE</span> table2 <span class="hljs-keyword">SET</span> summmary=@A <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span>=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="52-mysql里记录货币用什么字段类型好"><a href="#52-mysql里记录货币用什么字段类型好" class="headerlink" title="52.  mysql里记录货币用什么字段类型好"></a>52.  mysql里记录货币用什么字段类型好</h3><p>NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。</p><p>例如：</p><p>salary DECIMAL(9,2)</p><p>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。</p><p>因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI&#x2F;ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。</p><p>同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。Mysql当前不支持DECIMAL&#x2F;NUMERIC数据类型的这些变种形式的任一种。</p><p>这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。</p><p>DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</p><p>一个字符用于值的每一位. 小数点(如果scale&gt;0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。</p><p>DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。</p><p>当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。</p><p>当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，Mysql存储表示那个范围的相应的端点值。</p><p>我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。</p><h3 id="53-MYSQL数据表在什么情况下容易损坏？"><a href="#53-MYSQL数据表在什么情况下容易损坏？" class="headerlink" title="53. MYSQL数据表在什么情况下容易损坏？"></a>53. MYSQL数据表在什么情况下容易损坏？</h3><p>服务器突然断电导致数据文件损坏。</p><p>强制关机，没有先关闭 mysql 服务等。</p><h3 id="54-mysql有关权限的表都有哪几个？"><a href="#54-mysql有关权限的表都有哪几个？" class="headerlink" title="54. mysql有关权限的表都有哪几个？"></a>54. mysql有关权限的表都有哪几个？</h3><p>Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。</p><h3 id="55-Mysql中有哪几种锁？"><a href="#55-Mysql中有哪几种锁？" class="headerlink" title="55. Mysql中有哪几种锁？"></a>55. Mysql中有哪几种锁？</h3><p>MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁。</p><ul><li><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低</p></li><li><p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试合集搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搬运自用-大数据面试题合集</title>
    <link href="/2024/05/07/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2024/05/07/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>因为zjt老是把我叫走吃夜宵害我没空看面试所以存档一份。</p><h1 id="大数据面试题及答案"><a href="#大数据面试题及答案" class="headerlink" title="大数据面试题及答案"></a>大数据面试题及答案</h1><ul><li><p><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88">大数据面试题及答案</a></p><ul><li><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88-1">大数据面试题及答案</a><ul><li><a href="#1-kafka%E7%9A%84message%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF">1 kafka的message包括哪些信息</a></li><li><a href="#2-%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8Bkafka%E7%9A%84offset">2 怎么查看kafka的offset</a></li><li><a href="#3-hadoop%E7%9A%84shuffle%E8%BF%87%E7%A8%8B">3 hadoop的shuffle过程</a><ul><li><a href="#%E4%B8%80map%E7%AB%AF%E7%9A%84shuffle">一、Map端的shuffle</a></li><li><a href="#%E4%BA%8Creduce%E7%AB%AF%E7%9A%84shuffle">二、Reduce端的shuffle</a></li></ul></li><li><a href="#4-spark%E9%9B%86%E7%BE%A4%E8%BF%90%E7%AE%97%E7%9A%84%E6%A8%A1%E5%BC%8F">4 spark集群运算的模式</a></li><li><a href="#5-hdfs%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B">5 HDFS读写数据的过程</a></li><li><a href="#6-rdd%E4%B8%ADreducebykey%E4%B8%8Egroupbykey%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E5%A5%BD%E4%B8%BA%E4%BB%80%E4%B9%88">6 RDD中reduceBykey与groupByKey哪个性能好，为什么</a></li><li><a href="#7-spark20%E7%9A%84%E4%BA%86%E8%A7%A3">7 spark2.0的了解</a></li><li><a href="#8-rdd-%E6%80%8E%E4%B9%88%E5%88%86%E5%8C%BA%E5%AE%BD%E4%BE%9D%E8%B5%96%E5%92%8C%E7%AA%84%E4%BE%9D%E8%B5%96">8 rdd 怎么分区宽依赖和窄依赖</a></li><li><a href="#9-spark-streaming-%E8%AF%BB%E5%8F%96kafka%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">9 spark streaming 读取kafka数据的两种方式</a><ul><li><a href="#receiver-base">Receiver-base</a><ul><li><a href="#direct">Direct</a></li></ul></li></ul></li><li><a href="#10-kafka%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E7%A3%81%E7%9B%98">10 kafka的数据存在内存还是磁盘</a></li><li><a href="#11-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3kafka%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">11 怎么解决kafka的数据丢失</a></li><li><a href="#12-fsimage%E5%92%8Cedit%E7%9A%84%E5%8C%BA%E5%88%AB">12 fsimage和edit的区别？</a></li><li><a href="#13-%E5%88%97%E4%B8%BE%E5%87%A0%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">13 列举几个配置文件优化？</a></li><li><a href="#14-datanode-%E9%A6%96%E6%AC%A1%E5%8A%A0%E5%85%A5-cluster-%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E6%9E%9C-log-%E6%8A%A5%E5%91%8A%E4%B8%8D%E5%85%BC%E5%AE%B9%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E9%82%A3%E9%9C%80%E8%A6%81namenode%E6%89%A7%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%93%8D%E4%BD%9C%E8%BF%99%E6%A0%B7%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF">14 datanode 首次加入 cluster 的时候，如果 log 报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？</a></li><li><a href="#15-mapreduce-%E4%B8%AD%E6%8E%92%E5%BA%8F%E5%8F%91%E7%94%9F%E5%9C%A8%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%BF%99%E4%BA%9B%E6%8E%92%E5%BA%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BB%80%E4%B9%88">15 MapReduce 中排序发生在哪几个阶段？这些排序是否可以避免？为什么？</a></li><li><a href="#16-hadoop%E7%9A%84%E4%BC%98%E5%8C%96">16 hadoop的优化？</a></li><li><a href="#17-%E8%AE%BE%E8%AE%A1%E9%A2%98">17 设计题</a></li><li><a href="#18-%E6%9C%89-10-%E4%B8%AA%E6%96%87%E4%BB%B6%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6-1g%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E5%AD%98%E6%94%BE%E7%9A%84%E9%83%BD%E6%98%AF%E7%94%A8%E6%88%B7%E7%9A%84-query%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84query-%E9%83%BD%E5%8F%AF%E8%83%BD%E9%87%8D%E5%A4%8D%E8%A6%81%E6%B1%82%E4%BD%A0%E6%8C%89%E7%85%A7-query-%E7%9A%84%E9%A2%91%E5%BA%A6%E6%8E%92%E5%BA%8F%E8%BF%98%E6%98%AF%E5%85%B8%E5%9E%8B%E7%9A%84-top-k-%E7%AE%97%E6%B3%95">18 有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的query 都可能重复。要求你按照 query 的频度排序。还是典型的 TOP K 算法</a></li><li><a href="#19-%E5%9C%A825%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B4%E6%95%B0%E6%B3%A8%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E4%BB%A5%E5%AE%B9%E7%BA%B3%E8%BF%9925%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0">19 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</a></li><li><a href="#20-%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BB%9940%E4%BA%BF%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84-unsigned-int-%E7%9A%84%E6%95%B4%E6%95%B0%E6%B2%A1%E6%8E%92%E8%BF%87%E5%BA%8F%E7%9A%84%E7%84%B6%E5%90%8E%E5%86%8D%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E8%BF%99%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E5%9C%A8%E9%82%A3-40-%E4%BA%BF%E4%B8%AA%E6%95%B0%E5%BD%93%E4%B8%AD">20 腾讯面试题：给40亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</a></li><li><a href="#21-%E6%80%8E%E4%B9%88%E5%9C%A8%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%80%E4%B8%AA">21 怎么在海量数据中找出重复次数最多的一个？</a></li><li><a href="#22-%E4%B8%8A%E5%8D%83%E4%B8%87%E6%88%96%E4%B8%8A%E4%BA%BF%E6%95%B0%E6%8D%AE%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%9F%E8%AE%A1%E5%85%B6%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E9%92%B1-n-%E4%B8%AA%E6%95%B0%E6%8D%AE">22 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。</a></li><li><a href="#23-%E4%B8%80%E4%B8%AA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%A7%E7%BA%A6%E6%9C%89%E4%B8%80%E4%B8%87%E8%A1%8C%E6%AF%8F%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%AF%8D%E8%A6%81%E6%B1%82%E7%BB%9F%E8%AE%A1%E5%87%BA%E5%85%B6%E4%B8%AD%E6%9C%80%E9%A2%91%E7%B9%81%E5%87%BA%E7%8E%B0%E7%9A%84%E5%89%8D-10-%E4%B8%AA%E8%AF%8D%E7%BB%99%E5%87%BA%E6%80%9D%E6%83%B3%E7%BB%99%E5%87%BA%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">23 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，给出思想，给出时间复杂度分析。</a></li><li><a href="#24-100w-%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%84-100-%E4%B8%AA%E6%95%B0">24 100w 个数中找出最大的 100 个数。</a></li><li><a href="#25-%E6%9C%89%E4%B8%80%E5%8D%83%E4%B8%87%E6%9D%A1%E7%9F%AD%E4%BF%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E4%BB%A5%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%BD%A2%E5%BC%8F%E4%BF%9D%E5%AD%98%E4%B8%80%E8%A1%8C%E4%B8%80%E6%9D%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E8%AF%B7%E7%94%A8-5-%E5%88%86%E9%92%9F%E6%97%B6%E9%97%B4%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D-10-%E6%9D%A1">25 有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用 5 分钟时间，找出重复出现最多的前 10 条。</a></li></ul></li></ul><h2 id="大数据面试题及答案-1"><a href="#大数据面试题及答案-1" class="headerlink" title="大数据面试题及答案"></a>大数据面试题及答案</h2><h3 id="1-kafka的message包括哪些信息"><a href="#1-kafka的message包括哪些信息" class="headerlink" title="1 kafka的message包括哪些信息"></a>1 kafka的message包括哪些信息</h3><p> 一个Kafka的Message由一个固定长度的header和一个变长的消息体body组成<br> header部分由一个字节的magic(文件格式)和四个字节的CRC32(用于判断body消息体是否正常)构成。当magic的值为1的时候，会在magic和crc32之间多一个字节的数据：attributes(保存一些相关属性，比如是否压缩、压缩格式等等)；如果magic的值为0，那么不存在attributes属性<br> body是由N个字节构成的一个消息体，包含了具体的key&#x2F;value消息</p><h3 id="2-怎么查看kafka的offset"><a href="#2-怎么查看kafka的offset" class="headerlink" title="2 怎么查看kafka的offset"></a>2 怎么查看kafka的offset</h3><p> 0.9版本以上，可以用最新的Consumer client 客户端，有consumer.seekToEnd() &#x2F; consumer.position() 可以用于得到当前最新的offset：</p><h3 id="3-hadoop的shuffle过程"><a href="#3-hadoop的shuffle过程" class="headerlink" title="3 hadoop的shuffle过程"></a>3 hadoop的shuffle过程</h3><h4 id="一、Map端的shuffle"><a href="#一、Map端的shuffle" class="headerlink" title="一、Map端的shuffle"></a>一、Map端的shuffle</h4><p> 　　Map端会处理输入数据并产生中间结果，这个中间结果会写到本地磁盘，而不是HDFS。每个Map的输出会先写到内存缓冲区中，当写入的数据达到设定的阈值时，系统将会启动一个线程将缓冲区的数据写到磁盘，这个过程叫做spill。<br> 　　在spill写入之前，会先进行二次排序，首先根据数据所属的partition进行排序，然后每个partition中的数据再按key来排序。partition的目是将记录划分到不同的Reducer上去，以期望能够达到负载均衡，以后的Reducer就会根据partition来读取自己对应的数据。接着运行combiner(如果设置了的话)，combiner的本质也是一个Reducer，其目的是对将要写入到磁盘上的文件先进行一次处理，这样，写入到磁盘的数据量就会减少。最后将数据写到本地磁盘产生spill文件(spill文件保存在{mapred.local.dir}指定的目录中，Map任务结束后就会被删除)。</p><p> 　　最后，每个Map任务可能产生多个spill文件，在每个Map任务完成前，会通过多路归并算法将这些spill文件归并成一个文件。至此，Map的shuffle过程就结束了。</p><h4 id="二、Reduce端的shuffle"><a href="#二、Reduce端的shuffle" class="headerlink" title="二、Reduce端的shuffle"></a>二、Reduce端的shuffle</h4><p> 　　Reduce端的shuffle主要包括三个阶段，copy、sort(merge)和reduce。<br> 　　首先要将Map端产生的输出文件拷贝到Reduce端，但每个Reducer如何知道自己应该处理哪些数据呢？因为Map端进行partition的时候，实际上就相当于指定了每个Reducer要处理的数据(partition就对应了Reducer)，所以Reducer在拷贝数据的时候只需拷贝与自己对应的partition中的数据即可。每个Reducer会处理一个或者多个partition，但需要先将自己对应的partition中的数据从每个Map的输出结果中拷贝过来。<br> 　　接下来就是sort阶段，也成为merge阶段，因为这个阶段的主要工作是执行了归并排序。从Map端拷贝到Reduce端的数据都是有序的，所以很适合归并排序。最终在Reduce端生成一个较大的文件作为Reduce的输入。</p><p> 　　最后就是Reduce过程了，在这个过程中产生了最终的输出结果，并将其写到HDFS上。</p><h3 id="4-spark集群运算的模式"><a href="#4-spark集群运算的模式" class="headerlink" title="4 spark集群运算的模式"></a>4 spark集群运算的模式</h3><p> Spark 有很多种模式，最简单就是单机本地模式，还有单机伪分布式模式，复杂的则运行在集群中，目前能很好的运行在 Yarn和 Mesos 中，当然 Spark 还有自带的 Standalone 模式，对于大多数情况 Standalone 模式就足够了，如果企业已经有 Yarn 或者 Mesos 环境，也是很方便部署的。<br> standalone(集群模式)：典型的Mater&#x2F;slave模式，不过也能看出Master是有单点故障的；Spark支持ZooKeeper来实现 HA<br> on yarn(集群模式)： 运行在 yarn 资源管理器框架之上，由 yarn 负责资源管理，Spark 负责任务调度和计算<br> on mesos(集群模式)： 运行在 mesos 资源管理器框架之上，由 mesos 负责资源管理，Spark 负责任务调度和计算<br> on cloud(集群模式)：比如 AWS 的 EC2，使用这个模式能很方便的访问 Amazon的 S3;Spark 支持多种分布式存储系统：HDFS 和 S3</p><h3 id="5-HDFS读写数据的过程"><a href="#5-HDFS读写数据的过程" class="headerlink" title="5 HDFS读写数据的过程"></a>5 HDFS读写数据的过程</h3><p> <strong>读：</strong><br> 1、跟namenode通信查询元数据，找到文件块所在的datanode服务器<br> 2、挑选一台datanode（就近原则，然后随机）服务器，请求建立socket流<br> 3、datanode开始发送数据（从磁盘里面读取数据放入流，以packet为单位来做校验）<br> 4、客户端以packet为单位接收，现在本地缓存，然后写入目标文件<br> <img src="https://abumaster.oss-cn-beijing.aliyuncs.com/img/fix-dir/2021/08/29/17-19-32124c8fda5fcebef7af66ce6b384f8e-20210829171928-9cce98.png" alt="HDFS读流程"></p><p> <strong>写：</strong><br> 1、根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在<br> 2、namenode返回是否可以上传<br> 3、client请求第一个 block该传输到哪些datanode服务器上<br> 4、namenode返回3个datanode服务器ABC<br> 5、client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将真个pipeline建立完成，逐级返回客户端<br> 6、client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答<br> 7、当一个block传输完成之后，client再次请求namenode上传第二个block的服务器。<br> <img src="https://abumaster.oss-cn-beijing.aliyuncs.com/img/fix-dir/2021/08/29/17-29-03c90c9fb9679c5b96cde953eb36c97d-20210829172955-4f3dd5.png" alt="HDFS写流程"></p><h3 id="6-RDD中reduceBykey与groupByKey哪个性能好，为什么"><a href="#6-RDD中reduceBykey与groupByKey哪个性能好，为什么" class="headerlink" title="6 RDD中reduceBykey与groupByKey哪个性能好，为什么"></a>6 RDD中reduceBykey与groupByKey哪个性能好，为什么</h3><pre><code class="hljs"> reduceByKey：reduceByKey会在结果发送至reducer之前会对每个mapper在本地进行merge，有点类似于在MapReduce中的combiner。这样做的好处在于，在map端进行一次reduce之后，数据量会大幅度减小，从而减小传输，保证reduce端能够更快的进行结果计算。 groupByKey：groupByKey会对每一个RDD中的value值进行聚合形成一个序列(Iterator)，此操作发生在reduce端，所以势必会将所有的数据通过网络进行传输，造成不必要的浪费。同时如果数据量十分大，可能还会造成OutOfMemoryError。</code></pre><p>  通过以上对比可以发现在进行大量数据的reduce操作时候建议使用reduceByKey。不仅可以提高速度，还是可以防止使用groupByKey造成的内存溢出问题。</p><h3 id="7-spark2-0的了解"><a href="#7-spark2-0的了解" class="headerlink" title="7 spark2.0的了解"></a>7 spark2.0的了解</h3><pre><code class="hljs"> 更简单：ANSI SQL与更合理的API 速度更快：用Spark作为编译器 更智能：Structured Streaming</code></pre><h3 id="8-rdd-怎么分区宽依赖和窄依赖"><a href="#8-rdd-怎么分区宽依赖和窄依赖" class="headerlink" title="8 rdd 怎么分区宽依赖和窄依赖"></a>8 rdd 怎么分区宽依赖和窄依赖</h3><p> 宽依赖：父RDD的分区被子RDD的多个分区使用   例如 groupByKey、reduceByKey、sortByKey等操作会产生宽依赖，会产生shuffle<br> 窄依赖：父RDD的每个分区都只被子RDD的一个分区使用  例如map、filter、union等操作会产生窄依赖</p><h3 id="9-spark-streaming-读取kafka数据的两种方式"><a href="#9-spark-streaming-读取kafka数据的两种方式" class="headerlink" title="9 spark streaming 读取kafka数据的两种方式"></a>9 spark streaming 读取kafka数据的两种方式</h3><p> 这两种方式分别是：</p><h4 id="Receiver-base"><a href="#Receiver-base" class="headerlink" title="Receiver-base"></a>Receiver-base</h4><p> 使用Kafka的高层次Consumer API来实现。receiver从Kafka中获取的数据都存储在Spark Executor的内存中，然后Spark Streaming启动的job会去处理那些数据。然而，在默认的配置下，这种方式可能会因为底层的失败而丢失数据。如果要启用高可靠机制，让数据零丢失，就必须启用Spark Streaming的预写日志机制（Write Ahead Log，WAL）。该机制会同步地将接收到的Kafka数据写入分布式文件系统（比如HDFS）上的预写日志中。所以，即使底层节点出现了失败，也可以使用预写日志中的数据进行恢复。</p><h5 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h5><p> Spark1.3中引入Direct方式，用来替代掉使用Receiver接收数据，这种方式会周期性地查询Kafka，获得每个topic+partition的最新的offset，从而定义每个batch的offset的范围。当处理数据的job启动时，就会使用Kafka的简单consumer api来获取Kafka指定offset范围的数据。</p><h3 id="10-kafka的数据存在内存还是磁盘"><a href="#10-kafka的数据存在内存还是磁盘" class="headerlink" title="10 kafka的数据存在内存还是磁盘"></a>10 kafka的数据存在内存还是磁盘</h3><p> Kafka最核心的思想是使用磁盘，而不是使用内存，可能所有人都会认为，内存的速度一定比磁盘快，我也不例外。在看了Kafka的设计思想，查阅了相应资料再加上自己的测试后，发现磁盘的顺序读写速度和内存持平。<br> 而且Linux对于磁盘的读写优化也比较多，包括read-ahead和write-behind，磁盘缓存等。如果在内存做这些操作的时候，一个是JAVA对象的内存开销很大，另一个是随着堆内存数据的增多，JAVA的GC时间会变得很长，使用磁盘操作有以下几个好处：<br> 磁盘缓存由Linux系统维护，减少了程序员的不少工作。<br> 磁盘顺序读写速度超过内存随机读写。<br> JVM的GC效率低，内存占用大。使用磁盘可以避免这一问题。<br> 系统冷启动后，磁盘缓存依然可用。</p><h3 id="11-怎么解决kafka的数据丢失"><a href="#11-怎么解决kafka的数据丢失" class="headerlink" title="11 怎么解决kafka的数据丢失"></a>11 怎么解决kafka的数据丢失</h3><p> producer端：<br> 宏观上看保证数据的可靠安全性，肯定是依据分区数做好数据备份，设立副本数。<br> broker端：<br> topic设置多分区，分区自适应所在机器，为了让各分区均匀分布在所在的broker中，分区数要大于broker数。<br> 分区是kafka进行并行读写的单位，是提升kafka速度的关键。<br> Consumer端<br> consumer端丢失消息的情形比较简单：如果在消息处理完成前就提交了offset，那么就有可能造成数据的丢失。由于Kafka consumer默认是自动提交位移的，所以在后台提交位移前一定要保证消息被正常处理了，因此不建议采用很重的处理逻辑，如果处理耗时很长，则建议把逻辑放到另一个线程中去做。为了避免数据丢失，现给出两点建议：<br> enable.auto.commit&#x3D;false  关闭自动提交位移<br> 在消息被完整处理之后再手动提交位移</p><h3 id="12-fsimage和edit的区别？"><a href="#12-fsimage和edit的区别？" class="headerlink" title="12 fsimage和edit的区别？"></a>12 fsimage和edit的区别？</h3><p>   大家都知道namenode与secondary namenode 的关系，当他们要进行数据同步时叫做checkpoint时就用到了fsimage与edit，fsimage是保存最新的元数据的信息，当fsimage数据到一定的大小事会去生成一个新的文件来保存元数据的信息，这个新的文件就是edit，edit会回滚最新的数据。</p><h3 id="13-列举几个配置文件优化？"><a href="#13-列举几个配置文件优化？" class="headerlink" title="13 列举几个配置文件优化？"></a>13 列举几个配置文件优化？</h3><p>   1）Core-site.xml 文件的优化<br>     a、fs.trash.interval，默认值： 0；说明： 这个是开启hdfs文件删除自动转移到垃圾箱的选项，值为垃圾箱文件清除时间。一般开启这个会比较好，以防错误删除重要文件。单位是分钟。<br>     b、dfs.namenode.handler.count，默认值：10；说明：hadoop系统里启动的任务线程数，这里改为40，同样可以尝试该值大小对效率的影响变化进行最合适的值的设定。<br>     c、mapreduce.tasktracker.http.threads，默认值：40；说明：map和reduce是通过http进行数据传输的，这个是设置传输的并行线程数。</p><h3 id="14-datanode-首次加入-cluster-的时候，如果-log-报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？"><a href="#14-datanode-首次加入-cluster-的时候，如果-log-报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？" class="headerlink" title="14 datanode 首次加入 cluster 的时候，如果 log 报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？"></a>14 datanode 首次加入 cluster 的时候，如果 log 报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？</h3><p>   1）这样处理是不合理的，因为那么 namenode 格式化操作，是对文件系统进行格式化，namenode 格式化时清空 dfs&#x2F;name 下空两个目录下的所有文件，之后，会在目录 dfs.name.dir 下创建文件。<br>   2）文本不兼容，有可能时 namenode 与 datanode 的 数据里的 namespaceID、clusterID 不一致，找到两个 ID 位置，修改为一样即可解决。</p><h3 id="15-MapReduce-中排序发生在哪几个阶段？这些排序是否可以避免？为什么？"><a href="#15-MapReduce-中排序发生在哪几个阶段？这些排序是否可以避免？为什么？" class="headerlink" title="15 MapReduce 中排序发生在哪几个阶段？这些排序是否可以避免？为什么？"></a>15 MapReduce 中排序发生在哪几个阶段？这些排序是否可以避免？为什么？</h3><p>   1）一个 MapReduce 作业由 Map 阶段和 Reduce 阶段两部分组成，这两阶段会对数据排序，从这个意义上说，MapReduce 框架本质就是一个 Distributed Sort。<br>   2）在 Map 阶段，Map Task 会在本地磁盘输出一个按照 key 排序（采用的是快速排序）的文件（中间可能产生多个文件，但最终会合并成一个），在 Reduce 阶段，每个 Reduce Task 会对收到的数据排序，这样，数据便按照 Key 分成了若干组，之后以组为单位交给 reduce（）处理。<br>   3）很多人的误解在 Map 阶段，如果不使用 Combiner便不会排序，这是错误的，不管你用不用 Combiner，Map Task 均会对产生的数据排序（如果没有 Reduce Task，则不会排序，实际上 Map 阶段的排序就是为了减轻 Reduce端排序负载）。<br>   4）由于这些排序是 MapReduce 自动完成的，用户无法控制，因此，在hadoop 1.x 中无法避免，也不可以关闭，但 hadoop2.x 是可以关闭的。</p><h3 id="16-hadoop的优化？"><a href="#16-hadoop的优化？" class="headerlink" title="16 hadoop的优化？"></a>16 hadoop的优化？</h3><p>   1）优化的思路可以从配置文件和系统以及代码的设计思路来优化<br>   2）配置文件的优化：调节适当的参数，在调参数时要进行测试<br>   3）代码的优化：combiner的个数尽量与reduce的个数相同，数据的类型保持一致，可以减少拆包与封包的进度<br>   4）系统的优化：可以设置linux系统打开最大的文件数预计网络的带宽MTU的配置<br>   5）为 job 添加一个 Combiner，可以大大的减少shuffer阶段的maoTask拷贝过来给远程的   reduce task的数据量，一般而言combiner与reduce相同。<br>   6）在开发中尽量使用stringBuffer而不是string，string的模式是read-only的，如果对它进行修改，会产生临时的对象，二stringBuffer是可修改的，不会产生临时对象。<br>   7）修改一下配置：以下是修改 mapred-site.xml 文件<br>     a、修改最大槽位数：槽位数是在各个 tasktracker 上的 mapred-site.xml 上设置的，默认都是 2<br> <property><br> <name>mapred.tasktracker.map.tasks.maximum</name><br> <value>2</value><br> </property><br> <property><br> <name>mapred.tasktracker.reduce.tasks.maximum</name><br> <value>2</value><br> </property><br>     b、调整心跳间隔：集群规模小于 300 时，心跳间隔为 300 毫秒<br> mapreduce.jobtracker.heartbeat.interval.min 心跳时间<br> mapred.heartbeats.in.second 集群每增加多少节点，时间增加下面的值<br> mapreduce.jobtracker.heartbeat.scaling.factor 集群每增加上面的个数，心跳增多少<br>     c、启动带外心跳<br> mapreduce.tasktracker.outofband.heartbeat 默认是 false<br>     d、配置多块磁盘<br> mapreduce.local.dir<br>     e、配置 RPC hander 数目<br> mapred.job.tracker.handler.count 默认是 10，可以改成 50，根据机器的能力<br>     f、配置 HTTP 线程数目<br> tasktracker.http.threads 默认是 40，可以改成 100 根据机器的能力<br>     g、选择合适的压缩方式，以 snappy 为例：<br> <property><br> <name>mapred.compress.map.output</name><br> <value>true</value><br> </property><br> <property><br> <name>mapred.map.output.compression.codec</name><br> <value>org.apache.hadoop.io.compress.SnappyCodec</value><br> </property></p><h3 id="17-设计题"><a href="#17-设计题" class="headerlink" title="17 设计题"></a>17 设计题</h3><p>   1）采集nginx产生的日志，日志的格式为user  ip   time  url   htmlId  每天产生的文件的数据量上亿条，请设计方案把数据保存到HDFS上，并提供一下实时查询的功能（响应时间小于3s）<br> A、某个用户某天访问某个URL的次数<br> B、某个URL某天被访问的总次数<br> 实时思路是：使用Logstash + Kafka + Spark-streaming + Redis + 报表展示平台<br> 离线的思路是：Logstash + Kafka + Elasticsearch +  Spark-streaming + 关系型数据库<br> A、B、数据在进入到Spark-streaming 中进行过滤，把符合要求的数据保存到Redis中</p><h3 id="18-有-10-个文件，每个文件-1G，每个文件的每一行存放的都是用户的-query，每个文件的query-都可能重复。要求你按照-query-的频度排序。还是典型的-TOP-K-算法"><a href="#18-有-10-个文件，每个文件-1G，每个文件的每一行存放的都是用户的-query，每个文件的query-都可能重复。要求你按照-query-的频度排序。还是典型的-TOP-K-算法" class="headerlink" title="18 有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的query 都可能重复。要求你按照 query 的频度排序。还是典型的 TOP K 算法"></a>18 有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的query 都可能重复。要求你按照 query 的频度排序。还是典型的 TOP K 算法</h3><p>   解决方案如下：<br>     1）方案 1：<br>     顺序读取 10 个文件，按照 hash(query)%10 的结果将 query 写入到另外 10 个文件（记为）中。这样新生成的文件每个的大小大约也 1G（假设 hash 函数是随机的）。 找一台内存在 2G 左右的机器，依次对用 hash_map(query, query_count)来统计每个query 出现的次数。利用快速&#x2F;堆&#x2F;归并排序按照出现次数进行排序。将排序好的 query 和对应的 query_cout 输出到文件中。这样得到了 10 个排好序的文件（记为）。 对这 10 个文件进行归并排序（内排序与外排序相结合）。<br>     2）方案 2：<br>     一般 query 的总量是有限的，只是重复的次数比较多而已，可能对于所有的 query，一次性就可以加入到内存了。这样，我们就可以采用 trie 树&#x2F;hash_map等直接来统计每个 query出现的次数，然后按出现次数做快速&#x2F;堆&#x2F;归并排序就可以了。<br>     3）方案 3：<br>     与方案 1 类似，但在做完 hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如 MapReduce），最后再进行合并。</p><h3 id="19-在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。"><a href="#19-在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。" class="headerlink" title="19 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。"></a>19 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</h3><p>   1）方案 1：采用 2-Bitmap（每个数分配 2bit，00 表示不存在，01 表示出现一次，10 表示多次，11 无意义）进行，共需内存 2^32 * 2 bit&#x3D;1 GB 内存，还可以接受。然后扫描这 2.5亿个整数，查看 Bitmap 中相对应位，如果是 00 变 01，01 变 10，10 保持不变。所描完事后，查看 bitmap，把对应位是 01 的整数输出即可。<br>   2）方案 2：也可采用与第 1 题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p><h3 id="20-腾讯面试题：给40亿个不重复的-unsigned-int-的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那-40-亿个数当中？"><a href="#20-腾讯面试题：给40亿个不重复的-unsigned-int-的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那-40-亿个数当中？" class="headerlink" title="20 腾讯面试题：给40亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？"></a>20 腾讯面试题：给40亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</h3><p>   1）方案 1：oo，申请 512M 的内存，一个 bit 位代表一个 unsigned int 值。读入 40 亿个数，设置相应的 bit 位，读入要查询的数，查看相应 bit 位是否为 1，为 1 表示存在，为 0 表示不存在。<br>   2）方案 2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下： 又因为 2^32 为 40 亿多，所以给定一个数可能在，也可能不在其中； 这里我们把 40 亿个数中的每一个用 32 位的二进制来表示 ，假设这 40 亿个数开始放在一个文件中。 然后将这 40 亿个数分成两类:<br> 1.最高位为 0<br> 2.最高位为 1<br>     并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;&#x3D;20 亿，而另一个&gt;&#x3D;20 亿（这相当于折半了）； 与要查找的数的最高位比较并接着进入相应的文件再查找 再然后把这个文件为又分成两类:<br> 1.次最高位为 0<br> 2.次最高位为 1<br>     并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;&#x3D;10 亿，而另一个&gt;&#x3D;10 亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。<br> …..<br>     以此类推，就可以找到了,而且时间复杂度为 O(logn)，方案 2 完。<br>   3)附：这里，再简单介绍下，位图方法： 使用位图法判断整形数组是否存在重复 ,判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。<br>     位图法比较适合于这种情况，它的做法是按照集合中最大元素 max 创建一个长度为 max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上 1，如遇到 5 就给新数组的第六个元素置 1，这样下次再遇到 5 想置位时发现新数组的第六个元素已经是 1 了，这说明这次的数据肯定和以前的数据存在着重复。这 种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为 2N。如果已知数组的最大值即能事先给新数组定长的话效 率还能提高一倍。</p><h3 id="21-怎么在海量数据中找出重复次数最多的一个？"><a href="#21-怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="21 怎么在海量数据中找出重复次数最多的一个？"></a>21 怎么在海量数据中找出重复次数最多的一个？</h3><p>   1）方案 1：先做 hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><h3 id="22-上千万或上亿数据（有重复），统计其中出现次数最多的钱-N-个数据。"><a href="#22-上千万或上亿数据（有重复），统计其中出现次数最多的钱-N-个数据。" class="headerlink" title="22 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。"></a>22 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。</h3><p>   1）方案 1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用 hash_map&#x2F;搜索二叉树&#x2F;红黑树等来进行统计次数。然后就是取出前 N 个出现次数最多的数据了，可以用第 2 题提到的堆机制完成。</p><h3 id="23-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前-10-个词，给出思想，给出时间复杂度分析。"><a href="#23-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前-10-个词，给出思想，给出时间复杂度分析。" class="headerlink" title="23 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，给出思想，给出时间复杂度分析。"></a>23 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，给出思想，给出时间复杂度分析。</h3><p>   1）方案 1：这题是考虑时间效率。用 trie 树统计每个词出现的次数，时间复杂度是 O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前 10 个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是 O(n</em>lg10)。所以总的时间复杂度，是 O(n<em>le)与 O(n</em>lg10)中较大的哪一 个。</p><h3 id="24-100w-个数中找出最大的-100-个数。"><a href="#24-100w-个数中找出最大的-100-个数。" class="headerlink" title="24 100w 个数中找出最大的 100 个数。"></a>24 100w 个数中找出最大的 100 个数。</h3><p>   1）方案 1：在前面的题中，我们已经提到了，用一个含 100 个元素的最小堆完成。复杂度为O(100w<em>lg100)。<br>   2）方案 2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比 100 多的时候，采用传统排序算法排序，取前 100 个。复杂度为 O(100w</em>100)。<br>   3）方案 3：采用局部淘汰法。选取前 100 个元素，并排序，记为序列 L。然后一次扫描剩余的元素 x，与排好序的 100 个元素中最小的元素比，如果比这个最小的 要大，那么把这个最小的元素删除，并把 x 利用插入排序的思想，插入到序列 L 中。依次循环，直到扫描了所有的元素。复杂度为 O(100w*100)。</p><h3 id="25-有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用-5-分钟时间，找出重复出现最多的前-10-条。"><a href="#25-有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用-5-分钟时间，找出重复出现最多的前-10-条。" class="headerlink" title="25 有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用 5 分钟时间，找出重复出现最多的前 10 条。"></a>25 有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用 5 分钟时间，找出重复出现最多的前 10 条。</h3><p>   1）分析： 常规方法是先排序，在遍历一次，找出重复最多的前 10 条。但是排序的算法复杂度最低为nlgn。<br>   2）可以设计一个 hash_table, hash_map&lt;string, int&gt;，依次读取一千万条短信，加载到hash_table 表中，并且统计重复的次数，与此同时维护一张最多 10 条的短信表。 这样遍历一次就能找出最多的前 10 条，算法复杂度为 O(n)。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试合集搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>放个shoppee笔试合集吧方便复习</title>
    <link href="/2024/05/07/%E6%94%BE%E4%B8%AAshoppee%E7%AC%94%E8%AF%95%E5%90%88%E9%9B%86%E5%90%A7%E6%96%B9%E4%BE%BF%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/05/07/%E6%94%BE%E4%B8%AAshoppee%E7%AC%94%E8%AF%95%E5%90%88%E9%9B%86%E5%90%A7%E6%96%B9%E4%BE%BF%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>每次笔试前（这次有笔试吗？zjt说没有）编译器就必定会出幺蛾子，幸好他推荐给我一个网站：<a href="https://vscch.guyutongxue.site/">https://vscch.guyutongxue.site/</a><br>（感谢谷雨同学！！！救大命了）<br>下载一个这个编译器就可以运行</p><p>请注意！！！一定要按F6，不要去戳那个右上角的运行按钮！！！（终于能跑通了呜呜呜，而且不用加system(“pause”)，太牛了，，，</p><h1 id="一、最大整数"><a href="#一、最大整数" class="headerlink" title="一、最大整数"></a>一、最大整数</h1><p>给定一个int数组nums，排列每个数的顺序（每个数不可拆分，比如12不能拆成1和2），使之组成一个最大的整s数。<br>注意：输出结果可能非常大，所以返回一个字符串而不是整数。<br>输入样例：[10,2]<br>输出样例：“210”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string a,string b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b &gt; b+a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>    vector&lt;string&gt;strnum;<br>    <span class="hljs-comment">// int cur = 0;</span><br>    string temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>|| s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            <span class="hljs-comment">// 非数字字符，忽略</span><br>            strnum.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-comment">// cur = cur + 1;</span><br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp=temp+s[i];<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-type">int</span> size = strnum.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// for (int i=0;i&lt;size;i++)&#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;strnum[i]&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-built_in">sort</span>(strnum.<span class="hljs-built_in">begin</span>(),strnum.<span class="hljs-built_in">end</span>(),cmp);<br>    string result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        result = result + strnum[i];<br><br>    &#125;<br>    cout&lt;&lt;result;<br>    <span class="hljs-comment">// system(&quot;pause&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>演练</title>
    <link href="/2024/05/07/%E6%BC%94%E7%BB%83/"/>
    <url>/2024/05/07/%E6%BC%94%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<p>吸取上次xhs笔试失败经验（题没刷完就去匆匆笔试</p><p>这次简历一投就去techguide里刷题了</p><p>but shoppee给数据的方式看着好怪，就算不一定真的给这么怪的输入样例hyx也不能掉以轻心！</p><p>它给的测试样例是这样的：[10,2]</p><p>我试问最后官网上难道也有那两个方括号吗，，如果我没准备过一眼看到会心态颤抖一下，，但是时间是金钱，于是hyx把这点也考虑到了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>    vector&lt;string&gt;strnum;<br>    <span class="hljs-comment">// int cur = 0;</span><br>    string temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>|| s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            <span class="hljs-comment">// 非数字字符，忽略</span><br>            strnum.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-comment">// cur = cur + 1;</span><br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp=temp+s[i];<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-type">int</span> size = strnum.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        cout&lt;&lt;strnum[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shoppee笔试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop+python实现博客中文词频统计</title>
    <link href="/2024/05/05/Hadoop-python%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"/>
    <url>/2024/05/05/Hadoop-python%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>一时兴起想做个博客关键词统计！（如果有空的话看看能不能打包成插件发布到hexo上面）<br><img src="/../img/hadoop%E6%88%90%E5%93%81/wordcloud.png" alt="词云图example"><br>看到的时候还有点纳闷怎么“父亲”和“母亲”两个这么书面的词出现频率那么高，后来仔细一看——鉴定为看弗兰肯斯坦看的（之前读评论文的时候写了一堆）。</p><p>po一个小小的攻略在这里！（项目地址：<a href="https://github.com/Liebe-grausam/hadoop_chinese_wordcount%EF%BC%89">https://github.com/Liebe-grausam/hadoop_chinese_wordcount）</a></p><p>前置准备：ubuntu20.04 + hadoop环境，以及python文件运行必要的包。</p><p>step 1：<br>在input文件夹中放入待处理的文件。<br><img src="/../img/hadoop%E6%88%90%E5%93%81/input%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E5%AE%B9.png" alt="input文件夹内容"></p><p>step 2：<br>在script文件夹下启动终端，运行代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop jar <span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-regexp">/share/</span>hadoop<span class="hljs-regexp">/tools/</span>lib<span class="hljs-regexp">/hadoop-streaming-version.jar -files mapper.py,reducer.py -mapper &quot;python3 mapper.py&quot; -reducer &quot;python3 reducer.py&quot; -input road_to_repo/i</span>nput<span class="hljs-regexp">/ -output road_to_repo/</span>output/<br></code></pre></td></tr></table></figure><p>其中“hadoop-streaming-version.jar”的“version”要改成你的hadoop的实际版本，“road_to_repo”要改成克隆下来的该项目文件夹所在路径。</p><p><strong>most important!：此命令为一次性操作，如果运行失败，必须把生成的output文件夹删掉之后再重新运行该命令。</strong></p><p>代码运行需要一定时间，如果单纯为学习目的可以使用small_input文件夹作为输入。</p><p>代码运行结果保存在output文件夹下的part-00000中。<br><img src="/../img/hadoop%E6%88%90%E5%93%81/part-00000.png" alt="part-00000内容"></p><p>step 3：<br>由于MapReduce的作用是统计词频，并不是用来生成词云图，因此还需要将刚才的运行结果拷贝到script文件夹中的output.txt。<br>在script文件夹下启动终端，运行代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> word_cloud.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>即可得到同一目录下保存的word_cloud.png。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reduce成功！</title>
    <link href="/2024/05/04/reduce%E6%88%90%E5%8A%9F%EF%BC%81/"/>
    <url>/2024/05/04/reduce%E6%88%90%E5%8A%9F%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>编写了reduce文件并运行成功了！来备个份</p><p>split_mapper.py的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> jieba<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-comment"># 在这里对数据进行处理，比如去除非中文字符，并分词</span><br>    content = re.sub(<span class="hljs-string">r&#x27;[^\u4e00-\u9fa5]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, data)  <span class="hljs-comment"># 去除非中文字符</span><br>    words = jieba.cut(content)  <span class="hljs-comment"># 分词</span><br>    <span class="hljs-keyword">return</span> words<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>        words = process_data(line.strip())<br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;word&#125;</span>\t1&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>split_reducer.py的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reducer</span>():<br>    current_word = <span class="hljs-literal">None</span><br>    current_count = <span class="hljs-number">0</span><br>    word_count_dict = defaultdict(<span class="hljs-built_in">int</span>)<br><br>    <span class="hljs-comment"># 读取来自Mapper的输入</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>        word, count = line.strip().split(<span class="hljs-string">&#x27;\t&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 转换计数为整数类型</span><br>        <span class="hljs-keyword">try</span>:<br>            count = <span class="hljs-built_in">int</span>(count)<br>        <span class="hljs-keyword">except</span> ValueError:<br>            <span class="hljs-comment"># 如果无法转换，就跳过这一行</span><br>            <span class="hljs-keyword">continue</span><br>        <br>        <span class="hljs-comment"># 合并相同的单词并计算总次数</span><br>        <span class="hljs-keyword">if</span> current_word == word:<br>            current_count += count<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 输出累积的单词计数</span><br>            <span class="hljs-keyword">if</span> current_word:<br>                word_count_dict[current_word] += current_count<br>            current_word = word<br>            current_count = count<br><br>    <span class="hljs-comment"># 处理最后一个单词</span><br>    <span class="hljs-keyword">if</span> current_word == word:<br>        word_count_dict[current_word] += current_count<br><br>    <span class="hljs-comment"># 输出最终结果</span><br>    <span class="hljs-keyword">for</span> word, count <span class="hljs-keyword">in</span> word_count_dict.items():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;word&#125;</span>\t<span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    reducer()<br></code></pre></td></tr></table></figure><p>终端运行代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop jar <span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-regexp">/share/</span>hadoop<span class="hljs-regexp">/tools/</span>lib<span class="hljs-regexp">/hadoop-streaming-3.4.0.jar -files split_mapper.py,split_reducer.py -mapper &quot;python3 split_mapper.py&quot; -reducer &quot;python3 split_reducer.py&quot; -input ~/</span>桌面<span class="hljs-regexp">/posts/</span>small_input<span class="hljs-regexp">/ -output ~/</span>桌面<span class="hljs-regexp">/posts/</span>f_output/<br></code></pre></td></tr></table></figure><p>注意：选项是files不是file（因为是多个文件），并且要用逗号分隔而不是空格</p><p><img src="/../img/hadoop/%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%BB%93%E6%9E%9C.png" alt="词频统计结果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中文词频统计第一部分</title>
    <link href="/2024/05/04/%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <url>/2024/05/04/%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>先总结一下今天干了什么（工作日报</p><p>使用jieba进行分词，将post里的input文件夹下的所有.md文件读进标准输入，删除日期、标签、标题等元数据，过滤非中文字符，输出以每个词为键、值为1的键值对，表示该词出现了一次。</p><p><img src="/../img/hadoop/split.txt.png" alt="原来的输出版本，一堆未经处理的以空格分割的分词"></p><p><img src="/../img/hadoop/%E6%9C%AA%E7%BB%8Freduce%E7%9A%84%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1.png" alt="未经reduce的词频统计"></p><p>下一步的操作是要编辑reduce文件，使得同一键的count合并</p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跑通第二个hadoop</title>
    <link href="/2024/05/04/%E8%B7%91%E9%80%9A%E7%AC%AC%E4%BA%8C%E4%B8%AAhadoop/"/>
    <url>/2024/05/04/%E8%B7%91%E9%80%9A%E7%AC%AC%E4%BA%8C%E4%B8%AAhadoop/</url>
    
    <content type="html"><![CDATA[<p>跑的第一个hadoop是hadoop自带的英文词频统计。</p><p>因为自己手头有一堆博客的md文件，于是想做一个中文的词频统计。</p><p>（扩完容之后开跑！</p><p>苯人环境：hadoop单机版 Ubuntu20.04</p><p>苯人文件夹结构：</p><ul><li>posts<ul><li>scripts<ul><li>mapper.py</li><li>reducer.py（仍在编写中</li></ul></li><li>small_input<ul><li>*.md</li></ul></li><li>a_output<ul><li>…</li></ul></li></ul></li></ul><p>终端代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop jar <span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-regexp">/share/</span>hadoop<span class="hljs-regexp">/tools/</span>lib<span class="hljs-regexp">/hadoop-streaming-3.4.0.jar -file mapper.py -mapper &quot;python3 mapper.py&quot; -input ~/</span>桌面<span class="hljs-regexp">/posts/</span>small_input<span class="hljs-regexp">/ -output ~/</span>桌面<span class="hljs-regexp">/posts/</span>a_output/<br></code></pre></td></tr></table></figure><p>可以每打一部分就用“\”作为分割符，就可以接着输没输完的命令</p><p>mapper.py代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> jieba<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_input</span>(<span class="hljs-params">file</span>):<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br>        <span class="hljs-keyword">yield</span> line<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">separator=<span class="hljs-string">&#x27;\t&#x27;</span></span>):<br>    <span class="hljs-comment"># 输入来自标准输入(stdin)</span><br>    data = read_input(sys.stdin)<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data:<br>        line = line.strip()<br>        <span class="hljs-comment"># 提取标题、日期和标签</span><br>        title = re.findall(<span class="hljs-string">r&#x27;title:\s*(.+)&#x27;</span>, line)<br>        date = re.findall(<span class="hljs-string">r&#x27;date:\s*(.+)&#x27;</span>, line)<br>        tags = re.findall(<span class="hljs-string">r&#x27;tags:\s*(.+)&#x27;</span>, line)<br>        <span class="hljs-keyword">if</span> title:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;title:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;title[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> date:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;date:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;date[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> tags:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;tags:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;tags[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 提取正文并分词</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line.startswith(<span class="hljs-string">&#x27;---&#x27;</span>) <span class="hljs-keyword">and</span> line.strip():<br>            <span class="hljs-comment"># 去除非中文字符</span><br>            content = re.sub(<span class="hljs-string">r&#x27;[^\u4e00-\u9fa5]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, line)<br>            words = jieba.cut(content)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;content:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;<span class="hljs-string">&#x27; &#x27;</span>.join(words)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>分词成功！</p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最复杂的系统往往只需要最简单的扩容方式</title>
    <link href="/2024/05/04/%E6%9C%80%E5%A4%8D%E6%9D%82%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BE%80%E5%BE%80%E5%8F%AA%E9%9C%80%E8%A6%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/05/04/%E6%9C%80%E5%A4%8D%E6%9D%82%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BE%80%E5%BE%80%E5%8F%AA%E9%9C%80%E8%A6%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>环境：Ubuntu 20.04</p><p>先在虚拟机设置中增加硬盘容量，不过此时还处于灰色未分配状态</p><p>扩容前安装gparted</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install gparted<br></code></pre></td></tr></table></figure><p>终端运行gparted，出现图形界面</p><p>&#x2F;dev&#x2F;sda1 为主分区<br>&#x2F;dev&#x2F;sda2 为扩展分区<br>&#x2F;dev&#x2F;sda5 为逻辑分区（我的sda5挂在sda2目录下</p><p>这个时候的正确操作（网上绝无仅有版！）：</p><p>step1<br>右键sda2所在分区，选择更改大小选项，将箭头拖到最右端</p><p>step2<br>右键sda5所在分区，选择更改大小选项，将箭头拖到最右端</p><p>两个都要改！！因为是挂载版，比较特殊</p><p>（在尝试这个方法前还尝试了fdisk，并且gparted大部分人分区和我不一样（他们好像没有扩展分区所以没办法复现，中间甚至碰到了很多稀奇古怪的错误，，，<strong>虚拟机快照</strong>你值得拥有</p>]]></content>
    
    
    
    <tags>
      
      <tag>vmware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置hadoop环境</title>
    <link href="/2024/05/04/%E9%85%8D%E7%BD%AEhadoop%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/05/04/%E9%85%8D%E7%BD%AEhadoop%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>大学生哪有不疯的，，，</p><p>今天回到寝室，查了一下日常实习的岗位，决定向大数据工程师发起进攻（数据挖掘是算法，算法达咩</p><p>流程：尝试在docker上装hadoop镜像未遂，尝试装裸机版，被百度网盘的垃圾网速和windows的傻逼环境整笑了（发现文件夹里有.sh文件所以最后还是决定用虚拟机，，，装了好几个小时终于！</p><p><img src="/../img/env/475981eb67fff95876bff514e239de3.png" alt="java与hadoop运行成功界面"></p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表！</title>
    <link href="/2024/05/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%81/"/>
    <url>/2024/05/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>初构造链表类<br>此题要点：迭代法，保存cur nxt pre，因为改指针后会丢失原来的信息，注意return的东西是pre<br>自己可以定义类定义测试数据的话其实自由度很大</p><p>加油加油</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    node* next;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> v)&#123;<br>        value=v;<br>        next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function">node* <span class="hljs-title">reverse_node</span><span class="hljs-params">(node*head)</span></span>&#123;<br>    node* cur = head;<br>    node* nxt = <span class="hljs-literal">nullptr</span>;<br>    node* pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>        nxt = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(node*head)</span></span>&#123;<br>    node*cur = head;<br>    <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;cur-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cur = cur-&gt;next;<br><br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>    node* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>);<br>    head-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">2</span>);<br>    head-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">3</span>);<br>    head-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">print_list</span>(head);<br>    <span class="hljs-built_in">print_list</span>(<span class="hljs-built_in">reverse_node</span>(head));<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>手搓代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题前置知识</title>
    <link href="/2024/05/01/leetcode%E5%88%B7%E9%A2%98%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/05/01/leetcode%E5%88%B7%E9%A2%98%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>不太确定到时候会不会真的要求手搓，，</p><p>反正手搓的时候也可以借鉴，先刷力扣，把思路看会了起。</p><p>其实二叉搜索树索引和左右节点是对应的（理解一下，<br>left_child_index &#x3D; parent_index * 2 + 1<br>right_child_index &#x3D; parent_index * 2 + 2</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再不找工作就只能家里蹲进tz了！</title>
    <link href="/2024/05/01/%E5%86%8D%E4%B8%8D%E6%89%BE%E5%B7%A5%E4%BD%9C%E5%B0%B1%E5%8F%AA%E8%83%BD%E5%AE%B6%E9%87%8C%E8%B9%B2%E8%BF%9Btz%E4%BA%86%EF%BC%81/"/>
    <url>/2024/05/01/%E5%86%8D%E4%B8%8D%E6%89%BE%E5%B7%A5%E4%BD%9C%E5%B0%B1%E5%8F%AA%E8%83%BD%E5%AE%B6%E9%87%8C%E8%B9%B2%E8%BF%9Btz%E4%BA%86%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>hyx要加油！（还是不习惯翻墙搜索，，</p><p>这几天玩的差不多了，开始准备力扣算法题（希望不要再被机试刷下来了</p><p>补：日常实习好像没有机试，正合我意</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于恐惧和爱的选择</title>
    <link href="/2024/04/26/%E5%85%B3%E4%BA%8E%E6%81%90%E6%83%A7%E5%92%8C%E7%88%B1%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <url>/2024/04/26/%E5%85%B3%E4%BA%8E%E6%81%90%E6%83%A7%E5%92%8C%E7%88%B1%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p>关于恐惧和爱的选择，我们最好选择爱吧，因为死亡就要降临。（感觉这句特别好！想要写到歌词里去</p>]]></content>
    
    
    
    <tags>
      
      <tag>bubble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>假期开始！</title>
    <link href="/2024/04/26/%E5%81%87%E6%9C%9F%E5%BC%80%E5%A7%8B%EF%BC%81/"/>
    <url>/2024/04/26/%E5%81%87%E6%9C%9F%E5%BC%80%E5%A7%8B%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>多吃主食就可以增肥！</p><p>找老师开了一下小灶，发现是练习方法的问题，现在可以踢5个了！老师还说如果我能踢到10个（对？没听清）就直接联系她，嘿嘿！（离三对合格只差一个！看来期末合格有望！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GOOD NEWS!</title>
    <link href="/2024/04/26/GOOD-NEWS/"/>
    <url>/2024/04/26/GOOD-NEWS/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/html_dialect.png" alt="html_dialect"><br>将combine.py和modulate.py合并为一个文件，命名为generate.py，看上去更加简洁。</p><p>vscode中可以直接运行generate.py，开启一个新的终端，在终端中按规定运行即可在文件夹内生成对应的读音。</p><p>原来的raw文件夹全都删除，只留下预处理后的文件，去掉了文件夹的output前缀，看上去更加精练！python api与html方面即将进入尾声！如果成功调用api，就开启下一步的方言数据库建设，敬请期待！</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尝试搭前端界面！</title>
    <link href="/2024/04/25/%E5%B0%9D%E8%AF%95%E6%90%AD%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2/"/>
    <url>/2024/04/25/%E5%B0%9D%E8%AF%95%E6%90%AD%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>借助chatgpt搭了一个较为丑陋的前端界面（虽然觉得它丑，然后就push chatgpt再写了一个稍微好看一点的界面）</p><p>装了一些用来写前端的扩展，在菜鸟教程的推荐下装了一些前端常用的插件，比如：fitten code，看着它在每次我输入日记的时候它会自动给我补全一些东西，但是它补全的完全不是我想说的哈哈哈哈啊哈哈，发现ai取代人类的思维还是为时尚早！</p><p>明天晚上7点有个xhs笔试，但是那个时候我在火车上了！（顺延掉吧哈哈哈哈哈哈 还是寄希望于投日常实习好了（简历太丑，现在也在抓紧学一些东西</p><p>前端地位低，，自己玩玩还行，去公司最好还是投后端岗位，毕竟前端的工作主要是写代码，后端的工作主要是写接口，数据库，服务器等等，前端的工作量相对后端来说要小很多，而且前端的技术栈相对后端来说更加简单，所以更适合个人学习。（后面的原因是fitten code补全的</p><p>以下是index.html的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Text Reader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;hr&gt;</span><br><span class="hljs-comment">    &lt;h1&gt;Text Reader&lt;/h1&gt;</span><br><span class="hljs-comment">    &lt;hr&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;textInput&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请键入吴语拼音&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;readButton&quot;</span>&gt;</span>Read<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;app.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是styles.css的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Arial&#x27;</span>, sans-serif;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f4f4f4</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>);<br>&#125;<br><br><span class="hljs-selector-id">#textInput</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>&#125;<br><br><span class="hljs-selector-id">#readButton</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#007BFF</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">border</span>: none;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">transition</span>: background-color <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><br><span class="hljs-selector-id">#readButton</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0334f6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（这fitten code还怪聪明的</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哇！我运行了第一个Flask程序</title>
    <link href="/2024/04/25/%E5%93%87%EF%BC%81%E6%88%91%E8%BF%90%E8%A1%8C%E4%BA%86%E7%AC%AC%E4%B8%80%E4%B8%AAFlask%E7%A8%8B%E5%BA%8F/"/>
    <url>/2024/04/25/%E5%93%87%EF%BC%81%E6%88%91%E8%BF%90%E8%A1%8C%E4%BA%86%E7%AC%AC%E4%B8%80%E4%B8%AAFlask%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>python的程序已经差不多搭建完成了！（今天录入了全部的音素 方言词典开发计划进入下一阶段，即在web网页中嵌入python代码</p><p>发现了flask这个宝藏应用程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Filename : example.py</span><br><span class="hljs-comment"># Copyright : 2020 By Nhooo</span><br><span class="hljs-comment"># Author by : www.cainiaojc.com</span><br><span class="hljs-comment"># Date : 2020-08-08</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World&#x27;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>只要把这个代码保存到hello.py中并在终端中运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python hello.py<br></code></pre></td></tr></table></figure><p>就可以在弹出的本地端口中发现网页上已经展示了一行“helloworld”~</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大连行程</title>
    <link href="/2024/04/25/%E5%A4%A7%E8%BF%9E%E8%A1%8C%E7%A8%8B/"/>
    <url>/2024/04/25/%E5%A4%A7%E8%BF%9E%E8%A1%8C%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>因为五一打算去日照看海，突然想起之前去了大连的一些行程没有记录，遂记</p><p>当时应该就是7.3-7.5，中间下雨的时候就宅在民宿里，幸运的是同时看到了晴天的海和阴天的海。拍了很多人生照片嘿嘿</p><p>凭着记忆写一波：</p><p>7.3<br>傍晚的时候坐高铁到的大连（甚至还有地铁<br>安顿并且追剧</p><p>7.4<br>下午（雨）：<br>有轨电车<br>罗斯福广场<br>KKV（逛过最大的KKV！强烈安利</p><p>傍晚（雨）：<br>星海公园</p><p>7.5<br>星海广场！！<br>住宿定在了汉庭优佳大连机场酒店（因为第二天要飞到宁波去了</p>]]></content>
    
    
    
    <tags>
      
      <tag>travel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现列表化输入</title>
    <link href="/2024/04/25/%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E5%8C%96%E8%BE%93%E5%85%A5/"/>
    <url>/2024/04/25/%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E5%8C%96%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>这次对modulate和combine进行了扩展，使得它们不仅可以处理单个音素，现在可以批量处理了，由于如果输入输出是相同路径很容易造成损坏，于是建了一个临时文件夹来存放中间值。</p><p>深深体会到了分部编程的好处（不会短时间内引入大量的bug，循序渐进</p><p>写完了米德尔马契的ddl！明天写探奥论文（以及要整理出去玩的东西啦！！顺便做攻略</p><p>干的事情一多甚至已经来不及写博客了，，直接po一个readme来汇报一下现在的进度<br><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/%E8%BE%93%E5%85%A5%E9%9F%B3%E7%B4%A0%E4%B8%8E%E5%8D%87%E9%99%8D%E5%8D%8A%E9%9F%B3%E6%95%B0%E5%85%83%E7%BB%84%E5%88%97%E8%A1%A8.png" alt="README更新"></p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现变调功能并封装预处理py</title>
    <link href="/2024/04/22/%E5%AE%9E%E7%8E%B0%E5%8F%98%E8%B0%83%E5%8A%9F%E8%83%BD%E5%B9%B6%E5%B0%81%E8%A3%85%E9%A2%84%E5%A4%84%E7%90%86py/"/>
    <url>/2024/04/22/%E5%AE%9E%E7%8E%B0%E5%8F%98%E8%B0%83%E5%8A%9F%E8%83%BD%E5%B9%B6%E5%B0%81%E8%A3%85%E9%A2%84%E5%A4%84%E7%90%86py/</url>
    
    <content type="html"><![CDATA[<p>北京下了很大很大的雨，感觉像回家了，自己是满是水的星球上的厄崔迪王子</p><p>今天写完了经济地理学的论文，刷完了党课在线学习视频，实现了变调功能，还封装了preprocessing.py（把预处理功能的py全部整合到同一个文件，封装函数接口</p><p>满是水的天气使我开心与振奋，，应该是太想家了（以及没淋到雨嘿嘿</p><p>冲了很久的热水澡，虽然联系了一个想做小程序的学姐并且杳无音讯，但是她应该会去淘宝上找代做吧！PaperPass居然可以降AIGC，，，真的太牛了，让AI改AI。</p><p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/%E6%9B%B4%E6%96%B0modulate.png" alt="更新modulate"></p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比较优势</title>
    <link href="/2024/04/22/%E6%AF%94%E8%BE%83%E4%BC%98%E5%8A%BF/"/>
    <url>/2024/04/22/%E6%AF%94%E8%BE%83%E4%BC%98%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>“东亚经济奇迹”一个很重要的特点，就是政府帮助本土企业进入复杂度很高的行业，充分利用其中的学习效应、规模效应和技术外溢效应，迅速提升本土制造业的技术能力和国际竞争力。假如韩国按照其1970年显示出的“比较优势”来规划产业，就应该听从世界银行的建议去发展纺织业。但韩国没有这么做，而是一头扎进了本国根本没有的产业。到了1990年，韩国最具“比较优势”的十大类出口商品，比如轮船和电子产品，1970年时根本就不存在。可见“比较优势”具有很大的不确定性，是可以靠人为创造的。其实“比较优势”并不神秘，就是机会成本低的意思。而对于没干过的事情，事前其实无从准确判断机会成本，没干过怎么知道呢？中国也是如此。政府和私人部门合力进入很多复杂的、传统上没有比较优势的行业，但经过多年发展，其产品如今在国际上已经有了比较优势。</p></blockquote><p>感觉这一段写的特别好！比较优势具有很大的不确定性，是可以靠人为创造的。事前无从准确判断机会成本，没干过怎么知道呢？</p><blockquote><p>从光伏产业的发展中，我们还可以看到“东亚产业政策模式”的另一个特点：强调出口。当国内市场有限时，海外市场可以促进竞争，迫使企业创新。补贴和优惠政策难免会产生一些低效率的企业，但这些企业在面对挑剔的海外客户时，是无法过关的。而出口量大的公司，往往是效率相对高的公司，它们市场份额的扩大，会吸纳更多的行业资源，压缩国内低效率同行的生存空间，淘汰一些落后产能。当然，像我国这样的大国，要应对的国际局势变幻比小国更加复杂，所以不断扩大和稳定国内市场，才是行业长期发展的基础。另一方面，若地方政府利用行政手段阻碍落后企业破产，就会阻碍优胜劣汰和效率提升，加剧产能过剩的负面影响。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平滑连接元音辅音</title>
    <link href="/2024/04/21/%E5%B9%B3%E6%BB%91%E8%BF%9E%E6%8E%A5%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3/"/>
    <url>/2024/04/21/%E5%B9%B3%E6%BB%91%E8%BF%9E%E6%8E%A5%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<p>配了一副新眼镜和一副新墨镜！（今天干的事情好多反而懒得写博客了哈哈哈</p><p>发现方言网站上有很多音频缺失了，于是还是打算自己录了（主要是为了保持音色和声调的一致，不然合成会很奇怪</p><p>今天最重大的成就是平滑连接了元音和辅音（t+ei&#x3D;tei）经过反复的调整迭代出了一个最优的合成方案（不知道是否适用于别的组合的情形呢</p><p>批处理真的很方便，，这几天主要在做预处理的事情，全都在为后面做铺垫（慢慢来吧！这几天也学到了很多东西！就像疯狂星期一说的那样 不要留下遗憾，不要一遍一遍地让人生重来 想着先干完这个就一定有时间去干别的东西类似的事情</p><p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/0421dialect.png" alt="今日进度"><br><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/readme%E6%9B%B4%E6%96%B0%E9%A2%84%E5%A4%84%E7%90%86.png" alt="README更新预处理部分"></p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重大突破-分离辅音</title>
    <link href="/2024/04/20/%E9%87%8D%E5%A4%A7%E7%AA%81%E7%A0%B4/"/>
    <url>/2024/04/20/%E9%87%8D%E5%A4%A7%E7%AA%81%E7%A0%B4/</url>
    
    <content type="html"><![CDATA[<p>发现配的环境还是不大行，，于是今天又倒腾了好久的环境</p><p>一直很好奇为什么终端每次打印环境变量的时候都会出现一些奇怪的字符 就算是人工键入也是非常奇怪的字符，今天破案了</p><p>下次输环境变量的时候不要再右键文件属性然后复制了，直接点<br><img src="/../img/env/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240420234648.png" alt="watch this"><br>就会出来一个直接可以复制的地址，这样就不会出现奇怪的字符了</p><p>再不行就重新下一个包（注意一下下载的是essential部分还是full部分 以免漏掉一些东西 不过我感觉根源还是上面的复制问题</p><p>又仔细研究了一下上次下的synthesis轮子，（如果方言能像拼音一样直接拼出来就好了，拆解成多个音频，每个音频播放固定的时长</p><p>居然被我找到了！吴语拼音！因为玉环话和温岭话比较相近所以打算采用温岭话拼音方案！<a href="https://wu-chinese.com/romanization/wenling.html">吴语协会温岭话拼音链接</a></p><p>从官网的辅音介绍下载了一个ogg（既然是方言爱好者官网的，肯定比我这个“门外汉”读的标准），但是问题在于这个音频是送气的（ta），所以就在想怎么把辅音和元音分开，问了chatgpt给的答案也不尽人意，最后hyx发挥了她的智慧——</p><p>主要思路就是利用pydub库（一个处理音频的库），将官网下载的音频找到非静音部分（这个灵感来源是华为录音的跳过静音功能），再截取前面的一小部分，就可以分离开了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydub <span class="hljs-keyword">import</span> AudioSegment<br><span class="hljs-keyword">from</span> pydub.silence <span class="hljs-keyword">import</span> detect_nonsilent<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 加载音频文件</span><br>audio_file = <span class="hljs-string">&quot;ta.ogg&quot;</span><br>audio = AudioSegment.from_ogg(audio_file)<br><br><span class="hljs-comment"># 使用detect_nonsilent找到非静音部分</span><br>nonsilent_intervals = detect_nonsilent(audio, silence_thresh=-<span class="hljs-number">40</span>, min_silence_len=<span class="hljs-number">50</span>)<br><br><span class="hljs-comment"># 获取第一个非静音部分的开始位置</span><br><span class="hljs-keyword">if</span> nonsilent_intervals:<br>    start_pos = nonsilent_intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 截取去掉静音部分后的前25毫秒音频</span><br>    chunk = audio[start_pos:start_pos + <span class="hljs-number">25</span>]  <br><br>    <span class="hljs-comment"># 创建一个新的音频文件夹来保存截取出的音频</span><br>    output_folder = <span class="hljs-string">&quot;output_audio&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_folder):<br>        os.mkdir(output_folder)<br><br>    <span class="hljs-comment"># 保存截取出的音频</span><br>    output_file = os.path.join(output_folder, <span class="hljs-string">&quot;first_25ms_after_silence.ogg&quot;</span>)<br>    chunk.export(output_file, <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;ogg&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成功截取去掉静音部分后的前25毫秒音频。&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未找到非静音部分。&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>听了一下效果感觉还可以！明天试试看把它和元音音频合起来</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>明明配了环境，却仍然不能运行？</title>
    <link href="/2024/04/19/%E4%BF%A1%E7%A7%91%E5%A3%AC%E6%9E%81%E5%85%B6%E8%A6%81%E5%BC%BA%E7%9A%84%E4%B8%80%E7%94%9F/"/>
    <url>/2024/04/19/%E4%BF%A1%E7%A7%91%E5%A3%AC%E6%9E%81%E5%85%B6%E8%A6%81%E5%BC%BA%E7%9A%84%E4%B8%80%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>省流：看看是不是磁盘权限问题！（F盘是用户盘不是系统盘，所以设置环境变量要设置在用户的环境变量，而不是系统的环境变量</p><p>一些检查方法：</p><p>在windows10的powershell终端运行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> $<span class="hljs-keyword">en</span><span class="hljs-variable">v:PATH</span><br></code></pre></td></tr></table></figure><p>发现所有F盘的环境变量设置都无效，，，但是平时配其他盘就没事（重启了好多次终于想到用打印环境变量这一方法</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> $<span class="hljs-keyword">en</span><span class="hljs-variable">v:MY_VARIABLE_FROM_F_DRIVE</span><br></code></pre></td></tr></table></figure><p>（运行这一命令，输出为空，证实了我的想法</p><p>解决方案是把系统环境变量挪到用户环境变量（D盘同理<br><img src="/../img/env/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240419144020.png" alt="用户环境变量与系统环境变量"><br>C盘没内存的人是这样的，，卑微</p>]]></content>
    
    
    
    <tags>
      
      <tag>env</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方言词典开发计划！</title>
    <link href="/2024/04/19/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92%EF%BC%81/"/>
    <url>/2024/04/19/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2%E7%9A%84%E8%AE%BE%E6%83%B3.jpg" alt="一个界面的设想"><br>某种程度上也借鉴了德格方言词典app的设计（以简约为目标）。用户的登录&#x2F;注册与新增词条功能为次要功能，可以延缓开发。打算先从网页web版做起，再试试看能不能包装成apk。<br>起因是没钱买服务器，也不想在免费试用之后续费，于是决定先搞一个轻量级的应用。查了一个下午+一个晚上的资料，最终锁定采用flutter开发。<br><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/flutter%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F.png" alt="flutter部署成功"><br>想法是：如果用flutter开发了一个插件，就可以做到类似调用api的功能，即在静态网页上实现动态功能。</p><p>咨询了一下gpt，它也是这么认为的：</p><p>GPT：</p><p>是的，使用Flutter开发插件，你可以在静态网页上实现动态功能，类似于调用API的功能。Flutter插件可以与Web应用程序（例如JavaScript）进行交互，从而在静态网页中实现动态功能。</p><p>Flutter提供了<code>flutter_webview_plugin</code>这样的插件，它允许你在Flutter应用中嵌入Web视图。这样，你可以加载一个包含动态内容的网页，并与Flutter应用程序进行交互。</p><p>以下是使用<code>flutter_webview_plugin</code>插件嵌入Web视图的基本步骤：</p><ol><li>在<code>pubspec.yaml</code>文件中添加<code>flutter_webview_plugin</code>依赖：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br>  <span class="hljs-attr">flutter_webview_plugin:</span> <span class="hljs-string">^latest_version</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>运行<code>flutter pub get</code>安装依赖。</p></li><li><p>在Flutter应用中使用<code>WebviewScaffold</code>或<code>Webview</code>来嵌入Web视图：</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_webview_plugin/flutter_webview_plugin.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: WebviewScaffold(<br>        url: <span class="hljs-string">&quot;https://example.com&quot;</span>, <span class="hljs-comment">// 加载的网页URL</span><br>        appBar: AppBar(title: Text(<span class="hljs-string">&quot;Webview 示例&quot;</span>)),<br>        withZoom: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 允许缩放</span><br>        withLocalStorage: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 启用本地存储</span><br>        hidden: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 是否隐藏webview</span><br>        initialChild: Container( <span class="hljs-comment">// 加载过程中显示的控件</span><br>          color: Colors.white,<br>          child: Center(<br>            child: CircularProgressIndicator(),<br>          ),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用<code>WebviewScaffold</code>来加载一个网页，并显示一个AppBar。你可以根据需要自定义<code>WebviewScaffold</code>的属性，例如是否允许缩放、是否启用本地存储等。</p><p>通过这种方式，你可以在静态网页上实现动态功能，与Flutter应用程序进行交互，类似于调用API的功能。</p><p>终于看到了一点成功的可能性！睡觉！</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分税制改革具体举措</title>
    <link href="/2024/04/18/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9%E5%85%B7%E4%BD%93%E4%B8%BE%E6%8E%AA/"/>
    <url>/2024/04/18/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9%E5%85%B7%E4%BD%93%E4%B8%BE%E6%8E%AA/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%A4%96/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93.png" alt="本章小结"><br>经济发展就是盘活各种资源，提高资源使用效率（人力、土地等等）</p><h1 id="纵向失衡"><a href="#纵向失衡" class="headerlink" title="纵向失衡"></a>纵向失衡</h1><p>由于中央和省分成，省和市县分成，导致财权层层上收，事权层层下压（也就是俗话说的基层钱少事多），因此进行了支出分权，农村基本公共服务开支由中央和地方政府共同承担，乡财县管（规范乡镇行为，实现同县乡镇公共服务均等化），省直管县（让县财政和省财政直接发生关系，绕开市财政）。</p><h1 id="转移支付改革"><a href="#转移支付改革" class="headerlink" title="转移支付改革"></a>转移支付改革</h1><p>保证政府运作和公务员工资（可能会造成冗员问题，养了很多闲人），而且越穷的人拿到的转移支付越多，可能缺乏增收动力</p><h1 id="五个统筹"><a href="#五个统筹" class="headerlink" title="五个统筹"></a>五个统筹</h1><p>科学发展观的内容。人与自然和谐发展（自然保护区的就不准砍，，），统筹经济社会发展（主要还是社会稳定，所以民生问题也要关注</p>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>土地财政</title>
    <link href="/2024/04/18/%E5%9C%9F%E5%9C%B0%E8%B4%A2%E6%94%BF/"/>
    <url>/2024/04/18/%E5%9C%9F%E5%9C%B0%E8%B4%A2%E6%94%BF/</url>
    
    <content type="html"><![CDATA[<p>1998年之前，乡镇企业占用的都是农村集体土地。由于各大地方政府招商引资，城市土地一般以低价有偿转让，卖地收入不多。</p><h1 id="城市政府垄断土地建设"><a href="#城市政府垄断土地建设" class="headerlink" title="城市政府垄断土地建设"></a>城市政府垄断土地建设</h1><p>直到1998年颁布了一系列改革措施：职工停止分房（催生了商品房与房地产），颁布了《土地管理法》，即农村集体土地不能用于非农建设，这些土地必须通过征地成为国有土地才能发展工商业和建造住宅，因此，城市政府垄断了土地建设。</p><p>在2001年，制定了“招标拍卖”规则，土地财政膨胀。</p><p>土地财政的收入分为使用权转让收入和一系列税收收入（土地增值税、耕地占用税、契税）。在1999-2000的窗口期，招拍挂还未实施，土地转让不透明，一些开发商趁国企改革腾出的土地私下交易，以少量出让金就可开发房地产，这其中催生了许多腐败与混乱。</p><h1 id="工业化城市化两手抓"><a href="#工业化城市化两手抓" class="headerlink" title="工业化城市化两手抓"></a>工业化城市化两手抓</h1><p>改革后，地方政府一方面低价供应大量工业用地，一方面限制商住用地供给（获得垄断收益），随着工商业经济活动的繁荣，房价与地价不断哄抬。随着企业那边的改革交给政府的税越来越少，政府也从原来的狠抓工业化逐渐转变成工业化城市化两手抓。</p><h2 id="工业用地"><a href="#工业用地" class="headerlink" title="工业用地"></a>工业用地</h2><p>为什么地方政府不惜倒贴（提供各种补贴）也要供应工业用地呢？因为工业用地（制造业）可以带动转型升级，也可以提供增值税和其他税收，并且制造业上下游链条长，如果形成集群效应，还可以提升地方竞争优势，形成稳定税收来源。</p><p>而且工业用地对地域一般没有太大的限制，所以地方政府不大可能抬地价（人家厉害，哪都能生存，凭啥待这呢），要哄着企业</p><h2 id="商住用地"><a href="#商住用地" class="headerlink" title="商住用地"></a>商住用地</h2><p>商住用地一般仅服务本地居民，所以垄断性更高，更方便抬地价（软柿子</p>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>央地博弈与招商引资</title>
    <link href="/2024/04/17/%E5%A4%AE%E5%9C%B0%E5%8D%9A%E5%BC%88%E4%B8%8E%E6%8B%9B%E5%95%86%E5%BC%95%E8%B5%84/"/>
    <url>/2024/04/17/%E5%A4%AE%E5%9C%B0%E5%8D%9A%E5%BC%88%E4%B8%8E%E6%8B%9B%E5%95%86%E5%BC%95%E8%B5%84/</url>
    
    <content type="html"><![CDATA[<h1 id="央地博弈"><a href="#央地博弈" class="headerlink" title="央地博弈"></a>央地博弈</h1><p>分税制改革将税收分为三类，中央税、地方税和共享税。</p><p>增值税原本为地方税，现在变为共享税（中央75%，地方25%）。为防止地方收入急剧下跌，中央设立了“税收返还”机制：保证改革后地方增值税收入与改革前一样，新增部分才和中央分。广东谈判之后，在全国范围内用1993年做基年，引发第四季度的收税狂潮，由于地方突击征税，增值税占地方税收的比重在1993年出现了明显反常的尖峰。这让1994年的财政陷入了困境，中央承诺的税收返还因为数额剧增而无法到位，预算迟迟做不出来。当2001年推行所得税分成改革时，突击征税现象再次出现。</p><h1 id="招商引资"><a href="#招商引资" class="headerlink" title="招商引资"></a>招商引资</h1><p>地方发展经济的两条路线：税收（与中央分成）、预算外收入。</p><p>增加税收的途径：</p><ol><li>扩大税源（主要原因<br>改革前，企业按隶属关系上缴税收，改革后，企业按所在地上缴税收。这便吸引了地方政府招商引资。由于税收在生产环节征收（之前讲过增值税不管企业盈利亏本，只要生产了就要交税的），所以地方政府为了财政，重企业轻民生，重生产轻消费。（之前公考做到一道题就是盲目招商、招大商的问题，也导致了产能过剩与对环境的破坏）</li><li>加强征管（非主要原因</li></ol><p>增加预算外收入的途径：</p><ol><li>企业缴的各种杂项费用（行政收费、集资、赞助等），后来改革了就没有了</li><li><strong>土地财政（下一部分着重讲）</strong></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分税制改革背景</title>
    <link href="/2024/04/17/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9/"/>
    <url>/2024/04/17/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9/</url>
    
    <content type="html"><![CDATA[<p>由于原来的计划经济太僵化，所以进行了一系列改革转型。我国的基本国策决定了不能对所有权做出根本性变革，只能对经营权和使用权实行承包制来提高积极性。</p><p>中央根据地方实际来确定承包形式和分账比例，比较流行的是收入递增包干（以某一年为基准每年提高固定的百分比，超过的部分全部归地方，没超过的部分与中央五五分成）因此地方有动力扩大税收来源，大力发展经济。由于企业不管盈利与否，只要开工，都需要缴纳增值税，于是地方政府大力发展乡镇企业（这样就可以得到更多的税收）。</p><p>但是这样的财政包干造成了两个比重不断降低。</p><ol><li><p>中央财政预算收入占全国财政预算收入的比重不断降低。<br>这是因为地方的财政收入上涨的速度远远高于地方交给中央的那个税的增长率（就是自己发展的好留了很多）</p></li><li><p>全国财政预算总收入占GDP的比重越来越低。<br>这是因为地方财政担心报多了被中央压榨增多提高的百分比（怕变成老实人小丑），所以偷偷留几手（藏富于企业，企业偷税漏税），这样地方依然有预算外收入，但是上报的预算内收入就少了，要交的税就少了</p></li></ol><p>而如果中央没钱，就失去宏观调控的能力（手里没把米，叫鸡都不来），更没有财力去普及义务教育、赈灾……所以改革启动！</p>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事权划分三大原则</title>
    <link href="/2024/04/17/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/"/>
    <url>/2024/04/17/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/</url>
    
    <content type="html"><![CDATA[<p>《置身事内：中国政府与经济发展》：经济地理学的阅读书目，在此更新一些阅读笔记</p><h1 id="事权划分三大原则"><a href="#事权划分三大原则" class="headerlink" title="事权划分三大原则"></a>事权划分三大原则</h1><p>三大原则的共同主题是处理不同群体的利益差别与冲突。假如不同群体间完全没有差别和冲突，那事权如何划分就不重要，对结果影响不大。完全没有冲突当然不可能，但如果能让各个群体对利益和代价的看法趋同，也能消解很多矛盾，增强互信。所以国家对其公民都有基本的共同价值观教育，包括历史教育和国家观念教育。而对官员群体，我国自古以来就重视共同价值观的培养与教化，今天依然如此。</p><h2 id="1-公共服务的规模经济"><a href="#1-公共服务的规模经济" class="headerlink" title="1. 公共服务的规模经济"></a>1. 公共服务的规模经济</h2><p>一个城市总要划分成不同的区县，而行政边界的划分跟公共服务影响范围有关。</p><p>一方面，因为规模经济，覆盖的人越多越划算，政区越大越好；</p><p>另一方面，受制于人们获取这些服务的代价（距离、文化、意愿、基础设施），政区不能无限扩大。</p><blockquote><p>从公共服务覆盖范围角度看，不同人对公共服务的评价不同，享受该服务的代价不同，所以要划分不同的行政区域。</p></blockquote><h2 id="2-信息复杂性"><a href="#2-信息复杂性" class="headerlink" title="2. 信息复杂性"></a>2. 信息复杂性</h2><p>上级无法掌握和处理所有信息，虽然名义上有最终决定权，但是只有“形式权威”，下级具有信息优势，自主性很大，具有“实际权威”。上下级之间存在信息的获取与隐瞒问题。规则的模糊不清容易导致权力个人化，容易造成“一把手负责制”的专权与腐败现象。因此体制内的规章制度无法取代个人信任。</p><blockquote><p>从信息复杂性角度看，掌握不同信息的人，看法和判断不同，要把决策权交给占据信息优势的一方。</p></blockquote><h2 id="3-激励相容"><a href="#3-激励相容" class="headerlink" title="3. 激励相容"></a>3. 激励相容</h2><h3 id="垂直管理"><a href="#垂直管理" class="headerlink" title="垂直管理"></a>垂直管理</h3><p>适用于专业性强、标准化程度高的部门，工作主要由系统内的上级安排，任命、绩效与福利也主要由上级评价与决定。</p><h3 id="地方管理"><a href="#地方管理" class="headerlink" title="地方管理"></a>地方管理</h3><p>激励相容原则要求给地方放权：不仅要让地方负责，也要与地方分享发展成果；不仅要能激励地方努力做好，还要能约束地方不要搞砸，也不要努力过头。做任何事都有代价，最优的结果是让效果和代价匹配，而不是不计代价地达成目标。若不加约束，地方政府要实现短期经济高速增长目标并不难，可以尽情挥霍手中的资源，大肆借债、寅吃卯粮来推高增长数字，但这种结果显然不是最优的。</p><blockquote><p>从激励相容角度看，上下级的目标和能力不同，所以要设立有效的机制去激励下级完成上级的目标。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随记</title>
    <link href="/2024/04/17/%E9%9A%8F%E8%AE%B0/"/>
    <url>/2024/04/17/%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>因为之前的笔记本用完了，翻到了一个大一的时候用的笔记本。发现往里面记了很多有意思的东西，遂搬运。之前记录只是觉得有意思，或者有“价值”，当真正面临人生选择的时候，当认识了更多为了自己的梦想而去做一些看似愚蠢的事的人之后，不管是在名著中还是现实中。我很崇敬他们自洽而勇敢的生活方式，像放弃退休坚守招生岗位，为像我一样迷茫的孩子点了一盏灯，像sygg放弃了教育部秘书的光鲜职位而从上海回到小岛任教，像奶奶疫情后依然在经营着她的亏本小店，像米德尔马契里看似总是在做着错误的选择的多多。</p><p>我将我的前5&#x2F;8的大学用来迷茫，后3&#x2F;8的大学用来醒悟与召回。而今在寻找探奥论文素材的时候，偶然间又重新看到大一上册时的记录。那时候我没有被绩点和学业压力鞭挞，保持着最单纯的初心，选什么课都是为了好玩，也为了好玩去学习了一些很基础的一些东西（走了很多弯路，终于在大三下兜兜转转地绕回来）。</p><p>成功和功成名就没有什么关系，成功是一个人捍卫自己的完整性。他可以不为名利低下高傲的头，却会为一段自由俯身垂首。他开始变得勇敢，他不甘心再做一只囚鸟。人的每一种身份都是一种自我绑架，唯有失去是自由之途。我把自己丢了，也许他也只想飞翔一次。他应该羽翼丰满，为自己寻求一条明亮的活路。</p>]]></content>
    
    
    
    <tags>
      
      <tag>bubbles</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讯飞智文</title>
    <link href="/2024/04/17/%E8%AE%AF%E9%A3%9E%E6%99%BA%E6%96%87/"/>
    <url>/2024/04/17/%E8%AE%AF%E9%A3%9E%E6%99%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>低碳课要交一个作业，正好因为没有用过ai生成ppt，所以生成了一个看看效果</p><p><img src="/../img/%E8%AE%AF%E9%A3%9E%E6%99%BA%E6%96%87/ai%E7%94%9F%E6%88%90ppt.png" alt="AI生成ppt"><br>其实感觉乍一看还蛮好！不过有很多重复的内容和不合逻辑的内容，稍微调整一下顺序，删除几张重复的ppt，划分一下小节就好了。</p><p>快乐而又迅速地交作业（</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加减乘除法器</title>
    <link href="/2024/04/16/%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8/"/>
    <url>/2024/04/16/%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%8A%A0%E6%B3%95%E5%99%A8.jpg" alt="加法器"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%87%8F%E6%B3%95%E5%99%A8.png" alt="减法器"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E4%B9%98%E6%B3%95%E5%99%A8.jpg" alt="乘法器"><br>今天把之前艾美疫苗送的笔记本写完了，，可喜可贺<br>虽然除法器还没考过不过以防万一稍微瞄一眼<br><img src="/../img/%E8%AE%A1%E7%BB%84/32-bit%E9%99%A4%E6%B3%95%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="32-bit除法器的工作流程图"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E9%99%A4%E6%B3%95%E5%99%A8%E5%9B%BE%E7%A4%BA.jpg" alt="除法器图示"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于与门或门实现更好的理解</title>
    <link href="/2024/04/16/%E5%AF%B9%E4%BA%8E%E4%B8%8E%E9%97%A8%E6%88%96%E9%97%A8%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2024/04/16/%E5%AF%B9%E4%BA%8E%E4%B8%8E%E9%97%A8%E6%88%96%E9%97%A8%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>众所周知与门&#x3D;与非门+非门，或门&#x3D;或非门+非门</p><p>非门其实就是一个CMOS反相器</p><p>与非：1变0，NMOS擅长，接地，但NMOS不能直接接电源，所以最上面的NMOS要上接一个PMOS。同理另一个为了对称也接一个PMOS，但是PMOS不能接地，所以两个PMOS的下端与两个NMOS的上端要引出Y端（把两个PMOS门画在NMOS门的上面 使得它们整体隔开会好画一点</p><p>或非：0变1，PMOS擅长，接电源，但PMOS不能直接接地，所以最下面的PMOS要下接一个NMOS。同理另一个为了对称也接一个NMOS，但是NMOS不能接电源，所以两个NMOS的上端与两个PMOS的下端要引出Y端（把两个NMOS门画在PMOS门的下面 使得它们整体隔开会好画一点<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E4%B8%8E%E9%9D%9E%E4%B8%8E%E6%88%96%E9%9D%9E.jpg" alt="与非与或非"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRAM数字电路设计</title>
    <link href="/2024/04/16/SRAM%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/04/16/SRAM%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>难得gpt做了次人，遂记录一下和它的对话（整理后版本</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/SRAM%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5.jpg" alt="SRAM一些概念"></p><p>SRAM基本单元由两个CMOS反相器（其实就是两个非门）组成，两个反相器的输入输出交叉连接，即第一个反相器的输出连接第二个反相器的输入，第二个反相器的输出连接第一个反相器的输入。这实现了两个反相器输出状态的锁定、保存，即存储了一个位元的状态。</p><h1 id="BL：Bit-Line（位线）"><a href="#BL：Bit-Line（位线）" class="headerlink" title="BL：Bit Line（位线）"></a>BL：Bit Line（位线）</h1><p>在SRAM（静态随机存取存储器）的数字电路设计中，”BL” 通常指的是 “Bit Line”。</p><p>在SRAM单元中，位线用于连接存储单元和读&#x2F;写电路。它承载存储单元中的数据位，并负责将这些数据传输到读&#x2F;写电路以进行读取或写入操作。</p><p>在SRAM的读操作中，位线被用作数据传输路径，将存储单元中的数据位传输到读取电路。在写操作中，位线负责将数据位传输到存储单元，以更新存储的数据。</p><h1 id="Word-Line（字线）"><a href="#Word-Line（字线）" class="headerlink" title="Word Line（字线）"></a>Word Line（字线）</h1><p>在SRAM单元中，字线用于选择存储单元进行读或写操作（不管是读还是写，WL都为1，过程结束时为0）。当字线激活时，它会打开连接到该字线的所有存储单元的传输门，从而允许读取或写入操作。</p><p>在读操作中，字线使得选定的存储单元的数据位能够流入位线（Bit Line）进行读取。在写操作中，字线允许数据位从位线传输到选定的存储单元，以更新存储的数据。</p><h1 id="Q（输出）"><a href="#Q（输出）" class="headerlink" title="Q（输出）"></a>Q（输出）</h1><p>在数字电路设计中，通常使用 “Q” 来表示输出信号。这个标记表示该部分或组件的输出端。</p><p>例如，在触发器或存储器单元中，”Q” 和 “&#x2F;Q”（Q的反相输出）通常表示状态或数据的输出。这些输出可以连接到其他电路部分，以实现数据传输和处理。</p><h1 id="读-x2F-写过程"><a href="#读-x2F-写过程" class="headerlink" title="读&#x2F;写过程"></a>读&#x2F;写过程</h1><p><img src="/../img/%E8%AE%A1%E7%BB%84/SRAM%E8%AE%BE%E8%AE%A1.jpg" alt="SRAM设计"><br>SRAM设计中，WL为1时写入BL，并在Q中输出BL</p><p>在SRAM（静态随机存取存储器）的设计中，当Word Line（WL）被激活为逻辑”1”时：</p><ol><li><p><strong>写入操作</strong>：将位线（Bit Line，BL）的数据写入选定的存储单元。</p></li><li><p><strong>读取操作</strong>：存储单元的数据位被传输到位线（Bit Line，BL）。</p></li></ol><p>这时，”Q” 通常表示存储单元的输出，即位线（Bit Line，BL）的内容。当执行读取操作时，Q会输出位线上的数据，反映存储单元的状态。</p><p>SRAM的运行在写入和读出时基本没有区别。</p><h1 id="断电后SRAM将丢失所有电荷状态"><a href="#断电后SRAM将丢失所有电荷状态" class="headerlink" title="断电后SRAM将丢失所有电荷状态"></a>断电后SRAM将丢失所有电荷状态</h1><p>断电后的SRAM（静态随机存取存储器）不能持续存储数据。SRAM的存储方式是基于电荷状态在存储单元中存储数据，而这些电荷会随着时间和电流的丧失而消散。</p><p>当电源关闭时，SRAM中的电荷会迅速耗尽，导致数据丢失。这与DRAM（动态随机存取存储器）不同，DRAM使用电容来存储数据，需要定期刷新以保持数据，即使在断电后也能短暂保留数据。</p><p>因此，SRAM需要持续的电源供应以保持数据，一旦电源被中断或关闭，存储在其中的数据会立即丢失。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组期中复习-微程序控制器</title>
    <link href="/2024/04/14/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <url>/2024/04/14/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E8%A1%A5%E5%85%A8%E4%BB%A3%E7%A0%81.png" alt="微程序控制器补全代码"><br>怎么理解指令和微指令呢？大概就是微指令从指令中拆分出具体的很小的一个单位步骤，指令分为两个字节。前一个字节的前4位是操作码，后四位是寄存器号或者0000（像JMP没有寄存器所以就直接0000），第二个字节<strong>一定</strong>是存储单元地址（所以之前有一道选择题说能不能是寄存器+寄存器呢？对不起，不行，必须要有一个地址。<br>在这里设计的四条指令分别是：</p><ol><li>ADD R, M<br>◦ 功能： 将R的内容与M中的内容相加后存入R</li><li>LOAD R, M<br>◦ 功能： 将M中的内容装入R</li><li>STORE M, R<br>◦ 功能： 将R的内容存入M中</li><li>JMP L<br>◦ 功能： 无条件转向L处</li></ol><p>注： M和L为存储器地址， R为寄存器编号</p><h1 id="取指令"><a href="#取指令" class="headerlink" title="取指令"></a>取指令</h1><p>每条指令的T1周期， 都要发出PC_OUT、 MAR_IN、 M_读和PC_加共四个信号。这条微指令形式的信号序列如下：1111000000000000<br>每条指令的T2周期， 都要发MDR_OUT、 IR_IN两个信号这条微指令形式的信号序列如下：0000110000000000<br><img src="/../img/%E8%AE%A1%E7%BB%84/T1%E5%92%8CT2.jpg" alt="T1和T2"><br>故T2的微操作字段为0000110000000000，下址字段不是像T1周期执行完之后无脑下一步（毕竟T1释放了PC+信号，但是T2不是直接PC+，而是要看这个指令具体在哪里。从T1机器周期就开始传递的这个数据正是下一个要执行的指令地址。</p><p>下址字段为1xx10</p><p>最高位的1<br>意义：这通常表明，接下来的微指令将发生一个条件性的跳转。也就是说，CPU的下一步行动并不是简单地执行下一个顺序的微指令地址，而是根据某个条件来决定跳转的目标地址。（该例为执行IR寄存器中的内容（指令地址（指令寄存器</p><p>中间的xx<br>意义：这部分通常代表指令的操作码，它用于指示当前执行的指令类型。在微程序设计中，这可以用于基于正在执行的机器指令来选择相应的微指令流程。<br>例子：如果“xx”是从指令寄存器（IR）中解析出的当前机器指令的部分字段（比如操作码），这可以用来决定执行哪一组微指令。（load为00，add为01，store为10，jmp为11）</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E7%AD%94%E6%A1%88.png" alt="答案"><br>最后的10<br>其实也很好理解。因为不管是LOAD, ADD, STORE, 还是JMP，他们的“第一个”（图中是T3）的地址的后两位都是10（注意机器周期从开1始算，但是地址从0开始算</p><p>最上面那个取指令对于所有的指令LOAD, ADD, STORE, JMP都适用（即，分别取LOAD, ADD, …）都要从第一个机器周期开始算。因为不管是哪个指令首先都得从PC取出来，所以他们在T1和T2的步骤是一样的。</p><h1 id="LOAD-R-M"><a href="#LOAD-R-M" class="headerlink" title="LOAD R, M"></a>LOAD R, M</h1><p>然后就是LOAD指令在T3和T4的机器周期干了什么</p><p>先来看看LOAD指令在所有的周期干了什么吧<br>指令“LOAD R1, M1”的执行过程：<br><strong>① 取指令并形成下一条指令的地址（所有指令通用</strong><br>I. 控制器发“PCOUT” 和“MARIN” 信号， 使PC→MAR<br>II. 控制器发“M读” 信号， 使存储器的内容（指令） →MDR<br>III. 控制器发“PC加” 信号， 使PC+n→PC， 其中n为该指令占用的地址数<br>IV. 控制器发“MDROUT” 和“IRIN” 信号， 使MDR→IR</p><p>（上面的都干过了）</p><p><strong>② 执行指令“LOAD R1, M1”</strong><br>I. 控制器发“IROUT” 和“MARIN” 信号， 使IR中指令的地址段（即M1） →MAR<br>II. 控制器发“M读” 信号， 使存储器M1的内容（数据） →MDR<br>III. 控制器发“MDROUT” 和“R1IN” 信号， 使MDR→R1</p><p>我们重点关注②。LOAD R, M的功能是将M中的内容装入R。<br>I和II组合组成了T3：0110 0010 0000 0000<br>（注意MDRin没有用到，把指令读到MDR的指令是M读，而不是MDRIN<br>因为load还没执行完，所以下址字段无条件跳转到LOAD的下一个周期所在微地址0011（最高位的0标志无条件跳转）</p><p>III就是T4，因为此时LOAD的核心功能已经完成，所以下址字段为End指令所在位置。</p><h1 id="ADD-R-M"><a href="#ADD-R-M" class="headerlink" title="ADD R, M"></a>ADD R, M</h1><p>（省略取指令步骤</p><blockquote><p>执行指令“ADD R1,M2”<br>I. 控制器发“IROUT” 和“MARIN” 信号， 使IR中指令的地址段（ 即M2） →MAR<br>II. 控制器发“M读” 信号， 使存储器M2的内容（数据） →MDR，通过DBUS<br>III. 控制器发“MDROUT” 和“YIN” 信号， 使MDR→Y（ 即ALU的A端）<br>IV. 控制器发“R1OUT” ， 使R1→内部总线（ 即ALU的B端）<br>V. 控制器发“add” 信号， 使A+B→Z<br>VI. 控制器发“ZOUT” 和“R1IN” 信号， 使Z→R1</p></blockquote><p>这么冗长的步骤我也记不住啊，，一条条分解吧</p><p>ADD R,M的核心功能是把M中的内容取出来与R相加再存入R中。<br>M从哪来？<br>IR指令中来，指令中包含了所求地址，所以IR_OUT,它现在在总线，我再MAR_IN一下。（MAR和MDR的区别是，一个存的是这个地址，一个存的是地址的内容</p><p>我怎么读出这个M中的内容呢？（因为是内容相加而不是地址相加）那好办，M_读一下，MAR寄存器中存的地址<strong>的内容</strong>就到总线去了。然后把总线的内容通过MDRIN就可以读入MDR了</p><p>–to be continued</p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯？动归？</title>
    <link href="/2024/04/13/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2024/04/13/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<p>小红书笔试写到一道回溯题，，来不及写了，故在这里写完康康（正确率18%<br><img src="/../img/%E7%AC%94%E8%AF%95/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240413144759.png" alt="粉丝数问题"><br>祭出我写了一半的回溯代码，，（也有动归的残骸</p><p>漏看了一条很重要的信息：只有一个账号能推广多次<br>（带摄像头的线上笔试真的太磨人了，，，屏幕比较小没放大根本看不见</p><p>当时想加个最小值的返回判定但是来不及编译了，，加上去应该正确率不止这么点，挺可惜的，，不过就算写了也没来得及考虑推广多次的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// int dp[101][101];</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-comment">// 定义函数体</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ddd</span><span class="hljs-params">(<span class="hljs-type">int</span> bb,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>||bb&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x;i++)&#123;<br>        <span class="hljs-type">int</span> ii= a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x&gt;=ii)&#123;<br>            flag|=<span class="hljs-built_in">ddd</span>(bb<span class="hljs-number">-1</span>,x-ii);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 感觉还是动态规划</span><br>    <span class="hljs-comment">// 好像是回溯啊 那完蛋了</span><br><br>    <span class="hljs-comment">// 第一个参数是最少需要推广几次</span><br>    <span class="hljs-comment">// 第二个参数是现在的粉丝数量（这次推广之后</span><br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-comment">// for (int i=0;i&lt;n;i++)&#123;</span><br>    <span class="hljs-comment">//     int ii=a[i]/2;</span><br>    <span class="hljs-comment">//     dp[1][a[i]/2]=1;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ddd</span>(i,x))&#123;<br>            flag=<span class="hljs-literal">true</span>;<br>            cout&lt;&lt;i;<br>            <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag)&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// cout&lt;&lt;flag;</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>翻到了网上的解析，是用动归做的 因为我先做的下一题，，所以后来觉得这题不用动归做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>]; <span class="hljs-comment">// 本来我想设二维的，但是发现一维就够了</span><br><span class="hljs-comment">// dp[x]表示粉丝数恰好为x时至少需要推广的次数</span><br><span class="hljs-comment">// 初值全都赋成INF_MAX</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<span class="hljs-comment">// 输入的原账号的粉丝量</span><br><span class="hljs-type">int</span> t[<span class="hljs-number">100</span>];<span class="hljs-comment">// 每个账号推广后实际涨粉数（</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 这里就除以二 后面看着好看点</span><br>    &#125;<br>    <span class="hljs-comment">// 先考虑每个账号至多推广一次的情形</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>        dp[i]=<span class="hljs-number">99999</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        dp[t[i]]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// bool flag=0;</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span> (i-t[j]&gt;=<span class="hljs-number">0</span>)&#123;<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-t[j]]+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 控制一下下标范围，当时太急了也没来得及写</span><br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> tmp = dp[x];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x;j++)&#123;<br>            dp[j]=<span class="hljs-number">99999</span>;<br>        &#125;<br>        t[i]=a[i];<br>        <span class="hljs-comment">// dp[t[i]]=1;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            dp[t[j]]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 还有一个忽视了的点！题目问的是账号数不是推广的总次数</span><br>        <span class="hljs-comment">// 所以这里推广多次的账号dp值不需要设成2</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x;j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;n;m++)&#123;<br>                <span class="hljs-keyword">if</span> (j&gt;=t[m])&#123;<br>                    dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-t[m]]+<span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-comment">// 下标合法性</span><br>            &#125;<br>        &#125;<br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 回溯（bushi</span><br>        tmp = <span class="hljs-built_in">min</span>(tmp,dp[x]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[x]!=<span class="hljs-number">99999</span>)&#123;<br>        cout&lt;&lt;dp[x];<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout&lt;&lt;flag;</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>输出了一下还是错，，比对了一下标准答案发现是因为重新初始化，所以把之前迭代的数据丢失了，缺失了只推广一半粉丝数的数据，，所以蝴蝶效应影响到了其他的dp值（和循环内外顺序以及++&#x2F;–没有关系！</p><p>AC代码（应该AC了吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>]; <span class="hljs-comment">// 本来我想设二维的，但是发现一维就够了</span><br><span class="hljs-comment">// dp[x]表示粉丝数恰好为x时至少需要推广的次数</span><br><span class="hljs-comment">// 初值全都赋成INF_MAX</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<span class="hljs-comment">// 输入的原账号的粉丝量</span><br><span class="hljs-type">int</span> t[<span class="hljs-number">100</span>];<span class="hljs-comment">// 每个账号推广后实际涨粉数（</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 这里就除以二 后面看着好看点</span><br>    &#125;<br>    <span class="hljs-comment">// 先考虑每个账号至多推广一次的情形</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>        dp[i]=<span class="hljs-number">99999</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        dp[t[i]]=<span class="hljs-number">1</span>;<br>    &#125;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// bool flag=0;</span><br>    <br>    <span class="hljs-comment">// for (int j=0;j&lt;n;j++)&#123;</span><br>    <span class="hljs-comment">//     for (int i=t[j];i&lt;=x;i++)&#123;</span><br>    <span class="hljs-comment">//         dp[i]=min(dp[i],dp[i-t[j]]+1);</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span> (i&gt;=t[j])&#123;<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-t[j]]+<span class="hljs-number">1</span>);<br><br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-type">int</span> tmp = dp[x];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">// for (int j=1;j&lt;=x;j++)&#123;</span><br>        <span class="hljs-comment">//     dp[j]=99999;</span><br>        <span class="hljs-comment">// &#125;</span><br>        t[i]=a[i];<br>        <span class="hljs-comment">// dp[t[i]]=1;</span><br>        <span class="hljs-comment">// for (int j=0;j&lt;n;j++)&#123;</span><br>        <span class="hljs-comment">//     dp[t[j]]=1;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// dp[0]=0;</span><br>        <br>        <span class="hljs-comment">// 还有一个忽视了的点！题目问的是账号数不是推广的总次数</span><br>        <span class="hljs-comment">// 所以这里推广多次的账号dp值不需要设成2</span><br>        <br>        <br>        <span class="hljs-comment">// for (int m=0;m&lt;n;m++)&#123;</span><br>        <span class="hljs-comment">//     for (int j=t[m];j&lt;=x;j++)&#123;</span><br>        <span class="hljs-comment">//         dp[j]=min(dp[j],dp[j-t[m]]+1);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=x;j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;n;m++)&#123;<br>                <span class="hljs-keyword">if</span> (j&gt;=t[m])&#123;<br>                    dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-t[m]]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <br><br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 回溯（bushi</span><br>        tmp = <span class="hljs-built_in">min</span>(tmp,dp[x]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[x]!=<span class="hljs-number">99999</span>)&#123;<br>        cout&lt;&lt;dp[x];<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout&lt;&lt;flag;</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>再尝试下把回溯的方法补完，但是发现非常复杂，，gpt说这道题的最佳解法就是动态规划，回溯效率不高，，那就这样吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>xhs笔试复盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小红书！</title>
    <link href="/2024/04/12/%E5%B0%8F%E7%BA%A2%E4%B9%A6%EF%BC%81/"/>
    <url>/2024/04/12/%E5%B0%8F%E7%BA%A2%E4%B9%A6%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>没写完啊啊啊啊啊（好好反思一下，，，</p><p>pyq已经发了一大段话了这里就不发了，，第一次做线上后端笔试题，，感觉奇妙</p><p>考完立马装了C++11(呜呜呜)</p><p>昨天霉霉夜奔好快乐，，，一堆图和视频（由于已经过了时效了于是非常言简意赅呜呜，，但是快乐是无法形容的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11的新特性</title>
    <link href="/2024/04/11/C-11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2024/04/11/C-11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="类型推导关键字"><a href="#类型推导关键字" class="headerlink" title="类型推导关键字"></a>类型推导关键字</h1><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>让编译器通过初始值进行类型推演（必须有初始值！<br>先对底层const和顶层const进行说明：</p><h3 id="底层const（常量指针）"><a href="#底层const（常量指针）" class="headerlink" title="底层const（常量指针）"></a>底层const（常量指针）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p<br><span class="hljs-type">int</span> <span class="hljs-type">const</span>* p;<br></code></pre></td></tr></table></figure><p>这两种命名方式是等价的，指的都是常量指针，const在类型名前后都可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> num_a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span>  *p_a = &amp;num_a; <span class="hljs-comment">// 底层const</span><br><span class="hljs-comment">//*p_a = 2;  // 错误，无法修改对象的值</span><br>p = &amp;b; <span class="hljs-comment">// 正确，允许修改指向</span><br>num_a = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p>指向“常量”的指针不代表它所指向的内容一定是常量，只是代表不能通过解引用符（操作符*）来改变它所指向的内容。上例中指针p_a指向的内容就不是常量，可以通过赋值语句：num_a&#x3D;2;  来改变它所指向的内容。</p><h3 id="顶层const（指针常量）"><a href="#顶层const（指针常量）" class="headerlink" title="顶层const（指针常量）"></a>顶层const（指针常量）</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手搓快排</title>
    <link href="/2024/04/10/%E6%89%8B%E6%90%93%E5%BF%AB%E6%8E%92/"/>
    <url>/2024/04/10/%E6%89%8B%E6%90%93%E5%BF%AB%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<p>大一的时候都是依赖vs studio那个非常大的软件来编译简单算法程序运行，，vscode对我的作用就是单纯地完成课堂搭建的服务器平台或者什么classmachine上的作业，环境也配得稀烂，甚至这个学期前都没跑通过python环境，，（甚至还以为是jupyter或者自己编程的问题，之前还把Python课退掉了</p><p>亏得这个学期选的一门创新创业课里配了个大模型环境，对自己的配环境技术有了稍稍地自信，由于之前为了腾内存以及认定自己要去体制内所以卸载了vs studio，导致基本没有现成可用的IDE，于是今天配了C++的运行环境。复制了launch.json, tasks.json, c_cpp_properties.json, 把vscode的环境变量（bin文件夹）也加进环境变量里去了。一个小时内终于能运行快排代码了（要不是面试要求手搓肯定hyx也不会想到倒腾这玩意，，</p><p>综合了两篇教程，设置了独立弹出的终端，，，非常有成就感，，（虽然zjt锐评这些事情他大一下就做过而我大三下居然才刚刚开始，，，但是对于一个对计算机没啥兴趣的人来说已经很厉害了orz</p><p>自己手搓了一份代码，不过数据具有偶然性，，发现有些数据跑不通（以下是错误代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; num;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>]=&#123;&#125;;<br>    <span class="hljs-type">int</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = num<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> tmp = a[base];<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// flag为0表示low为空指针，1表示high为空指针</span><br>    <span class="hljs-keyword">while</span>(high!=low)&#123;<br>        <span class="hljs-keyword">if</span> (flag==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// low为空指针，不操作low，只操作high</span><br>            <span class="hljs-keyword">if</span> (a[high]&gt;tmp)&#123;<br>                high--;<br>                <span class="hljs-comment">// high指向的数比基准值大，high左移一个单位</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                a[low]=a[high];<br>                <span class="hljs-comment">// high指向的数比基准值小，把a[high]赋值给a[low]</span><br>                flag=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 现在high为空</span><br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// high为空指针，不操作high，操作low</span><br>            <span class="hljs-keyword">if</span> (a[low]&lt;tmp)&#123;<br>                low++;<br>                <span class="hljs-comment">// low指向的数比基准值小，low右移一个单位</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                a[high]=a[low];<br>                <span class="hljs-comment">// low指向的数比基准值大，把a[low]赋值给a[high]</span><br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 现在low为空</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    a[high]=tmp;<br>    <span class="hljs-comment">// 当high指针和low指针重合时将基准值赋值给a[high]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>错误代码的总体思路：</p><p>基准值设在左边第一个。然后把a[0]取出来作为tmp基准值。设立两个指针low和high，初始low指向左边第一个，high指向右边第一个。初始low为空（因为low指向的值被取出来了），（我这里设了flag标定是对low操作还是对high操作，更简洁的方法是套两个while循环），主要作用就是一直找，找到第一个不应在这个位置的就和high&#x2F;low交换，待会码一个简洁版的。模拟了一下对21, 100, 3, 50, 100进行操作，发现只能实现3, 21, 100, 50, 100这样的功能，即只能保证基准值左边的比它小，基准值右边的比他大，但是这两个序列分别怎么排呢？不清楚，没排。（<strong>错因：没有递归</strong>）</p><p>正确代码：<br>（新增头文件algorithm，用来调用sort</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-comment">// 划分函数</span><br>    <span class="hljs-type">int</span> i = low;<br>    <span class="hljs-type">int</span> j = high;<br>    <br>    <span class="hljs-type">int</span> tmp = a[i];<br>    <span class="hljs-keyword">while</span>(j&gt;i)&#123;<br>        <span class="hljs-keyword">while</span>(a[j]&gt;tmp &amp;&amp;i&lt;j)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i&lt;j)&#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>            i++;<br>            <span class="hljs-comment">// 少了这一步！！！</span><br>        &#125;<br>        <span class="hljs-comment">// 一着急把if写在while里面了，，应该拿外面来</span><br>        <span class="hljs-keyword">while</span>(a[i]&lt;=tmp &amp;&amp; i&lt;j)&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 上面没加等于，所以这里加等于</span><br>        <span class="hljs-keyword">if</span> (i&lt;j)&#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>            j--;<br>            <span class="hljs-comment">// 少了这一步</span><br>        &#125;    <br>        <br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> i;<br><br>&#125;<br><span class="hljs-comment">// 快速排序函数分为两部分</span><br><span class="hljs-comment">// 一部分是划分函数（需返回枢值位置），一部分是函数主体</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">if</span>(low&lt;high)&#123;<br>        mid = <span class="hljs-built_in">part</span>(low,high);<br>        <span class="hljs-comment">// 一紧张忘给mid赋值了</span><br>        <span class="hljs-built_in">quicksort</span>(low,mid<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">quicksort</span>(mid+<span class="hljs-number">1</span>,high);<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; num;<br>    <br>    <span class="hljs-type">int</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = num<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">quicksort</span>(<span class="hljs-number">0</span>,num<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps：今天打开vscode差点以为又不能运行了，吓鼠，，，仔细一看是因为没有在文件夹下</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小米面试准备</title>
    <link href="/2024/04/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2024/04/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<p>感觉来不及准备了所以搞点高频考点突击一下。</p><h1 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h1><h2 id="my-answer："><a href="#my-answer：" class="headerlink" title="my answer："></a>my answer：</h2><p>线程和别的线程共享一个地址空间？）每个进程有自己独立的地址空间<br>（用标准的角度讲应该属于拥有资源的角度<br>（其他忘了</p><h2 id="standard："><a href="#standard：" class="headerlink" title="standard："></a>standard：</h2><ol><li>调度：进程是<strong>资源管理</strong>的基本单位，线程是<strong>程序执行</strong>的基本单位。</li><li>切换：线程上下文切换比进程上下文切换要快得多。</li><li>拥有资源： 进程是拥有资源的一个独立单位，线程<strong>不拥有系统资源，但是可以访问隶属于进程的资源</strong>。</li><li>系统开销： 创建或撤销进程时，系统都要为之<strong>分配或回收系统资源</strong>，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li></ol><h1 id="面向对象的三个特征"><a href="#面向对象的三个特征" class="headerlink" title="面向对象的三个特征"></a>面向对象的三个特征</h1><h2 id="my-answer：-1"><a href="#my-answer：-1" class="headerlink" title="my answer："></a>my answer：</h2><p>不会斯密达</p><h2 id="standard：-1"><a href="#standard：-1" class="headerlink" title="standard："></a>standard：</h2><p>面向对象编程的三大特征是封装、继承和多态。</p><ol><li><p>封装：封装是指将数据和操作数据的方法（即函数）捆绑在一起，形成一个<strong>类</strong>。通过封装，我们可以<strong>隐藏内部实现细节，只暴露必要的接口给外部使用</strong>。这样可以提高代码的可维护性和安全性，并且方便其他开发者使用该类。</p></li><li><p>继承：继承是指一个类可以<strong>派生出子类</strong>，子类会继承父类的属性和方法。通过继承，子类可以重用父类的代码，并且可以在不修改父类的情况下进行功能扩展。继承可以建立类之间的层次关系，使得代码更加灵活和可扩展。</p></li><li><p>多态：多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。 那么在继承中要构成多态还有两个条件：必须通过基类的指针或者引用调用虚函数；被调用的函数必须是<strong>虚函数</strong>，且派生类必须对基类的虚函数进行重写.</p></li></ol><h1 id="介绍一下项目（操统）"><a href="#介绍一下项目（操统）" class="headerlink" title="介绍一下项目（操统）"></a>介绍一下项目（操统）</h1><p>因为每次应该都会问到所以感觉需要重点打磨。</p><p>结合一篇博客来重点作答一下（参考：博客园 MIT 6.S081 xv6调试不完全指北）</p><h2 id="操统版"><a href="#操统版" class="headerlink" title="操统版"></a>操统版</h2><p>印象比较深刻的一个项目是MIT 6.S081对xv6的优化，其中有一个部分需要实现为每个新进程单独分配一个属于它的内核页。里面的细节非常多，debug起来也比较困难。比如说要在scheduler切换进程的时候, 刷新TLB和使用的虚拟-物理页表影射base，而且当控制权返回给调度器时，要切换为全局内核页表。这个点让我debug了很久。</p><h3 id="可能延伸的问题"><a href="#可能延伸的问题" class="headerlink" title="可能延伸的问题"></a>可能延伸的问题</h3><h4 id="咋debug的？"><a href="#咋debug的？" class="headerlink" title="咋debug的？"></a>咋debug的？</h4><p>通过网上查阅操作系统的官方文档、技术论坛和社区的讨论，还有就是通过printf大法或者gdb调试。MIT 6.S081 2019提供的xv6采用的指令集是riscv，因此我们虚拟机上针对x86指令集的gdb可能无法较好的调试。我们需要用交叉编译工具来编译xv6，并用交叉编译工具提供的gdb来调试。</p><h5 id="关于gdb的延伸"><a href="#关于gdb的延伸" class="headerlink" title="关于gdb的延伸"></a>关于gdb的延伸</h5><p>通过-g调试命令，gdb可以监控pc（程序计数器）、sp（堆栈指针）、各类寄存器的值，结合ELF中的符号表，就可以将这些信息“翻译”为我们想要看的变量。比如说如果输入命令 file user&#x2F;_sleep，其目的就是告诉gdb，加载_sleep的符号表，用它的符号表去解释你看到的东西。</p><h5 id="printf一般print啥的延伸"><a href="#printf一般print啥的延伸" class="headerlink" title="printf一般print啥的延伸"></a>printf一般print啥的延伸</h5><ol><li><p><strong>进程切换相关信息</strong>：打印当前正在运行的进程ID，以及即将切换到的进程ID。这可以帮助确认进程切换逻辑是否按预期执行。</p></li><li><p><strong>页表信息</strong>：打印页表的内容，包括虚拟地址到物理地址的映射情况，以及页表项的各种标志位（如是否有效、访问权限等）。这可以帮助确认进程切换时页表是否被正确更新。</p></li><li><p><strong>CPU寄存器状态</strong>：打印CPU寄存器的当前状态，包括程序计数器（PC）、栈指针（SP）等。这可以帮助确定进程切换后CPU状态的正确性。</p></li><li><p><strong>内核空间的映射情况</strong>：打印内核页表的内容，以及当前CPU的SATP寄存器的值（即当前使用的页表基地址）。这可以帮助确认内核空间的映射是否正确切换。</p></li><li><p><strong>TLB的状态</strong>：打印TLB的内容，可以帮助确认TLB是否被正确刷新，以及新的地址映射是否已经生效。</p></li><li><p><strong>锁的获取和释放信息</strong>：打印进程切换过程中获取和释放的锁，以及锁的持有情况。这可以帮助检查进程切换过程中的并发访问是否受到正确的同步保护。</p></li><li><p><strong>内存管理相关信息</strong>：打印内存分配和释放的信息，以及内存池或内存区域的状态。这可以帮助确认内存管理功能是否按预期工作。</p></li></ol><h6 id="怎么打印锁"><a href="#怎么打印锁" class="headerlink" title="怎么打印锁"></a>怎么打印锁</h6><p>在操作系统的源代码中，锁通常会定义为一个结构体，其中包含锁的状态和与锁相关的其他信息。锁的定义通常会包括锁的状态（如是否被持有）、持有锁的进程ID等信息。我们可以在锁的源代码中添加printf语句，以便打印锁的状态和其他信息。</p><p>下面是一个简单的示例，假设有一个名为<code>my_lock</code>的锁，它的内部结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> &#123;</span><br>    <span class="hljs-type">int</span> is_locked;<br>    <span class="hljs-type">int</span> holding_pid;<br>    <span class="hljs-comment">// 其他锁相关的信息</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">my_lock</span>;</span><br></code></pre></td></tr></table></figure><p>在需要打印锁信息的地方，可以添加类似以下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Lock status: %s\n&quot;</span>, my_lock.is_locked ? <span class="hljs-string">&quot;Locked&quot;</span> : <span class="hljs-string">&quot;Unlocked&quot;</span>);<br><span class="hljs-keyword">if</span> (my_lock.is_locked) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Holding process ID: %d\n&quot;</span>, my_lock.holding_pid);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关于交叉编译的延伸"><a href="#关于交叉编译的延伸" class="headerlink" title="关于交叉编译的延伸"></a>关于交叉编译的延伸</h4><p>交叉编译是指在一个主机上为另一个不同体系结构的目标平台（通常是嵌入式系统或者其他类型的系统）编译软件。在交叉编译过程中，编译器、链接器和其他开发工具被配置为生成目标平台上可执行的代码，而不是在主机上运行的代码。</p><h4 id="关于riscv的延伸"><a href="#关于riscv的延伸" class="headerlink" title="关于riscv的延伸"></a>关于riscv的延伸</h4><p>RISC-V采用精简的指令集设计，只包含少量基本指令，并且设计为模块化的架构。它允许处理器设计者根据特定的应用需求选择添加适当的扩展，以实现更高级别的性能和功能，设计用于各种用途的计算机处理器，包括嵌入式系统、个人计算机、服务器和超级计算机等。它的设计理念是基于精简、模块化和可扩展的原则，旨在提供高性能、低功耗和可靠性。</p><p>可扩展性：RISC-V架构具有多个标准扩展，包括基本指令集（RV32I&#x2F;RV64I）、乘法&#x2F;除法扩展（M）、原子操作扩展（A）、浮点数扩展（F&#x2F;D）、向量扩展（V）等。这些扩展允许处理器设计者根据需求选择添加额外的功能，例如浮点运算、向量计算等。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>歌词存档</title>
    <link href="/2024/04/10/%E6%AD%8C%E8%AF%8D%E5%AD%98%E6%A1%A3/"/>
    <url>/2024/04/10/%E6%AD%8C%E8%AF%8D%E5%AD%98%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>前半部分歌词orz！感觉这版写的比之前的流水账好（后半段写的尤其好</p><p>以及今天投了简历玩（书到用时方恨少啊，，怎么就把之前的课件和课程资料全删光了，，</p><p>想过平凡的每天&#x2F;也想勇敢向前<br>想要游荡在旷野&#x2F;却把亲人想念<br>愤世嫉俗的谎言&#x2F;被无力感裹挟<br>清澈带盐的海风&#x2F;结局却不能回头</p><p>抬头是狂风沙暴&#x2F;北京真是荒漠<br>低头是预制汤锅&#x2F;吃货开始emo<br>明明已二十出头&#x2F;却仍不想长大<br>每天将光阴虚过&#x2F;我到底犯错了吗</p><p>技术不停地迭代&#x2F;他们奋力在追赶<br>人们啊各自相残&#x2F;以同伴尸骸为餐<br>数据像量子海洋&#x2F;海浪上升不停歇<br>城市被齐齐切割&#x2F;我们不停地坠落</p><p>秋冬春夏的色彩&#x2F;沿四面八方飞散<br>操纵者躲在幕后&#x2F;管窥着斑斓巨兽<br>人们紧紧地拥抱&#x2F;三维向二维坍缩<br>那文明绘制的画&#x2F;如此短暂而哀伤</p>]]></content>
    
    
    
    <tags>
      
      <tag>写歌尝试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生出来了！</title>
    <link href="/2024/04/08/%E7%94%9F%E5%87%BA%E6%9D%A5%E4%BA%86%EF%BC%81/"/>
    <url>/2024/04/08/%E7%94%9F%E5%87%BA%E6%9D%A5%E4%BA%86%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>在没有教程的情况下，学会了采样乐器的方法，学会了调试混音参数，学会了设定采样区间，学会了渐入渐出，而且今天编的旋律比昨天的好听（昨天的不适合唱，跨度太大，今天的已经比较接近一些口水歌了</p><p>明天去新太阳录demo</p><p>特地在中午洗头并且编了头发，戴了蝴蝶结，穿了短裙和小白鞋，学了一些（很多）国际音标（很神奇！）明天继续戴蝴蝶结（今天戴了弹簧夹，明天戴抓夹嘿嘿</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>音韵学存档</title>
    <link href="/2024/04/06/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%AD%98%E6%A1%A3/"/>
    <url>/2024/04/06/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%AD%98%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%9F%BA%E6%9C%AC%E4%BA%94%E5%85%83%E9%9F%B3.png" alt="基本五元音"><br>i-最高最前  u-最高最后  a-最低 开口度最大</p><p>中间的过渡生成了e和o两种音</p><p>前展后圆规律：发音在前的一定是展的，发音在后的一定是圆的</p><p><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E8%88%8C%E9%9D%A2%E5%85%83%E9%9F%B3.png" alt="舌面元音"><br>最中间的是央元音（着、了、的）（发音最轻松的音 所以一般用作助词</p><p><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E8%88%8C%E5%B0%96%E5%85%83%E9%9F%B3.png" alt="舌尖元音"><br>把“姿”和“知”的辅音部分去掉就变成那个不认识的东西的读音</p><p>另外两个就是把“卒”和“猪”的辅音部分去掉<br><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%8D%8A%E5%85%83%E9%9F%B3.png" alt="半元音"></p><p>牙和阳因为要发音（直接用作辅音的那种），所以要浊化一点（就是发音的厉害一点，，细微的区分</p>]]></content>
    
    
    
    <tags>
      
      <tag>音韵学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】想要做很多很多很酷的事情</title>
    <link href="/2024/04/05/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%83%B3%E8%A6%81%E5%81%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E9%85%B7%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <url>/2024/04/05/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%83%B3%E8%A6%81%E5%81%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E9%85%B7%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    
    <content type="html"><![CDATA[<p>前几天在梦想清单里也写了一些近期或未来想干的事情，比如想写一首歌（晚上已经在倒腾suno了，由于生成旋律相对容易但是拟合中文歌词比较不成熟，所以现在目前的进度还在：有旋律，但想着填词）！因为自己无法独立与长辈交流所以想学习玉环话音韵学（已经下载了pdf），发现自己有很多想干的事情！（感觉找回了一点活力</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>梦想清单</title>
    <link href="/2024/04/03/%E6%A2%A6%E6%83%B3%E6%B8%85%E5%8D%95/"/>
    <url>/2024/04/03/%E6%A2%A6%E6%83%B3%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>感觉自己很长一段时间都处在一种迷茫的状态，很想走出这种状态！从现在开始尝试吧</p><p>我感觉我是比较幸运的人，父母也非常开明。我一直都认为工作是非常耗尽心力的事情，而且我对一致性、不变性的追求已经到了一种病态的程度，也许这和安全感的稀缺有关系。在昨天深更半夜和zjt聊天以及今天早上践行一些提问的时候“被迫”和父母进行了交谈，我才第一次意识到人生可以是不那么stable的。毕竟人生只有一次！我也认为应该活得wild一点。</p><p>我一直认为我是一个很注重稳定性的人，但是我发现我日常的举动无不体现着“自由精神”，从小翘课，公然违抗老师命令，有自己的主见，有自己喜欢的乐器和乐队，讨厌规规矩矩，讨厌被束缚。只是对安全感的过分追求让我作茧自缚。我想我不应该被困住。我企图用一条确定的道路困住自己，这样就可以自己不用再思考。但是被困住的人生真的是我想要的吗？</p><p><strong>我想要做出怎样的事，让6岁的自己崇敬不已？</strong></p><p>一定不是随波逐流，那时候我总是察言观色，非常没有安全感，如果我接下来的生活依然能够保持孩童的好奇心，想要了解什么就尽力去了解，不要丧失对生活的活力，大脑依旧在转动，想尝试什么就尽量尝试（比如说旅游、组乐队、编曲、画画、学语言、看文学作品）。那我一定会非常崇敬。</p><p><strong>如果我是上帝，准备怎样拯救世界？</strong></p><p>我很崇敬多萝西娅这样的上帝式的角色，她希望让身边的人都幸福而不太看重自己的幸福。其实我也无法想象怎么拯救世界，，，我希望像wowaka一样，燃烧自己，呐喊出自己心中所想，让别人在他的音乐中受到拯救，自己也受到了拯救，这种互相救赎的感觉是极好的。</p><p><strong>如果没有经济限制，你想做什么？</strong></p><p>在市中心有一套独立的小别墅（其实已经有了但是不在市中心，，无所谓，在杭州实现经济自由之后可能真的会回去吧，会请很长很长的年假！）（当然如果工作是线上的话就更好了，在哪里都无所谓，想回去就回去（我dream一下！）</p><p>但是那个小别墅应该是我爸妈养老的地方所以我还是倾向于自己搞一个场地，然后我就练练电吉他，疯一疯（如果能遇到志同道合的乐队朋友的话</p><p><strong>你认为在怎样的事情中可以复现你曾经的精神体验？</strong></p><p>沉浸式、、形成心流的事情其实都可以，画手书的时候（全神贯注），在新太阳地下室躲在门后用民谣吉他大唱特唱摇滚乐的时候，看完电影之后写感想的时候，总之是输出性质的工作的时候都可以</p><p><strong>如果只有一年好活了，你会干什么？</strong></p><p>买一个电吉他（没错我甚至还没有电吉他），配备一些小音箱，找个老师先领我入门然后我大玩特玩</p><p>吃很多很多的三文鱼</p><p>很想把家乡话学会，，现在是只能讲日常用语的程度，，（其实现在就想看看有没有记载太平话的音韵学的书</p><p><strong>你的高我的事业是什么？</strong></p><p>先渡己，后渡人。</p><p><strong>你希望被后世怎样记得？</strong></p><p>她是一个天真的老顽童，有些不可思议，似乎她总是很幸运，只要是她想要得到的她就一定会达成。（她可能拥有很多追随者，也可能身后空无一人，但这对她都无所谓</p><p><strong>你的墓碑上只能写一个身份，你希望是什么？</strong></p><p>自由人！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树洞奇遇</title>
    <link href="/2024/04/02/%E6%A0%91%E6%B4%9E%E5%A5%87%E9%81%87/"/>
    <url>/2024/04/02/%E6%A0%91%E6%B4%9E%E5%A5%87%E9%81%87/</url>
    
    <content type="html"><![CDATA[<p>歌词接龙 要求：不是同一首歌，但是意思能连贯起来</p><p>洞友的力量真是太强大了！（我是D君</p><blockquote><p>第一句：我来到，你的城市<br>#27690146 12小时前 04-02 00:46<br>[Alice] 坐在小酒馆的门口<br>#27690153 12小时前 04-02 00:46<br>[Bob] 来一首我最爱的普通音乐<br>#27690160 12小时前 04-02 00:47<br>[Carol] 钟声响起归家的讯号<br>#27690172 12小时前 04-02 00:48<br>[Dave] 夜太乱以为心已与你交换<br>（E君格式不对 叉出去<br>#27690183 12小时前 04-02 00:48<br>[Francis] 杂讯太多信号弱 就连风吹都要干扰<br>#27690185 12小时前 04-02 00:48<br>[Grace] 光落在你脸上 可爱一如往常<br>#27690188 12小时前 04-02 00:49<br>[Hans] 神魂颠倒<br>#27690191 12小时前 04-02 00:49<br>[Isabella] 我颠颠又倒倒<br>#27690211 12小时前 04-02 00:50<br>[Jason] 听得见过山车有远渐驶近<br>#27690288 12小时前 04-02 00:55<br>[Carol] 透过手指尖看着天<br>#27690319 12小时前 04-02 00:57<br>[Francis] 天黑黑 会不会 让我忘了你是谁<br>[Kate] Re Francis: 谁能给我麻木的酒 醒着醉<br>[Louis] Re Kate: 以为你 有天会感动<br>#27690459 12小时前 04-02 01:09<br>[Margaret] 你却始终站在梦里难触碰<br>#27691472 5小时前 04-02 08:26<br>[Nathan] 如果再看你一眼 是否还会有感觉<br>[Olivia] Re Nathan: 想着或许，下个路口仍是同样的结局<br>#27691836 4小时前 04-02 09:38<br>[Paul] 每天都追赶太阳</p></blockquote><p>中午不知道吃啥就点了袁记云饺，结果去了发现外卖没了，桌子上还摆放着好多袁记云饺。猜测估计是别人拿错了。刚发一条树洞就发现下一条刚好是那个同学发的（一路小跑拿回来好可爱哈哈哈哈哈哈啊哈哈）算是奇遇了，非常好玩。遂拎着袁记云饺去了理教（因为路上突然收到了见面课通知，but没带包 直奔签到现场吃饭然后折返</p><p>星有野居然玩蛋仔啊啊啊！狮哥狮姐啥时成哇（</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>今日（昨日）成就！</title>
    <link href="/2024/04/02/%E4%BB%8A%E6%97%A5%EF%BC%88%E6%98%A8%E6%97%A5%EF%BC%89%E6%88%90%E5%B0%B1%EF%BC%81/"/>
    <url>/2024/04/02/%E4%BB%8A%E6%97%A5%EF%BC%88%E6%98%A8%E6%97%A5%EF%BC%89%E6%88%90%E5%B0%B1%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>继上节体育课偶然发现自己已经可以连续踢出两个毽子后这几天加紧练习！虽然大部分时候还是只能踢一个但是偶尔也可以踢出四个（单只脚），有很大的进步！</p><p>爪爪大作战mvp及获胜记录增加了很多！爪爪技术精进！判断推理刚好看到讲义的第99页（经zjt提醒才发现还有网课要听），经济地理学完全不想写读书笔记，，，（打算gpt）主要这个学期看的电子书实在太多了比较烦了</p><p>感觉自己大学后期的学习主要看兴趣和内驱力，，感兴趣的就多看一点，不感兴趣的就少看一点，甚至感兴趣的都懒得按格式写（认为格式的组织影响了我脑内观点的输出），虽然老师站在学术的角度还是很强调格式，，不过选英语课的人有几个最后真的去做研究呢（至少选英语课的都不是外院的人，我也是觉得读论文比较有意思，反正我读的评论文体也少，不需要花大量时间去组织资料，可能做学术的更需要条条框框吧</p><p>甚至因为自己厌恶条条框框对自己将来的职业规划产生了怀疑。不过晚上仔细想了一下，如果是自己不感兴趣的内容（应付摆烂式），顺便把格式做了对我来说也没有大碍，主要还是自己感兴趣的内容因为自己有很多自己的想法，所以就不想按照格式。不过以后的工作大概率是自己不感兴趣的。无论是大厂螺丝钉比较单一的职能，还是信息老师这种单一授课，或者其他泛体制内岗位。所以如果怀着摆烂心态的话，有没有条条框框都无所谓了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计组期中兼MOOC梳理-2</title>
    <link href="/2024/04/01/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%85%BCMOOC%E6%A2%B3%E7%90%86-2/"/>
    <url>/2024/04/01/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%85%BCMOOC%E6%A2%B3%E7%90%86-2/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BF%98%E5%8E%9F%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81-1.png" alt="还原机器代码-1"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BF%98%E5%8E%9F%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81-2.jpg" alt="还原机器代码-2"><br>前面都没问题，注意一下beq那行（一般beq都是while循环），而且后面一般跟label</p><blockquote><p>虽然偏移量是1，不过实际上读的是下下一条指令（毕竟没有偏移的话就直接读下一条了（很重要！！</p></blockquote><p>D触发器：主要有一个数据输入、一个数据输出和一个时钟输入。在时钟clock的上升沿（0→1）， 采样输入D的值，传送到输出Q， 其余时间输出Q的值不变</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8.png" alt="2016期中-一位全加器"><br>为什么与S连的都是或非门？（A,B两个输入先或非一下，然后再和进位的输入或非），因为S只是某一位的取值（类比个位 只需关注奇偶）又加上二进制只有10两个数字，所以看一下一不一样就行</p><p>为什么Cout先连与门再连或门？AB两个输入先与一下，如果全是1那就构成进位条件。如果AB不全是一呢？没关系AB只要有一个是1就可以了（异或为1），并且如果输入的进位也是1的话也可以构成进位条件，两者满足其一就可以<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BE%93%E5%87%BA%E4%BF%A1%E5%8F%B7i+1.png" alt="进位输出信号分析"><br>可以推一下i&#x3D;1的时候的公式<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BF%9B%E4%BD%8D%E4%BF%A1%E5%8F%B7%E5%85%AC%E5%BC%8Fi+1%E6%8E%A8%E5%AF%BC.jpg" alt="2016期中-进位信号公式i+1推导"><br>以上都是行波进位加法器。</p><p>如果是超前进位加法器：<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%B6%85%E5%89%8D%E8%AE%A1%E7%AE%97%E8%BF%9B%E4%BD%8D%E4%BF%A1%E5%8F%B7%EF%BC%88%E4%B8%89%E7%BA%A7%E9%97%A8%E5%BB%B6%E8%BF%9F%EF%BC%89.png" alt="超前计算进位信号（三级门延迟）"><br>他主要优化的点在于C2的值不需要依赖C1，节省了等待时间（全都是并行计算的），一个竖列的全都是同时算出来，总共三个数列，所以计算Ci的延迟时间固定位三级门延迟</p><p>但是总的一整个超前进位加法器是四级门延迟的。那是因为S3的计算依赖于C3，而计算C3需要三级门延迟。所以计算出S3需要四级门延迟（关键路径<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="超前进位加法器"></p><p><img src="/../img/%E8%AE%A1%E7%BB%84/2016%E6%9C%9F%E4%B8%AD-%E4%B8%8E%E9%97%A8.png" alt="2016期中-与门"><br>非门记忆：让positive的人在上面，本negative人只想当一个阴暗爬行的接地鼠鼠<br><img src="/../img/%E8%AE%A1%E7%BB%84/2017%E6%9C%9F%E4%B8%AD-%E6%88%96%E9%97%A8.png" alt="2017期中-或门（画的是或非门）"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E7%AE%97%E9%97%A8%E5%BB%B6%E8%BF%9F%E6%95%B0.png" alt="2016期中-计算n位行波进位加法器门延迟数"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渐入佳境！</title>
    <link href="/2024/03/31/%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%EF%BC%81/"/>
    <url>/2024/03/31/%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>要失去多邻国连击了啊啊啊啊啊！！（迅速补了 看到很多浊音发音</p><p>没听过的单词背起来真的太狼狈了，hitorie的歌词也有局限（归根结底还是听得太少，，，于是今天紧急搜了一首别的</p><p>正好是告五人（居然唱日语！</p><blockquote><p>見て、晴れの日<br>mi te  hare no hi<br>看啊、是晴天呢</p></blockquote><p>本单元背单词be like：有种听答案以及听方言的感觉哈哈哈哈啊哈哈（</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计组期中兼MOOC梳理-1</title>
    <link href="/2024/03/30/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%85%BCMOOC%E6%A2%B3%E7%90%86-1/"/>
    <url>/2024/03/30/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%85%BCMOOC%E6%A2%B3%E7%90%86-1/</url>
    
    <content type="html"><![CDATA[<p>妈的GPT写的答案全错</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E9%80%89%E6%8B%A9%E9%A2%98.png" alt="高亮为gpt，红笔为自己写的"></p><p>ljl的体系是mooc与上课课件正交的部分，，，</p><p>阿塔纳索夫研发的是ABC计算机，不是ENIAC。（2016期中）</p><p>第一台存储程序式电子计算机是EDSAC必考。（记忆点：S-save&#x2F;store）</p><p>冯诺依曼五个基本组成部分必考。</p><blockquote><p>① 运算器， CA： central arithmetical<br>② 控制器， CC： central control<br>③ 存储器， M： memory<br>④ 输入设备， I： input<br>⑤ 输出设备， O： output</p></blockquote><p>还有其他两个特点分别是：数据和程序均以二进制代码形式不加区别地存放在存储器中，存放位置由存储器的地址指定；计算机在工作时能够自动地从存储器中取出指令加以执行。</p><p>吗嘟这么多课件找不到的内容原来全在MOOC里！气死我了！</p><p>计算机执行指令的具体步骤：取指（Fetch），译码（Decode），执行（Execute），回写（Write-back）。（2017期中）</p><blockquote><p>取指：①控制器将指令的地址送往存储器 ②存储器按给定的地址读出指令内容，送回控制器<br>译码：①控制器分析指令的操作性质 ②控制器向有关部件发出指令所需的控制信号<br>执行：①控制器从通用寄存器或存储器取出操作数 ②控制器命令运算器对操作数进行指令规定的运算<br>回写：将运算结果写入通用寄存器或存储器</p></blockquote><p>在 x86 实模式下， 假设 CS&#x3D;3000H， DS&#x3D;2000H，则指令“MOV AX,[3000H]” 执行时访问的内存地址是23000H。(2017期中) （MOOC课件上有原题一模一样）</p><blockquote><p>计算方法：DS*16+[3000H] 段地址×16＋偏移地址</p></blockquote><p>按两个32位源操作数所在位置划分，MIPS和x86的加法指令都能够支持的是：寄存器 + 寄存器（2016期中）</p><blockquote><p>记住就行了，，默默插一嘴，这题也出现在MOOC的期末考试中，所以肯定是正确答案</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>甜美的单词实在太难记了</title>
    <link href="/2024/03/30/%E5%86%AC%E5%A4%A9%E7%9A%84/"/>
    <url>/2024/03/30/%E5%86%AC%E5%A4%A9%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="冬天-ふゆ"><a href="#冬天-ふゆ" class="headerlink" title="冬天-ふゆ"></a>冬天-ふゆ</h1><p>フユノ，フ是fu，fu的平假名像湖水一样弯弯曲曲，片假名像一只口渴的张嘴小狗想要去湖边喝水。ユ是yu（you），根据中文拼音看起来像沐浴的浴（看起来像一个淋浴喷头），no是禁止的一撇。<br>fuyu，听起来像蜉蝣（很美丽的单词），在日语里指冬天。no是“的”的意思。</p><h1 id="背部-せなか"><a href="#背部-せなか" class="headerlink" title="背部-せなか"></a>背部-せなか</h1><blockquote><p>背中(せなか)を見(み)つめるの、もう嫌(いや)だ。——《なぜなぜ》<br>翻译：一直凝望着后背，已经厌倦。</p></blockquote><p>“背中”仅指人体的背部。“背”（せな）指的是物体的背面或者表面，不仅仅局限于人体的背部。这个词可以用来描述物体的正反面，比如说 “书的背”（书的封面）、”背对着墙”、”背光”（指背面光源）等。</p><h1 id="房间-へや"><a href="#房间-へや" class="headerlink" title="房间-へや"></a>房间-へや</h1><p>“房间” 在日语中通常用「部屋」（へや）来表示。”部屋” 指的是一个房间、居室或室内空间。</p><blockquote><p>“ひとりぼっちの部屋で泣くのが”——《loveless》<br>翻译：独自在房间中哭泣</p></blockquote><h1 id="色-いろ"><a href="#色-いろ" class="headerlink" title="色-いろ"></a>色-いろ</h1><p>“色” 在日语中的发音是 “いろ”（iro）。</p><blockquote><p>積もり積もる煌めきの色  不確か、されど鮮やかな色——《さいはて》<br>翻译：层层堆积的闪耀之色  不确定然而却艳丽无比的颜色——《尽头》</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>靡靡</title>
    <link href="/2024/03/30/%E9%9D%A1%E9%9D%A1/"/>
    <url>/2024/03/30/%E9%9D%A1%E9%9D%A1/</url>
    
    <content type="html"><![CDATA[<p>今天学日语单词学到了靡靡二字。mimi，指耳朵。我就觉得我一定在哪里听过，于是检索了一下脑子里的歌曲库。</p><blockquote><p>口をつぐんで<br>耳をふさいで<br>思いの丈並べたって<br>——《立方棱镜》</p></blockquote><p>“耳をふさいで”这句的意思是“堵上耳朵”，を（wo）是一个助词通常用于标示动作的对象，塞いで（fusaide）是动词塞ぐ（fusagu）的て形，意味着“to plug”或“to cover”，在这里指的是动作的执行方式，即“covering”或“plugging”。所以，当这个短语被使用时，它通常是在告诉某人要覆盖或塞住他们的耳朵。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>每项工程使用红色零件总金额</title>
    <link href="/2024/03/30/%E6%AF%8F%E9%A1%B9%E5%B7%A5%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%BA%A2%E8%89%B2%E9%9B%B6%E4%BB%B6%E6%80%BB%E9%87%91%E9%A2%9D/"/>
    <url>/2024/03/30/%E6%AF%8F%E9%A1%B9%E5%B7%A5%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%BA%A2%E8%89%B2%E9%9B%B6%E4%BB%B6%E6%80%BB%E9%87%91%E9%A2%9D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>按零件数量总和的降序列出每项工程所使用的每种红色零件的总的金额（工程可以向不同的供应商购买同一零件，总金额＝单价*供货数量）。输出工程号、零件号、总金额。</p></blockquote><p>样例输出：</p><table><thead><tr><th>jno</th><th>pno</th><th>sum_money</th></tr></thead><tbody><tr><td>J4</td><td>P1</td><td>73000</td></tr><tr><td>J4</td><td>P4</td><td>22400</td></tr></tbody></table><p>依然是使用聚集函数（不要忘了group by，这里直接写两列就可以了</p><p>一开始遇到的问题是ambiguous列名，解决措施是注明这个列是来自哪张表的</p><p>left join的原因和上一题同理</p><p>ORDER BY可以实现升&#x2F;降序，ASC为升序，DESC为降序，格式为order by 列名 asc&#x2F;desc, 列名 asc&#x2F;desc,…（按排序关键字顺序书写，前面的关键字优先看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> J.JNO,P.PNO,<span class="hljs-built_in">SUM</span>(QTY<span class="hljs-operator">*</span>PRICE)<br><span class="hljs-keyword">FROM</span> J <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span> J.JNO<span class="hljs-operator">=</span>SPJ.JNO<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> P <span class="hljs-keyword">ON</span> P.PNO<span class="hljs-operator">=</span>SPJ.PNO<br><span class="hljs-keyword">WHERE</span> P.COLOR <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;红色&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> JNO,PNO<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">SUM</span>(QTY) <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列出每个城市的工程使用零件总量</title>
    <link href="/2024/03/30/%E5%88%97%E5%87%BA%E6%AF%8F%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%BD%BF%E7%94%A8%E9%9B%B6%E4%BB%B6%E6%80%BB%E9%87%8F/"/>
    <url>/2024/03/30/%E5%88%97%E5%87%BA%E6%AF%8F%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%BD%BF%E7%94%A8%E9%9B%B6%E4%BB%B6%E6%80%BB%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>列出每个城市的工程所使用的零件总的数量。</p></blockquote><p>样例输出：</p><table><thead><tr><th>CITY</th><th>sum(QTY)</th></tr></thead><tbody><tr><td>Paris</td><td>800</td></tr><tr><td>Rome</td><td>1200</td></tr></tbody></table><p>这道题用到了聚集函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> CITY,<span class="hljs-built_in">SUM</span>(QTY)<br><span class="hljs-keyword">FROM</span> J <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span>  SPJ.JNO<span class="hljs-operator">=</span>J.JNO<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CITY       <br></code></pre></td></tr></table></figure><p>left join是因为要列出每个城市的工程零件量，但是不排除有些城市可能零件量为零。（每次都忘了写on</p><p>最后要加一行group by 列名（having 条件表达式，不过这题没有涉及所以不用having</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求供应了所有零件的供应商</title>
    <link href="/2024/03/29/%E6%B1%82%E4%BE%9B%E5%BA%94%E4%BA%86%E6%89%80%E6%9C%89%E9%9B%B6%E4%BB%B6%E7%9A%84%E4%BE%9B%E5%BA%94%E5%95%86/"/>
    <url>/2024/03/29/%E6%B1%82%E4%BE%9B%E5%BA%94%E4%BA%86%E6%89%80%E6%9C%89%E9%9B%B6%E4%BB%B6%E7%9A%84%E4%BE%9B%E5%BA%94%E5%95%86/</url>
    
    <content type="html"><![CDATA[<p>先复习一下关系代数里面的除法</p><p>学生表R：</p><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th><th>院系</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>19</td><td>计算机</td></tr></tbody></table><p>除数S1：</p><table><thead><tr><th>年龄</th></tr></thead><tbody><tr><td>19</td></tr></tbody></table><p>R÷S1&#x3D;学生表中年龄为19的学生信息的新表格，但这个新表格中的字段不包括年龄。</p><p>即：</p><table><thead><tr><th>学号</th><th>姓名</th><th>院系</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>计算机</td></tr></tbody></table><p>所以除法结果就是在被除表中，同时满足除数表的所有条件，但没有除数表中的字段的新表（如果结果有多条记录要全部列出）。</p><p>言归正传，由于评测台的版本过于老，所以不支持except，只能搞where not exists嵌套</p><p>所以不妨来绕一下，供应了所有零件 &#x3D; 不存在一个零件，它不在该供应商的供应零件集中，具体推导可以看下面图片<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9B%9E%E6%83%B3%E8%B5%B7%E8%A2%AB%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%94%AF%E9%85%8D%E7%9A%84%E6%81%90%E6%83%A7.jpg" alt="回想起被数理逻辑支配的恐惧"></p><p>一开始最里面的嵌套是用where not in写的，但是问了gpt之后说这样会导致一些空值的情况，所以最好还是用where not exists</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SNAME<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> P<br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">FROM</span> SPJ<br>        <span class="hljs-keyword">WHERE</span> SPJ.SNO <span class="hljs-operator">=</span> S.SNO<br>        <span class="hljs-keyword">AND</span> SPJ.PNO <span class="hljs-operator">=</span> P.PNO<br>    )<br>)<br></code></pre></td></tr></table></figure><p>SELECT 1是性能问题，它使得只要找到一条记录就返回结果。当然如果是为了考试的话用SELECT *也没有任何问题</p><p>可以将这段代码的执行思想类比为一个嵌套的循环，其中外部循环是对供应商的循环，内部循环是对零件的循环。这种思想类似于控制变量的概念，即在外部循环中保持一个变量不变（当前供应商），而在内部循环中迭代另一个变量（零件）。</p><ol><li>外部的 SELECT SNAME FROM S … 查询遍历供应商表 S 中的每个供应商。</li><li>对于每个供应商，内部的子查询开始执行。这个子查询对零件表 P 中的每个零件进行循环（通过 NOT EXISTS 子句），并检查是否存在至少一条记录，表示当前供应商供应该零件。如果不存在这样的记录，表示当前供应商缺少供应的零件。</li><li>如果对于当前供应商不存在任何缺少供应的零件，即内部子查询返回空结果集，那么外部的 NOT EXISTS 就会返回 TRUE，表示当前供应商满足条件。</li><li>如果对于当前供应商存在至少一种缺少供应的零件，那么外部的 NOT EXISTS 就会返回 FALSE，表示当前供应商不满足条件。</li></ol><p>这种查询的执行方式确实类似于使用嵌套的循环来检查每个供应商是否满足条件。这样的查询结构有助于控制变量，以确保每个供应商都经过了正确的检查，而不会在内部循环中受到外部循环的影响（省流，类似于for循环控制外层变量在内层循环中不变，这样就能保证最内层的循环查找的一定是同一个供应商的供货记录</p><p>最外层的表是S，中间的是P，最内层的是SPJ</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>坠落的审判</title>
    <link href="/2024/03/28/%E5%9D%A0%E8%90%BD%E7%9A%84%E5%AE%A1%E5%88%A4/"/>
    <url>/2024/03/28/%E5%9D%A0%E8%90%BD%E7%9A%84%E5%AE%A1%E5%88%A4/</url>
    
    <content type="html"><![CDATA[<p>晚上看了树洞上吵得很凶的坠落的审判，确实感叹语境不同每个人的观感都不太一样，像有些没体验过类似处境的人可能就不太理解电影的观点，而不同的人也可能会有不同的观点。但是如果强行忽视电影所传达出来的女性主义观点而去揪着讨论别的不重要的意向，我认为是一种很高傲的行为。</p><p>这部片给了我很大的惊喜，虽然话题与画风都非常沉重，但是相比之前看的另一部女性主义电影（芭比），当时是怀着很大的期望，但是比较失望地走出来，感觉没有拍到自己想要看到的点。但是这部片很精确地表达了我的想法。我眼中的女性主义，可能不局限于女性一个性别。感觉有点矛盾，但是我的想法是影片中的妻子角色其实是平常家庭中的丈夫，而丈夫角色却是平常的妻子。光头律师为影片中的丈夫辩护，而梵尚则为妻子辩护，光头看似咄咄逼人，其实体现了很多女孩子（或者较为弱势的群体）的困境，即不得不采取一种激进的手段，即证明他杀来达到判刑的目的，（类似于必须将房子屋顶打破，才能开一扇窗户），但是这样的证明是必定失败的。因为精神控制所带来的迫害无法被证明，它不是实质性的可以构成证据的损害，有很大的主观性。所以在开头我就知道妻子不可能被判刑，她一定会被无罪释放。</p><p>和npy一起看这个影片，并做了很多讨论。我们两个个体都有各自的特殊性。我从小在男生堆里长大，而他却截然相反。所以我们都具有对方性别的一些观念。他结合自己家庭的情况认为妻子（即日常的丈夫）理应做出更多，但我结合自己家庭的情况认为在大部分情况下只能采用无奈的措施，即牺牲其中一方，否则对于整体不利。总之感觉是一个取舍的问题。只有双方达成共识，要么都不牺牲，要么另一方必须看到对方做出的牺牲，ta不能粗暴地认为对方的事情全部是由于自由意志，（看似是自由意志，其实是在特定语境下做出的妥协与权衡），当一方的退让不被看见，那么就必然爆发极大的争端。</p><p>其中一个共识是那个边牧真的好可怜orz！And npy提出了一个疑问是为什么最后男孩会选择为妈妈辩护，我的理解是那是小孩的无奈之举吧，曾经小孩认为母亲是一个怪物，但是最后他们还是要生活在同一屋檐下，而母亲也确实是爱着这个小孩，所以小孩最终还是接受了她。就和很多家庭的结局一样，伤害者和被伤害者被血缘与爱的锁链禁锢，最终还是相互原谅，和平地生活在一起（）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>イヴステッパー</title>
    <link href="/2024/03/28/%E3%82%A4%E3%83%B4%E3%82%B9%E3%83%86%E3%83%83%E3%83%91%E3%83%BC/"/>
    <url>/2024/03/28/%E3%82%A4%E3%83%B4%E3%82%B9%E3%83%86%E3%83%83%E3%83%91%E3%83%BC/</url>
    
    <content type="html"><![CDATA[<p>学了一点点日语满怀信心地点开eve stepper的标题，然后沉默</p><p>谁家好人整天用片假名做标题啊啊啊</p><p>找到了一个更易于记忆的点：u就是捂着肚子，为什么捂着肚子呢，因为痛经。为什么片假名长这样呢，因为痛经所以上吊想鼠。</p><p>但是右边加两撇是什么鬼，，，copilot了一下，发现用来指代外来词（u浊化变成v）</p><p>イ-i  ヴ-v  ス-su？？？（没有dick的没有下半身精灵 输） テ-te（跑得忒快了于是需要用手压住帽子） ッ-cu（三点水的shi的下面那个撇没有那么上翘） パ-（小圆点是半浊音，只出现在h行，这个本来念ha，卓别林的八字须，半浊音之后念pa</p><p>大概理解了日式英语为什么这么奇怪了，，，i v s tei cu pa？？？？？什么玩意</p><p>查了一下这个ッ，「ッ」是日语中的一个特殊假名，它表示一个促音。促音的作用是让下一个假名的辅音发音变得更短，停顿更突然。所以ッパ就是双写p的意思（大概</p><p>eve stepper，，，行吧我大致理解了（鼓掌</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>只向与自己不同城市工程供应</title>
    <link href="/2024/03/28/%E5%8F%AA%E5%90%91%E4%B8%8E%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%B7%A5%E7%A8%8B%E4%BE%9B%E5%BA%94/"/>
    <url>/2024/03/28/%E5%8F%AA%E5%90%91%E4%B8%8E%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%B7%A5%E7%A8%8B%E4%BE%9B%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<p>挑战独立做出数据库题目！</p><blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>求只向与自己位于不同城市的工程供应零件的供应商姓名。</p></blockquote><p>首先，这个供应商不能是什么零件都没有供应，所以以SPJ为主表进行left join</p><p>注意这个left join的格式必须是某某表LEFT JOIN 另一个表 ON 一些条件！！！</p><p>如果要连续left join的话另起一行就可以</p><p>WHERE NOT IN的格式也要注意！是WHERE 某一列 NOT IN（括号里面套娃select）</p><p>讲完了格式讲一下这道题的思路，大体上就是首先，这个供应商必须供应了零件，所以以spj为主表，然后，（判断推理的思路！）“只向与自己位于不同城市供应了零件”的反面是“向与自己位于相同城市的工程供应过零件”（在sql查询中，这个“过”非常重要，“只”相对难办）于是我们求出“向与自己位于相同城市的工程供应过零件”再not in一下就好了！</p><p>放代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME<br><span class="hljs-keyword">FROM</span> SPJ <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> S <span class="hljs-keyword">ON</span> SPJ.SNO<span class="hljs-operator">=</span>S.SNO<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> J <span class="hljs-keyword">ON</span> SPJ.JNO<span class="hljs-operator">=</span>J.JNO<br><span class="hljs-keyword">WHERE</span> S.SNAME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span>(<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME<br>    <span class="hljs-keyword">FROM</span> SPJ <br>    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> S <span class="hljs-keyword">ON</span> SPJ.SNO<span class="hljs-operator">=</span>S.SNO    <br>    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> J <span class="hljs-keyword">ON</span> SPJ.JNO<span class="hljs-operator">=</span>J.JNO<br>    <span class="hljs-keyword">WHERE</span> S.CITY<span class="hljs-operator">=</span>J.CITY<br>)     <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>どうしてなんだい</title>
    <link href="/2024/03/28/%E3%81%A9%E3%81%86%E3%81%97%E3%81%A6%E3%81%AA%E3%82%93%E3%81%A0%E3%81%84/"/>
    <url>/2024/03/28/%E3%81%A9%E3%81%86%E3%81%97%E3%81%A6%E3%81%AA%E3%82%93%E3%81%A0%E3%81%84/</url>
    
    <content type="html"><![CDATA[<p>日语键盘指日可待，，，等学到比较熟练了再装一个日语键盘</p><p>看了几个常用语，doshite和naze都是为什么的意思，于是联想到hitorie的《なぜなぜ》（何故何故）加两个点就是变成浊音</p><p>里面有一句歌词叫doshitenandaiどうしてなんだい，qq音乐给出的翻译是为何难解，比较书面语的时候可能会失去一些情感的表达吧（我的理解），所以分别查了一下，doshite是比较轻柔的语气问为什么，nandai是一种口语表达，表示惊讶、疑问或者不满（应该是偏不满多一点）。将两者结合起来可以给表达增添感情色彩。深感学一门语言的重要，可以通过一手的资料（而非翻译后的二手甚至n手），这样可以更加贴近作曲与歌者的内心。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>尝试独立做出数据库题目！</title>
    <link href="/2024/03/27/%E5%B0%9D%E8%AF%95%E7%8B%AC%E7%AB%8B%E5%81%9A%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%EF%BC%81/"/>
    <url>/2024/03/27/%E5%B0%9D%E8%AF%95%E7%8B%AC%E7%AB%8B%E5%81%9A%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>实在觉得老是抄不太好，所以决定认真学数据库！（一方面也是因为以后可能要当信息老师，一个信息老师如果连数据库都不会怎么教学生嘻嘻</p><p>多邻国太好玩了orz！现在已经知道了一是i chi，二是ni，三是sa n，四是yo n，六是ro ku，七是na na，颜色有点忘记了，，，不过无所谓！</p><p>i就是以，chi是独轮车（entp出老千版），ni是仁，sa是切腹自尽（面向刀，而且完全贯穿），yo是悠悠球，n是椅子和折叠椅，ro是落井下石和耳朵，ku是裤子下蹲，na是拿着十字架</p><blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>求没有供应零件号为P1和P2两种零件的供应商姓名。</p></blockquote><p>苯人直接自信上代码！</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME<br><span class="hljs-keyword">FROM</span> S <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span> S.SNO=SPJ.SNO<br><span class="hljs-keyword">WHERE</span> SPJ.PNO&lt;&gt;<span class="hljs-string">&#x27;P1&#x27;</span> <span class="hljs-keyword">AND</span> SPJ.PNO&lt;&gt;<span class="hljs-string">&#x27;P2&#x27;</span><br></code></pre></td></tr></table></figure><p>不出意外又是wrong answer，，，来看看到底哪里出了问题</p><p>首先左连接肯定是对的（万一有供货商一个货都没供过呢</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/c98e040f4e9128d2e3b7de08207b89c.jpg" alt="发现了问题所在"></p><p>它删除了供货商供货P1,P2的两行，然后把这个供应商供货其他货物的信息原封不动地保留了下来（我本来下意识以为它会自动删掉来着，但是本质上筛下来的是除了P1和P2以外的供货记录</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SNAME<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">WHERE</span> SNO <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> SNO<br><span class="hljs-keyword">FROM</span> SPJ<br><span class="hljs-keyword">WHERE</span> PNO=<span class="hljs-string">&#x27;P1&#x27;</span> <span class="hljs-keyword">OR</span> PNO=<span class="hljs-string">&#x27;P2&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>成功AC！</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五十音打卡-2</title>
    <link href="/2024/03/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%89%93%E5%8D%A1-2/"/>
    <url>/2024/03/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%89%93%E5%8D%A1-2/</url>
    
    <content type="html"><![CDATA[<p>更新上一篇博客的时候不出意外又spawn fail了，，这次重启大法也不管用了！由于zjt在睡午觉于是自己点开了帮助社区尝试从里面检索一些有价值的solution</p><p><img src="/../img/%E4%BA%94%E5%8D%81%E9%9F%B3%E5%AD%A6%E4%B9%A0/40f64614cb5dc9752924e20abd10d2f.png" alt="评论区"></p><p>于是尝试右键git bash。卧槽！丝滑！太丝滑了！下次别再用win的cmd了</p><p>言归正传又看了一点五十音的趣味记忆，接着背，，</p><p><img src="/../img/%E4%BA%94%E5%8D%81%E9%9F%B3%E5%AD%A6%E4%B9%A0/ka%20ki%20ku%20ke%20ko%20sa%20shi%20su.jpg" alt="ka ki ku ke ko sa shi su"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>金宇彬好笨</title>
    <link href="/2024/03/27/%E9%87%91%E5%AE%87%E5%BD%AC%E5%A5%BD%E7%AC%A8/"/>
    <url>/2024/03/27/%E9%87%91%E5%AE%87%E5%BD%AC%E5%A5%BD%E7%AC%A8/</url>
    
    <content type="html"><![CDATA[<p>这个系列用来专门更数据库<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240327124313.png" alt="列出所有供应商的信息"><br>总的说来就是列出所有供应商的信息，包括供应商姓名、所供应的零件名（没有供应零件的供应商也要列出，最后结果中不要出现重复元组）</p><p>想实现的效果like this<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/fd6783cf6517e9620578fc548e54fa6.jpg" alt="主要的痛点在于空行怎么实现"><br>在网上看到了一个用banbao搭博客的学长（姑且称他为banbao学长）的代码，但是运行之后是错误的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">select distinct S<span class="hljs-selector-class">.SNAME</span>, P<span class="hljs-selector-class">.PNAME</span><br>from S,SPJ,P<br>where S<span class="hljs-selector-class">.SNO</span> = SPJ<span class="hljs-selector-class">.SNO</span> and SPJ<span class="hljs-selector-class">.PNO</span> = P.PNO<br></code></pre></td></tr></table></figure><p>还没从关系模型里一堆奇怪的符号转过弯来的我表示震惊，大致研究了一下，distinct可以去掉重复行，from的作用是笛卡尔积（不是自然连接！！！！！）where这行起到了自然连接的作用</p><p>笛卡尔积就是无脑乘起来（相当于小学的乘法法则 总共有a×b×c种</p><p>但是对于苯人贫瘠的脑子还是无法想象，于是我想起以前高中某信息代课老师笨笨的做法，以上表为例全部列了出来</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%A4%A7%E5%8A%9B%E5%87%BA%E5%A5%87%E8%BF%B9.jpg" alt="大力出奇迹"></p><p>于是恍然大悟（模拟自然连接的筛选法则</p><p>所以学长的问题在于他没有实现空行，如何把空行揪出来呢</p><p>网上查询了一下（GPT），可以通过左外连接来实现这个需求。左外连接可以保证左边表（S 表）的所有记录都会被返回，即使它们在右边的表（这里是 SPJ 表）中没有匹配的记录。对于没有供应零件的供应商，其相关的零件名字段会返回为 NULL。</p><p>正确的代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME, P.PNAME<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span> S.SNO = SPJ.SNO<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> P <span class="hljs-keyword">ON</span> SPJ.PNO = P.PNO<br></code></pre></td></tr></table></figure><p>和学长代码的主要区别就是把（伪）自然连接换成了左外连接！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>五十音打卡-1</title>
    <link href="/2024/03/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%89%93%E5%8D%A1-1/"/>
    <url>/2024/03/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%89%93%E5%8D%A1-1/</url>
    
    <content type="html"><![CDATA[<p>从今天开始正式学习日语！先从放弃了很多次的五十音开始orz（差点drop错设备<br><img src="/../img/%E4%BA%94%E5%8D%81%E9%9F%B3%E5%AD%A6%E4%B9%A0/aiueo.jpg" alt="a i u e o"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>地磁暴</title>
    <link href="/2024/03/26/%E5%9C%B0%E7%A3%81%E6%9A%B4/"/>
    <url>/2024/03/26/%E5%9C%B0%E7%A3%81%E6%9A%B4/</url>
    
    <content type="html"><![CDATA[<p>估计是地磁暴的影响，，，今天好难受，，感觉什么都打不起精神</p><p>下午刷了一点探奥的慕课，把米德尔马契看完了（终于！），下节英语课终于可以放心地好好听了</p><p>85公里进度9.4&#x2F;85（遥遥无期啊啊啊，，，好累好累好累！！！</p><p>想要这个学期至少学会日语和电吉他中的一样（加油。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Tiring</title>
    <link href="/2024/03/25/Tiring/"/>
    <url>/2024/03/25/Tiring/</url>
    
    <content type="html"><![CDATA[<p>最近居然产生了一种疲惫感，，一段时间内应该不会再弹太多hitorie的歌了，一方面也是觉得很多曲子弹不出原有的风味。后期应该会梳理一份比较适合吉他弹唱的歌单，在毕业之前想在石舫弹琴唱歌（flag</p><p>报名了普通话考试，清明的时候去开放大学考。可能得稍微准备准备（沉淀.jpg</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哼哼哼论文</title>
    <link href="/2024/03/25/%E5%93%BC%E5%93%BC%E5%93%BC%E8%AE%BA%E6%96%87/"/>
    <url>/2024/03/25/%E5%93%BC%E5%93%BC%E5%93%BC%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>哼哼哼哼哼！</p><p>看不懂我写的论文的人都没品！我觉得从数据退出结论是一个非常不掺杂个人感情的做法，我更愿意为了一个我希望去了解的议题去检索资料，然后再自己引申出一些想法，而不是套公式模板一样地去做！数据？数据我当然有！我特地为了这个论文去检索了很多很多的数据！但是我觉得没有意思！非常没有意思！不如讲点自己心里的东西！我还是更适合当一个诗人而不是当一个审判家！全是数据有什么好看的！只有数据没有灵魂！格式有什么意思！只是看起来写的认真！我唧唧咕咕唧唧咕咕唧唧咕咕！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>济南的春天</title>
    <link href="/2024/03/24/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/"/>
    <url>/2024/03/24/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>周末出逃济南行程记录~</p><p>周五zjt提前结束了小班课故提前出发！在北京南站吃了一顿汉堡王（黑松露和另一个什么味，因为黑松露更好吃所以只记住了黑松露），晚上七点到达“县城”济南站。</p><p>挑几张没有发票圈的放在博客里面hhh</p><p><img src="/../img/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/IMG_20240324_222649.jpg" alt="一出站就看到经一路的火车雕像"></p><p><img src="/../img/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/1711165164818_121418_edit_100645265969537.jpg" alt="美仑酒店的早餐，虽然离景点有二十分钟车程但是非常丰盛"></p><p>除了大明湖和几个专门给小孩子玩的水池以外其他的水真的很清澈！不愧是泉城，很喜欢这里的水。周六这天较为暖和，穿了在北京还没穿过的粉色v领薄毛衣，先趁早去了趵突泉，占领了与对岸相比人少了很多的高地。若不是知道是由于地下断层之类的原因，真的会认为底下有一个水泵在持续不断的运作。</p><p>池底和台阶都有细细密密的气泡偶尔升上来，如果在这边一直发呆，看着气泡上升也是一件美事。几乎每一个泉都清澈见底，红色的小鱼惬意地游动，还能看到池底的钱币，可惜由于反光而且缺乏专业的摄影设施所以拍不出此番美景。从南门出来打车去了大明湖公园，在门口领教了民间中华毽和太极拳，太极可能我们这边还有，但是毽子我们那边真的不咋踢。这与气候有很大的关系，毕竟我们那边多雨潮湿，毽子一旦遇雨则会变成落汤鸡。玉兰花开得极盛，园内的其他花也争奇斗艳。刚好遇上了樱花节，与园子里的各种花美美合影。</p><p>中午骑车去五龙潭附近吃饭，共享单车一直显示离停车点还有7m无法停车，悻悻地交了5块钱调度费。吃完之后便去景区里面游玩。一个巨大的收获是认识了两个水鸟的名字。北京各个湖中常见的“潜水鸭”原来是䴙䴘，那只一直伸头的蠢鸭子竟然是游泳的鸡（骨顶鸡）。</p><p>逛完五龙潭后回酒店休整，晚上来附近的一家鲁菜馆觅食之后又爬了回去（走不动是这样的）。葱烧鲤鱼非常好吃！剥好的虾姑也不错（有点咸，刚好下饭</p><p>DAY2济南大降温，刮了很大的风。去了环城公园（白石泉、黑虎泉、宽厚里、解放阁都在这一块），还买了一杯济南大碗茶。去宽厚里吃了中饭便打道回府，收拾东西之后开始了“流浪生活”，打卡了经三与纬三的爱心路口，买了一只zjt心心念念的德州扒鸡回到酒店大厅大快朵颐，准备回程。</p><p>可能是因为五哈录节目的原因，周日济南人尤其多，像春运一样，非常庆幸在周六那天起的特别早并且错峰看完了景点。火车票更是早早的就没有了（还好提前抢了）。为了赶周一的课周日晚上就回到了北京，迎接北京的雨水！（天气预报看早了，对两地的气温做了一些错误的估计</p><p><img src="/../img/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/IMG_20240324_202123.jpg" alt="Jungle Tiger限定皮肤"></p><p>由于对济南的道路命名方式非常好奇于是查了一下。第一种理论说济南受山河地形影响，东西狭长，南北窄小。古时织物“长者为经，短者为纬”，故将商埠区内东西方向的长道路命名为经，南北方向的短道路命名为纬。另一种理论则是古代建城讲究阴阳五行之说，“山南水北为阳，山北水南为阴”，而济南城位于山北水南皆为阴，从地理位置上阴气重，因此当时建城官员在命名时便将经纬逆转，抵消阴气，使得乾坤颠倒，由阴转阳。所以经一、纬三这种这么现代化的名字原来是古代起的！感到非常神奇。</p>]]></content>
    
    
    
    <tags>
      
      <tag>travel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大唱特唱想念！</title>
    <link href="/2024/03/21/%E5%A4%A7%E5%94%B1%E7%89%B9%E5%94%B1%E6%83%B3%E5%BF%B5%EF%BC%81/"/>
    <url>/2024/03/21/%E5%A4%A7%E5%94%B1%E7%89%B9%E5%94%B1%E6%83%B3%E5%BF%B5%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>唱歌的时候偶尔会唱到非常非常有感觉的歌！！就唱得非常率性特别开心！但是重唱一遍就唱不出那个感觉orz</p><p>对摇滚在音乐上的定义一般是三和弦的强调与重复，而且右手力量上来了之后可以非常迅速地扫弦（把木吉他弹成电吉他的感觉），but电吉他好贵and门槛好高，可能要等有一个自己的地下室之后再配备相关的装备。唱的时候就可以专注于情绪的表达而不是和弦的走向！喜欢这种率性的感觉。</p><p>之前是唱了nazenaze，这次唱了梁博的想念，差点忘了梁博也是摇滚歌手了ww。每次练完wowaka都会随机找一首很久没听的歌来当做换换口味。感觉快把自己唱哭了，果然看得懂歌词的歌更容易感情共鸣，but之后再唱一定又是不同的感觉了。很喜欢这种感觉。树洞上看到有人在听hitorie的歌，很感动，希望有越来越多的人听他的声音（感觉好像传教士，给自己赋予了亿点点宗教精神）</p><p>moikai！moikai！！最遗憾的就是这首歌一直唱不出自己想要的感觉（现场真的太炸了啊啊啊啊超喜欢现场），估计是调太低了，下次调高一点试试看，，，（阿里嘎多真的好可爱</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ollama</title>
    <link href="/2024/03/21/Ollama/"/>
    <url>/2024/03/21/Ollama/</url>
    
    <content type="html"><![CDATA[<p>昨天加入了环境变量，之前困扰的ollama报错问题也解决了。<br><img src="/../img/ollama/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.png" alt="运行环境"><br><img src="/../img/ollama/%E4%BB%A5%E6%B5%81%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B.png" alt="以流的形式运行实例"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ollama<br>stream = ollama.chat(<br>    model=<span class="hljs-string">&#x27;MyModel&#x27;</span>,<br>    messages=[&#123;<span class="hljs-string">&#x27;role&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>: <span class="hljs-string">&#x27;Why is the sky blue?&#x27;</span>&#125;],<br>    stream=<span class="hljs-literal">True</span>,<br>)<br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> stream:<br>  <span class="hljs-built_in">print</span>(chunk[<span class="hljs-string">&#x27;message&#x27;</span>][<span class="hljs-string">&#x27;content&#x27;</span>], end=<span class="hljs-string">&#x27;&#x27;</span>, flush=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ollama</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩了AI</title>
    <link href="/2024/03/20/%E7%8E%A9%E4%BA%86AI/"/>
    <url>/2024/03/20/%E7%8E%A9%E4%BA%86AI/</url>
    
    <content type="html"><![CDATA[<p>第一次跑一个ai的实例独立跑通了！之前没跑通是因为环境变量的问题，设置了环境变量就好了！（事实证明不能忽视控制台的警告哇</p><p>本地部署完成！（算是？</p><p>成就：获得免费API（记得运行的时候要全局翻墙</p><p><img src="/../img/%E7%8E%A9%E4%BA%86AI/API_keys.png" alt="API keys"><br><img src="/../img/%E7%8E%A9%E4%BA%86AI/%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B.png" alt="运行示例"><br>源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> groq <span class="hljs-keyword">import</span> Groq<br><br>client = Groq(api_key=<span class="hljs-string">&quot;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&quot;</span>)<br><br>chat_completion = client.chat.completions.create(<br>    messages=[<br>        &#123;<br>            <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,<br>            <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;why is the sea blue?&quot;</span>,<br>        &#125;<br>    ],<br>    model=<span class="hljs-string">&quot;gemma-7b-it&quot;</span>,<br>)<br><br><span class="hljs-built_in">print</span>(chat_completion.choices[<span class="hljs-number">0</span>].message.content)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>groq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nonsense!</title>
    <link href="/2024/03/20/Nonsense/"/>
    <url>/2024/03/20/Nonsense/</url>
    
    <content type="html"><![CDATA[<p>新太阳的免费乐谱架被搬走了（悲），接下来只能自己把乐谱架搬到新太阳练了。今天为了解放脖子除了学（W）here以外完全没有看谱子唱，（虽然感觉言之无物but唱得很自由很放松！）</p><p>rolling girl的现场特别特别伟大，，，moikai！！moikai！！</p><p>NONSENSE感觉比unknown mother goose还难唱，，bpm太高了orz</p><p>文字上的判断推理只差最后一p视频了，然后就是图推ww！希望立体图可以不要再无脑蒙选项</p><p>suno.ai做出来的榜单前几的音乐都挺好听耶，，，（第二的合成器波感觉很可），，还以为做出来的曲子都是些不三不四的曲子，有点超出想象了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>立方棱镜</title>
    <link href="/2024/03/19/%E7%AB%8B%E6%96%B9%E6%A3%B1%E9%95%9C/"/>
    <url>/2024/03/19/%E7%AB%8B%E6%96%B9%E6%A3%B1%E9%95%9C/</url>
    
    <content type="html"><![CDATA[<p>成功把姐妹带入hitorie坑！wowaka门！</p><p>看了立方棱镜的现场，特别特别伟大，，，和v曲完全不同的感觉，但是两版都很好听，，，</p><p>今天外面风大得要死，向北拜访小天鹅一家，差点错过了探奥签到（其实是路过二教楼下突然想起今天是周二，遂跑步前往理教，签完遂溜），路过东侧门草坪，这么大的风甚至也能找到摄影的同学。第一次在湖面上直观的感受到了风的形状，湖面上的波光特别美丽，因为风大所以湖边人少，找了很久终于找到了天鹅一家，我一直远远地观望，不想打扰到他们，后来来了几个同学怼脸看，于是天鹅一家便迁徙到我的位置，甚至还能看到他们上岸、下水、梳理羽毛。这风刮得我肺疼，不过能近距离观测小天鹅也值了！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>乡村路带我回家</title>
    <link href="/2024/03/18/%E4%B9%A1%E6%9D%91%E8%B7%AF%E5%B8%A6%E6%88%91%E5%9B%9E%E5%AE%B6/"/>
    <url>/2024/03/18/%E4%B9%A1%E6%9D%91%E8%B7%AF%E5%B8%A6%E6%88%91%E5%9B%9E%E5%AE%B6/</url>
    
    <content type="html"><![CDATA[<p>打开b站发现很喜欢的一个雨世界手书博主更新了，真的很喜欢胖猫线，非常温暖的归乡色调，，，hyx潸然泪下</p><p>刚好今天也和室友聊了雨世界的世界观，，看到这样一条评论非常喜欢</p><blockquote><p>对于蛞蝓猫而言，迭代器这样的造物宛若神明，而祂们或是祂们的创造者所追求的飞升，则更是无法企及的东西——但那与猫猫有又有什么关系呢？蛞蝓猫只是一个黏糊糊的小动物，想要的也只是能吃饱、能躲雨和能找到家人罢了。<br>我认为DLC的那些结局是对原版那种极度虚无的飞升结局的一种否定：或许最终一切都会归于虚无，但现在，你仍旧可以追求现世的幸福，与自己的家人和同伴在一起，共同度过一段美好的时光。胖猫打开了返乡的大门，黄白可以回到猫猫树，矛大师回到了红日身边，水猫选择在月姐这里留下——也许并不是所有猫猫都有好结局，但至少，我们并非只有遁入虚无这一件事可做。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>采风</title>
    <link href="/2024/03/18/%E9%87%87%E9%A3%8E/"/>
    <url>/2024/03/18/%E9%87%87%E9%A3%8E/</url>
    
    <content type="html"><![CDATA[<p>久违地去了北边，看了很多很多的新生的枝叶与花花。拍了很多很满意的构图，新生的枝叶与未落尽的枯叶，橙色的枫叶与粉白的山桃同框，未开的花苞，柔软的柳枝，蜘蛛网和树枝上留下的小鸟的绒毛也一并记录，发光的枝条与闪烁的花朵，蓝白相间的天空。</p><p>私以为春天的花朵与机械质地的摄像头同框有一种戴着镣铐跳舞的美。</p><p>在北边碰到一个奶奶，这个奶奶想去未名湖边（然鹅我自己也迷路），遂取消了寻找小天鹅计划，帮她拍了几张照并且带她去了未名湖。大概是想起了自己家里的长辈所以产生了老吾老以及人之老的念头。虽然后面就没怎么拍花了，但对我来说是很有意义感的一段小插曲。（甚至因为刚好在湖边目睹了鸭鸭交配的全过程）奶奶的孙子也在北大读书，但是因为课业忙所以让老人一个人在学校转悠x （哼！借口，如果我外婆过来北大我肯定翘课陪她玩</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>天微微仔光</title>
    <link href="/2024/03/17/%E5%A4%A9%E5%BE%AE%E5%BE%AE%E4%BB%94%E5%85%89/"/>
    <url>/2024/03/17/%E5%A4%A9%E5%BE%AE%E5%BE%AE%E4%BB%94%E5%85%89/</url>
    
    <content type="html"><![CDATA[<p>发现日摇（或日摇风格）乐队大多对音乐有一种虔诚。有一种献祭的味道。</p><p>起因是对象给我推了一首很对我胃口的歌，有一条弹幕“某某市某某县某某街道毫无压力”，虽然和我那个街道只差10分钟车程。由于up主自制的mv有一种浓浓的佛教味与雨世界味（虚空流体飞升）所以天然增强了亲切感，了解了一下这首歌的背景，是一段很悲伤的历史。</p><p>虽然主唱感觉音色和我很相似，但是听到后面觉得完全是摇滚风格，，真的很喜欢这个风格，知乎上搜了一下发现确实是非常喜欢的日摇风格（虽然我日摇风格也听得不多，只听过hitorie笑死</p><p>本来就听不懂的闽南语（好像日语）和日摇风格混合，感觉又有点二次元味，让人心里涌起了一种奇异之感。副歌的怒音很震撼，让我产生了一种想要像了解hitorie一样了解这个乐队的冲动。</p><p>总之大晚上听到这样的音乐很激动，，，不知道几点能睡着了，十一点半迅速码了一篇平复一下我激动的心情，，，（有人一直在连我的耳机 平时早就怒关电脑睡觉了，愣是支棱起来为了循环久一点硬是解决了耳机问题，，，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>突然回想！</title>
    <link href="/2024/03/17/%E7%AA%81%E7%84%B6%E5%9B%9E%E6%83%B3%EF%BC%81/"/>
    <url>/2024/03/17/%E7%AA%81%E7%84%B6%E5%9B%9E%E6%83%B3%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>食欲不振所以买了葡萄糖酸锌口服液，仔细一看自己平时吃的维生素，发现自己吃的维生素里面就有好多锌（是吃的那一支的几十倍了），极为震撼。</p><p>看到华农兄弟的“总集篇”，感觉好感慨，有一种蒙太奇的感觉（）一个小小的通知，荒废的养殖场，屏幕前乐观的脸，这么多亩的油菜，，，又看到对象转的一些童年动画片讽刺现在的一些现象，恰值3·15，这么多不达标的食材，，，要不是北京菜这么难吃而且都是预制菜，我也不会厌食了</p><p>自习的时候不知怎的就想起以前在年级大会上的“光荣事迹”，一查才发现原来是这个意思，瞬间脚趾抠地，，，不过这种事情大家估计都忘记了（万幸</p><p><img src="/../img/%E7%AA%81%E7%84%B6%E6%83%B3%E8%B5%B7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240317200634.png" alt="救大命"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>立竿见影</title>
    <link href="/2024/03/16/%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1/"/>
    <url>/2024/03/16/%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<p>吃了一颗鱼油立刻狂打哈欠，，，真的假的</p><p>中午逼着自己吃了三两米饭！一颗鱼油下肚之后回到寝室一分钟内已经打了十几个哈欠。吃了香蕉 吃了开心果（半包 做完了数据库作业！待会加餐（加餐失败</p><p>晚上去吃了老爸推荐的餐厅（虽然他说我菜点的不好，没鱼没虾的），有被环境吓到（毕竟是第一次和同龄人不在父母陪同下去吃这种餐厅），然后吃掉了一半多的羊肉（有史以来吃的最多的一次，zjt吃了一半，我没数自己吃了多少但是觉得自己吃的也很多），感觉自己看上去已经做好了长大的准备但是实际上心里还没做好长大的准备orz</p><p>花粉粉尘严重超标，感觉快过敏了，风巨大无比，感觉头发上也沾满了粉尘。看了一节判断推理，本来直接扔掉的题目现在强的要命，，（换个地方学数理逻辑</p><p><img src="/../img/%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240316220014.png" alt="聊天截图"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>增重计划！</title>
    <link href="/2024/03/15/%E5%A2%9E%E9%87%8D%E8%AE%A1%E5%88%92%EF%BC%81/"/>
    <url>/2024/03/15/%E5%A2%9E%E9%87%8D%E8%AE%A1%E5%88%92%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>继晚上在北京的街头痛哭流涕之后苯人的增重计划开始！</p><p>过瘦可能会导致贫血、尿、记忆衰退、胆结石之类的疾病，研究更指出男性有140% 、女性有100% 的机率会死得更早！（通过类似闭眼单脚站的恐吓术直接实现增加重视度！</p><p>重点提要：每天吃进去的热量要多于自己消耗的！</p><p>看到网上的食谱，说女生增重和男生增重基本没有区别，唯一的区别就是增加黄豆、木瓜、坚果、莴笋、猪脚等等的食物。首先排除猪脚（虽然gqq爱吃但是我是真的不会吃！！！），木瓜，，毫无疑问也是我平时基本不吃的东西，but坚果可以！正好桌上有坚果！吃掉！莴笋平时经常吃，黄豆经常会和肉放在一起，下次一定也要吃掉！（好像可以通过练臀和练胸来增重，先试着吃多一点吧</p><p>餐前不要喝水和饮料！！！避免让它们充满我的胃！多吃香蕉！！优先选择能量密度大的食物。</p><p><img src="/../img/%E5%A2%9E%E9%87%8D/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240315205112.png" alt="含有碳水化合物的食物"></p><p><img src="/../img/%E5%A2%9E%E9%87%8D/15g%E7%A2%B3%E6%B0%B4%E5%8C%96%E5%90%88%E7%89%A9.png" alt="15g碳水形象化"></p><p>吃碳水吃碳水吃碳水！！！吃高能量食物！</p><blockquote><p>坚果：杏仁、核桃、夏威夷豆、花生等。<br>水果干：葡萄干、梅干等。<br>高脂：全脂牛奶、优格、起司、奶油等。<br>油：初榨橄榄油、酪梨油、夏威夷坚果油等。<br>谷物：燕麦、米饭等。<br>肉类：鸡肉、牛肉、猪肉、羊肉等，选择较不油腻的区块。<br>薯类：马铃淑、山药、番薯等。<br>黑巧克力、花生酱、椰奶等食物。</p></blockquote><p>全脂牛奶是极好的（看来hyx要开始买麦片了。</p><p>增加有氧运动（等姨妈期过后吧，85km还没咋跑哇哇哇柳絮要来了ww</p><p>发现食谱里好多都是不爱吃的东西，，难怪增不了重，，zjt竟然在公司里一个月重了5斤！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些感慨</title>
    <link href="/2024/03/15/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%85%A8/"/>
    <url>/2024/03/15/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%85%A8/</url>
    
    <content type="html"><![CDATA[<p>看到一篇gzh讲了县城心理老师的处境，感觉很感慨。当年去tzyz讲学（忘了）的时候就觉得这些孩子的心理都比我们学校的健康太多，甚至还有一个专门的心理楼层，我都不知道我们学校的那个在哪，之前问了cxzx的npy，他说他们学校有定期的心理课，但是我们学校却一次都没有开过，班会课也都是打鸡血。我心理最崩溃的时候会偷偷跑到隔壁的空教室待在那边哭，一哭就是一节课，but不知道的老师还以为我是过去学习的，然后开始鼓励我们班的同学和我一样占领旁边的空教室，感觉心里也挺复杂的哈哈哈。</p><p>当时接触到一个tzyz的妹妹，她说家里人说她的问题就是太放松了，感觉考不上清北，只能考上浙大、人大或者复交，我心里就想考不上清北挺好的，干嘛人人都去冲清北呢，掉车尾多难受，，那个学校拥有整个tz最大的心理中心，是一所示范学校。而我们是完全效仿衡水。感觉到了高三每个人都很压抑，很心累，已经不愿回忆了，可能每个人都有每个人的烦恼。之前还看见北京的孩子很凡尔赛地说着“课外活动太多了负担不过来”，可能人家的烦恼是我们所理解不来的吧。</p><p>今天三个人围在一起踢毽子，由原来的没有办法发球到渐渐能接几个球了，感觉挺好hhh有进步就好，一方面生理期也是重要影响因素。课前闭眼单脚站差点变成全班站最久的，吓鼠我了。不过还是很欣喜。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些零碎</title>
    <link href="/2024/03/14/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E/"/>
    <url>/2024/03/14/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E/</url>
    
    <content type="html"><![CDATA[<p>昨天收拾了所有换季的衣服，把衣柜基本清理干净了！今天想点一杯姨妈热饮x 因为来姨妈的原因巨累无比，明天好想请假（</p><p>看老师跑了本地大模型跃跃欲试，觉得这个很简单自己又可以了，结果又遇到一些不知名报错（）不进厂是对的，环境都配不来（尖叫</p><p>进厂可以，但是要先找一个人帮我把所有环境配好（可能Mac真的会好配很多，，，吧，但据说现在Mac也很难配了），然后让我没有任何后顾之忧地开发（那还是当老师吧，不用导入这么多乱七八糟的东西只需要讲算法，but又想起今年奶奶让我修电视的经历（我：不会修哇） 有时候也不知道自己大学学了什么 感觉学了一堆高深莫测的理论 你有这么先进的机械进入中国！记住我给出的原理！</p><p>选了天空群岛做壁纸，本来想选有彩虹的那张但是清晰度太低了，于是选了在广播系统上的矛大师（你）用了可爱的rw鼠标指针（编辑文字的时候是垃圾佬钻管道，默认状态下是垃圾佬抖腿），本来还有一只蠕动的桌宠但是太烧cpu了</p><p>看了一点判断推理，觉得类比推理还是很玄学（鼙鼓一点都坐不住啊啊啊啊啊啊还是漫画好看</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些零碎的事情</title>
    <link href="/2024/03/13/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <url>/2024/03/13/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    
    <content type="html"><![CDATA[<p>昨天晚上回来的时候心情真的特别烦想要找个人说说话，但是一想到过去一些失败的社交经历就瞬间萎掉了。感觉自己没有办法找到“沉默不语或漫不经心地听”“喋喋不休”的过渡点，所以大部分时候的讲话都处在“无目的地应和”，这样既避免了沉默，也避免了喋喋不休。而与陌生人的交流却非常擅长。我会率先挑起话题并且确定这个话题双方都感兴趣（毕竟就是在那个场合才认识了陌生人），然后呢，就没有然后了。感觉人是孤独的吧。但是别人却能找到叽叽喳喳的同伴，我却没有这样的人。即便是之前的关系也鲜少维护。大部分时候觉得一个人挺好，但是没有考虑到在亲密关系的维护中也是同理。以前是想去社交的，后来发现一致的人太少，大部分人只是走在自己的道路上罢了，鲜少有人主动关心别人身上到底发生了什么。所以遇见这样的人我很感激，但这样的人也往往只是闪耀了一瞬便消失在自己的视野。</p><p>我的视野范围内还是没有这样的人。我大抵是和凉先辈一样的角色，或者弗兰肯斯坦，将自己囚禁在一个小小的地下室中。我很孤独，不过我也确实获得了快乐。想复制一个自己，但是复制出来又然后呢？她会替代我吗？单纯作为一个陪玩的工具还是不太好吧。这又牵扯到生命意义的问题了。不过我可以肯定地说，即便身边有人，我也仍然处于一个人的状态。这让我不禁思考，关系的意义到底又是什么呢？只是为了“无目的的应和”吗？写到这里情绪又上来了，情绪的源头到底又在哪里呢？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>失败的耗材-3</title>
    <link href="/2024/03/12/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-3/"/>
    <url>/2024/03/12/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-3/</url>
    
    <content type="html"><![CDATA[<p>英文的评论文章缺实难读。一开始没有理解评论员的观点，后来有一些理解了。我认为维克多的家庭是放纵型家庭，因为他的父亲没有正确地引导他，而是放任他走上了歧路。但是评论员恰恰认为维克多的家庭是专制型家庭，因为他的父亲将狭义的理性主义世界观强加在他的身上（对死亡的定义），他对年轻人感兴趣的东西（炼金术师的理论）不屑一顾，他断然否认了维克多的激情，这间接促使了维克多的“反叛”。</p><blockquote><p>我的呻吟惊醒了一个正睡在我身边椅子上的老妇人。她是监狱雇来的护士，是一个狱卒的妻子，而她的面部表情则代表了她那个阶级所有的恶劣品质。她脸上的轮廓粗鲁而又麻木，就像那种看惯了别人受苦受难，而毫不动心的那种人。她说话的腔调，则显示出她内心完全的漠不管心。她用英语对我说话，这声音听起来很耳熟，好像我在昏迷中听到过。……我厌恶地不再理那个老女人。她居然会这样毫无怜悯之心地对一个刚从死亡线上抢救回来的人说话。我感到浑身虚弱，根本无力考虑所发生的种种变故。我命运坎坷，恍如一场噩梦。有时候我真的怀疑是否这一切都是真的。……周围的一切阴森逼人，没有人愿意靠近我用一句温柔、体贴的话语来安慰我；也没有谁愿意伸出亲切的手来扶我一把。医生来过，开了点药方，老妇人则替我备药。而前者一看就知道十分草率马虎，后者则一连凶相，毫无怜悯之心。除了能赚到几个钱的刽子手之外，谁还会对一个杀人犯的命运感兴趣呢？</p></blockquote><p>评论者认为《弗兰肯斯坦》的中心主题是“渴望被真正看到”。这不仅体现在怪物身上，也体现在年幼的维克多身上。当婴儿看着母亲的脸时，最理想的情况在于婴儿在母亲眼中看到的是它自己。这是婴儿最早的确知自己存在的经历。维克多的抱怨和怪物的抱怨如出一辙。</p><p>他与伊丽莎白的结合来自父母对他未来幸福的希望，这种结合并不是他的成就，反而是他向父母屈服的标志，因此他一直处于一种矛盾的心境中，并选择尽可能拖延婚姻。尽管他以“必须把怪物铲除干净”为看似正当的理由，但新婚之夜他还是和新娘分开行动，这在现在看起来是匪夷所思的，正常人会寸步不离地守在新娘身边，生怕她被怪物伤害，而这个人居然把新娘一个人扔在房间里。维克多向他人展示的自我极有可能是欺诈性的，他将他的自我投射到了怪物身上。婴儿会向母亲周期性地展示自己的手势（真实自我），足够好的母亲会成功回应他的手势，使婴儿感到无所不能。与之相反，不够好的母亲会经常回应失败，或者试图用自己的替代手势加给婴儿。婴儿的这种顺从是虚假自我的最早阶段。虚假自我的功能是隐藏和保护真正的自我。</p><blockquote><p>关于我制造的那个魔鬼，我一直不愿作出解释，所以始终保持着沉默。我希望别人把我当成疯子，这样，这件事就永远不会从我嘴里泄露出去了。此外，我也真的不能把这个任何人听了都会吓得心惊肉跳，魂飞魄散的秘密告诉别人。我必须自己对别人的同情的渴望，缄默不言，才能避免自己将这样重大的秘密公诸于众。当然，和我上面提到的类似的话语有时还会不由自主地从嘴里漏出来，但是我却不能加以解释。不过这些话多少包含了几分真相，所以也能稍稍减轻我所忍受的难言之苦。</p></blockquote><p>类似于这样的语句经常出现，维克多经常采取逃避、隐瞒、封闭的措施，这也是他隐藏真实自我的表现。</p><p>论文的名字叫《Invisibility, and Nameless Dread》。正是因为维克多与怪物的情感表达与真实自我不被看见（在别人眼里被迫或主动地隐形），才让他与怪物各自产生无名之惧，正如Hanna Segal所解释的婴儿被欺骗后的焦虑与毁灭性的失望。怪物烧毁了它的小屋，移除了他的情感道具。小屋代表了它精神稳定的可能性。这部小说是双重束缚。维克多忠于使他被隐形的父系世界，他创造了一个非理性的生物，“邪恶”的生物也在黑暗中迷失。</p><p>完结撒花。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>失败的耗材-2</title>
    <link href="/2024/03/12/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-2/"/>
    <url>/2024/03/12/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-2/</url>
    
    <content type="html"><![CDATA[<p>依旧是弗兰肯斯坦。在知乎里看到一段对其他论文的引用感觉可以更好地解释为什么父亲这种粗暴地否定死亡的意义是不对的。</p><blockquote><p>恐惧虽然有其对他人的骚扰，但对其本身不是没有积极的意义。然而低能懒惰的管理者为了保证控制权的质量，经常施行将恐惧彻底否定的行为。久而久之，那些本来该从恐惧中获取的东西的缺席会对人格形成各种各样的伤害，从而导致个体重新形成了另一种持续的介于怀疑和恐惧之间的焦虑情绪，但因为怀疑和恐惧本身已被否定，这焦虑无法进行任何程度的描述——知道那个人重新可以描述恐惧和怀疑本身开始。</p></blockquote><p>无名之痛其实是无法和意识沟通的，埋藏在潜意识中的情感痛苦。</p><blockquote><p>父亲对母亲简直百依百顺，关怀备至，就像一个园丁保护着奇花异草一般，不让她受一点风寒，并且精心安排她的周围环境，使她温柔、善良的心灵能够焕发出愉悦。虽然母亲的情绪后来始终宁静安详，但她的健康还是因为过去的不幸遭遇而受到损伤。在他们结婚以前的两年之中，父亲陆续辞去了所有的公职。在他们结合之后，他们立即移居到气候宜人的意大利，希望异国的美景和旅行所带来的快乐能够帮助母亲恢复健康。——CHAPTER 1</p></blockquote><p>父亲对母亲倍加呵护的态度其实也是这对父母对这个独子的态度。</p><blockquote><p>从意大利出发，他们又游历了德国和法国，我是他们的长子，出生在那不勒斯，所以我在襁褓里就伴随着他们四处游历。整整好几年间，我都是他们的独子。他们彼此如胶似漆，并且从蕴藏着他们无尽爱意的矿藏中源源不断地向我倾注他们的爱心。母亲的温柔抚爱和父亲慈祥和蔼的笑容，就是他们留给我最早的印象。我是他们的小宝贝，更重要的是，我是他们的孩子，是上天赐予他们的无辜而且无助的生命。我需要他们养育，而我的未来也牵系在他们手中，他们是将我引向幸福、还是苦难，就看他们如何履行对我的职责了。他们非常清醒地意识到，他们赐予了我生命，并对我负有完全的责任，再加上他们本来就都是充满爱心和柔情的人，所以可以想见，我婴儿时期的每时每刻都耳濡目染在耐心、仁慈、自制的氛围中。我就像被一条绸带牵引着，一路上都是无尽的幸福和快乐。</p></blockquote><p>每时每刻都耳濡目染在耐心、仁慈、自制的氛围中，感觉这个孩子不像是孩子，倒像是父母的玩物。虽然我们家的实际情况也差不多，我妈经常说出类似“生个孩子玩玩”之类的话，我也很同意她的观点，决定以后无聊的时候也生个玩玩，这个观念居然也是错的！那得品行多么高尚的人才有资格做父母啊！我还是不要对自己这么苛求了（雾）。</p><p>【论文对此段文字的观点是时时刻刻让婴儿耳濡目染着自制，这损害了婴儿的独立性。但我偏向于认为这只是对他们家庭氛围的一种叙述，不是他的爸爸妈妈时刻在耳朵旁嚼舌根，所以我不同意论文在此处的观点。】</p><p>言归正传，约翰·马丁阐明了四种不同类型的养育方式，从文章看来，弗兰肯斯坦家庭的养育方式应该属于放纵型（没有要求，有求必应）。这类家长照顾孩子的每一个需求，顺应孩子的每一个请求。他们不愿意制定规则，也不提出期望，因此没有规训的基础或需要。他们会提醒，会唠叨，但很少落实口头威胁并采取行动。他们经常妥协，不会说“不”，即便扬言惩罚，也并不会真正实施，他们觉得孩子不会犯错误。他们希望讨得孩子的欢心，表现得更像是孩子的朋友，而不是父母。有些人表面上随时都在孩子身边，但并没有参与孩子实际在做的事情。放纵型父母往往比其他类型的父母富裕，受教育程度更高。</p><p><img src="/../img/%E6%97%A0%E5%90%8D%E4%B9%8B%E7%97%9B/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240312095717.png" alt="四种养育方式"></p><p>放任型的教育方式一定正确吗？它会导致什么样的后果？我在知乎上找到了相关的回答。回答太长了，所以我概括了一下。</p><p>尽管在我们的文化中，这些类型的父母被描绘为可爱而古怪的。放纵型父母的教育方式可以被看作采取最不容易遭到抵抗的方式。往好里说，他们只是希望他们的孩子能够快乐。往坏了想，他们根本不想做教育子女的工作。不管是哪一种，他们没有给孩子建立任何限制、规则，或在孩子青春期时可供叛逆的强有力的成年人形象。要说“不”可是很花力气的。强迫一个孩子做一件杂事或任务是很累人的。跟一个愤怒的孩子交谈、相处也是很费事的。因为对孩子说“不”，而被你的孩子讨厌，哪怕只是暂时的，也是非常痛苦的。放纵型父母觉得与其教孩子做家务还不如自己做来得轻松。当孩子惹麻烦的时候，他们也经常给孩子找别的理由来当借口。</p><p>当孩子长大后回顾往事，他也许会怪自己不懂事——他青春期时父母就完全没管过他，他以为这样他们就对他没有任何影响了，不管是正面的影响还是负面的，所以除了自己，他还能怪谁呢？他意识不到他缺席的爸爸和心事重重的妈妈都没有付出一点时间和精力来教育他。</p><p>青少年天性渴望自由，他们正处于建立自己独特的同一性的阶段，也期望与父母分离。但重要的是虽然青少年渴望自由，但毫无约束对他们无益。青少年需要一个可以与之对抗的强大的父母。他们在与父母的规则和违反规则的后果的冲突中学习如何做出好的决定和如何管理他们的冲动。不幸的是放纵型家庭的孩子往往没有这一切。放纵型的教育还有另一个缺陷:孩子得不到父母足够的反馈，他得为自己负责，找到他对自己的期待:他擅长什么，他的弱点是什么，他应该争取什么。</p><p>（查了那么多理论之后开始发牢骚：感觉养好一个孩子真是一件麻烦且复杂的事）</p><p>所以我恍然大悟，这就是为什么弗兰肯斯坦从头到尾都非常敬重自己的父母，即便他们在精神层面是缺失的，也依然认为他们尽了养育的职责。</p><blockquote><p>每当我回忆自己孩提时代的时候，总是觉得无以言表的快乐。可惜此后，不幸就开始玷污我的心灵，把我原本大有作为的光明前程断送在阴暗、狭隘的自我中心里。此外，在叙述我早年的经历的时候，我也要提及一些事情，这些事情后来一步步地，不知不觉地把我引向苦难的深渊。因为当我发现那些可怕的、宿命般的狂热刚刚在我内心升腾起来的时候，那种狂热还只是像山涧里的溪水，断断续续，时隐时现，可是慢慢到最后，它就变成汹涌澎湃滔滔大河，将我所有的快乐和希望都冲得无影无踪。</p></blockquote><p>弗兰肯斯坦是一个天才，但是他在年少时缺乏引导，这也间接地促使他走上了歧路。他不知道什么是对，什么是错，所有的对错都是他自己定义的。他缺乏一个严厉且权威的父亲给他树立规则，原本处于一个溺爱环境的他导致他无法融入集体生活。这在后面也有体现。</p><blockquote><p>我父亲并没有很高的科学素养，所以没有人可以引导我走出孩子式的盲目，并把我作为一个学生对知识的渴求善加利用。于是在我的新导师的指导下，我全身心地投入到对水晶球和长生不老药的研究上，而且后者很快就吸引了我全部的注意力。对我来说，财富是次要的，但是如果我能够使人类免除疾病，并且使人类除了死亡之外，能够对任何伤害刀枪不入的话，那么，这将是多么了不起的成就啊！</p></blockquote><blockquote><p>我钻进即将载我远行的马车，心头泛起最伤感的情怀。我一直以来都生活在亲人和朋友中间，尽力使彼此都体会到亲情和友情的快乐。可现在我是一个人了。在我将去就读的大学里，我必须寻找新的朋友，自己保护自己。在此之前，我的生活一直远离人群，大多数时间都是呆在家里，这使得我非常不习惯和陌生面孔的相处。我爱我的兄弟、伊丽莎白，和克莱瓦尔，这些是我”熟悉的老面孔”，但是我相信自己完全和陌生人合不来。</p></blockquote><blockquote><p>父亲后来在来信中并没有进一步责怪我，而只是把我的沉默理解为我比往日更加投入在学业上。冬天、春天、夏天，时光就在我的辛劳中从身边滑过，但是我没有欣赏到鲜花盛开，嫩叶暴芽的美景。这些都是在以前最令我兴奋雀跃的景致了，我只是完全沉浸在自己的工作中了。</p></blockquote><p>以上更加佐证了我的观点。由于篇幅限制，会另起一篇。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>失败的耗材-1</title>
    <link href="/2024/03/11/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-1/"/>
    <url>/2024/03/11/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-1/</url>
    
    <content type="html"><![CDATA[<p>​因为英语课的要求，所以找了一个在线网站匆忙地补了弗兰肯斯坦。在简介发现这是严格意义上第一本科幻小说，所以津津有味地看了起来，虽然自己实际上要回课的内容并不是这一篇小说。</p><p>这是一个​篇幅比较短，非常精妙的作品。我花了一个小时的时间不间断地把它看完，觉得非常震撼。另一方面也是因为自己某段时间对很多事情感到困惑，主动去查询了很多亲子关系方面的知识以及很多心理的成因（我自己小时候也有非常严重的分离焦虑，现在已经因为很多事情的捶打而渐渐的消退，但是我认为我的母亲也有非常严重的分离焦虑症）。</p><p>弗兰肯斯坦是一个对自然科学非常狂热的人，就如同他自己对沃尔特所说：</p><blockquote><p>“疯狂地获取知识有多么危险！随遇而安、服从天命的人比野心勃勃、妄图更大成就的人幸福。”</p></blockquote><blockquote><p>“一个完美的人永远应该保持平静、祥和的心态，永远都不能让一时的热情和一时的冲动破坏内心的平静。”</p></blockquote><p>他因为对名利的贪欲以及对道德的漠视（原著中他对挚友克莱瓦尔对研究道德关系的著作的不理解），从死人骸骨中拼凑出一个失败的耗材。</p><blockquote><p>“I ought to be thy Adam ; but I am rather the fallen angel.”</p></blockquote><p>这是一个孩子对遗弃他的父亲的控诉。弗兰肯斯坦创造了人，滥用神权，破解谜题却无视后果。普罗米修斯草率地创造了人类并给人以火，触犯了神的禁忌（巨人自焚也许就是对火的暗示）。在警示了科学的边界的同时，也体现着对生命的敬畏。</p><p>老师认为弗兰肯斯坦是一个雌雄同体的角色。他首先是一个男性，但是他又像一个母亲一样创造了巨人（尽管他“生而不养”）。他还举了著名的绒布妈妈实验。不过当时我在想的是，弗兰肯斯坦有一对受人敬重且爱他的父母，为什么又会成为一个重度抑郁患者？为什么不能像他的父母那样去养育自己所造出来的“人”？</p><p>令我比较兴奋的是，老师在课后布置的课后作业正是为了回答这一问题。</p><p>弗兰肯斯坦和怪物组成了小说的双线，他诉说了两个看上去大相径庭的情感遗弃故事。维克多对于他父亲（文章中只能看出对父亲的态度因为母亲早逝）的态度也是防御性质的，而怪物恰恰可以视为维克多自我的一面。维克多的童年是受父母保护的和谐童年，他在家中倍受爱戴，父母为了抚养他也非常尽责，但他的“孩子”却被创造者抛弃与漠视。</p><p>弗兰肯斯坦对他父亲的描述中，他似乎是一个公众人物，没有私人的自我，弗兰肯斯坦对他的动词是“敬重”，感觉没有特别强烈的那种“爱”的情感，而是更多出于一种责任。我对这对父子的相处模式非常感兴趣，于是截取了一些关于他的父亲的片段。</p><blockquote><p>“我是日内瓦人，我的家族是当地最有名望的豪门之一。我的祖先们几代以来都是担任政府顾问和市政官，而我父亲已经担任过好几个社会要职，声名显赫。父亲因为他的正直和对公共事务孜孜不倦地关注而倍受人们尊敬，他把自己整个青春时代都用于处理国家事务，因此不断变化的环境一直使他未能成婚，直到他的人生开始走下坡路时，才为人夫和人父。因为父亲的婚姻状况很能显示他的品格，所以我不能不提几句……（家道中落，最真挚的友谊，感到痛惜，朋友家产耗尽，毫无其他经济来源）就在这个时候，我父亲走进了他们的小屋，他就像一个保护神一样来到女孩身边，负起照顾她的责任。在她父亲的葬礼结束后，我父亲把她接到了日内瓦，寄宿在他的一个亲戚那里。两年以后，卡罗琳娜成为了他的妻子。”——CHAPTER 1</p></blockquote><blockquote><p>“六年的时间恍然如梦，留下的只有一条洗刷不掉的痕迹，而我当年离开家，前往英格尔斯塔德的时候，就是站在这儿最后一次拥抱了父亲。我可敬可爱的父亲啊！对我来说，他永远都是这样。我久久凝视着壁炉架上方母亲的肖像，这是按照我父亲的意愿而画成的一件具有纪念意义的作品。在画中，卡罗琳娜·博福特，我的母亲，跪在她父亲的灵柩旁边，悲痛欲绝。她虽然衣着朴素，脸色苍白，但却自有种高贵美丽的气质，并不让人觉得可怜。而这幅画的下方，就是威廉的一幅小肖像。我一看，就不禁泪流满面。”——CHAPTER 7</p></blockquote><p>有评论说，弗兰肯斯坦父亲对他母亲卡罗琳娜的“爱”是“一种感觉”的苍白衍生物，这种情绪充满了责任与工具性。</p><blockquote><p>“如果父亲当时不是这样轻描淡写，而是愿意费一些工夫向我解释——阿格里帕的理论已经被完全推翻，而科学家已经引入一套现代科学体系，要比旧的理论体系强有力得多，因为旧的理论模式只是空中楼阁，而新的理论模式是建立在事实和实证的基础上的——那么，我的好奇心肯定就会得到满足，然后把科纳柳斯·阿格里帕的书扔在一边，既而用更大的热情投入到我原来的研究上。而且如果是这样的话，我的思想甚至根本就不会产生致命的冲动，最后将我引向毁灭。但是我父亲那仓促的一瞥令我感到他根本就不知道书里在说些什么，于是我继续贪婪地埋头阅读这本书。”——CHAPTER 1</p></blockquote><p>温尼科特将母亲对于婴儿的作用分为“客体母亲”与“环境母亲”，客体母亲支持婴儿无所不能的感觉（尿布湿了就有人换，饿了就有奶吃），让婴儿确信婴儿自身存在的真实性，环境母亲是帮助婴儿隔绝外部世界的一层屏障，这是一种过渡领域，但也需要向外部世界提供灵活性以适应其创造力。婴儿的性格取决于孩子形成的最早的关系，如果以足够好的方式回应，就会形成好的性格，如果不承认他的内心世界，而是强加自己版本的现实，抑制婴儿的想象力、欲望、痛苦等自发性情感，那么就不能够形成好的性格。</p><blockquote><p>“我知道我的杳无音讯令他们非常不安，我至今都很清楚地记得我父亲在信里说： “我知道，即使你在那里自得其乐的时候，也仍然会充满深情地想念我们，但是我们也该定期收到你的家信呀。请你一定要原谅我，如果你中断和我们的联络的话，我只能将之视为你连你其他应尽的责任也一概打算视了。”——CHAPTER 4</p></blockquote><blockquote><p>“父亲发现我的性情、和生活习惯发生了巨大变化之后非常痛苦，他时常发自内心地开导我，希望我能够振作精神，鼓起勇气，驱散蒙在我心头的阴云。”维克多，”他说，”难道我心里就不难受吗？没人比我更爱你的弟弟了。”，他流着泪说，”但是，我们对于活着的人来说就没有责任了吗？我们不应该过度悲伤，这样只会增加别人的痛苦。这也是你对自己应尽的责任啊，因为过分忧伤会损害你的健康，让你无法享受生活的乐趣，甚至一蹶不振，不能尽基本的社会义务，这样一来，你对社会还有什么用呢？”父亲的说法虽然言之有理，但是却不符合我的情况。要是我的内心不是如打翻了的五味瓶一般，各种痛苦、恐惧、悲哀，绝望的情感都搅和在一起的话，我可能会第一个把内心的悲哀掩盖起来，并去安慰我的朋友。可是现在，我只能无望地看着我的父亲，并尽量避免在他眼前出现。”——CHAPTER 9</p></blockquote><blockquote><p>“要研究生命的起源，就必须求助于死亡。我已经掌握了解剖学，但这还远远不够，我必须观察尸体自然腐烂的经过。父亲在我幼年时期对我进行教育的时候，总是非常小心，不让我的心灵被任何超自然的恐怖事物所惊吓。我记得我从来都不害怕迷信传说，也不害怕幽灵鬼怪。黑暗不会令我产生任何恐怖的联想，墓地对我来说也只是存放失去了生命的躯壳的地方，那些原本美丽强健的肉体最终会成为蛆虫的美餐。”</p></blockquote><p>对死亡本该有的那些原始的恐惧被系统地禁止与解构。</p><p>截了小说前半部分的很多父子之间的互动，我才发现看似非常和谐的父子关系实际上却令维克多感到回避。还关注到一些除了父子之外的维克多对于别人的看法，比如对于他的妻子： </p><blockquote><p>“每个人都喜欢伊丽莎白，大家对她的爱深沉、强烈，而我对此总会感到无比的自豪和喜悦。在伊丽莎白来我家的前一天晚上，母亲开玩笑地对我说：”我有一件漂亮的礼物要送给我的维克多，明天他就可以拥有了。”第二天，她把伊丽莎白带到了我的面前，说这就是她许诺的那份礼物。而我呢，带着孩子式的认真，真的从字面上理解我妈妈的话，认为伊丽莎白归我所有，将由我来保护她、爱她、珍惜她。我把所有对她的赞美都看成对我个人财产的由衷赞美。我们虽以堂兄妹相称，但是没有任何语言、任何表达法可以描述她和我之间的关系——她对我来说不仅是妹妹，因为她至死都只属于我一个人。”——CHAPTER 1</p></blockquote><p>不过这个口吻令我感到有点奇怪。“个人财产”“拥有”感觉有一点物化妹妹的迹象，但是我倾向于认为他们俩是true love，至少维克多本人对伊丽莎白有着精神上依赖的情感，维克多因为父亲养育造成的影响，对非理性的否认构成了他的整个童年，那他不知如何表达情感便也成为一种很正常且可悲的事了。其实还有相关的片段，在于他认为自己是一个非常可怜的脆弱的人所以觉得他和非常精神平和的象征着精神寄托的伊丽莎白非常相配，当然以现在的恋爱观来看这是一种非常畸形的单方面的倾斜，两人本应该各自美丽而不要牵扯太多的类似救赎，不要把对方看成自己的圣母，也不要想着去拯救对方。</p><p>论文没翻译完，自己的感想倒是写了一大段，有空再写。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些神奇的想法</title>
    <link href="/2024/03/09/%E4%B8%80%E4%BA%9B%E7%A5%9E%E5%A5%87%E7%9A%84%E6%83%B3%E6%B3%95/"/>
    <url>/2024/03/09/%E4%B8%80%E4%BA%9B%E7%A5%9E%E5%A5%87%E7%9A%84%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本来只是想上小红书搜一些学习攻略结果不小心又点进视频里面了（捂脸），发现已经刷到很多宠物鹦鹉撕纸放在身后的行为，觉得很神奇，所以检索了一下，发现这是母鸟絮窝的方式，就是把草咬成一小截一小截，插在后面鼙鼓羽毛下，这样就可以带很多根，也叫别草。这是成鸟准备繁殖的信号。</p><p>之前吃饭的时候也想到为什么要吃盐的原因，有姐妹帮我查了是因为动物喜欢去盐碱地舔一舔盐巴，然后人们发现这种物质会让动物兴奋，于是就自己也尝了尝。感觉很多自然界的事情都特别有意思！</p><p>今天真的好渴，，，而且连考三门真的太反人性了！虽然大概率是陪考，不过科三的时候摸鱼画证件照画得差点在考场笑出来，，，下次不干了，，，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>明与暗</title>
    <link href="/2024/03/08/%E6%98%8E%E4%B8%8E%E6%9A%97/"/>
    <url>/2024/03/08/%E6%98%8E%E4%B8%8E%E6%9A%97/</url>
    
    <content type="html"><![CDATA[<p>我总是会为一些替代经历产生恐惧。因为害怕被伤害选择逃避，试图排除所有的危险，也许是对于幼儿时期的“全能自我”的迷恋，希望一辈子都像一个婴儿一样被所有人关心，即退行，而这也是我一直以来的防御机制。</p><p>转载了一点知乎的回答，觉得写的特别好，所以时时翻看勉励自己。</p><p>逃避伤害是对的，但是他的目的应该是为了尽可能选择值得的牺牲，而不是为了永远幸福地生活下去。如果“千万不要受伤害”在决策中变得越来越重要，只会让人生被浸透在“可能受伤害”的恐惧之中。越是恐惧，便越是敏感。最后除了自绝于人类，将没有任何手段能安抚极端敏感的恐惧。</p><p>要学会主动接受受伤的可能性，即聪明的受伤、有控制的、有意的受伤。在不断受伤之中形成耐受、脱去敏感，“伤害”的威力也就被剥夺了。</p><p>“于何时在何地为何人接受何种受伤的风险”应该是经过深思熟虑后进行的一种选择，而且这种选择应该贯穿整个人生。</p><p>与这种可能性主动的共舞，慢慢就会学会跳舞，于是别人不敢的，你敢；别人不肯的，你肯；别人不能的，你能。慢慢地就会体会到，唯有有效的牺牲是真正幸福的。因为人终将死去，你所舍不得牺牲的最终仍然会化为飞烟，你根本就不能选择“不失去”。</p><p>牺牲有技巧，有价值最大化的复杂策略。你不能选择拒绝牺牲，而只能选择学习牺牲的智慧和技术。如何将有限的人生转化为最大的人类福利、世界的福利，是一门需要毕生学习的课程。</p><p>你回避一种伤害，只该是因为不愿虚掷你的“受伤余额”，但绝不是为了守着这份余额到死的。不要再在一次次逃避中践踏光阴了！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HITORIE</title>
    <link href="/2024/03/06/HITORIE/"/>
    <url>/2024/03/06/HITORIE/</url>
    
    <content type="html"><![CDATA[<p>在地下室大唱特唱HITORIE。过路的人问我为什么喜欢日本的歌，我不假思索地回答，因为我喜欢HITORIE这个乐队，准确的说，我喜欢这个乐队的主唱。</p><p>wowaka的歌都很难翻唱。他的几首比较广为传诵的歌都是非常快的bpm，令人上气不接下气，但是在我非常低落的时期，他那种宣泄式的嘶吼的迷茫是我的精神支柱。从进入大学以来，几乎每个学期都在循环他的老歌。</p><p>发现冬野里有一句歌词是，“所有人都拥有的&#x2F;唯一的&#x2F;心脏&#x2F;即使被洋溢的色彩所浸染&#x2F;也依然跳不够&#x2F;不要离开我”，很感慨。</p><p>在五月天假唱风波时，我会想到wowaka的万人合唱unknown-mother goose现场。每一个人都向前挥动着手臂，就像巨浪。他不够高，甚至够不到立式话筒。但是他踮起脚抬起头，似乎是咬牙切齿地，但是饱含感情地喊出每一个词，弹奏着手中的电吉他。当我第一次听到现场最后那个爆发式的质问时，我的眼泪情不自禁地流了下来。有人假唱，有人燃尽生命怒吼。</p><p>从那首歌起，我对他的认知从一个净写些这么难翻唱的v家曲的p主，到发自内心认为他是一个可敬的歌者。我深深地崇拜着他的灵魂，尽管他也一样看似是现实逃避之人。从那一刻起我也开始去了解我几乎不怎么接触的日语歌领域，开始了解他担任主唱的乐队，开始费力地学着罗马音。</p><p>我带上耳机跟随着sleepwalk的节奏就像mv里漫步的舞者，这首歌是我循环次数最多的歌。我一边仰望着晴朗冬日里光秃秃的树枝枝干，一边一遍遍地听着冬野，每当听到那个钢琴变奏眼神都会突然变得柔和而悲伤。那时还在疫情学期，夜晚的未名湖非常寂静，我在未名湖的夜晚向着对面大喊“为何难解？为何难解！”。我一面郑重地弹奏，一面想象他站在台上的样子。我决定把记忆中的那个他重现出来，一直一直唱着他的歌。这是我的怀念，以最郑重的方式。</p><p>“在颤抖到无法动弹前，唱起来，唱起歌谣，只是唱着歌谣。”</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>上善若水</title>
    <link href="/2024/03/05/%E4%B8%8A%E5%96%84%E8%8B%A5%E6%B0%B4/"/>
    <url>/2024/03/05/%E4%B8%8A%E5%96%84%E8%8B%A5%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p>昨天发了一篇博客是想就inner peace这个话题发发牢骚的，后来想查一下inner peace的官方解释，发现是类似于一种自得其乐，不争的概念。啥是不争？于是进行了一些递归式检索，发现了它最早的出处。</p><p>“上善若水，水善利万物而不争。处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。”</p><p>要想理解不争，还得理解尤的意思。尤指过错吗？但是扶苏不争导致胡亥继任，秦朝灭亡，显然不争并不能避免错误。尤指别人的怨恨吗？道德品行再高的人也会被一些不理解的人责骂，这是人性所然。其实尤指的不是别人的怨恨，而是每个人自己的怨恨之心。所以老子这句话的意思是：如果你与世无争，就不会有怨恨之心。</p><p>诸烦恼中，瞋为最重。诸心病中，第一难治。一念嗔心起，百万障门开。杀瞋心安隐，杀瞋心不悔；瞋为毒之根，瞋灭一切善；杀瞋诸佛赞，杀瞋则无忧！那么如何才能杀掉心中的“嗔”呢？佛陀提供了一个绝招叫忍辱。而老子也提供一个必杀技叫不争。所谓“忍辱”，不正是“不争”吗？</p><p>只要有竞争，有博弈，就难免有得失，有成败。而水谦虚卑下，清湛悠然，择地而居。水助万物而自乐，滋润万物而不居功，柔弱处下，与世无争，这样才能免去患得患失的精神折磨，免去纷争、痛苦与烦恼。</p><p>但是我在检索的时候留意到上面广为传颂的版本反而是以讹传讹流传下来的版本，而真正的版本，很奇怪，表面上看起来是完全相反的观念。</p><p>“上善若水，水善利万物而有争。居众之所亚，故几于道。心善渊，居善地，予善天，正善信，事善能，动善时。不争容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。夫唯不争，故无尤。”</p><p>老子的原意，是争与不争的辩证。心善渊，居善地，予善天，正善信，事善能，动善时，是水的六个品性，也是不争的六个含义，而不是上一版本的人的品性。水像宇宙一样包容，像大地一样公平，像苍天一样无私，水真实可靠，有求必应，善于激发万物的潜能，也会在干旱缺水时雪中送炭。水滋润万物，满足需求，故而不争。但一切生命离不开水，万物无不归往，此为有争。水的这种“服务性”让我不禁想起了《沙丘》中的姐妹会。这个组织表面避其锋芒，负责激发各大家族基因组的潜能，甘于退居身后，因此在纷争之中保全自身，实则又把救世主牢牢控制。这种主旨也是“弱能胜强”在某种方面上的体现。</p><p>反者道之动，弱者道之用。前者指的是同一事物的循环往复，向着反面发展。后者则是不同个体之间的关系互动，强即是弱，弱即是强。我自己的心中也时时滋长许多恶念，正好我的主命格为水，故以此作为id来提醒自己。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我想要获得安宁的心境</title>
    <link href="/2024/03/04/%E6%88%91%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E5%AE%89%E5%AE%81%E7%9A%84%E5%BF%83%E5%A2%83/"/>
    <url>/2024/03/04/%E6%88%91%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E5%AE%89%E5%AE%81%E7%9A%84%E5%BF%83%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>我想要获得安宁的心境，而西方资本想获得货币的自我增值。我不会臣服于他们的工业化学制剂。是春天的错，我狂热地爱着春天。气温无预兆地变冷又变暖，就像我的心脏我的血液。冬天让我思维静止在室内，春天让我疯狂，都怪春天。</p><p>我厌倦了日复一日的发笑，我享受着遗弃的快乐。我会屈服于阳光，过度曝光却又寒冷刺骨。我怒目圆睁，步入轨道。</p><p>我手握着自行车把，一辆电动车撞向了我的腰间。我无所谓。我的手冻得麻木，失去知觉。</p><p>文史楼一股尿味，地学楼也是，一教也是，宿舍也是。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>可能只是碰巧吃到了辣椒籽</title>
    <link href="/2024/03/03/%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E7%A2%B0%E5%B7%A7%E5%90%83%E5%88%B0%E4%BA%86%E8%BE%A3%E6%A4%92%E7%B1%BD/"/>
    <url>/2024/03/03/%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E7%A2%B0%E5%B7%A7%E5%90%83%E5%88%B0%E4%BA%86%E8%BE%A3%E6%A4%92%E7%B1%BD/</url>
    
    <content type="html"><![CDATA[<p>吃到巨辣的东西时不要放弃一整盆菜，你可能只是碰巧吃到了辣椒籽。</p><p>如果一条鱼刺特别多也不代表这条鱼全是刺，你可能只是碰巧吃到了背部。</p><p>学会了All too well的前八分钟，手磨出泡了，明天休战一天。还以为毽子水平倒退了，原来是因为穿了白牛仔裤有了心里负担。晚上换了条裤子又练了一会，汗都出来了。</p><p>穿着风衣去五四跑了一会，谁能在外面阳光明媚的情况下憋在室内呢？开会的时候看完了沙丘前十五章，报告厅真的太挤了。两个小时内肝完了冯式结构读书报告，因为想练琴所以尤其高效。</p><p>变成凤凰蛋了，终于！这几天一直在跑训练图，辛苦了！感觉不开麦组队打训练图还是为时过早了些，线下再教训zjt。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FLIPPED DUNE</title>
    <link href="/2024/03/02/FLIPPED-DUNE/"/>
    <url>/2024/03/02/FLIPPED-DUNE/</url>
    
    <content type="html"><![CDATA[<p>二十四小时内看了两场电影，zjt说DUNE的海报字体设计很独特。这个学期要读的书有点多，但还是想找沙丘的原著看。FLIPPED个人认为有点强行HE。</p><p>“有没有一种可能，女主父亲允许男主在院子里挖洞是为了给女儿做恋爱脑切除手术，让女儿看清他有多坏。”</p><p>“标题都叫怦然心动了，你不HE让那些来看的小情侣怎么办？”</p><p>再次感觉每一个经历都是在为现在的我做铺垫，比如写博客在中间空一行就得益于之前想整自媒体但没整成的经验。</p><p>蹭进元培楼也愈发轻车熟路了，就是坐的有点后排被挡了字幕。</p><p>和zjt逛海淀公园，打牌。天气回暖，气温正好。他说我穿着羊羔绒的衣服更像一只小羊羔了。正好今天也cos了dongdong羊，薯片小羊训练图是大好图哇，虽然很艰难但是过关了，感觉有望成为硬核蛋。</p><p>尝试改手机端的icon但是没改成，无所谓，反正电脑端看得比较多。</p><p>今天练习了两百下毽子，从一开始的满场地跑，到大概有五十到一百下是可以踢一下接住的了，脚也暖和了。难怪说这是一个减轻玉玉的运动。</p><p>连续两天被错认为在准备十佳节目了哈哈，一个留学生姐姐走近并试图和我交流，差点没听懂口音不过她冲我比了个大拇指。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单脚站立的乌鸦</title>
    <link href="/2024/03/01/%E5%8D%95%E8%84%9A%E7%AB%99%E7%AB%8B%E7%9A%84%E4%B9%8C%E9%B8%A6/"/>
    <url>/2024/03/01/%E5%8D%95%E8%84%9A%E7%AB%99%E7%AB%8B%E7%9A%84%E4%B9%8C%E9%B8%A6/</url>
    
    <content type="html"><![CDATA[<p>研究表明，单脚闭眼站立不超过五秒的人十几年内会死。我哆哆嗦嗦地摇着花手，湖边北岸的鸭子双脚站立在将融未融的湖面上，而我维持着脚底的温度。</p><p>乌鸦侧着脑袋，看太阳表面的脉搏闪闪发光。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】古人计划</title>
    <link href="/2024/02/29/%E5%8F%A4%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    <url>/2024/02/29/%E5%8F%A4%E4%BA%BA%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>以前新生训练营的时候，很想与人交流，但碍于周围人都在看手机，只好作罢。手机，确实是一个隔断交流的东西，又加上开学后日益压抑、充满了距离感与落差感的氛围，我的内向指数也逐渐上涨。</p><p>智能手机第一次入侵了我的生活，之所以说是入侵，主要是因为以前我从来都是将它当做一个工具来使用，或搜题，或拍照，或聊天。</p><p>而现在我却被绑架了。当周围所有人都在看手机时，这是一个拒绝交流的信号，我也不得不低下头去，把眼睛拘束在屏幕之中。当时从不冲浪的我甚至不知道手机有什么好看的，也不知道该看什么。训练营在抬头与低头的循环中结束。</p><p>暑假的时候，妈妈把退役的智能手机给外婆用，尽管外婆不识字，但也觉得智能机好用，不会像老年机一样发出闹心的声音。但上初三的表妹占据了大部分手机的使用权，每天要刷至少两个小时的短视频。推开门，她坐在书桌前，悄悄把手机埋在参考书下，外放音量调到最小。她聊起现在班级里大家都在吐槽“应试教育”，不知怎的，这种专有名词从她口中讲出倒显得她像个早熟的小老头。同一部手机，所有年龄段的人收看着几乎一样的东西，所以大学生逐渐幼稚，小孩却早早体验大人的生活。</p><p>“你都看啥小说啊？”</p><p>“无限流！”她语气中不无骄傲。</p><p>“啥是无限流啊？”</p><p>“无限流就是……”她吧啦吧啦给我解释了半天，大致听了个明白。</p><p>可能前面的一代人看我们这代也饱含着同情与艳羡。但我认为短视频和电视剧、游戏有着本质的区别。短视频是一种漫长且没有尽头的刺激，刺激过后，只有精神涣散与空虚。于是尝试戒掉电子榨菜，并在这个四年一遇的日子重启了博客。</p><p>非常感谢grey’pe提供的建站帮助。</p><p>注：无限流，指系统强制给你下达任务，主角有无限生命，只有任务完成才能回到原来的世界。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
