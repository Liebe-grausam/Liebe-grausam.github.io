<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>别人的字节面经</title>
    <link href="/2024/07/08/%E5%88%AB%E4%BA%BA%E7%9A%84%E5%AD%97%E8%8A%82%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/07/08/%E5%88%AB%E4%BA%BA%E7%9A%84%E5%AD%97%E8%8A%82%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p>这是一份最终版字节面经，也是一份最终版互联网面经。如果这次还面不过的话应该就放弃这条路了。</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络分层及其典型协议"><a href="#网络分层及其典型协议" class="headerlink" title="网络分层及其典型协议"></a>网络分层及其典型协议</h2><p>OSI七层模型：<br>应用层（Application Layer）：这是网络体系结构中的最顶层，提供用户接口和应用程序之间的通信服务。在这一层，用户可以访问各种网络应用程序，如电子邮件、文件传输和远程登录。<br>表示层（Presentation Layer）：该层负责数据的格式化、加密和压缩，以确保数据在不同系统之间的交换是有效的和安全的。它还提供了数据格式转换和语法转换的功能。<br>会话层（Session Layer）：会话层管理应用程序之间的通信会话，负责建立、维护和终止会话。它还提供了数据的同步和检查点恢复功能，以确保通信的完整性和持续性。<br>传输层（Transport Layer）：传输层为应用程序提供端到端的数据传输服务，负责数据的分段、传输控制、错误恢复和流量控制。它主要使用 TCP（传输控制协议）和 UDP（用户数据报协议）来实现这些功能。<br>网络层（Network Layer）：网络层负责数据包的路由和转发，以及网络中的寻址和拥塞控制。它选择最佳的路径来传输数据包，以确保它们能够从源主机到目标主机进行传输。<br>数据链路层（Data Link Layer）：数据链路层提供点对点的数据传输服务，负责将原始比特流转换为数据帧，并检测和纠正传输中出现的错误。它还控制访问物理媒介的方式，以及数据帧的传输和接收。<br>物理层（Physical Layer）：物理层在物理媒介上传输原始比特流，定义了连接主机的硬件设备和传输媒介的规范。它确保比特流能够在网络中准确地传输，例如通过以太网、光纤和无线电波等媒介。<br><img src="/../img/%E5%AD%97%E8%8A%82%E7%BB%88%E6%9E%81%E9%9D%A2%E8%AF%95/f4617ed300054efe99d9acb0bc7105fe.png"></p><h2 id="数据链路层重要知识"><a href="#数据链路层重要知识" class="headerlink" title="数据链路层重要知识"></a>数据链路层重要知识</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>帧是数据链路层的基本单位，发送端在网络层的一段数据前后添加特定标记形成帧，接收端根据前后特定标记识别出帧。<br>只有数据链路层才能识别帧，物理层只负责传输比特流。 这也满足计算机网络层次结构设计的一个原则——层与层之间相互独立、解耦。</p><p>网络层将IP数据报 传送到数据链路层作为帧的数据部分，数据链路层在分别其前后增加了一个标记。帧在物理层就是一串01比特流。</p><p>帧首部和尾部是特定的控制字符(特定比特流)<br>帧首部(SOH)：00000001<br>帧尾部(EOT)：00000100</p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>控制字符在帧数据中，但是要当做不存在的去处理</p><p>在帧数据部分出现的首尾控制字符前加一个转义字符(ESC)。如果数据中也出现转义字符咋办，那就再转义字符前再加一个转义字符。<br>ESC在这里的作用就像C语言中的“\”。</p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>物理层只管传输比特流，无法控制和判断是否出错。物理层在传输过程中很容易受到环境干扰，进而产生错误但物理层无法察觉。因此数据链路层负责起“差错监测”的工作。</p><ol><li>奇偶校验</li></ol><p>根据原始数据1的个数来增加奇偶校验码。分为单比特奇偶校验（检查）和多维奇偶校验（可纠错）</p><p>一维奇偶校验码的编码规则是把信息码元先分组，在每组最后加一位校验码元，使该码中1的数目为奇数或偶数，奇数时称为奇校验码，偶数时称为偶校验码。<br>单维奇偶校验只能发现错误位数为奇数的错误，即比如两位出错，奇偶校验无法发现错误。</p><p>二维就是在空间上先形成二维数组，然后每行每列都有一个校验码。</p><ol start="2"><li>CRC循环冗余校验</li></ol><p>选一个 r+1 bit 的生成多项式G(x)，作为双方的除数。<br>若原始数据为D，发送方用M&#x3D;D*2^r作为被除数。<br>M除以G,得到一个余数R,即为CRC循环冗余检验码。<br>最终发送的数据为M+R。<br>（相当于，在原始数据和“原始数据左移r位得到的被除数除以生成多项式得到的余数”一起发送（把余数添加在最后</p><p>发送方发送这个数据之后，接收方再用这个数据除以原来的除数（生成多项式得到的除数），如果余数为零就没有错误。</p><p>能检查出全部单比特错。<br>能检查出全部的奇数个比特错。<br>能检查出全部长度小于或等于r位的突发错。<br>硬件电路效率很高。</p><p>CRC冗余检验通常工作在数据链路层。（√）<br>存在100%能查错的算法。（×，目前不存在）<br>校验和查错速度比CRC检验快。（×，CRC是基于底层硬件的差错方式，更快）<br>散列函数（如MD5算法）（这玩意是单向加密的，无法通过MD5加密后的数据来还原）可用于数据保密通信。（×，只能检查数据的完整性）<br>奇偶校验只能查错，不能纠错。（×，多维奇偶校验可以纠错）<br>纠错机制应广泛用于计算机网络通信（×，代价太大，更多的是差错控制机制）</p><h2 id="TCP、UDP差异及应用场景"><a href="#TCP、UDP差异及应用场景" class="headerlink" title="TCP、UDP差异及应用场景"></a>TCP、UDP差异及应用场景</h2><p>可靠性<br>点对点 vs 一对多 多对一 多对多<br>分片（TCP在传输层分片，UDP在网络层分片<br>首部开销<br>是否要建立连接<br>传输是否有边界（如何传输</p><p>应用场景：TCP用于FTP文件传输，HTTP &#x2F; HTTPS；UDP用于包总量较少的通信，如 DNS、SNMP 等，视频、音频等多媒体通信，广播通信。</p><h2 id="TCP如何保证数据可靠传输"><a href="#TCP如何保证数据可靠传输" class="headerlink" title="TCP如何保证数据可靠传输"></a>TCP如何保证数据可靠传输</h2><ol><li>控制位</li><li>校验码</li><li>建立连接</li><li>拥塞控制（其实快速重传包含在拥塞控制里面）<br><strong>慢启动</strong>（初始cwnd&#x3D;1，收到ack cwnd++，经过一个RTT（往返时间）没出现丢包重传则cwnd*2，直到cwnd&gt;&#x3D;sshtresh门限则终止该阶段<br><strong>拥塞避免</strong>（每收到一个ack cwnd+&#x3D;1&#x2F;cwnd 线性增长<br>如果碰到<strong>超时重传</strong>（发送方传了之后没收到ack）的情况则sshresh&#x3D;cwnd&#x2F;2，cwnd&#x3D;1，重新回到慢启动阶段<br>如果碰到<strong>快速重传</strong>（收到三个重复ACK） cwnd &#x3D; cwnd&#x2F;2, sshresh &#x3D; cwnd, cwnd&#x3D;cwnd+3，重传丢失的数据包，如果再收到重复的ACK则cwnd+1，如果收到了新的ACK则恢复原来的状态，重新进入拥塞避免</li><li>seq、ack</li><li>滑动窗口</li></ol><h2 id="TCP3次握手4次挥手"><a href="#TCP3次握手4次挥手" class="headerlink" title="TCP3次握手4次挥手"></a>TCP3次握手4次挥手</h2><p>握手：<br>syn（seq&#x3D;x） synack （seq&#x3D;y ack&#x3D;x+1） ack（seq&#x3D;x+1 ack&#x3D;y+1）（注意要加一）<br>挥手：<br>fin（fin&#x3D;u） ack（seq&#x3D;v ack&#x3D;u+1） finack(seq&#x3D;w ack&#x3D;u+1) ack(seq&#x3D;u+1 ack&#x3D;w+1)</p><h2 id="挥手之后客户端进入close状态要等多久"><a href="#挥手之后客户端进入close状态要等多久" class="headerlink" title="挥手之后客户端进入close状态要等多久"></a>挥手之后客户端进入close状态要等多久</h2><p>2MSL（MSL指报文被丢弃前的最长存活时间</p><p>一方面也是为了避免连接复用之后旧的数据包还没过期就到达，一方面是为了确认服务器已经关闭<br>这是为了确保服务器收到ACK报文，如果服务器没收到ACK报文就要重传FINACK报文，如果在此期间客户端又收到了这个报文就要重新计时。</p><h2 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h2><p>这是由TCP的传输特性引起的。因为TCP是流式传输，如果请求发送的数据量没达到缓冲区大小，那么多个请求可能会合并成一个请求进行发送，这样TCP可能没办法判断哪一段流属于一个信息。<br>粘包时：发送方每次写入数据 &lt; 接收方套接字(Socket)缓冲区大小。<br>拆包时：发送方每次写入数据 &gt; 接收方套接字(Socket)缓冲区大小。<br>日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中</p><p>解决办法：</p><p>1、<strong>固定长度</strong>：客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；</p><p>2、<strong>特殊字符边界</strong>：客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；</p><p>3、<strong>自定义消息结构</strong>：将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；</p><p>4、通过自定义协议进行粘包和拆包的处理。</p><p>补充：http协议如何解决粘包</p><p>读取请求行&#x2F;请求头、响应行&#x2F;响应头<br>1、遇到第一个\r\n表示读取请求行或响应行结束；<br>2、遇到\r\n\r\n表示读取请求头或响应头结束；</p><p>读取body数据<br>HTTP协议通常使用Content-Length来标识body的长度。在服务器端，需要先申请对应长度的buffer，然后再赋值。<br>如果需要一边生产数据一边发送数据，就需要使用”Transfer-Encoding: chunked” 来代替Content-Length，也就是对数据进行分块传输（使用chunked协议）。</p><p>chunk协议主要内容<br>1、主要包含三部分: chunk，last-chunk和trailer。如果分多次发送，则chunk有多份。<br>2、 chunk主要包含大小和数据，大小表示这个这个chunk包的大小，使用16进制标示。其中chunk之间的分隔符为CRLF。<br>3、通过last-chunk来标识chunk发送完成。一般读取到last-chunk(内容为0)的时候，代表chunk发送完成。<br>4、trailer表示增加header等额外信息，一般情况下header是空。通过CRLF来标识整个chunked数据发送完成。</p><p>chunk协议优&#x2F;缺点</p><p>优点</p><p>1、假如body的长度是10K，对于Content-Length则需要申请10K连续的buffer，而对于Transfer-Encoding:chunked可以申请1k的空间，然后循环使用10次。节省了内存空间的开销。<br>2、如果内容的长度不可知，则可使用chunked方式能有效的解决Content-Length的问题<br>3、http服务器压缩可以采用分块压缩，而不是整个块压缩。分块压缩可以一边进行压缩，一般发送数据，来加快数据的传输时间。</p><p>缺点<br>1、chunked协议解析比较复杂。<br>2、在http转发的场景下(比如nginx)难以处理，比如如何对分块数据进行转发。</p><p>Nginx（读作 “engine x”）是一款开源的高性能HTTP服务器及反向代理服务器。</p><p>以下是Nginx的几个主要功能：</p><ol><li><strong>HTTP服务器</strong>：Nginx可以用作Web服务器，用于提供静态文件、处理HTTP请求、提供SSL支持等。</li><li><strong>反向代理服务器</strong>：Nginx可以作为反向代理，将客户端请求转发到后端服务器，通常用于负载均衡、缓存以及安全性提升。</li><li><strong>负载均衡</strong>：Nginx可以将流量分配到多个后端服务器，从而提高网站的可靠性和性能。</li><li><strong>缓存</strong>：Nginx可以缓存静态内容和代理内容，从而减少服务器的负载并加快响应时间。</li><li><strong>邮件代理服务器</strong>：Nginx也可以用作IMAP&#x2F;POP3&#x2F;SMTP邮件代理服务器。</li></ol><p>Nginx以其高性能、低资源消耗和模块化设计著称，使其成为许多高流量网站的首选Web服务器。例如，WordPress、GitHub、Netflix和Dropbox都在使用Nginx。</p><h2 id="输入URL到网页的过程"><a href="#输入URL到网页的过程" class="headerlink" title="输入URL到网页的过程"></a>输入URL到网页的过程</h2><p>查域名是否在本地缓存中<br>DNS解析到IP地址（顶级域名解析器-&gt;根域名解析器-&gt;本地域名解析器）<br><strong>建立TCP连接</strong><br>向服务器发请求头<br>请求服务器中资源<br>页面渲染</p><h2 id="websocket协议"><a href="#websocket协议" class="headerlink" title="websocket协议"></a>websocket协议</h2><p>普遍认为，WebSocket的优点有如下几点：</p><p>1）较少的控制开销：在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小；<br>2）<strong>更强的实时性</strong>：由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少；<br>3）保持连接状态：与 HTTP 不同的是，WebSocket 需要先创建连接，这就使得其成为一种<strong>有状态</strong>的协议，之后通信时可以省略部分状态信息；<br>4）更好的二进制支持：WebSocket <strong>定义了二进制帧</strong>，相对 HTTP，可以更轻松地处理二进制内容；<br>5）可以支持扩展：WebSocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。<br>由于 WebSocket 拥有上述的优点，所以它被广泛地应用在即时通讯&#x2F;IM、实时音视频、在线教育和游戏等领域。</p><p>WebSocket 协议和 HTTP&#x2F;HTTPS 协议有一定的关联，但它们是为不同的用途设计的协议。</p><p>HTTP&#x2F;HTTPS 协议：</p><ol><li><strong>用途</strong>：HTTP（Hypertext Transfer Protocol）和 HTTPS（HTTP Secure）主要用于客户端和服务器之间的请求-响应通信。它们适用于请求短期连接，比如网页浏览、文件下载等。</li><li><strong>连接模式</strong>：HTTP&#x2F;HTTPS 是无状态协议，每次请求都需要新建一个连接，并在请求完成后关闭连接。</li><li><strong>传输方式</strong>：HTTP 通过明文传输数据，而 HTTPS 在 HTTP 基础上加入了 SSL&#x2F;TLS 加密层，用于确保数据的安全传输。</li><li><strong>通信方向</strong>：通常是单向的，即客户端发送请求，服务器返回响应。</li></ol><p>WebSocket 协议：</p><ol><li><strong>用途</strong>：WebSocket 是一种全双工通信协议，设计用于在客户端和服务器之间建立长时间的连接，实现实时、低延迟的双向通信。它适用于需要频繁消息交换的应用，如在线聊天、实时游戏、股票行情推送等。</li><li><strong>连接模式</strong>：WebSocket 通过一个初始的 HTTP&#x2F;HTTPS 请求进行连接升级（handshake），然后在该连接上保持持续的、双向的通信，直到连接被关闭。</li><li><strong>传输方式</strong>：WebSocket 连接建立后，数据以帧（frames）形式传输，可以是文本或二进制数据。初始握手使用 HTTP&#x2F;HTTPS 协议，因此 WebSocket 也可以通过 SSL&#x2F;TLS 加密实现安全通信，即 WSS（WebSocket Secure）。</li><li><strong>通信方向</strong>：全双工通信，即客户端和服务器都可以随时发送数据。</li></ol><p>关联：</p><ol><li><p><strong>连接建立</strong>：WebSocket 的连接是通过 HTTP&#x2F;HTTPS 协议的握手（handshake）机制建立的。客户端发送一个 HTTP 请求，包含 <code>Upgrade</code> 头部字段，要求升级到 WebSocket 协议。如果服务器同意升级请求，则返回一个包含 <code>101 Switching Protocols</code> 状态码的响应，随后连接升级为 WebSocket。</p><p>握手示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==<br><span class="hljs-attribute">Sec-WebSocket-Version</span><span class="hljs-punctuation">: </span>13<br></code></pre></td></tr></table></figure></li><li><p><strong>安全性</strong>：WebSocket 可以通过 HTTPS（即 WSS）来建立加密连接，确保数据传输的安全性。类似于 HTTPS 相对于 HTTP 的作用，WSS 提供了对 WebSocket 数据流的加密。</p></li></ol><p>总结来说，WebSocket 和 HTTP&#x2F;HTTPS 在初始握手阶段有直接关联，但它们在设计目的、连接模式和通信方式上有明显的区别。HTTP&#x2F;HTTPS 适用于请求-响应模型，而 WebSocket 适用于需要持续、低延迟双向通信的场景。</p><h2 id="为什么握手要三次，挥手要四次"><a href="#为什么握手要三次，挥手要四次" class="headerlink" title="为什么握手要三次，挥手要四次"></a>为什么握手要三次，挥手要四次</h2><p>握手三次：<br>确认客户端和服务端的收发能力都没问题<br>四次挥手：<br>关闭连接时，客户端向服务端发送 FIN时，仅仅表示客户端不再发送数据了但是还能接收数据。<br>服务端收到客户端的FIN报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</p><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>Client hello：<br>SSL&#x2F;TLS ver、client random、密码套件</p><p>Server hello：<br>SSL&#x2F;TLS check、Server random、密码套件 check、数字证书</p><p>client response：<br>CA密钥 check 真实性<br>通信算法改变通知<br>握手结束通知<br>摘要</p><p>server response：<br>通信算法改变通知<br>握手结束通知<br>摘要</p><p>加密通信ing</p><h2 id="对一个已经上线的使用HTTPS的客户端应用，假设有问题，如何排查，如何抓包？"><a href="#对一个已经上线的使用HTTPS的客户端应用，假设有问题，如何排查，如何抓包？" class="headerlink" title="对一个已经上线的使用HTTPS的客户端应用，假设有问题，如何排查，如何抓包？"></a>对一个已经上线的使用HTTPS的客户端应用，假设有问题，如何排查，如何抓包？</h2><p>确认问题：确定问题是发生在客户端、服务器还是网络。检查客户端日志、服务器日志以及网络状况。<br>检查证书：确认客户端和服务器使用的SSL&#x2F;TLS证书是否有效且未过期。<br>验证网络连接：确保网络连接正常，没有防火墙或其他网络设备阻止流量。<br>使用wireshark抓包（客户端代理设置成127.0.0.1:8080</p><h2 id="DNS协议如何多级寻址"><a href="#DNS协议如何多级寻址" class="headerlink" title="DNS协议如何多级寻址"></a>DNS协议如何多级寻址</h2><p>查缓存-&gt;<strong>本地</strong>询问根域名服务器-&gt;根域名服务器返回顶级域名服务器-&gt;<strong>本地</strong>查顶级域名服务器-&gt;顶级域名服务器返回授权域名服务器-&gt;本地查授权域名服务器-&gt;授权域名服务器返回给本地域名服务器-&gt;<strong>保存到缓存</strong>并返回给本机</p><h2 id="域名和ip的对应关系？"><a href="#域名和ip的对应关系？" class="headerlink" title="域名和ip的对应关系？"></a>域名和ip的对应关系？</h2><p>（多对多！！！）<br>一个域名可以对应很多个ip，比如百度有很多个ip<br>一个ip也可以对应很多个域名，比如一台计算机上可以有很多个服务</p><h2 id="linux通过什么文件修改域名对应的ip"><a href="#linux通过什么文件修改域名对应的ip" class="headerlink" title="linux通过什么文件修改域名对应的ip"></a>linux通过什么文件修改域名对应的ip</h2><p>修改配置文件&#x2F;etc&#x2F;hosts<br>例如：<br>192.168.1.100 example.com<br>10.0.0.1 test.com</p><p>可以用ping命令验证修改是否有效</p><h2 id="怎么修改域名服务器"><a href="#怎么修改域名服务器" class="headerlink" title="怎么修改域名服务器"></a>怎么修改域名服务器</h2><p>修改&#x2F;etc&#x2F;resolv.conf配置文件<br>使用nameserver关键字指定DNS服务器的IP地址，每行一个。例如：<br>nameserver 8.8.8.8<br>nameserver 8.8.4.4</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="介绍一下主流操作系统"><a href="#介绍一下主流操作系统" class="headerlink" title="介绍一下主流操作系统"></a>介绍一下主流操作系统</h2><ol><li>Windows<br>开发公司：微软公司<br>最新版本：Windows 11（2021年发布）<br>特点：<br>广泛使用于个人电脑和企业环境。<br>友好的用户界面和丰富的软件生态系统。<br>包含Microsoft Office、Edge浏览器和Cortana等内置应用。<br>强大的硬件兼容性和游戏支持。<br>应用场景：办公、娱乐、游戏、教育。</li><li>macOS<br>开发公司：苹果公司<br>最新版本：macOS Ventura（2023年发布）<br>特点：<br>独特的设计和高效的用户界面。<br>深度集成<strong>苹果生态</strong>系统，如iCloud、iMessage和Siri。<br>强大的图形和视频编辑功能，广泛用于创意行业。<br>基于<strong>Unix</strong>的稳定和安全架构。<br>应用场景：设计、视频编辑、软件开发、日常使用。</li><li>Linux<br>开发者：社区开发，众多发行版（如Ubuntu、Fedora、Debian）<br>特点：<br>开源、自由软件，<strong>高度可定制化</strong>。<br>多种发行版，适用于不同的需求和用户群体。<br>强大的<strong>命令行工具</strong>和服务器管理功能。<br><strong>安全性和稳定性</strong>高，适合开发和服务器环境。<br>应用场景：服务器、开发、教育、科学研究。</li></ol><h2 id="介绍一下Linux下内核态和用户态，为什么要分为内核态和用户态？"><a href="#介绍一下Linux下内核态和用户态，为什么要分为内核态和用户态？" class="headerlink" title="介绍一下Linux下内核态和用户态，为什么要分为内核态和用户态？"></a>介绍一下Linux下内核态和用户态，为什么要分为内核态和用户态？</h2><p>用户态和内核态是操作系统为了保护系统资源和实现权限控制而设计的两种不同的CPU运行级别。用户态（User Mode）是程序运行时的正常状态，而内核态（Kernel Mode）是系统在执行内核代码或响应系统调用时的特权状态。</p><p>用户态与内核态的区别<br>权限：内核态具有执行所有指令和访问所有内存空间的权限，而用户态则受到限制，不能直接访问<strong>内核地址空间</strong>或执行<strong>特权指令</strong>。<br>代码：内核态主要执行操作系统的<strong>内核代码</strong>，如中断处理程序、设备驱动、文件系统等。用户态则主要执行应用程序的代码。<br>资源访问：在用户态下，程序不能直接访问<strong>受保护的系统资源</strong>，如硬件设备、中断、内核数据结构等。在内核态下，程序可以访问这些资源。</p><h2 id="用户态和内核态如何切换"><a href="#用户态和内核态如何切换" class="headerlink" title="用户态和内核态如何切换"></a>用户态和内核态如何切换</h2><p>切换场景：<br>系统调用、异常、外部中断<br>系统调用（System Call）：当用户程序需要请求操作系统提供的服务时，会通过系统调用进入内核态。系统调用会触发一个特殊的中断，将CPU从用户态切换到内核态。在内核态下，操作系统会执行相应的服务例程，完成请求后，再通过中断返回指令将CPU切换回用户态。<br>异常（Exception）：当程序执行过程中出现错误或异常情况（如除以零、非法指令、缺页等）时，CPU会自动切换到内核态，以便操作系统能够处理这些异常。<br>外部中断（External Interrupt）：外部设备（如键盘、鼠标、磁盘等）产生的中断信号会使CPU从用户态切换到内核态。操作系统会处理这些中断，执行相应的中断处理程序，然后再将CPU切换回用户态。</p><p>切换的时候会先保存<strong>处理器状态</strong>与<strong>错误信息</strong>至<strong>状态寄存器</strong>，主要保存4个东西，异常触发的<strong>指令地址PC</strong>,异常的<strong>原因</strong>，当前CPU的<strong>栈指针SP</strong>。当发生用户态到内核态的切换时，CPU会先获取<strong>异常向量表</strong>，然后根据异常的原因来调用相应的<strong>异常处理函数</strong>。异常处理完成后，会<strong>恢复应用储蓄的现场</strong>，恢复PC与SP指针，并切换回用户态。</p><h2 id="介绍进程线程协程"><a href="#介绍进程线程协程" class="headerlink" title="介绍进程线程协程"></a>介绍进程线程协程</h2><p>详见博客</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>四个条件：<br>不可剥夺（破坏方法：进程不能获得所需要的全部资源时他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用）<br>互斥（资源特性，无法改变）<br>循环等待（资源按顺序编号，将紧缺的稀少的排在后面<br>请求和保持（申请时不占用系统资源，或者静态分配一开始全部申请过来</p><p>破坏死锁四个条件是乐观锁（死锁预防）<br>死锁避免是悲观锁（动态分配，安全状态和不安全状态，如果分配后会进入不安全状态则不予分配）</p><h2 id="cache是什么？为什么要用cache"><a href="#cache是什么？为什么要用cache" class="headerlink" title="cache是什么？为什么要用cache"></a>cache是什么？为什么要用cache</h2><p>CPU缓存（Cache）是一种位于CPU与主内存（RAM）之间的高速存储器，用于存储近期访问过的数据和指令。CPU缓存的设计目的是为了减少CPU访问主内存所需的时间，提高处理器的性能。因为缓存的访问速度比主内存快得多，所以当CPU需要访问某个数据时，如果数据已经在缓存中，那么CPU可以更快地获取它。</p><p>CPU分为三级缓存。<br>L1、L2、L3，L2在L1未命中的情形下提供较大的数据与指令缓存空间，L3在L2未命中的情形下提供，，，</p><p>直接映射缓存：每个主内存块只能映射到缓存的一个固定位置。这种方式实现简单，但可能导致缓存冲突。<br>全相联映射缓存：每个主内存块可以映射到缓存的任何位置。这种方式可以降低缓存冲突的可能性，但实现起来较为复杂，同时搜索缓存的速度相对较慢。<br>组相联映射缓存：这是直接映射缓存和全相联映射缓存的折衷方案。缓存被划分为多个组，每个主内存块可以映射到特定组中的任何位置。这种方式在降低缓存冲突和提高查找速度方面都表现得较好。</p><p>缓存替换策略</p><p>当缓存已满，且需要存储新的数据或指令时，缓存替换策略决定了哪些数据或指令应该被替换。常见的替换策略有：</p><p>随机替换：从缓存中随机选择一个条目进行替换。这种策略实现简单，但可能导致频繁使用的数据被替换。<br>最近最少使用（LRU）：替换缓存中最久未使用的数据或指令。这种策略依赖局部性原理，试图保留最近访问过的数据。实现起来相对复杂，但在许多情况下性能较好。<br>最不经常使用（LFU）：替换缓存中使用频率最低的数据或指令。这种策略试图保留访问次数较多的数据，但需要跟踪每个缓存条目的访问计数，实现相对复杂。<br>先进先出（FIFO）：替换缓存中最早进入的数据或指令。这种策略实现简单，但可能导致频繁使用的数据被替换。</p><h2 id="Linux硬链接软链接区别"><a href="#Linux硬链接软链接区别" class="headerlink" title="Linux硬链接软链接区别"></a>Linux硬链接软链接区别</h2><p>硬链接（hard link）和符号链接（symbolic link，也称为软链接）是Unix和类Unix文件系统中两种不同的文件链接类型。它们用于创建文件或目录的引用。</p><p>硬链接</p><p>硬链接是文件系统中一个文件的额外引用。在Unix和类Unix文件系统中，每个文件都有一个称为inode的数据结构来存储文件的元数据，例如文件权限、所有者、大小等。每个文件都有一个或多个文件名（硬链接），它们指向相应的inode。换句话说，<strong>硬链接是文件名和inode之间的关联</strong>。</p><p>硬链接的特点如下：</p><p>硬链接<strong>不能跨文件系统</strong>。由于硬链接直接关联到inode，它只能在同一个文件系统中创建。<br>硬链接<strong>不能引用目录</strong>。这是为了防止文件系统中出现循环引用和其他不一致性问题。<br>删除一个文件的所有硬链接会导致文件被删除。<strong>当一个文件的最后一个硬链接被删除时，文件系统将释放该文件的inode以及占用的存储空间</strong>。<br>硬链接不影响原始文件的访问。所有硬链接都指向相同的inode，<strong>因此访问任何一个硬链接实际上是访问原始文件</strong>。<br>符号链接</p><p>符号链接是一种特殊的文件，它包含指向另一个文件或目录的路径。与硬链接直接关联到inode不同，符号链接通过路径名来引用目标文件。当用户或应用程序访问符号链接时，文件系统会自动将其重定向到目标路径。</p><p>符号链接的特点如下：</p><p>符号链接<strong>可以跨文件系统</strong>。由于符号链接通过路径名引用目标文件，它可以链接到其他文件系统中的文件或目录。<br>符号链接<strong>可以引用目录</strong>。这使得符号链接在文件系统组织和目录结构管理中非常有用。<br>删除符号链接不会影响目标文件。当删除一个符号链接时，<strong>只有链接本身被删除，而目标文件保持不变</strong>。<br>符号链接可能引起死链接（dangling link）。如果目标文件被删除或移动，符号链接将指向一个不存在的路径，导致死链接。</p><h2 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><p>问这个就是在问select poll epoll区别</p><h3 id="为什么数据库连接池不采用io多路复用"><a href="#为什么数据库连接池不采用io多路复用" class="headerlink" title="为什么数据库连接池不采用io多路复用"></a>为什么数据库连接池不采用io多路复用</h3><p>一、什么是数据库连接池<br>数据库连接池是一种常见的技术，旨在通过维护一组预先建立的数据库连接，以减少应用程序与数据库服务器之间的连接和断开开销。数据库连接池的目标是提高应用程序的性能和响应速度，以及减少数据库服务器的负载。</p><p>二、为什么数据库连接池不采用IO多路复用<br>虽然IO多路复用是一种高效的网络编程技术，但它在数据库连接池中并不常被采用。以下是一些原因：</p><p>1.阻塞调用<br>数据库操作通常是<strong>阻塞式</strong>的，也就是说，在查询执行完成之前，应用程序会一直等待结果返回。使用IO多路复用在这种情况下并不会带来明显的优势，因为无论如何应用程序仍然需要等待结果。</p><p>IO多路复用更适用于<strong>非阻塞式</strong>操作，其中应用程序可以继续处理其他任务而不必等待结果。使用IO多路复用可能并不能提高数据库操作的效率。</p><p>2.连接管理<br>数据库连接池负责管理连接的生命周期，包括连接的创建、维护和释放。连接的创建和释放通常涉及到一些额外的操作，例如身份验证、资源分配和清理等。这些操作通常需要使用阻塞式调用，无法与IO多路复用结合使用。</p><p>采用IO多路复用可能会导致连接管理复杂化，增加了实现的复杂性和错误处理的难度。</p><p>3.数据库连接的状态<br>数据库连接通常需要<strong>维护一些状态信息，例如事务状态、游标位置</strong>等。这些状态信息在连接生命周期内是<strong>特定于连接</strong>的，并且不能简单地在不同的IO复用事件之间共享。</p><p>使用IO多路复用可能需要<strong>引入更多的同步机制和上下文切换</strong>，从而降低性能和增加复杂性。</p><p>4.连接池稳定性<br>数据库连接池是一个关键的基础设施组件，对于应用程序的可用性和性能至关重要。采用IO多路复用可能会增加连接池的复杂性和风险。</p><p>IO多路复用本身是一种复杂的技术，需要细致的管理和错误处理。据库操作包括查询解析、数据读取、事务处理等多个步骤；错误的实现可能导致连接泄漏、资源竞争和不稳定的行为，从而影响整个应用程序的稳定性。</p><p>5.事务处理的支持<br>数据库连接需要支持事务处理，确保数据的完整性和一致性。</p><p>然而，IO多路复用不能保证数据的原子性，因此在处理事务时并不适合使用。</p><p>三、总结<br>尽管IO多路复用在网络编程中是一个重要的技术，但由于数据库连接的特殊需求，例如保持连接状态、支持事务处理，以及数据库操作的阻塞性等，数据库连接池通常不采用IO多路复用技术。</p><p>虽然IO多路复用是一种高效的网络编程技术，但在数据库连接池中往往不被广泛采用。数据库连接池更适合使用传统的阻塞式调用，以便更好地管理连接的生命周期和状态，并提供稳定和可靠的连接池功能。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL搜索引擎"><a href="#MySQL搜索引擎" class="headerlink" title="MySQL搜索引擎"></a>MySQL搜索引擎</h2><h2 id="innodb和myisam区别"><a href="#innodb和myisam区别" class="headerlink" title="innodb和myisam区别"></a>innodb和myisam区别</h2><h2 id="b树-b-树"><a href="#b树-b-树" class="headerlink" title="b树 b+树"></a>b树 b+树</h2><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h2 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redis sds底层数据结构</title>
    <link href="/2024/07/04/sds%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/07/04/sds%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/wangshuai6707/article/details/131101404">csdn：sds详解</a><br>这是原版的sds</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sds</span>&#123;<br><span class="hljs-type">int</span> len; <span class="hljs-comment">//buf数组中已占用的字节数量</span><br><span class="hljs-type">int</span> free; <span class="hljs-comment">//记录buf数组中未使用字节的数量</span><br><span class="hljs-type">char</span> buf[]; <span class="hljs-comment">//字符数组，用于保存字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>改进版的sds：<br>Redis 6.0中的SDS仍然包含三个成员变量len、free和buf，但是buf不再是一个字符数组，而是一个unsigned char类型的数组。此外，在Redis 6.0中新增了四个SDS类：sdsHdr5、sdsHdr8、sdsHdr16和sdsHdr32。这四个类分别代表SDS字符串的头部数据结构，用于存储SDS字符串的长度和空闲空间，以及标记SDS字符串的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">__attribute__</span> ((__packed__)) sdshdr8 &#123;<br>    <span class="hljs-type">uint8_t</span> len;     <span class="hljs-comment">// 已使用的长度</span><br>    <span class="hljs-type">uint8_t</span> alloc;   <span class="hljs-comment">// 分配的总长度（不包括空终止符）</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">// 类型标志</span><br>    <span class="hljs-type">char</span> buf[];      <span class="hljs-comment">// 实际存储字符串的字符数组</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>len属性可以使sds做到常数时间复杂度内读取长度。</p><p>在 SDS 中，alloc 字段的值通常根据需要动态分配和调整。为了优化性能并减少频繁的内存分配操作，SDS 采用了一些预分配和惰性释放的策略。具体来说，当需要扩展内存时，SDS 会预分配比实际需要更多的内存，以减少未来的内存分配操作。</p><p>预分配策略<br>小字符串的预分配：对于长度小于1MB的字符串，SDS 每次扩展时会将分配的内存空间翻倍，以便有足够的预留空间。例如，如果当前字符串长度是50字节，需要扩展到60字节，SDS 可能会将内存空间扩展到100字节。<br>大字符串的预分配：对于长度大于等于1MB的字符串，SDS 每次扩展时会多分配1MB的空间。这种策略适用于非常大的字符串，可以有效减少内存分配的次数。</p><p>SDS的总体结构包括头部sdshdr和存储用户数据的buf，其中用户数据后总跟着一个\0。SDS有四种不同的头部，分别是sdshdr8、sdshdr16、sdshdr32和sdshdr64，其中len属性表示字符串长度，buf[]数组用来保存字符串的每个元素，alloc属性表示整个SDS除过头部与末尾的\0之后，剩余的字节数，flags始终为一字节，以低三位标识着头部的类型，高5位未使用。</p><h3 id="string优势"><a href="#string优势" class="headerlink" title="string优势"></a>string优势</h3><ol><li>动态扩容<br>SDS可以动态增加内存空间，避免了静态数组的大小限制。</li><li>常数复杂度获取字符串长度<br>SDS中的len属性表示字符串长度，可以在常数时间内获取字符串长度。</li><li>杜绝缓冲区溢出<br>SDS会检查内存是否足够，避免了缓冲区溢出的问题。<br>缓冲区溢出（Buffer Overflow）是一种常见的计算机安全漏洞和编程错误。当程序试图向缓冲区（如数组或内存块）中写入超出其容量的数据时，会导致缓冲区溢出。这种溢出会覆盖相邻的内存区域，从而引发各种潜在的严重问题，包括程序崩溃、数据损坏和安全漏洞。</li></ol><p>缓冲区是一个固定大小的内存空间，用于临时存储数据。当数据超过缓冲区的容量时，剩余的数据会写入到缓冲区之外的内存区域，覆盖本不应被修改的数据。这种行为可能会导致以下几种问题：</p><p><strong>程序崩溃</strong>：覆盖了关键数据或代码，导致程序异常终止。<br><strong>数据损坏</strong>：合法数据被覆盖，导致数据不一致或数据丢失。<br><strong>安全漏洞</strong>：攻击者可以利用缓冲区溢出覆盖函数返回地址或其他关键控制信息，从而执行任意代码或取得系统控制权。</p><p>以下是一个简单的 C 语言示例，演示了缓冲区溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vulnerable_function</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *input)</span> &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 定义一个大小为10的缓冲区</span><br>    <span class="hljs-built_in">strcpy</span>(buffer, input); <span class="hljs-comment">// 将输入拷贝到缓冲区中</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Buffer content: %s\n&quot;</span>, buffer);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *large_input = <span class="hljs-string">&quot;This is a very long input string that will overflow the buffer.&quot;</span>;<br>    vulnerable_function(large_input); <span class="hljs-comment">// 调用存在缓冲区溢出的函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>buffer</code> 大小为 10 字节，而 <code>input</code> 字符串远大于 10 字节。当 <code>strcpy</code> 函数将 <code>input</code> 拷贝到 <code>buffer</code> 时，会导致缓冲区溢出，覆盖缓冲区后面的内存区域，可能导致程序崩溃或其他意想不到的行为。</p><ol start="4"><li>减少修改字符串的内存重新分配次数<br>SDS采用惰性空间释放和空间预分配的策略，可以减少修改字符串的内存重新分配次数。</li><li>二进制安全<br>不以‘\0’来判断字符串是否结束，而是以len属性表示的长度来判断字符串是否结束，所以支持存储任何二进制数据。（因为二进制数据中有很多\0</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>其实感觉家里人也挺可爱的</title>
    <link href="/2024/06/23/%E5%88%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E5%8F%97%EF%BC%81/"/>
    <url>/2024/06/23/%E5%88%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E5%8F%97%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>怎么感觉我是一个完全割裂的人哈哈哈哈</p><p>这是前几天写下的句子：</p><blockquote><p>一回到家就被铺天盖地地催考公了，，我觉得我连自己家的钥匙都没有（可能就是因为总是拿不到对自己的控制权所以干脆摆烂放弃了吧 别人想着旅行 很神奇的是我自己却连一点欲望都没有。<br>也许工作这方面真的要先斩后奏吧 又被念叨说什么结婚生子之类的事情了 可是我一回家就被说长发很丑，，被各种挑剔 一不听话就被摆脸色<br>虽然我很爱你们 我觉得你们也很爱我 可是我想我们可能都不知道爱是什么吧<br>我想我们可能只是不知道什么是爱。我们可能没有余力去爱，我们是分裂又扭曲的爱。<br>很奇怪，，在宿舍里的感受竟然比在家里的感受更好，想宿舍的姐妹了，打算早点回去吧 难道这是我长大的迹象吗？我居然有了自己的想法 干着其他人可能从初高中就开始干的事 我第一次想要 我不想放弃一切可能性 可能在上学期我还是这样的人 可是一旦被夸后（想要被真心实意的夸奖 我觉得夸奖的力量真的胜于其他的任何一切。我不想被买断人生 我想要想做什么就随心所欲地做 想辞职就辞职 我也不想生个小孩绑架他一定要怎么样 至少我不会贬低他 而不是被金钱买断人生 我想要被爱</p></blockquote><p>这几天都在外婆家学做饭（感觉做饭好简单 最难的就是预处理了 发现自己已经有力气切冻硬的生肉了<br>中午做了冬瓜 血蛤 长豆 至少现在已经不怕火了</p><p>感觉网上都对自己的亲戚深恶痛绝（？ 但是实际上我觉得他们也挺可爱的 （比如吃饭的时候大人在外放抖音 小孩子悄咪咪凑过去被挨一顿训 说饭桌上不许玩手机要好好吃饭！（当然小孩子自己肯定不开心哈哈哈哈哈</p><p>很久没见到那两个双胞胎妹妹了 但是比起因为别人说的话感到伤心 更伤心的是那种疏远感（上次见到还往舅妈身后躲一下 不过他们家的分工带娃方式也刚好导致了 指小孩上初中的时候由我妈“提携” 然后很小的时候是外婆抚养 那两个双胞胎大的归舅妈养 小的归外婆养（现在统一由舅妈抚养） （怎么感觉形成一条产业链了哈哈哈</p><p>昨天被舅妈很兴奋地提了一堆问题（你能想象全家人联合其他人一起劝我考公的场面嘛） 然后今天外婆就悄咪咪跟我说 下次她问你你不要说这么多！然后又补一句你不许说是我说的</p><p>因为小时候都是外婆带的 所以来他们家会比较伤心（觉得原本属于自己的家已经不是自己的了，也很久没去他们家吃饭了 不过自从舅舅家有新家过后老家变得安静了许多（好耶</p><p>小弟弟也挺可爱的，，还凑过来对我说悄悄话（可惜我重度耳背哇哇哇 戴耳机戴久了导致的）我说我要回去睡觉了（其实是追番）他还恋恋不舍地说我们家也有床哩（哎呀珍惜吧！以后大了就不一定这么可爱了 昨天去他们家做饭 他领着我介绍了一遍整个家的布局（哈哈其实我比你更熟啊喂 我在这待的时间可比你长</p><p>我希望人是向善的，，而且我们家父母都是那一辈的年长的人 也算混得比较好的一批 所以对后辈弟弟妹妹都有或多或少的提携和帮助，，爸爸叔叔相互扶持 妈妈舅舅更是直接住得非常近</p><p>我都不敢想象以后要是出现了子宫工厂这个世界会怎么办，，至少社会主义国家应该不会到那一天的吧</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>刚回家的感想</title>
    <link href="/2024/06/22/%E5%88%9A%E5%9B%9E%E5%AE%B6%E7%9A%84%E6%84%9F%E6%83%B3/"/>
    <url>/2024/06/22/%E5%88%9A%E5%9B%9E%E5%AE%B6%E7%9A%84%E6%84%9F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>一回到家就被铺天盖地地催考公了，，我觉得我连自己家的钥匙都没有（可能就是因为总是拿不到对自己的控制权所以干脆摆烂放弃了吧 别人想着旅行 很神奇的是我自己却连一点欲望都没有。</p><p>也许工作这方面真的要先斩后奏吧 又被念叨说什么结婚生子之类的事情了 可是我一回家就被说长发很丑，，被各种挑剔 一不听话就被摆脸色</p><p>虽然我很爱你们 我觉得你们也很爱我 可是我想我们可能都不知道爱是什么吧</p><p>我想我们可能只是不知道什么是爱。我们可能没有余力去爱，我们是分裂又扭曲的爱。</p><p>很奇怪，，在宿舍里的感受竟然比在家里的感受更好，想宿舍的姐妹了，打算早点回去吧 难道这是我长大的迹象吗？我居然有了自己的想法 干着其他人可能从初高中就开始干的事 我第一次想要 我不想放弃一切可能性 可能在上学期我还是这样的人 可是一旦被夸后（想要被真心实意的夸奖 我觉得夸奖的力量真的胜于其他的任何一切。我不想被买断人生 我想要想做什么就随心所欲地做 想辞职就辞职 我也不想生个小孩绑架他一定要怎么样 至少我不会贬低他 而不是被金钱买断人生 我想要被爱</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sql语句书写</title>
    <link href="/2024/06/18/sql%E8%AF%AD%E5%8F%A5%E4%B9%A6%E5%86%99/"/>
    <url>/2024/06/18/sql%E8%AF%AD%E5%8F%A5%E4%B9%A6%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="clj作业SQJ订单表"><a href="#clj作业SQJ订单表" class="headerlink" title="clj作业SQJ订单表"></a>clj作业SQJ订单表</h1><h2 id="每项工程使用红色零件总金额"><a href="#每项工程使用红色零件总金额" class="headerlink" title="每项工程使用红色零件总金额"></a>每项工程使用红色零件总金额</h2><blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>按零件数量总和的降序列出每项工程所使用的每种红色零件的总的金额（工程可以向不同的供应商购买同一零件，总金额＝单价*供货数量）。输出工程号、零件号、总金额。</p></blockquote><p>样例输出：</p><table><thead><tr><th>jno</th><th>pno</th><th>sum_money</th></tr></thead><tbody><tr><td>J4</td><td>P1</td><td>73000</td></tr><tr><td>J4</td><td>P4</td><td>22400</td></tr></tbody></table><p>依然是使用聚集函数（不要忘了group by，这里直接写两列就可以了</p><p>一开始遇到的问题是ambiguous列名，解决措施是注明这个列是来自哪张表的</p><p>left join的原因和上一题同理</p><p>ORDER BY可以实现升&#x2F;降序，ASC为升序，DESC为降序，格式为order by 列名 asc&#x2F;desc, 列名 asc&#x2F;desc,…（按排序关键字顺序书写，前面的关键字优先看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> J.JNO,P.PNO,<span class="hljs-built_in">SUM</span>(QTY<span class="hljs-operator">*</span>PRICE)<br><span class="hljs-keyword">FROM</span> J <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span> J.JNO<span class="hljs-operator">=</span>SPJ.JNO<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> P <span class="hljs-keyword">ON</span> P.PNO<span class="hljs-operator">=</span>SPJ.PNO<br><span class="hljs-keyword">WHERE</span> P.COLOR <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;红色&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> JNO,PNO<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">SUM</span>(QTY) <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><h2 id="求供应了所有零件的供应商"><a href="#求供应了所有零件的供应商" class="headerlink" title="求供应了所有零件的供应商"></a>求供应了所有零件的供应商</h2><p>先复习一下关系代数里面的除法</p><p>学生表R：</p><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th><th>院系</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>19</td><td>计算机</td></tr></tbody></table><p>除数S1：</p><table><thead><tr><th>年龄</th></tr></thead><tbody><tr><td>19</td></tr></tbody></table><p>R÷S1&#x3D;学生表中年龄为19的学生信息的新表格，但这个新表格中的字段不包括年龄。</p><p>即：</p><table><thead><tr><th>学号</th><th>姓名</th><th>院系</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>计算机</td></tr></tbody></table><p>所以除法结果就是在被除表中，同时满足除数表的所有条件，但没有除数表中的字段的新表（如果结果有多条记录要全部列出）。</p><p>言归正传，由于评测台的版本过于老，所以不支持except，只能搞where not exists嵌套</p><p>所以不妨来绕一下，供应了所有零件 &#x3D; 不存在一个零件，它不在该供应商的供应零件集中，具体推导可以看下面图片<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9B%9E%E6%83%B3%E8%B5%B7%E8%A2%AB%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%94%AF%E9%85%8D%E7%9A%84%E6%81%90%E6%83%A7.jpg" alt="回想起被数理逻辑支配的恐惧"></p><p>一开始最里面的嵌套是用where not in写的，但是问了gpt之后说这样会导致一些空值的情况，所以最好还是用where not exists</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SNAME<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> P<br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">FROM</span> SPJ<br>        <span class="hljs-keyword">WHERE</span> SPJ.SNO <span class="hljs-operator">=</span> S.SNO<br>        <span class="hljs-keyword">AND</span> SPJ.PNO <span class="hljs-operator">=</span> P.PNO<br>    )<br>)<br></code></pre></td></tr></table></figure><p>SELECT 1是性能问题，它使得只要找到一条记录就返回结果。当然如果是为了考试的话用SELECT *也没有任何问题</p><p>可以将这段代码的执行思想类比为一个嵌套的循环，其中外部循环是对供应商的循环，内部循环是对零件的循环。这种思想类似于控制变量的概念，即在外部循环中保持一个变量不变（当前供应商），而在内部循环中迭代另一个变量（零件）。</p><ol><li>外部的 SELECT SNAME FROM S … 查询遍历供应商表 S 中的每个供应商。</li><li>对于每个供应商，内部的子查询开始执行。这个子查询对零件表 P 中的每个零件进行循环（通过 NOT EXISTS 子句），并检查是否存在至少一条记录，表示当前供应商供应该零件。如果不存在这样的记录，表示当前供应商缺少供应的零件。</li><li>如果对于当前供应商不存在任何缺少供应的零件，即内部子查询返回空结果集，那么外部的 NOT EXISTS 就会返回 TRUE，表示当前供应商满足条件。</li><li>如果对于当前供应商存在至少一种缺少供应的零件，那么外部的 NOT EXISTS 就会返回 FALSE，表示当前供应商不满足条件。</li></ol><p>这种查询的执行方式确实类似于使用嵌套的循环来检查每个供应商是否满足条件。这样的查询结构有助于控制变量，以确保每个供应商都经过了正确的检查，而不会在内部循环中受到外部循环的影响（省流，类似于for循环控制外层变量在内层循环中不变，这样就能保证最内层的循环查找的一定是同一个供应商的供货记录</p><p>最外层的表是S，中间的是P，最内层的是SPJ</p><h2 id="只向与自己不同城市工程供应"><a href="#只向与自己不同城市工程供应" class="headerlink" title="只向与自己不同城市工程供应"></a>只向与自己不同城市工程供应</h2><blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>求只向与自己位于不同城市的工程供应零件的供应商姓名。</p></blockquote><p>首先，这个供应商不能是什么零件都没有供应，所以以SPJ为主表进行left join</p><p>注意这个left join的格式必须是某某表LEFT JOIN 另一个表 ON 一些条件！！！</p><p>如果要连续left join的话另起一行就可以</p><p>WHERE NOT IN的格式也要注意！是WHERE 某一列 NOT IN（括号里面套娃select）</p><p>讲完了格式讲一下这道题的思路，大体上就是首先，这个供应商必须供应了零件，所以以spj为主表，然后，（判断推理的思路！）“只向与自己位于不同城市供应了零件”的反面是“向与自己位于相同城市的工程供应过零件”（在sql查询中，这个“过”非常重要，“只”相对难办）于是我们求出“向与自己位于相同城市的工程供应过零件”再not in一下就好了！</p><p>放代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME<br><span class="hljs-keyword">FROM</span> SPJ <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> S <span class="hljs-keyword">ON</span> SPJ.SNO<span class="hljs-operator">=</span>S.SNO<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> J <span class="hljs-keyword">ON</span> SPJ.JNO<span class="hljs-operator">=</span>J.JNO<br><span class="hljs-keyword">WHERE</span> S.SNAME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span>(<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME<br>    <span class="hljs-keyword">FROM</span> SPJ <br>    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> S <span class="hljs-keyword">ON</span> SPJ.SNO<span class="hljs-operator">=</span>S.SNO    <br>    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> J <span class="hljs-keyword">ON</span> SPJ.JNO<span class="hljs-operator">=</span>J.JNO<br>    <span class="hljs-keyword">WHERE</span> S.CITY<span class="hljs-operator">=</span>J.CITY<br>)     <br></code></pre></td></tr></table></figure><h2 id="列出每个城市的工程使用零件总量"><a href="#列出每个城市的工程使用零件总量" class="headerlink" title="列出每个城市的工程使用零件总量"></a>列出每个城市的工程使用零件总量</h2><blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>列出每个城市的工程所使用的零件总的数量。</p></blockquote><p>样例输出：</p><table><thead><tr><th>CITY</th><th>sum(QTY)</th></tr></thead><tbody><tr><td>Paris</td><td>800</td></tr><tr><td>Rome</td><td>1200</td></tr></tbody></table><p>这道题用到了聚集函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> CITY,<span class="hljs-built_in">SUM</span>(QTY)<br><span class="hljs-keyword">FROM</span> J <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span>  SPJ.JNO<span class="hljs-operator">=</span>J.JNO<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CITY       <br></code></pre></td></tr></table></figure><p>left join是因为要列出每个城市的工程零件量，但是不排除有些城市可能零件量为零。（每次都忘了写on</p><p>最后要加一行group by 列名（having 条件表达式，不过这题没有涉及所以不用having</p><h1 id="面试搬运-SQL面试五十题"><a href="#面试搬运-SQL面试五十题" class="headerlink" title="面试搬运-SQL面试五十题"></a>面试搬运-SQL面试五十题</h1><p>字号太小了就搬过来了。<br>原地址：<a href="https://blog.csdn.net/qiqi123i/article/details/108455130">https://blog.csdn.net/qiqi123i/article/details/108455130</a></p><ol><li>查询课程编号为“01”的课程比“02”的课程成绩高的所有学生的学号（难）</li><li>查询平均成绩大于60分的学生的学号和平均成绩</li><li>查询所有学生的学号、姓名、选课数、总成绩</li><li>查询姓“猴”的老师的个数</li><li>查询没学过“张三”老师课的学生的学号、姓名</li><li>查询学过“张三”老师所教的所有课的同学的学号、姓名</li><li>查询学过编号为“01”的课程并且也学过编号为“02”的课程的学生的学号、姓名</li><li>查询课程编号为“02”的总成绩</li><li>查询所有课程成绩小于60分的学生的学号、姓名</li><li>查询没有学全所有课的学生的学号、姓名</li><li>查询至少有一门课与学号为“01”的学生所学课程相同的学生的学号和姓名 （难）</li><li>查询和“01”号同学所学课程完全相同的其他同学的学号（难）</li><li>查询没学过”张三”老师讲授的任一门课程的学生姓名 和47题一样</li><li>查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</li><li>检索”01”课程分数小于60，按分数降序排列的学生信息</li><li>按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩(难)</li><li>查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率</li><li>按各科成绩进行排序，并显示排名(难)</li><li>查询学生的总成绩并进行排名</li><li>查询不同老师所教不同课程平均分从高到低显示</li><li>查询所有课程的成绩第2名到第3名的学生信息及该课程成绩（重要 25类似）</li><li>使用分段[100-85],[85-70],[70-60],[&lt;60]来统计各科成绩，分别统计各分数段人数：课程ID和课程名称</li><li>查询学生平均成绩及其名次</li><li>查询各科成绩前三名的记录（不考虑成绩并列情况）</li><li>查询每门课程被选修的学生数</li><li>查询出只有两门课程的全部学生的学号和姓名</li><li>查询男生、女生人数</li><li>查询名字中含有”风”字的学生信息</li><li>查询1990年出生的学生名单</li><li>查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩</li><li>查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列</li><li>查询课程名称为”数学”，且分数低于60的学生姓名和分数</li><li>查询所有学生的课程及分数情况</li><li>查询任何一门课程成绩在70分以上的姓名、课程名称和分数</li><li>查询不及格的课程并按课程号从大到小排列</li><li>查询课程编号为03且课程成绩在80分以上的学生的学号和姓名</li><li>求每门课程的学生人数</li><li>查询选修“张三”老师所授课程的学生中成绩最高的学生姓名及其成绩</li><li>查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 （难）</li><li>查询每门功成绩最好的前两名</li><li>统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</li><li>检索至少选修两门课程的学生学号</li><li>查询选修了全部课程的学生信息</li><li>查询各学生的年龄</li><li>查询没学过“张三”老师讲授的任一门课程的学生姓名</li><li>查询两门以上不及格课程的同学的学号及其平均成绩</li><li>查询本月过生日的学生</li><li>查询下一个月过生日的学生</li></ol><h1 id="SQL测验"><a href="#SQL测验" class="headerlink" title="SQL测验"></a>SQL测验</h1><p>不想成为那个八股背的非常流利但是sql一道都不会写的人于是开始恶补啊啊啊啊啊</p><p>一个选择题测验网站：<a href="https://www.w3school.com.cn/quiz/quiz.asp?quiz=sql">https://www.w3school.com.cn/quiz/quiz.asp?quiz=sql</a></p><p>注：“您的回答”下没有“正确答案”的就是答对了</p><p>1.SQL 指的是？<br>您的回答：Structured Query Language</p><p>2.哪个 SQL 语句用于从数据库中提取数据？<br>您的回答：SELECT</p><p>3.哪条 SQL 语句用于更新数据库中的数据？<br>您的回答：UPDATE</p><p>4.哪条 SQL 语句用于删除数据库中的数据？<br>您的回答：DELETE</p><p>5.哪条 SQL 语句用于在数据库中插入新的数据？<br>您的回答：INSERT INTO</p><p>6.通过 SQL，您如何从 “Persons” 表中选取 “FirstName” 列？<br>您的回答：SELECT FirstName FROM Persons</p><p>7.通过 SQL，您如何从 “Persons” 表中选取所有的列？<br>您的回答：SELECT * FROM Persons</p><p>8.通过 SQL，您如何从 “Persons” 表中选取 “FirstName” 列的值等于”Peter” 的所有记录？<br>您的回答：SELECT * FROM Persons WHERE FirstName&#x3D;’Peter’</p><p>9.通过 SQL，您如何从 “Persons” 表中选取 “FirstName” 列的值以 “a” <strong>开头</strong>的所有记录？<br>您的回答：SELECT * FROM Persons WHERE FirstName LIKE ‘%a’<br><strong>正确答案：SELECT * FROM Persons WHERE FirstName LIKE ‘a%’</strong></p><p>10.请判断下列说法是否正确：当所列出的某个条件为 true 时，OR 运算符会显示记录。当列出的所有条件为 true 时，AND 运算符会显示记录。<br>您的回答：正确</p><p>11.通过 SQL，您如何在表 Persons 中选择 FirstName 等于 Thomas 而 LastName 等于 Carter 的所有记录？<br>您的回答：SELECT * FROM Persons WHERE FirstName&#x3D;’Thomas’ AND LastName&#x3D;’Carter’</p><p>12.通过 SQL，您如何按字母顺序选取 Persons 表中 LastName 介于 Adams 和 Carter 的所有记录？<br>您的回答：SELECT * FROM Persons WHERE LastName&gt;’Adams’ AND LastName&lt;’Carter’<br><strong>正确答案：SELECT * FROM Persons WHERE LastName BETWEEN ‘Adams’ AND ‘Carter’</strong></p><p>13.哪条 SQL 语句可返回唯一不同的值？<br>您的回答：SELECT DISTINCT</p><p>14.哪个 SQL 关键词用于对<strong>结果集</strong>进行排序？<br>您的回答：SORT BY<br><strong>正确答案：ORDER BY</strong></p><p>15.通过 SQL，您如何根据 “FirstName” 列降序地从 “Persons” 表返回所有记录？<br>您的回答：SELECT * FROM Persons ORDER BY FirstName DESC</p><p>16.通过 SQL，您如何向 “Persons” 表插入新的记录？<br>您的回答：INSERT INTO Persons VALUES (‘Jimmy’, ‘Jackson’)</p><p>17.通过 SQL，您如何向 “Persons” 表中的 “LastName” 列插入 “Wilson” ？<br>您的回答：INSERT INTO Persons (LastName) VALUES (‘Wilson’)</p><p>18.您如何把 “Persons” 表中 “LastName” 列的 “Gates” 改为 “Wilson” ？<br>您的回答：UPDATE Persons SET LastName&#x3D;’Wilson’ WHERE LastName&#x3D;’Gates’</p><p>19.通过 SQL，您如何在 “Persons” 表中删除 “FirstName” 等于 “Fred” 的纪录？<br>您的回答：DELETE ROW FirstName&#x3D;’Fred’ FROM Persons<br><strong>正确答案：DELETE FROM Persons WHERE FirstName &#x3D; ‘Fred’</strong></p><p>20.通过 SQL，您如何返回 “Persons” 表中记录的数目？<br>您的回答：SELECT COUNT(*) FROM Persons</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>总线时序图</title>
    <link href="/2024/06/13/%E6%80%BB%E7%BA%BF/"/>
    <url>/2024/06/13/%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>以主模块读一个数据和写一个数据这种最简单的场景为例讲解总线时序图。<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240613143245.png" alt="示意图-读1个数据的传输"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240613143407.png"><br>写数据的过程就是把下面两行砍掉。</p><p><strong>Q1: 主模块怎么会知道该什么时候读呢？</strong></p><p>说实话他不知道。所以他会<strong>在每一个时钟上升沿的时候都会去</strong>问问。（ljl有一个很好的比喻，就是在校门口抓人，我规定读到的那个人必须在11点出来，就算11点以前已经到了也不行，必须十一点整再出来，那么十一点的时候读到的就一定是正确数据。</p><p>同理从模块也不知道什么时候该读所以它会一直采样。</p><p><strong>Q2: 我们怎么知道过几个时钟周期之后应该采样读数据呢（这个是针对设计的时候我们怎么知道要过多久）</strong></p><p>芯片在研发的时候会提前测试，测试一下这条指令执行要多久。比如说在正常情况下要一个时钟周期，不过电脑慢的时候（比如气温过高确实电脑运行速度会变慢）可能要两个。那就设置成等两个时钟周期之后来看看。</p><p>偶尔遇到特殊情况可能10个时钟周期才能读完，但我们不能因为这种很特殊的情况就设成10个时钟周期，拖慢了整体的效率。因此有一行HREADY就是为了解决当主模块发起传输时，从模块却未准备好（无法提供读数据或无法接收写数据）的问题。</p><p>但是我们设定了两个小时之后回来哇，所以尽管还没做好准备，主模块一定会在两个小时之后抓住他遇到的第一个数据并错认为这就是正确数据，所以我要告诉他我还没做好准备。</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240613152340.png"></p><p><strong>Q3：为什么明明是读数据，HWDATA上却有数据呢？</strong></p><p>其实是为了简便。设计方把同一张图用了两遍，实际上读的时候HWDATA上是没有数据的。直接遮住就行。不过就像设计城市道路一样，道路要预先铺好，至于你这次走不走那不关他的事。</p><p><strong>Q4：那个巨大的灰色六边形是什么？</strong><br>因为有一个变化的过程。所以这个时候他的信号并不是很稳定（除了时钟信号以外大部分信号都有一个这样的过程。<br>就拿HADDR为例，他在经历变化的过程之后会有一个白色的六边形，内容是A，这就是他在经历变化之后所形成的稳定值。<br>由于变化过程可能比较长也可能比较短，所以这个六边形持续的时间是不一样的（比如读数据比单纯改变地址要复杂，这个时候六边形持续的时间就会比较长</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Frankenstein</title>
    <link href="/2024/06/13/Frankenstein/"/>
    <url>/2024/06/13/Frankenstein/</url>
    
    <content type="html"><![CDATA[<p>​因为英语课的要求，所以找了一个在线网站匆忙地补了弗兰肯斯坦。在简介发现这是严格意义上第一本科幻小说，所以津津有味地看了起来，虽然自己实际上要回课的内容并不是这一篇小说。</p><p>这是一个​篇幅比较短，非常精妙的作品。我花了一个小时的时间不间断地把它看完，觉得非常震撼。另一方面也是因为自己某段时间对很多事情感到困惑，主动去查询了很多亲子关系方面的知识以及很多心理的成因（我自己小时候也有非常严重的分离焦虑，现在已经因为很多事情的捶打而渐渐的消退，但是我认为我的母亲也有非常严重的分离焦虑症）。</p><p>弗兰肯斯坦是一个对自然科学非常狂热的人，就如同他自己对沃尔特所说：</p><blockquote><p>“疯狂地获取知识有多么危险！随遇而安、服从天命的人比野心勃勃、妄图更大成就的人幸福。”</p></blockquote><blockquote><p>“一个完美的人永远应该保持平静、祥和的心态，永远都不能让一时的热情和一时的冲动破坏内心的平静。”</p></blockquote><p>他因为对名利的贪欲以及对道德的漠视（原著中他对挚友克莱瓦尔对研究道德关系的著作的不理解），从死人骸骨中拼凑出一个失败的耗材。</p><blockquote><p>“I ought to be thy Adam ; but I am rather the fallen angel.”</p></blockquote><p>这是一个孩子对遗弃他的父亲的控诉。弗兰肯斯坦创造了人，滥用神权，破解谜题却无视后果。普罗米修斯草率地创造了人类并给人以火，触犯了神的禁忌（巨人自焚也许就是对火的暗示）。在警示了科学的边界的同时，也体现着对生命的敬畏。</p><p>老师认为弗兰肯斯坦是一个雌雄同体的角色。他首先是一个男性，但是他又像一个母亲一样创造了巨人（尽管他“生而不养”）。他还举了著名的绒布妈妈实验。不过当时我在想的是，弗兰肯斯坦有一对受人敬重且爱他的父母，为什么又会成为一个重度抑郁患者？为什么不能像他的父母那样去养育自己所造出来的“人”？</p><p>令我比较兴奋的是，老师在课后布置的课后作业正是为了回答这一问题。</p><p>弗兰肯斯坦和怪物组成了小说的双线，他诉说了两个看上去大相径庭的情感遗弃故事。维克多对于他父亲（文章中只能看出对父亲的态度因为母亲早逝）的态度也是防御性质的，而怪物恰恰可以视为维克多自我的一面。维克多的童年是受父母保护的和谐童年，他在家中倍受爱戴，父母为了抚养他也非常尽责，但他的“孩子”却被创造者抛弃与漠视。</p><p>弗兰肯斯坦对他父亲的描述中，他似乎是一个公众人物，没有私人的自我，弗兰肯斯坦对他的动词是“敬重”，感觉没有特别强烈的那种“爱”的情感，而是更多出于一种责任。我对这对父子的相处模式非常感兴趣，于是截取了一些关于他的父亲的片段。</p><blockquote><p>“我是日内瓦人，我的家族是当地最有名望的豪门之一。我的祖先们几代以来都是担任政府顾问和市政官，而我父亲已经担任过好几个社会要职，声名显赫。父亲因为他的正直和对公共事务孜孜不倦地关注而倍受人们尊敬，他把自己整个青春时代都用于处理国家事务，因此不断变化的环境一直使他未能成婚，直到他的人生开始走下坡路时，才为人夫和人父。因为父亲的婚姻状况很能显示他的品格，所以我不能不提几句……（家道中落，最真挚的友谊，感到痛惜，朋友家产耗尽，毫无其他经济来源）就在这个时候，我父亲走进了他们的小屋，他就像一个保护神一样来到女孩身边，负起照顾她的责任。在她父亲的葬礼结束后，我父亲把她接到了日内瓦，寄宿在他的一个亲戚那里。两年以后，卡罗琳娜成为了他的妻子。”——CHAPTER 1</p></blockquote><blockquote><p>“六年的时间恍然如梦，留下的只有一条洗刷不掉的痕迹，而我当年离开家，前往英格尔斯塔德的时候，就是站在这儿最后一次拥抱了父亲。我可敬可爱的父亲啊！对我来说，他永远都是这样。我久久凝视着壁炉架上方母亲的肖像，这是按照我父亲的意愿而画成的一件具有纪念意义的作品。在画中，卡罗琳娜·博福特，我的母亲，跪在她父亲的灵柩旁边，悲痛欲绝。她虽然衣着朴素，脸色苍白，但却自有种高贵美丽的气质，并不让人觉得可怜。而这幅画的下方，就是威廉的一幅小肖像。我一看，就不禁泪流满面。”——CHAPTER 7</p></blockquote><p>有评论说，弗兰肯斯坦父亲对他母亲卡罗琳娜的“爱”是“一种感觉”的苍白衍生物，这种情绪充满了责任与工具性。</p><blockquote><p>“如果父亲当时不是这样轻描淡写，而是愿意费一些工夫向我解释——阿格里帕的理论已经被完全推翻，而科学家已经引入一套现代科学体系，要比旧的理论体系强有力得多，因为旧的理论模式只是空中楼阁，而新的理论模式是建立在事实和实证的基础上的——那么，我的好奇心肯定就会得到满足，然后把科纳柳斯·阿格里帕的书扔在一边，既而用更大的热情投入到我原来的研究上。而且如果是这样的话，我的思想甚至根本就不会产生致命的冲动，最后将我引向毁灭。但是我父亲那仓促的一瞥令我感到他根本就不知道书里在说些什么，于是我继续贪婪地埋头阅读这本书。”——CHAPTER 1</p></blockquote><p>温尼科特将母亲对于婴儿的作用分为“客体母亲”与“环境母亲”，客体母亲支持婴儿无所不能的感觉（尿布湿了就有人换，饿了就有奶吃），让婴儿确信婴儿自身存在的真实性，环境母亲是帮助婴儿隔绝外部世界的一层屏障，这是一种过渡领域，但也需要向外部世界提供灵活性以适应其创造力。婴儿的性格取决于孩子形成的最早的关系，如果以足够好的方式回应，就会形成好的性格，如果不承认他的内心世界，而是强加自己版本的现实，抑制婴儿的想象力、欲望、痛苦等自发性情感，那么就不能够形成好的性格。</p><blockquote><p>“我知道我的杳无音讯令他们非常不安，我至今都很清楚地记得我父亲在信里说： “我知道，即使你在那里自得其乐的时候，也仍然会充满深情地想念我们，但是我们也该定期收到你的家信呀。请你一定要原谅我，如果你中断和我们的联络的话，我只能将之视为你连你其他应尽的责任也一概打算视了。”——CHAPTER 4</p></blockquote><blockquote><p>“父亲发现我的性情、和生活习惯发生了巨大变化之后非常痛苦，他时常发自内心地开导我，希望我能够振作精神，鼓起勇气，驱散蒙在我心头的阴云。”维克多，”他说，”难道我心里就不难受吗？没人比我更爱你的弟弟了。”，他流着泪说，”但是，我们对于活着的人来说就没有责任了吗？我们不应该过度悲伤，这样只会增加别人的痛苦。这也是你对自己应尽的责任啊，因为过分忧伤会损害你的健康，让你无法享受生活的乐趣，甚至一蹶不振，不能尽基本的社会义务，这样一来，你对社会还有什么用呢？”父亲的说法虽然言之有理，但是却不符合我的情况。要是我的内心不是如打翻了的五味瓶一般，各种痛苦、恐惧、悲哀，绝望的情感都搅和在一起的话，我可能会第一个把内心的悲哀掩盖起来，并去安慰我的朋友。可是现在，我只能无望地看着我的父亲，并尽量避免在他眼前出现。”——CHAPTER 9</p></blockquote><blockquote><p>“要研究生命的起源，就必须求助于死亡。我已经掌握了解剖学，但这还远远不够，我必须观察尸体自然腐烂的经过。父亲在我幼年时期对我进行教育的时候，总是非常小心，不让我的心灵被任何超自然的恐怖事物所惊吓。我记得我从来都不害怕迷信传说，也不害怕幽灵鬼怪。黑暗不会令我产生任何恐怖的联想，墓地对我来说也只是存放失去了生命的躯壳的地方，那些原本美丽强健的肉体最终会成为蛆虫的美餐。”</p></blockquote><p>对死亡本该有的那些原始的恐惧被系统地禁止与解构。</p><p>截了小说前半部分的很多父子之间的互动，我才发现看似非常和谐的父子关系实际上却令维克多感到回避。还关注到一些除了父子之外的维克多对于别人的看法，比如对于他的妻子： </p><blockquote><p>“每个人都喜欢伊丽莎白，大家对她的爱深沉、强烈，而我对此总会感到无比的自豪和喜悦。在伊丽莎白来我家的前一天晚上，母亲开玩笑地对我说：”我有一件漂亮的礼物要送给我的维克多，明天他就可以拥有了。”第二天，她把伊丽莎白带到了我的面前，说这就是她许诺的那份礼物。而我呢，带着孩子式的认真，真的从字面上理解我妈妈的话，认为伊丽莎白归我所有，将由我来保护她、爱她、珍惜她。我把所有对她的赞美都看成对我个人财产的由衷赞美。我们虽以堂兄妹相称，但是没有任何语言、任何表达法可以描述她和我之间的关系——她对我来说不仅是妹妹，因为她至死都只属于我一个人。”——CHAPTER 1</p></blockquote><p>不过这个口吻令我感到有点奇怪。“个人财产”“拥有”感觉有一点物化妹妹的迹象，但是我倾向于认为他们俩是true love，至少维克多本人对伊丽莎白有着精神上依赖的情感，维克多因为父亲养育造成的影响，对非理性的否认构成了他的整个童年，那他不知如何表达情感便也成为一种很正常且可悲的事了。其实还有相关的片段，在于他认为自己是一个非常可怜的脆弱的人所以觉得他和非常精神平和的象征着精神寄托的伊丽莎白非常相配，当然以现在的恋爱观来看这是一种非常畸形的单方面的倾斜，两人本应该各自美丽而不要牵扯太多的类似救赎，不要把对方看成自己的圣母，也不要想着去拯救对方。</p><p>在知乎里看到一段对其他论文的引用感觉可以更好地解释为什么父亲这种粗暴地否定死亡的意义是不对的。</p><blockquote><p>恐惧虽然有其对他人的骚扰，但对其本身不是没有积极的意义。然而低能懒惰的管理者为了保证控制权的质量，经常施行将恐惧彻底否定的行为。久而久之，那些本来该从恐惧中获取的东西的缺席会对人格形成各种各样的伤害，从而导致个体重新形成了另一种持续的介于怀疑和恐惧之间的焦虑情绪，但因为怀疑和恐惧本身已被否定，这焦虑无法进行任何程度的描述——知道那个人重新可以描述恐惧和怀疑本身开始。</p></blockquote><p>无名之痛其实是无法和意识沟通的，埋藏在潜意识中的情感痛苦。</p><blockquote><p>父亲对母亲简直百依百顺，关怀备至，就像一个园丁保护着奇花异草一般，不让她受一点风寒，并且精心安排她的周围环境，使她温柔、善良的心灵能够焕发出愉悦。虽然母亲的情绪后来始终宁静安详，但她的健康还是因为过去的不幸遭遇而受到损伤。在他们结婚以前的两年之中，父亲陆续辞去了所有的公职。在他们结合之后，他们立即移居到气候宜人的意大利，希望异国的美景和旅行所带来的快乐能够帮助母亲恢复健康。——CHAPTER 1</p></blockquote><p>父亲对母亲倍加呵护的态度其实也是这对父母对这个独子的态度。</p><blockquote><p>从意大利出发，他们又游历了德国和法国，我是他们的长子，出生在那不勒斯，所以我在襁褓里就伴随着他们四处游历。整整好几年间，我都是他们的独子。他们彼此如胶似漆，并且从蕴藏着他们无尽爱意的矿藏中源源不断地向我倾注他们的爱心。母亲的温柔抚爱和父亲慈祥和蔼的笑容，就是他们留给我最早的印象。我是他们的小宝贝，更重要的是，我是他们的孩子，是上天赐予他们的无辜而且无助的生命。我需要他们养育，而我的未来也牵系在他们手中，他们是将我引向幸福、还是苦难，就看他们如何履行对我的职责了。他们非常清醒地意识到，他们赐予了我生命，并对我负有完全的责任，再加上他们本来就都是充满爱心和柔情的人，所以可以想见，我婴儿时期的每时每刻都耳濡目染在耐心、仁慈、自制的氛围中。我就像被一条绸带牵引着，一路上都是无尽的幸福和快乐。</p></blockquote><p>每时每刻都耳濡目染在耐心、仁慈、自制的氛围中，感觉这个孩子不像是孩子，倒像是父母的玩物。虽然我们家的实际情况也差不多，我妈经常说出类似“生个孩子玩玩”之类的话，我也很同意她的观点，决定以后无聊的时候也生个玩玩，这个观念居然也是错的！那得品行多么高尚的人才有资格做父母啊！我还是不要对自己这么苛求了（雾）。</p><p>【论文对此段文字的观点是时时刻刻让婴儿耳濡目染着自制，这损害了婴儿的独立性。但我偏向于认为这只是对他们家庭氛围的一种叙述，不是他的爸爸妈妈时刻在耳朵旁嚼舌根，所以我不同意论文在此处的观点。】</p><p>言归正传，约翰·马丁阐明了四种不同类型的养育方式，从文章看来，弗兰肯斯坦家庭的养育方式应该属于放纵型（没有要求，有求必应）。这类家长照顾孩子的每一个需求，顺应孩子的每一个请求。他们不愿意制定规则，也不提出期望，因此没有规训的基础或需要。他们会提醒，会唠叨，但很少落实口头威胁并采取行动。他们经常妥协，不会说“不”，即便扬言惩罚，也并不会真正实施，他们觉得孩子不会犯错误。他们希望讨得孩子的欢心，表现得更像是孩子的朋友，而不是父母。有些人表面上随时都在孩子身边，但并没有参与孩子实际在做的事情。放纵型父母往往比其他类型的父母富裕，受教育程度更高。</p><p><img src="/../img/%E6%97%A0%E5%90%8D%E4%B9%8B%E7%97%9B/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240312095717.png" alt="四种养育方式"></p><p>放任型的教育方式一定正确吗？它会导致什么样的后果？我在知乎上找到了相关的回答。回答太长了，所以我概括了一下。</p><p>尽管在我们的文化中，这些类型的父母被描绘为可爱而古怪的。放纵型父母的教育方式可以被看作采取最不容易遭到抵抗的方式。往好里说，他们只是希望他们的孩子能够快乐。往坏了想，他们根本不想做教育子女的工作。不管是哪一种，他们没有给孩子建立任何限制、规则，或在孩子青春期时可供叛逆的强有力的成年人形象。要说“不”可是很花力气的。强迫一个孩子做一件杂事或任务是很累人的。跟一个愤怒的孩子交谈、相处也是很费事的。因为对孩子说“不”，而被你的孩子讨厌，哪怕只是暂时的，也是非常痛苦的。放纵型父母觉得与其教孩子做家务还不如自己做来得轻松。当孩子惹麻烦的时候，他们也经常给孩子找别的理由来当借口。</p><p>当孩子长大后回顾往事，他也许会怪自己不懂事——他青春期时父母就完全没管过他，他以为这样他们就对他没有任何影响了，不管是正面的影响还是负面的，所以除了自己，他还能怪谁呢？他意识不到他缺席的爸爸和心事重重的妈妈都没有付出一点时间和精力来教育他。</p><p>青少年天性渴望自由，他们正处于建立自己独特的同一性的阶段，也期望与父母分离。但重要的是虽然青少年渴望自由，但毫无约束对他们无益。青少年需要一个可以与之对抗的强大的父母。他们在与父母的规则和违反规则的后果的冲突中学习如何做出好的决定和如何管理他们的冲动。不幸的是放纵型家庭的孩子往往没有这一切。放纵型的教育还有另一个缺陷:孩子得不到父母足够的反馈，他得为自己负责，找到他对自己的期待:他擅长什么，他的弱点是什么，他应该争取什么。</p><p>（查了那么多理论之后开始发牢骚：感觉养好一个孩子真是一件麻烦且复杂的事）</p><p>所以我恍然大悟，这就是为什么弗兰肯斯坦从头到尾都非常敬重自己的父母，即便他们在精神层面是缺失的，也依然认为他们尽了养育的职责。</p><blockquote><p>每当我回忆自己孩提时代的时候，总是觉得无以言表的快乐。可惜此后，不幸就开始玷污我的心灵，把我原本大有作为的光明前程断送在阴暗、狭隘的自我中心里。此外，在叙述我早年的经历的时候，我也要提及一些事情，这些事情后来一步步地，不知不觉地把我引向苦难的深渊。因为当我发现那些可怕的、宿命般的狂热刚刚在我内心升腾起来的时候，那种狂热还只是像山涧里的溪水，断断续续，时隐时现，可是慢慢到最后，它就变成汹涌澎湃滔滔大河，将我所有的快乐和希望都冲得无影无踪。</p></blockquote><p>弗兰肯斯坦是一个天才，但是他在年少时缺乏引导，这也间接地促使他走上了歧路。他不知道什么是对，什么是错，所有的对错都是他自己定义的。他缺乏一个严厉且权威的父亲给他树立规则，原本处于一个溺爱环境的他导致他无法融入集体生活。这在后面也有体现。</p><blockquote><p>我父亲并没有很高的科学素养，所以没有人可以引导我走出孩子式的盲目，并把我作为一个学生对知识的渴求善加利用。于是在我的新导师的指导下，我全身心地投入到对水晶球和长生不老药的研究上，而且后者很快就吸引了我全部的注意力。对我来说，财富是次要的，但是如果我能够使人类免除疾病，并且使人类除了死亡之外，能够对任何伤害刀枪不入的话，那么，这将是多么了不起的成就啊！</p></blockquote><blockquote><p>我钻进即将载我远行的马车，心头泛起最伤感的情怀。我一直以来都生活在亲人和朋友中间，尽力使彼此都体会到亲情和友情的快乐。可现在我是一个人了。在我将去就读的大学里，我必须寻找新的朋友，自己保护自己。在此之前，我的生活一直远离人群，大多数时间都是呆在家里，这使得我非常不习惯和陌生面孔的相处。我爱我的兄弟、伊丽莎白，和克莱瓦尔，这些是我”熟悉的老面孔”，但是我相信自己完全和陌生人合不来。</p></blockquote><blockquote><p>父亲后来在来信中并没有进一步责怪我，而只是把我的沉默理解为我比往日更加投入在学业上。冬天、春天、夏天，时光就在我的辛劳中从身边滑过，但是我没有欣赏到鲜花盛开，嫩叶暴芽的美景。这些都是在以前最令我兴奋雀跃的景致了，我只是完全沉浸在自己的工作中了。</p></blockquote><p>以上更加佐证了我的观点。</p><p>英文的评论文章缺实难读。一开始没有理解评论员的观点，后来有一些理解了。我认为维克多的家庭是放纵型家庭，因为他的父亲没有正确地引导他，而是放任他走上了歧路。但是评论员恰恰认为维克多的家庭是专制型家庭，因为他的父亲将狭义的理性主义世界观强加在他的身上（对死亡的定义），他对年轻人感兴趣的东西（炼金术师的理论）不屑一顾，他断然否认了维克多的激情，这间接促使了维克多的“反叛”。</p><blockquote><p>我的呻吟惊醒了一个正睡在我身边椅子上的老妇人。她是监狱雇来的护士，是一个狱卒的妻子，而她的面部表情则代表了她那个阶级所有的恶劣品质。她脸上的轮廓粗鲁而又麻木，就像那种看惯了别人受苦受难，而毫不动心的那种人。她说话的腔调，则显示出她内心完全的漠不管心。她用英语对我说话，这声音听起来很耳熟，好像我在昏迷中听到过。……我厌恶地不再理那个老女人。她居然会这样毫无怜悯之心地对一个刚从死亡线上抢救回来的人说话。我感到浑身虚弱，根本无力考虑所发生的种种变故。我命运坎坷，恍如一场噩梦。有时候我真的怀疑是否这一切都是真的。……周围的一切阴森逼人，没有人愿意靠近我用一句温柔、体贴的话语来安慰我；也没有谁愿意伸出亲切的手来扶我一把。医生来过，开了点药方，老妇人则替我备药。而前者一看就知道十分草率马虎，后者则一连凶相，毫无怜悯之心。除了能赚到几个钱的刽子手之外，谁还会对一个杀人犯的命运感兴趣呢？</p></blockquote><p>评论者认为《弗兰肯斯坦》的中心主题是“渴望被真正看到”。这不仅体现在怪物身上，也体现在年幼的维克多身上。当婴儿看着母亲的脸时，最理想的情况在于婴儿在母亲眼中看到的是它自己。这是婴儿最早的确知自己存在的经历。维克多的抱怨和怪物的抱怨如出一辙。</p><p>他与伊丽莎白的结合来自父母对他未来幸福的希望，这种结合并不是他的成就，反而是他向父母屈服的标志，因此他一直处于一种矛盾的心境中，并选择尽可能拖延婚姻。尽管他以“必须把怪物铲除干净”为看似正当的理由，但新婚之夜他还是和新娘分开行动，这在现在看起来是匪夷所思的，正常人会寸步不离地守在新娘身边，生怕她被怪物伤害，而这个人居然把新娘一个人扔在房间里。维克多向他人展示的自我极有可能是欺诈性的，他将他的自我投射到了怪物身上。婴儿会向母亲周期性地展示自己的手势（真实自我），足够好的母亲会成功回应他的手势，使婴儿感到无所不能。与之相反，不够好的母亲会经常回应失败，或者试图用自己的替代手势加给婴儿。婴儿的这种顺从是虚假自我的最早阶段。虚假自我的功能是隐藏和保护真正的自我。</p><blockquote><p>关于我制造的那个魔鬼，我一直不愿作出解释，所以始终保持着沉默。我希望别人把我当成疯子，这样，这件事就永远不会从我嘴里泄露出去了。此外，我也真的不能把这个任何人听了都会吓得心惊肉跳，魂飞魄散的秘密告诉别人。我必须自己对别人的同情的渴望，缄默不言，才能避免自己将这样重大的秘密公诸于众。当然，和我上面提到的类似的话语有时还会不由自主地从嘴里漏出来，但是我却不能加以解释。不过这些话多少包含了几分真相，所以也能稍稍减轻我所忍受的难言之苦。</p></blockquote><p>类似于这样的语句经常出现，维克多经常采取逃避、隐瞒、封闭的措施，这也是他隐藏真实自我的表现。</p><p>论文的名字叫《Invisibility, and Nameless Dread》。正是因为维克多与怪物的情感表达与真实自我不被看见（在别人眼里被迫或主动地隐形），才让他与怪物各自产生无名之惧，正如Hanna Segal所解释的婴儿被欺骗后的焦虑与毁灭性的失望。怪物烧毁了它的小屋，移除了他的情感道具。小屋代表了它精神稳定的可能性。这部小说是双重束缚。维克多忠于使他被隐形的父系世界，他创造了一个非理性的生物，“邪恶”的生物也在黑暗中迷失。</p><p>完结撒花。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计组期末复习</title>
    <link href="/2024/06/13/%E8%AE%A1%E7%BB%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/13/%E8%AE%A1%E7%BB%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机概述"><a href="#计算机概述" class="headerlink" title="计算机概述"></a>计算机概述</h2><p>大型计算机和超级计算机区别：<br>大型计算机强调高速输入输出、 海量存储空间和并行事务处理等方面的特性，以面向大容量数据的事务处理为主， 兼顾科学计算<br>超级计算机是运算速度最快、 性能最高、 技术最复杂的一类计算机，适用于高度计算密集型的科学计算任务</p><p>世界上第一台电子计算机：ENIAC<br>最快计算能力量级：1194PFlops</p><p>寻址方式：物理地址 &#x3D; 段基值× 16+偏移量<br>如汇编指令 MOV AX, [3000H] 操作数默认存放在DS指向的数据段中，即[3000H]&#x3D;DS:[3000H]<br>设： DS&#x3D;2000H，则：物理地址&#x3D;2000H× 16+3000H&#x3D;23000H</p><p>CISC、RISC区别：<br>CISC（complicate）指令丰富、功能强大、寻址方式灵活，但是指令使用率不均衡、结构复杂<br>RISC（reduced）结构简单易于设计、指令精简程序执行效率高，但是指令数较少且寻址方式不灵活。</p><p>微程序硬布线控制器区别</p><p>硬布线：<br>硬布线控制器关键特征： 直接由组合逻辑电路产生微操作控制信号<br>优点： 指令执行速度很快<br>缺点： 控制逻辑的电路复杂， 设计和验证难度大； 扩充和修改也很困难</p><p>微程序：<br>利用软件方法来设计硬件的技术， 可实现复杂指令的操作控制<br>缺点： 速度较慢（每执行一条指令都要启动控制存储器中的一串微指令（ 即一段微程序） ， 执行速度相对于“硬布线控制器” 要慢<br>优点：</p><ol><li>规整性<br>◦ 用程序的方法来产生和组织微命令信号（ 将程序技术引入CPU）<br>◦ 用存储逻辑控制代替组合逻辑控制（ 将存储逻辑引入CPU）</li><li>灵活性<br>◦ 可以较方便地增加和修改指令， 只要增加或修改一部分微程序即可</li></ol><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616201102.png"><br>转移条件判定的预测：要不要转移？<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616201552.png"></p><p>Pentium对历史位的设定更倾向于预测转移发生， 三种历史位状态都预测转移发生<br>① 11：称为“强发生” 状态（strongly taken）<br>② 10：称为“发生” 状态（taken）<br>③ 01：称为“弱发生” 状态（weakly taken）</p><p>转移目标地址的预测：转移到哪里？<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616202252.png"></p><ol><li>分配BTB表项<br>◦ 当一条转移指令第一次执行时， 在BTB中为其分配一个表项<br>◦ 该指令自身的地址保存在“转移指令地址” 域<br>◦ 转移目标地址保存在“转移目标地址” 域</li><li>BTB表项比较<br>◦ 将需要预测的指令地址与BTB的“转移指令地址” 域进行比较。 若有一项匹配， 则称为BTB命中<br>◦ BTB命中表明：该指令此前被执行过， 而且为转移指令</li><li>产生转移目标地址<br>◦ 若BTB命中， 且该指令转移条件判定的预测结果为“发生转移” ， 则将该表项的“转移目标地址” 域读出作为下一条指令地址</li><li>更新BTB<br>◦ 转移指令最终执行得到的目标地址和条件判定结果要和预测结果进行比较， 如果不一致， 则需要根据最终执行结果更新BTB</li></ol><p>进行BTB表项比较的时机：</p><ol><li>取指的同时（Xscale）<br>优点：在流水线较早阶段获得转移目标地址<br>缺点：每条指令均需访问BTB，功耗开销较大</li><li>译码完成后（Pentium）<br>优点：转移指令才需访问BTB，功耗开销较小<br>缺点：在流水线较晚阶段获得转移目标地址</li><li>预译码完成后，取指的同时（UltraSPARC III）<br>将上述两种方法的优点进行结合</li></ol><p>返回地址栈RAS<br>特殊的转移指令RET使用的专用预测部件。</p><p>优点<br>① 无需判定转移条件（均为无条件转移）<br>② 执行“过程返回” 指令时， 转移目标地址已经生成（早在执行“过程调用” 指令的时候生成）<br>③ “过程返回” 指令的出现是可预期的（“过程调用” 指令和“过程返回” 指令必须成对出现）<br>缺点<br>① 每次执行同一条“过程返回” 指令时， 转移目标地址往往不同<br>② 转移目标地址在存储器中， 访问时间较长<br>③ 在流水线晚期才访问存储器获得转移目标地址</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/tx0011.png" alt="R型指令、I型指令、J型指令"></p><h2 id="与门、或门"><a href="#与门、或门" class="headerlink" title="与门、或门"></a>与门、或门</h2><p>众所周知与门&#x3D;与非门+非门，或门&#x3D;或非门+非门</p><p>非门其实就是一个CMOS反相器</p><p>与非：1变0，NMOS擅长，接地，但NMOS不能直接接电源，所以最上面的NMOS要上接一个PMOS。同理另一个为了对称也接一个PMOS，但是PMOS不能接地，所以两个PMOS的下端与两个NMOS的上端要引出Y端（把两个PMOS门画在NMOS门的上面 使得它们整体隔开会好画一点</p><p>或非：0变1，PMOS擅长，接电源，但PMOS不能直接接地，所以最下面的PMOS要下接一个NMOS。同理另一个为了对称也接一个NMOS，但是NMOS不能接电源，所以两个NMOS的上端与两个PMOS的下端要引出Y端（把两个NMOS门画在PMOS门的下面 使得它们整体隔开会好画一点<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E4%B8%8E%E9%9D%9E%E4%B8%8E%E6%88%96%E9%9D%9E.jpg" alt="与非与或非"></p><h2 id="SRAM数字电路设计"><a href="#SRAM数字电路设计" class="headerlink" title="SRAM数字电路设计"></a>SRAM数字电路设计</h2><p><img src="/../img/%E8%AE%A1%E7%BB%84/SRAM%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5.jpg" alt="SRAM一些概念"></p><p>SRAM基本单元由两个CMOS反相器（其实就是两个非门）组成，两个反相器的输入输出交叉连接，即第一个反相器的输出连接第二个反相器的输入，第二个反相器的输出连接第一个反相器的输入。这实现了两个反相器输出状态的锁定、保存，即存储了一个位元的状态。</p><h3 id="BL：Bit-Line（位线）"><a href="#BL：Bit-Line（位线）" class="headerlink" title="BL：Bit Line（位线）"></a>BL：Bit Line（位线）</h3><p>在SRAM（静态随机存取存储器）的数字电路设计中，”BL” 通常指的是 “Bit Line”。</p><p>在SRAM单元中，位线用于连接存储单元和读&#x2F;写电路。它承载存储单元中的数据位，并负责将这些数据传输到读&#x2F;写电路以进行读取或写入操作。</p><p>在SRAM的读操作中，位线被用作数据传输路径，将存储单元中的数据位传输到读取电路。在写操作中，位线负责将数据位传输到存储单元，以更新存储的数据。</p><h3 id="Word-Line（字线）"><a href="#Word-Line（字线）" class="headerlink" title="Word Line（字线）"></a>Word Line（字线）</h3><p>在SRAM单元中，字线用于选择存储单元进行读或写操作（不管是读还是写，WL都为1，过程结束时为0）。当字线激活时，它会打开连接到该字线的所有存储单元的传输门，从而允许读取或写入操作。</p><p>在读操作中，字线使得选定的存储单元的数据位能够流入位线（Bit Line）进行读取。在写操作中，字线允许数据位从位线传输到选定的存储单元，以更新存储的数据。</p><h3 id="Q（输出）"><a href="#Q（输出）" class="headerlink" title="Q（输出）"></a>Q（输出）</h3><p>在数字电路设计中，通常使用 “Q” 来表示输出信号。这个标记表示该部分或组件的输出端。</p><p>例如，在触发器或存储器单元中，”Q” 和 “&#x2F;Q”（Q的反相输出）通常表示状态或数据的输出。这些输出可以连接到其他电路部分，以实现数据传输和处理。</p><h3 id="读-x2F-写过程"><a href="#读-x2F-写过程" class="headerlink" title="读&#x2F;写过程"></a>读&#x2F;写过程</h3><p><img src="/../img/%E8%AE%A1%E7%BB%84/SRAM%E8%AE%BE%E8%AE%A1.jpg" alt="SRAM设计"><br>SRAM设计中，WL为1时写入BL，并在Q中输出BL</p><p>在SRAM（静态随机存取存储器）的设计中，当Word Line（WL）被激活为逻辑”1”时：</p><ol><li><p><strong>写入操作</strong>：将位线（Bit Line，BL）的数据写入选定的存储单元。</p></li><li><p><strong>读取操作</strong>：存储单元的数据位被传输到位线（Bit Line，BL）。</p></li></ol><p>这时，”Q” 通常表示存储单元的输出，即位线（Bit Line，BL）的内容。当执行读取操作时，Q会输出位线上的数据，反映存储单元的状态。</p><p>SRAM的运行在写入和读出时基本没有区别。</p><h3 id="断电后SRAM将丢失所有电荷状态"><a href="#断电后SRAM将丢失所有电荷状态" class="headerlink" title="断电后SRAM将丢失所有电荷状态"></a>断电后SRAM将丢失所有电荷状态</h3><p>断电后的SRAM（静态随机存取存储器）不能持续存储数据。SRAM的存储方式是基于电荷状态在存储单元中存储数据，而这些电荷会随着时间和电流的丧失而消散。</p><p>当电源关闭时，SRAM中的电荷会迅速耗尽，导致数据丢失。这与DRAM（动态随机存取存储器）不同，DRAM使用电容来存储数据，需要定期刷新以保持数据，即使在断电后也能短暂保留数据。</p><p>因此，SRAM需要持续的电源供应以保持数据，一旦电源被中断或关闭，存储在其中的数据会立即丢失。</p><h2 id="加法器、减法器、乘法器、除法器"><a href="#加法器、减法器、乘法器、除法器" class="headerlink" title="加法器、减法器、乘法器、除法器"></a>加法器、减法器、乘法器、除法器</h2><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%8A%A0%E6%B3%95%E5%99%A8.jpg" alt="加法器"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%87%8F%E6%B3%95%E5%99%A8.png" alt="减法器"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E4%B9%98%E6%B3%95%E5%99%A8.jpg" alt="乘法器"><br>今天把之前艾美疫苗送的笔记本写完了，，可喜可贺<br>虽然除法器还没考过不过以防万一稍微瞄一眼<br><img src="/../img/%E8%AE%A1%E7%BB%84/32-bit%E9%99%A4%E6%B3%95%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="32-bit除法器的工作流程图"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E9%99%A4%E6%B3%95%E5%99%A8%E5%9B%BE%E7%A4%BA.jpg" alt="除法器图示"></p><h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E8%A1%A5%E5%85%A8%E4%BB%A3%E7%A0%81.png" alt="微程序控制器补全代码"><br>怎么理解指令和微指令呢？大概就是微指令从指令中拆分出具体的很小的一个单位步骤，指令分为两个字节。前一个字节的前4位是操作码，后四位是寄存器号或者0000（像JMP没有寄存器所以就直接0000），第二个字节<strong>一定</strong>是存储单元地址（所以之前有一道选择题说能不能是寄存器+寄存器呢？对不起，不行，必须要有一个地址。<br>在这里设计的四条指令分别是：</p><ol><li>ADD R, M<br>◦ 功能： 将R的内容与M中的内容相加后存入R</li><li>LOAD R, M<br>◦ 功能： 将M中的内容装入R</li><li>STORE M, R<br>◦ 功能： 将R的内容存入M中</li><li>JMP L<br>◦ 功能： 无条件转向L处</li></ol><p>注： M和L为存储器地址， R为寄存器编号</p><h3 id="取指令"><a href="#取指令" class="headerlink" title="取指令"></a>取指令</h3><p>每条指令的T1周期， 都要发出PC_OUT、 MAR_IN、 M_读和PC_加共四个信号。这条微指令形式的信号序列如下：1111000000000000<br>每条指令的T2周期， 都要发MDR_OUT、 IR_IN两个信号这条微指令形式的信号序列如下：0000110000000000<br><img src="/../img/%E8%AE%A1%E7%BB%84/T1%E5%92%8CT2.jpg" alt="T1和T2"><br>故T2的微操作字段为0000110000000000，下址字段不是像T1周期执行完之后无脑下一步（毕竟T1释放了PC+信号，但是T2不是直接PC+，而是要看这个指令具体在哪里。从T1机器周期就开始传递的这个数据正是下一个要执行的指令地址。</p><p>下址字段为1xx10</p><p>最高位的1<br>意义：这通常表明，接下来的微指令将发生一个条件性的跳转。也就是说，CPU的下一步行动并不是简单地执行下一个顺序的微指令地址，而是根据某个条件来决定跳转的目标地址。（该例为执行IR寄存器中的内容（指令地址（指令寄存器</p><p>中间的xx<br>意义：这部分通常代表指令的操作码，它用于指示当前执行的指令类型。在微程序设计中，这可以用于基于正在执行的机器指令来选择相应的微指令流程。<br>例子：如果“xx”是从指令寄存器（IR）中解析出的当前机器指令的部分字段（比如操作码），这可以用来决定执行哪一组微指令。（load为00，add为01，store为10，jmp为11）</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E7%AD%94%E6%A1%88.png" alt="答案"><br>最后的10<br>其实也很好理解。因为不管是LOAD, ADD, STORE, 还是JMP，他们的“第一个”（图中是T3）的地址的后两位都是10（注意机器周期从开1始算，但是地址从0开始算</p><p>最上面那个取指令对于所有的指令LOAD, ADD, STORE, JMP都适用（即，分别取LOAD, ADD, …）都要从第一个机器周期开始算。因为不管是哪个指令首先都得从PC取出来，所以他们在T1和T2的步骤是一样的。</p><h3 id="LOAD-R-M"><a href="#LOAD-R-M" class="headerlink" title="LOAD R, M"></a>LOAD R, M</h3><p>然后就是LOAD指令在T3和T4的机器周期干了什么</p><p>先来看看LOAD指令在所有的周期干了什么吧<br>指令“LOAD R1, M1”的执行过程：<br><strong>① 取指令并形成下一条指令的地址（所有指令通用</strong><br>I. 控制器发“PCOUT” 和“MARIN” 信号， 使PC→MAR<br>II. 控制器发“M读” 信号， 使存储器的内容（指令） →MDR<br>III. 控制器发“PC加” 信号， 使PC+n→PC， 其中n为该指令占用的地址数<br>IV. 控制器发“MDROUT” 和“IRIN” 信号， 使MDR→IR</p><p>（上面的都干过了）</p><p><strong>② 执行指令“LOAD R1, M1”</strong><br>I. 控制器发“IROUT” 和“MARIN” 信号， 使IR中指令的地址段（即M1） →MAR<br>II. 控制器发“M读” 信号， 使存储器M1的内容（数据） →MDR<br>III. 控制器发“MDROUT” 和“R1IN” 信号， 使MDR→R1</p><p>我们重点关注②。LOAD R, M的功能是将M中的内容装入R。<br>I和II组合组成了T3：0110 0010 0000 0000<br>（注意MDRin没有用到，把指令读到MDR的指令是M读，而不是MDRIN<br>因为load还没执行完，所以下址字段无条件跳转到LOAD的下一个周期所在微地址0011（最高位的0标志无条件跳转）</p><p>III就是T4，因为此时LOAD的核心功能已经完成，所以下址字段为End指令所在位置。</p><h3 id="ADD-R-M"><a href="#ADD-R-M" class="headerlink" title="ADD R, M"></a>ADD R, M</h3><p>（省略取指令步骤</p><blockquote><p>执行指令“ADD R1,M2”<br>I. 控制器发“IROUT” 和“MARIN” 信号， 使IR中指令的地址段（ 即M2） →MAR<br>II. 控制器发“M读” 信号， 使存储器M2的内容（数据） →MDR，通过DBUS<br>III. 控制器发“MDROUT” 和“YIN” 信号， 使MDR→Y（ 即ALU的A端）<br>IV. 控制器发“R1OUT” ， 使R1→内部总线（ 即ALU的B端）<br>V. 控制器发“add” 信号， 使A+B→Z<br>VI. 控制器发“ZOUT” 和“R1IN” 信号， 使Z→R1</p></blockquote><p>这么冗长的步骤我也记不住啊，，一条条分解吧</p><p>ADD R,M的核心功能是把M中的内容取出来与R相加再存入R中。<br>M从哪来？<br>IR指令中来，指令中包含了所求地址，所以IR_OUT,它现在在总线，我再MAR_IN一下。（MAR和MDR的区别是，一个存的是这个地址，一个存的是地址的内容</p><p>我怎么读出这个M中的内容呢？（因为是内容相加而不是地址相加）那好办，M_读一下，MAR寄存器中存的地址<strong>的内容</strong>就到总线去了。然后把总线的内容通过MDRIN就可以读入MDR了</p><h2 id="2016、2017期中往年题复盘"><a href="#2016、2017期中往年题复盘" class="headerlink" title="2016、2017期中往年题复盘"></a>2016、2017期中往年题复盘</h2><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E9%80%89%E6%8B%A9%E9%A2%98.png" alt="高亮为gpt，红笔为自己写的"></p><p>ljl的体系是mooc与上课课件正交的部分，，，</p><p>阿塔纳索夫研发的是ABC计算机，不是ENIAC。（2016期中）</p><p>第一台存储程序式电子计算机是EDSAC必考。（记忆点：S-save&#x2F;store）</p><p>冯诺依曼五个基本组成部分必考。</p><blockquote><p>① 运算器， CA： central arithmetical<br>② 控制器， CC： central control<br>③ 存储器， M： memory<br>④ 输入设备， I： input<br>⑤ 输出设备， O： output</p></blockquote><p>还有其他两个特点分别是：数据和程序均以二进制代码形式不加区别地存放在存储器中，存放位置由存储器的地址指定；计算机在工作时能够自动地从存储器中取出指令加以执行。</p><p>吗嘟这么多课件找不到的内容原来全在MOOC里！气死我了！</p><p>计算机执行指令的具体步骤：取指（Fetch），译码（Decode），执行（Execute），回写（Write-back）。（2017期中）</p><blockquote><p>取指：①控制器将指令的地址送往存储器 ②存储器按给定的地址读出指令内容，送回控制器<br>译码：①控制器分析指令的操作性质 ②控制器向有关部件发出指令所需的控制信号<br>执行：①控制器从通用寄存器或存储器取出操作数 ②控制器命令运算器对操作数进行指令规定的运算<br>回写：将运算结果写入通用寄存器或存储器</p></blockquote><p>在 x86 实模式下， 假设 CS&#x3D;3000H， DS&#x3D;2000H，则指令“MOV AX,[3000H]” 执行时访问的内存地址是23000H。(2017期中) （MOOC课件上有原题一模一样）</p><blockquote><p>计算方法：DS*16+[3000H] 段地址×16＋偏移地址</p></blockquote><p>按两个32位源操作数所在位置划分，MIPS和x86的加法指令都能够支持的是：寄存器 + 寄存器（2016期中）</p><blockquote><p>记住就行了，，默默插一嘴，这题也出现在MOOC的期末考试中，所以肯定是正确答案</p></blockquote><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BF%98%E5%8E%9F%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81-1.png" alt="还原机器代码-1"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BF%98%E5%8E%9F%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81-2.jpg" alt="还原机器代码-2"><br>前面都没问题，注意一下beq那行（一般beq都是while循环），而且后面一般跟label</p><blockquote><p>虽然偏移量是1，不过实际上读的是下下一条指令（毕竟没有偏移的话就直接读下一条了（很重要！！</p></blockquote><p>D触发器：主要有一个数据输入、一个数据输出和一个时钟输入。在时钟clock的上升沿（0→1）， 采样输入D的值，传送到输出Q， 其余时间输出Q的值不变</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8.png" alt="2016期中-一位全加器"><br>为什么与S连的都是或非门？（A,B两个输入先或非一下，然后再和进位的输入或非），因为S只是某一位的取值（类比个位 只需关注奇偶）又加上二进制只有10两个数字，所以看一下一不一样就行</p><p>为什么Cout先连与门再连或门？AB两个输入先与一下，如果全是1那就构成进位条件。如果AB不全是一呢？没关系AB只要有一个是1就可以了（异或为1），并且如果输入的进位也是1的话也可以构成进位条件，两者满足其一就可以<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BE%93%E5%87%BA%E4%BF%A1%E5%8F%B7i+1.png" alt="进位输出信号分析"><br>可以推一下i&#x3D;1的时候的公式<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BF%9B%E4%BD%8D%E4%BF%A1%E5%8F%B7%E5%85%AC%E5%BC%8Fi+1%E6%8E%A8%E5%AF%BC.jpg" alt="2016期中-进位信号公式i+1推导"><br>以上都是行波进位加法器。</p><p>如果是超前进位加法器：<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%B6%85%E5%89%8D%E8%AE%A1%E7%AE%97%E8%BF%9B%E4%BD%8D%E4%BF%A1%E5%8F%B7%EF%BC%88%E4%B8%89%E7%BA%A7%E9%97%A8%E5%BB%B6%E8%BF%9F%EF%BC%89.png" alt="超前计算进位信号（三级门延迟）"><br>他主要优化的点在于C2的值不需要依赖C1，节省了等待时间（全都是并行计算的），一个竖列的全都是同时算出来，总共三个数列，所以计算Ci的延迟时间固定位三级门延迟</p><p>但是总的一整个超前进位加法器是四级门延迟的。那是因为S3的计算依赖于C3，而计算C3需要三级门延迟。所以计算出S3需要四级门延迟（关键路径<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="超前进位加法器"></p><p><img src="/../img/%E8%AE%A1%E7%BB%84/2016%E6%9C%9F%E4%B8%AD-%E4%B8%8E%E9%97%A8.png" alt="2016期中-与门"><br>非门记忆：让positive的人在上面，本negative人只想当一个阴暗爬行的接地鼠鼠<br><img src="/../img/%E8%AE%A1%E7%BB%84/2017%E6%9C%9F%E4%B8%AD-%E6%88%96%E9%97%A8.png" alt="2017期中-或门（画的是或非门）"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E7%AE%97%E9%97%A8%E5%BB%B6%E8%BF%9F%E6%95%B0.png" alt="2016期中-计算n位行波进位加法器门延迟数"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程、线程与协程</title>
    <link href="/2024/06/12/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"/>
    <url>/2024/06/12/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/ThinkWon/article/details/102021274">csdn 进程与线程的区别（超详细）</a><br>与进程不同的是同类的多个线程共享进程的<strong>堆和方法区</strong>资源，但每个线程有自己的<strong>程序计数器、虚拟机栈和本地方法栈</strong></p><p>进程<br>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p><p>线程<br>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><p>多进程：在使用QQ的同时用爱奇艺看剧<br>多线程：比如百度网盘同时有上传和下载任务，一个线程负责上传，另一个线程负责下载</p><p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p>执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是<strong>线程不能独立执行，必须依存在应用程序中，</strong>由应用程序提供多个线程执行控制，两者均可并发执行</p><h2 id="操作系统的出现：单进程-gt-多进程"><a href="#操作系统的出现：单进程-gt-多进程" class="headerlink" title="操作系统的出现：单进程-&gt;多进程"></a>操作系统的出现：单进程-&gt;多进程</h2><p>单个CPU下的并发：如在使用QQ的同时用爱奇艺看剧</p><p>资源利用率：可以在其他程序执行过程出现等待的时候，去执行其他程序，从而提高程序的利用率</p><p>公平性：所有的程序可以共享计算机资源，一种有效的方式是通过时间片的方式来让程序共享计算机资源</p><p>进程的调度</p><p>单核的 CPU 一次只能执行一个任务，想要实现多任务，需要把 CPU 的运行时间切成一段一段的时间片，每个时间片运行一个程序，循环的分配时间片给不同的应用程序，由于时间片非常的短，在用户看来，就像是多个任务同时在运行。</p><p>任务通信：在编写多任务程序时，可以一个程序执行一个任务，必要时，程序之间进行通信即可</p><p>缺点：<br>一是内核的管理成本高，二是无法简单地通过内存同步数据，很不方便于是多线程模式就出现了。</p><h2 id="有了协程为什么还要有线程"><a href="#有了协程为什么还要有线程" class="headerlink" title="有了协程为什么还要有线程"></a>有了协程为什么还要有线程</h2><p>协程（coroutines）和线程（threads）都是用于并发编程的工具，但它们在实现机制、应用场景和特性上有所不同，因此在实际开发中，它们各自有着不同的优点和用途。</p><h3 id="协程的特点"><a href="#协程的特点" class="headerlink" title="协程的特点"></a>协程的特点</h3><ol><li><p><strong>轻量级</strong>：</p><ul><li>协程是轻量级的，创建和切换协程的开销很小。它们通常由应用程序在用户态控制，不需要进行内核态的切换。</li></ul></li><li><p><strong>非抢占式</strong>：</p><ul><li>协程是非抢占式的，它们只在特定的操作（如 <code>await</code> 或 <code>yield</code>）时进行切换，这意味着一个协程的执行不会被其他协程中断。</li></ul></li><li><p><strong>更高的资源利用率</strong>：</p><ul><li>协程通常使用单线程来执行多个任务，因此可以避免线程上下文切换的开销。</li></ul></li><li><p><strong>适用于 I&#x2F;O 密集型任务</strong>：</p><ul><li>协程在处理 I&#x2F;O 密集型任务时非常高效，因为它们可以在等待 I&#x2F;O 操作完成时让出控制权，从而让其他任务运行。</li></ul></li></ol><h3 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h3><ol><li><p><strong>抢占式多任务</strong>：</p><ul><li>线程是抢占式的，操作系统可以在任何时候中断一个线程，并切换到另一个线程。这对于保证系统的响应性和处理时间关键任务很重要。</li></ul></li><li><p><strong>真正的并行执行</strong>：</p><ul><li>多个线程可以在多核 CPU 上真正并行执行，从而充分利用多核系统的处理能力。对于 CPU 密集型任务，多线程可以提供更好的性能。</li></ul></li><li><p><strong>操作系统级的调度</strong>：</p><ul><li>线程由操作系统调度和管理，可以利用操作系统提供的线程调度功能，如优先级调度。</li></ul></li><li><p><strong>适用于 CPU 密集型任务</strong>：</p><ul><li>对于需要大量计算的任务，使用多线程可以有效地利用多核 CPU 的优势。</li></ul></li><li><p><strong>不同的应用场景</strong>：</p><ul><li>协程适用于<strong>I&#x2F;O 密集型任务</strong>和大量小任务的<strong>并发</strong>处理，如网络请求、文件读写等。线程更适用于 <strong>CPU 密集型任务</strong>和需要<strong>并行</strong>处理的计算任务，如图像处理、科学计算等。</li></ul></li><li><p><strong>并行处理</strong>：</p><ul><li>协程在单线程环境中并不能实现真正的并行执行，无法利用多核 CPU 的优势。线程可以在多核 CPU 上实现真正的并行处理，从而提高计算密集型任务的性能。</li></ul></li><li><p><strong>实时和抢占式需求</strong>：</p><ul><li>有些应用程序需要实时响应和抢占式任务处理，线程可以提供这种特性，保证系统在高负载下的响应时间和性能。</li></ul></li><li><p><strong>现有生态和库支持</strong>：</p><ul><li>许多现有的库和框架是基于线程模型构建的，特别是在一些系统编程和底层开发中，线程仍然是主要的并发处理工具。</li></ul></li></ol><h3 id="综合利用"><a href="#综合利用" class="headerlink" title="综合利用"></a>综合利用</h3><p>现代编程中，通常会结合使用协程和线程，以发挥各自的优势。例如：</p><ul><li>使用线程池处理 CPU 密集型任务，同时在每个线程中使用协程处理 I&#x2F;O 密集型任务。</li><li>在主线程中使用协程处理大量异步 I&#x2F;O 操作，同时使用辅助线程处理复杂的计算任务。</li></ul><p>这种混合使用可以充分利用系统资源，提升应用程序的整体性能和响应性。</p><h2 id="进程和协程结合？"><a href="#进程和协程结合？" class="headerlink" title="进程和协程结合？"></a>进程和协程结合？</h2><p>在这种架构中，每个进程可以被看作是一个独立的工作单元，进程内创建一个单线程，并在这个单线程中运行多个协程。这种方式充分利用了协程的轻量级并发处理能力和进程的隔离性与安全性。（多进程，每个进程内使用单线程与协程的架构）</p><ol><li><p><strong>多进程</strong>：</p><ul><li>每个进程是独立的工作单元，具有独立的内存空间和资源。</li><li>进程之间的隔离提高了系统的稳定性和安全性。</li><li>多进程可以利用多核 CPU，实现真正的并行计算。</li></ul></li><li><p><strong>单线程</strong>：</p><ul><li>在每个进程内，创建一个单线程，该线程运行一个事件循环（Event Loop）。</li><li>单线程避免了线程上下文切换的开销，并简化了同步问题。</li></ul></li><li><p><strong>协程</strong>：</p><ul><li>在单线程内运行多个协程，通过协作式多任务实现高效的并发处理。</li><li>协程特别适合处理 I&#x2F;O 密集型任务，如网络请求、文件读写等。</li></ul></li></ol><p>这种架构利用了多进程来实现并行计算，每个进程内部使用单线程和协程来高效地处理 I&#x2F;O 密集型任务。这样既充分利用了多核 CPU 的计算能力，又避免了线程上下文切换的开销，同时简化了并发编程中的同步问题。</p><p>这种设计非常适合以下场景：</p><ul><li><strong>高并发 Web 服务器</strong>：使用多个进程处理客户端连接，每个进程内使用协程处理请求和响应。</li><li><strong>大规模数据爬取</strong>：使用多个进程管理爬虫实例，每个实例内使用协程并发抓取数据。</li><li><strong>数据处理管道</strong>：使用多个进程分割数据处理的不同阶段，每个阶段内部使用协程处理 I&#x2F;O 操作。</li></ul><h2 id="即时通讯软件是I-x2F-O密集型的吗"><a href="#即时通讯软件是I-x2F-O密集型的吗" class="headerlink" title="即时通讯软件是I&#x2F;O密集型的吗"></a>即时通讯软件是I&#x2F;O密集型的吗</h2><p>是的，即时通讯软件（聊天软件）通常是 I&#x2F;O 密集型的。这是因为它们需要处理大量的网络 I&#x2F;O 操作，比如：</p><ol><li><p><strong>网络通信</strong>：</p><ul><li>处理大量的客户端连接。</li><li>接收和发送消息。</li><li>保持长连接（如 WebSocket 连接）以实现实时通信。</li></ul></li><li><p><strong>数据存储和检索</strong>：</p><ul><li>读写数据库以存储和检索消息记录、用户信息等。</li><li>使用缓存系统（如 Redis）来加速数据访问。</li></ul></li><li><p><strong>文件传输</strong>：</p><ul><li>处理文件上传和下载，如发送图片、视频、音频等。</li></ul></li></ol><h3 id="为什么即时通讯软件是-I-x2F-O-密集型的？"><a href="#为什么即时通讯软件是-I-x2F-O-密集型的？" class="headerlink" title="为什么即时通讯软件是 I&#x2F;O 密集型的？"></a>为什么即时通讯软件是 I&#x2F;O 密集型的？</h3><ol><li><p><strong>高并发连接</strong>：</p><ul><li>即时通讯软件需要同时处理大量的用户连接，用户的消息收发、状态更新等操作都需要频繁的网络 I&#x2F;O。</li></ul></li><li><p><strong>实时性要求</strong>：</p><ul><li>消息需要在用户之间实时传递，要求低延迟的网络 I&#x2F;O 操作。</li></ul></li><li><p><strong>数据持久化</strong>：</p><ul><li>用户的聊天记录、消息历史等需要存储在数据库中，并且需要频繁的数据库读写操作。</li></ul></li></ol><h3 id="应对-I-x2F-O-密集型任务的技术"><a href="#应对-I-x2F-O-密集型任务的技术" class="headerlink" title="应对 I&#x2F;O 密集型任务的技术"></a>应对 I&#x2F;O 密集型任务的技术</h3><p>由于即时通讯软件的 I&#x2F;O 密集型特性，采用合适的技术来处理 I&#x2F;O 操作非常重要。以下是一些常用的技术和架构：</p><ol><li><p><strong>异步 I&#x2F;O 和协程</strong>：</p><ul><li>使用异步 I&#x2F;O（如 <code>asyncio</code>、<code>aiohttp</code>）和协程来处理大量并发连接，避免线程上下文切换的开销，提高并发性能。</li></ul></li><li><p><strong>多进程</strong>：</p><ul><li>使用多进程来隔离不同的服务组件，利用多核 CPU 提高并行处理能力和系统稳定性。</li></ul></li><li><p><strong>事件驱动架构</strong>：</p><ul><li>采用事件驱动架构（如 Node.js、<code>Twisted</code>）来处理异步 I&#x2F;O 操作，提高响应速度。</li></ul></li><li><p><strong>高效的网络库</strong>：</p><ul><li>使用高效的网络库（如 <code>libuv</code>、<code>epoll</code>、<code>kqueue</code>）来处理大规模并发连接。</li></ul></li><li><p><strong>缓存系统</strong>：</p><ul><li>使用缓存系统（如 Redis、Memcached）来加速数据访问，减轻数据库压力。</li></ul></li><li><p><strong>分布式架构</strong>：</p><ul><li>采用分布式架构，将不同的服务组件部署在不同的服务器上，利用负载均衡和服务发现机制提高系统的扩展性和可用性。</li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手撕力扣高频面试题</title>
    <link href="/2024/06/11/%E6%89%8B%E6%92%95%E5%8A%9B%E6%89%A3%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/06/11/%E6%89%8B%E6%92%95%E5%8A%9B%E6%89%A3%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>题目来源：<br><a href="https://www.csview.cn/algorithm-mandatory/">csview网站</a><br>此处采用ACM模式，序号为力扣官网题号</p><p>切记，写不出来不代表面试不通过，写得出来也不代表面试就通过了。放宽心，多写注释让面试官看到你的分析能力以及应变能力。卡着就多讲思路。非常感谢虾皮的面试官，他确实给了我很大的鼓励。</p><h1 id="面过的"><a href="#面过的" class="headerlink" title="面过的"></a>面过的</h1><h2 id="227-基本计算器II"><a href="#227-基本计算器II" class="headerlink" title="227.基本计算器II"></a>227.基本计算器II</h2><p>思路：<br>step1：中缀转后缀<br>定义一个符号栈和一个vector<string>数组<br>碰到数字就push进vector数组里面<br>碰到符号的话：<br>如果 该符号位左括号 or 栈空 or 栈顶优先级小于该符号优先级 or 栈顶为左括号 就进栈<br>否则 依次弹出栈顶直到符合条件 最后进栈<br>如果 碰到的为右括号 则依次弹出栈顶直到遇到左括号 把左括号也pop掉<br>step2：后缀表达式求值<br>碰到数字，入栈<br>碰到符号，从数字栈中弹出两个值计算，将得到的值压栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">(<span class="hljs-type">char</span> sym)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (sym==<span class="hljs-string">&#x27;+&#x27;</span>||sym==<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (sym==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-comment">// 请务必注意return 0这一点！！！</span><br>&#125;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s_mid;<br>    s_mid=<span class="hljs-string">&quot;1+(2+3)*2&quot;</span>;<br>    string s_back;<br>    stack&lt;<span class="hljs-type">char</span>&gt;symbol;<br>    <span class="hljs-type">int</span> len =s_mid.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <br>        <span class="hljs-comment">// if (symbol.empty()) symbol.push(s_mid[i]);</span><br>        <span class="hljs-comment">// 这是错的！！！要先判断它是不是数字！！！</span><br>        <span class="hljs-keyword">if</span> (s_mid[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s_mid[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)  s_back = s_back + s_mid[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol.<span class="hljs-built_in">empty</span>()) symbol.<span class="hljs-built_in">push</span>(s_mid[i]);<br>        <span class="hljs-comment">// 数字直接输出</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s_mid[i]==<span class="hljs-string">&#x27;(&#x27;</span>) symbol.<span class="hljs-built_in">push</span>(s_mid[i]);<br>        <span class="hljs-comment">// 左括号直接入栈</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s_mid[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span> (symbol.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;top:&quot;</span>&lt;&lt;symbol.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>                s_back = s_back + symbol.<span class="hljs-built_in">top</span>();<br>                cout&lt;&lt;s_back&lt;&lt;endl;<br>                symbol.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            symbol.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 最后将左括号也pop掉</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span> (!symbol.<span class="hljs-built_in">empty</span>()&amp;&amp;<span class="hljs-built_in">priority</span>(s_mid[i])&lt;=<span class="hljs-built_in">priority</span>(symbol.<span class="hljs-built_in">top</span>()))&#123;<br>                s_back = s_back+symbol.<span class="hljs-built_in">top</span>();<br>                symbol.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            symbol.<span class="hljs-built_in">push</span>(s_mid[i]);<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span> (!symbol.<span class="hljs-built_in">empty</span>())&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;symbol.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;<span class="hljs-string">&quot;stack is empty.&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <br>        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;s_back&lt;&lt;endl;<br>        <br>    &#125;<br>    <span class="hljs-keyword">while</span> (!symbol.<span class="hljs-built_in">empty</span>())&#123;<br>        s_back = s_back + symbol.<span class="hljs-built_in">top</span>();<br>        symbol.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout&lt;&lt;s_back&lt;&lt;endl;<br>    <span class="hljs-comment">// 至此最难的部分：中缀转后缀完成</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。（原地<br>双指针，cur表示当前遍历到的位置，p表示非零元素位置，从第一个开始遍历，把遍历到的非零元素赋给p位置，并且最后把后面的数都赋成0</p><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p>不要用淹没法了，用2表示已遍历过的格子<br>count++放在dfs外面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> row 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> column 5</span><br><span class="hljs-type">int</span> grid[row][column]= &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_array</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;column;j++)&#123;<br>            cout&lt;&lt;grid[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;current (i,j) is &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;endl;<br>    <span class="hljs-comment">// 已遍历过的格子要进行标记</span><br>    <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">0</span>||i&gt;=row)&#123;<br>        <span class="hljs-comment">// 边界外</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;i out of range&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j&lt;<span class="hljs-number">0</span>||j&gt;=column)&#123;<br>        <span class="hljs-comment">// 边界外</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;j out of range&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (grid[i][j]!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    grid[i][j]=<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 标记为已遍历过的陆地格子</span><br>    <span class="hljs-built_in">dfs</span>(i<span class="hljs-number">-1</span>,j);<br>    <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j);<br>    <span class="hljs-built_in">dfs</span>(i,j+<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(i,j<span class="hljs-number">-1</span>);<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;original data:&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">print_array</span>();<br>    <span class="hljs-comment">// preprocess();</span><br>    <span class="hljs-comment">// cout&lt;&lt;&quot;after preprocess:&quot;&lt;&lt;endl;</span><br>    <span class="hljs-comment">// print_array();</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;column;j++)&#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j]==<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(i,j);<br>                count++;<br>                <span class="hljs-comment">// 注意count++要放在dfs外面！！！</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">print_array</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;count value is &quot;</span>&lt;&lt;count;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h2><p>注意点：<br>记得返回新的头结点（也就是返回pre<br>以及设的几个tmp节点是pre，cur和nex</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">listnode</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    listnode* next;<br>    <span class="hljs-built_in">listnode</span>(<span class="hljs-type">int</span> v,listnode* n)&#123;<br>        value = v;<br>        next = n;<br>    &#125;<br>&#125;;<br><span class="hljs-function">listnode* <span class="hljs-title">reverse_list</span><span class="hljs-params">(listnode* head)</span></span>&#123;<br>    listnode* pre = <span class="hljs-literal">nullptr</span>;<br>    listnode* cur = head;<br>    listnode* nex = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>        nex = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = nex;<br>    &#125;<br>    <span class="hljs-comment">// 这里记得要返回新的头结点</span><br>    <span class="hljs-keyword">return</span> pre;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(listnode* head)</span></span>&#123;<br>    listnode* tmp = head;<br>    cout&lt;&lt;<span class="hljs-string">&quot;current list:&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">while</span> (tmp!=<span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;tmp-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        tmp = tmp-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    listnode *head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">-1</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">4</span>,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">print_list</span>(head-&gt;next);<br>    listnode* newhead = <span class="hljs-built_in">reverse_list</span>(head-&gt;next);<br>    <span class="hljs-built_in">print_list</span>(newhead);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19.删除链表的倒数第N个结点"></a>19.删除链表的倒数第N个结点</h2><p>思路：快慢指针，快指针先走N步，然后慢指针再开始走，直到快指针走到终点，慢指针指向的节点就是第N个结点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">listnode</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    listnode* next;<br>    <span class="hljs-built_in">listnode</span>(<span class="hljs-type">int</span> v,listnode* n)&#123;<br>        value = v;<br>        next = n;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">delete_n_last_node</span><span class="hljs-params">(listnode*head, <span class="hljs-type">int</span> n)</span></span>&#123;<br>    listnode* fast = head;<br>    listnode* slow = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        fast = fast-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (fast!=<span class="hljs-literal">nullptr</span>)&#123;<br>        fast=fast-&gt;next;<br>        slow = slow-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow-&gt;value;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    listnode *head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">-1</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">listnode</span>(<span class="hljs-number">4</span>,<span class="hljs-literal">nullptr</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">delete_n_last_node</span>(head,<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h2><p>思路：从根结点开始递归比较，先看两个根节点是否为空，如果都为空，那就说明是两棵一样的树，如果一个空一个不空，说明两棵树不同，先判断非空状况再判断root的value属性，最后再递归比较左子树右子树是否一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">treenode</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    treenode* left;<br>    treenode* right;<br>    <span class="hljs-built_in">treenode</span>(<span class="hljs-type">int</span> v,treenode* l,treenode* r)&#123;<br>        value = v;<br>        left = l;<br>        right = r;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_same_tree</span><span class="hljs-params">(treenode* root1,treenode* root2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root1==<span class="hljs-literal">nullptr</span>&amp;&amp;root2==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (root1==<span class="hljs-literal">nullptr</span>&amp;&amp;root2!=<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (root2==<span class="hljs-literal">nullptr</span>&amp;&amp;root1!=<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (root1-&gt;value!=root2-&gt;value) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">is_same_tree</span>(root1-&gt;left,root2-&gt;left)&amp;&amp;<span class="hljs-built_in">is_same_tree</span>(root1-&gt;right,root2-&gt;right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    treenode*root1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    root1-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    root1-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    treenode*root2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    root2-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    root2-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_same_tree</span>(root1,root2)) cout&lt;&lt;<span class="hljs-string">&quot;is same!&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;different&quot;</span>&lt;&lt;endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p>思路：递归，返回左右子树深度的最大值加一</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">treenode</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    treenode* left;<br>    treenode* right;<br>    <span class="hljs-built_in">treenode</span>(<span class="hljs-type">int</span> v,treenode* l,treenode* r)&#123;<br>        value = v;<br>        left = l;<br>        right = r;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_depth</span><span class="hljs-params">(treenode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max_depth</span>(root-&gt;left),<span class="hljs-built_in">max_depth</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    treenode*root1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    root1-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    root1-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    root1-&gt;left-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">treenode</span>(<span class="hljs-number">4</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    cout&lt;&lt;<span class="hljs-built_in">max_depth</span>(root1);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h2><p>遍历字符串 s 中的每一个字符 i，以 i 为中心，向左右两侧扩展，找到以 i 为中心的最长回文子串 s1 和以 i 和 i+1 为中心的最长回文子串 s2，最后返回其中最长的回文子串。</p><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h2><p>首先，看到这道题要想到这是动态规划。<br>其次，一开始记得初始值要设成最大的。<br>转移方程：dp[i+coin[j]]&#x3D;min(dp[i+coin[j]],dp[i]+1);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> verybig 100000</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change_coin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;coin,<span class="hljs-type">int</span> total)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(total+<span class="hljs-number">100</span>,verybig);<br>    <span class="hljs-comment">// 记得初始化一下</span><br>    <span class="hljs-type">int</span> cnt = coin.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// dp[n]表示需要凑到这么多金额所需最小硬币数</span><br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;=total;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt;j++)&#123;<br>            dp[i+coin[j]]=<span class="hljs-built_in">min</span>(dp[i+coin[j]],dp[i]+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[total]==verybig) dp[total]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dp[total];<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;coin1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt;coin2 = &#123;<span class="hljs-number">2</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt;coin3 = &#123;<span class="hljs-number">1</span>&#125;;<br>    cout&lt;&lt;<span class="hljs-built_in">change_coin</span>(coin1,<span class="hljs-number">11</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">change_coin</span>(coin2,<span class="hljs-number">3</span>)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">change_coin</span>(coin3,<span class="hljs-number">0</span>)&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><p>记得是动规<br>转移方程不能只考虑相邻的两个！！<br>if (a[i]&gt;a[j]){<br>    dp[i]&#x3D;max(dp[j]+1,dp[i]);<br>}<br>else{<br>    dp[i]&#x3D;max(dp[i],dp[j]);<br>}</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_longest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;a)</span></span>&#123;<br>    <span class="hljs-type">int</span> len = a.<span class="hljs-built_in">size</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(len);<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>            <span class="hljs-keyword">if</span> (a[i]&gt;a[j])&#123;<br>                dp[i]=<span class="hljs-built_in">max</span>(dp[j]+<span class="hljs-number">1</span>,dp[i]);<br>                <span class="hljs-comment">// 如果是递增就把a[i]算上</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[j]);<br>                <span class="hljs-comment">// 如果不是，dp[i]就等于前面这些的最大值</span><br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-comment">// 注释语句的错误原因在于只考虑了相邻两个数的大小关系</span><br>        <span class="hljs-comment">// if (a[i]&gt;a[i-1])&#123;</span><br>        <span class="hljs-comment">//     dp[i]=max(dp[i-1]+1,dp[i]);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// else&#123;</span><br>        <span class="hljs-comment">//     dp[i]=max(dp[i-1],dp[i]);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[len<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;a = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt;b = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt;c = &#123;<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>&#125;;<br>    cout&lt;&lt;<span class="hljs-built_in">find_longest</span>(a)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">find_longest</span>(b)&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-built_in">find_longest</span>(c)&lt;&lt;endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="153-旋转数组找旋转点"><a href="#153-旋转数组找旋转点" class="headerlink" title="153.旋转数组找旋转点"></a>153.旋转数组找旋转点</h2><p>先和high比再和low比</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> len 7</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 这个应该就是返回旋转点</span><br>    <span class="hljs-type">int</span> a[len] = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> r = len<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (l&lt;r)&#123;<br>        <br>        <span class="hljs-type">int</span> m = (l+r)/<span class="hljs-number">2</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;l,r,m = &quot;</span>&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;r&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;m&lt;&lt;endl;<br>        <span class="hljs-comment">// 官解：先和high比再和low比</span><br>        <span class="hljs-keyword">if</span> (a[r]&gt;a[m])&#123;<br>            r = m;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            l = m+<span class="hljs-number">1</span>;<br>        &#125;<br><br>    &#125;<br>    cout&lt;&lt;a[l];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="33-旋转数组找target值"><a href="#33-旋转数组找target值" class="headerlink" title="33.旋转数组找target值"></a>33.旋转数组找target值</h2><p>要确认哪一段升序（判断条件比较复杂，要比较两个端点的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> len 7</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[len]=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">int</span> target;<br>    cin&gt;&gt;target;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> r = len<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// int m = (l+r)/2;</span><br>    <span class="hljs-comment">// 我们要先判断 [0,mid] 是有序数组还是 [mid+1,r] 是有序数组</span><br>    <span class="hljs-keyword">while</span> (l&lt;=r)&#123;<br>        <span class="hljs-type">int</span> m = (l+r)/<span class="hljs-number">2</span>;<br>        cout&lt;&lt;<span class="hljs-string">&quot;l,r,m=&quot;</span>&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;r&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;m&lt;&lt;endl;<br>        <span class="hljs-comment">// 我们要看 [l, mid] 和 [mid + 1, r] 哪个部分是有序的</span><br>        <span class="hljs-comment">// 如果 [l, mid] 有序，且target在a[l]和a[mid]之间，那就在该区间搜索</span><br>        <span class="hljs-comment">// 否则在 [mid+1,r] 区间搜索</span><br>        <span class="hljs-keyword">if</span> (target==a[m])&#123;<br>            cout&lt;&lt;m;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 我们要先判断</span><br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>]&lt;=a[m])&#123;<br>            <span class="hljs-comment">// 说明[0,m]段升序</span><br>            <span class="hljs-comment">// 以及这个判断要求一定要提到最外面</span><br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>]&lt;=target&amp;&amp;target&lt;a[m])&#123;<br>                <span class="hljs-comment">// 如果target在索引0-m之间</span><br>                <span class="hljs-comment">// 两边的范围都要写</span><br>                <span class="hljs-comment">// 前面要带等号，后面判断过了就不用带等号了</span><br>                r = m<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                l = m+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 说明[m+1,len-1]段升序</span><br>            <span class="hljs-keyword">if</span> (a[m]&lt;target&amp;&amp;a[len<span class="hljs-number">-1</span>]&gt;=target)&#123;<br>                <span class="hljs-comment">// 如果target索引在[m,len-1]之间</span><br>                l = m+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                r = m<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[l]!=target) cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;l;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h2><p>贪心，先按左边界升序排列（用自定义cmp函数<br>再将重复的进行合并</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_interval</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> begin;<br>    <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-built_in">my_interval</span>(<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> e)&#123;<br>        begin = b;<br>        end = e;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(my_interval a,my_interval b)</span></span>&#123;<br>    <span class="hljs-comment">// 按左边界升序排列</span><br>    <span class="hljs-keyword">return</span> a.begin&lt;b.begin;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_intervals</span><span class="hljs-params">(vector&lt;my_interval&gt;intervals)</span></span>&#123;<br>    <span class="hljs-type">int</span> len = intervals.<span class="hljs-built_in">size</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;intervals:&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;[&quot;</span>&lt;&lt;intervals[i].begin&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;intervals[i].end&lt;&lt;<span class="hljs-string">&quot;]&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;my_interval&gt;intervals;<br>    intervals.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">my_interval</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>));<br>    <span class="hljs-comment">// 直接构造临时对象pushback</span><br>    intervals.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">my_interval</span>(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    <span class="hljs-comment">// intervals.push_back(my_interval(1,3));</span><br>    <span class="hljs-comment">// intervals.push_back(my_interval(8,10));</span><br>    <span class="hljs-comment">// intervals.push_back(my_interval(2,6));</span><br>    <span class="hljs-comment">// intervals.push_back(my_interval(15,18));</span><br>    <span class="hljs-built_in">print_intervals</span>(intervals);<br>    <span class="hljs-type">int</span> size = intervals.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(),intervals.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-built_in">print_intervals</span>(intervals);<br>    vector&lt;my_interval&gt;result;<br>    result.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-keyword">if</span> (intervals[i].begin&lt;=result[cur].end)&#123;<br>            <span class="hljs-comment">// 合并产生新的右边界</span><br>            result[cur].end = intervals[i].end;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            result.<span class="hljs-built_in">push_back</span>(intervals[i]);<br>            cur++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">print_intervals</span>(result);<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> num 3</span><br><span class="hljs-comment">// 标记该数是否使用过</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">permutate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;a,vector&lt;<span class="hljs-type">int</span>&gt;&amp;tmp,<span class="hljs-type">bool</span>* flag,<span class="hljs-type">int</span> count)</span></span>&#123;<br>    <span class="hljs-type">int</span> len = a.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (count==len)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;count;i++)&#123;<br>            cout&lt;&lt;tmp[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span> (!flag[i])&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(a[i]);<br>            flag[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">permutate</span>(a,tmp,flag,count+<span class="hljs-number">1</span>);<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>            flag[i]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">bool</span> flag[num]=&#123;<span class="hljs-number">0</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt;test1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-comment">// vector&lt;int&gt;test2 = &#123;0,1&#125;;</span><br>    <span class="hljs-comment">// vector&lt;int&gt;test3 = &#123;1&#125;;</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;tmp;<br>    <span class="hljs-built_in">permutate</span>(test1,tmp,flag,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// print_permutations(test2);</span><br>    <span class="hljs-comment">// print_permutations(test3);</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><p>unordered_map一定要声明一对，，<br>注意一下unordered_map的使用方法：first，second，find（end），emplace</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> max_len = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_charindex</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;char_index)</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;current char_index:&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i:char_index)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;[&quot;</span>&lt;&lt;i.first&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;i.second&lt;&lt;<span class="hljs-string">&quot;]&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// hashmap key为字符，value为字符在滑动窗口中的下标</span><br>    <span class="hljs-comment">// 之所以在写tp-link笔试的时候没通过竟是因为！！！声明数据类型的时候应该声明一对！！！</span><br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;char_index;<br>    string s = <span class="hljs-string">&quot;abcabcbb&quot;</span>;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 标记滑动窗口的区间</span><br>    <span class="hljs-keyword">while</span>(right&lt;len)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;left,right:&quot;</span>&lt;&lt;left&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;right&lt;&lt;endl;<br>        <span class="hljs-built_in">print_charindex</span>(char_index);<br>        <span class="hljs-keyword">if</span> (char_index.<span class="hljs-built_in">find</span>(s[right])==char_index.<span class="hljs-built_in">end</span>())&#123;<br>            <span class="hljs-comment">// 滑动窗口中目前没有这样的字符</span><br>            <span class="hljs-comment">// 把这个字符和它的索引加进hashmap</span><br>            char_index.<span class="hljs-built_in">emplace</span>(s[right],right);<br>            cout&lt;&lt;<span class="hljs-string">&quot;successfully emplace [&quot;</span>&lt;&lt;s[right]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;right&lt;&lt;<span class="hljs-string">&quot;]&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-built_in">print_charindex</span>(char_index);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 滑动窗口已经有了这样的字符，左值要发生变化</span><br>            left = char_index[s[right]]+<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 不要漏写后面那个加一，因为要把他剔除出去</span><br>            <span class="hljs-comment">// hashmap中的它的字符和索引也要做相应的更新</span><br>            char_index[s[right]]=right;<br>            <span class="hljs-built_in">print_charindex</span>(char_index);<br>        &#125;<br>        <br>        max_len = <span class="hljs-built_in">max</span>(max_len,right-left+<span class="hljs-number">1</span>);<br>        right++;<br><br>    &#125;<br>    cout&lt;&lt;max_len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sql性能调优</title>
    <link href="/2024/06/10/sql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <url>/2024/06/10/sql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<p>六月份了还没找到实习，焦虑是肯定焦虑的，，一方面也后悔自己早早就想着躺平，现在蓝条回满了发现已经错失了很多良机</p><p>不过人生总会犯错，，幸好shoppee这家还算投的早，可能（可能！）真的会给我发offer（感谢收留啊啊啊啊虽然还没收留，肯面我我也很开心了</p><p>总之还是多看点sql</p><p>查询优化：利用启发式方法尽量减少侯选计划， 利用基于代价的方法准确地确定执行计划</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spark&amp;flink&amp;hive</title>
    <link href="/2024/06/09/%E5%85%B3%E4%BA%8Espark/"/>
    <url>/2024/06/09/%E5%85%B3%E4%BA%8Espark/</url>
    
    <content type="html"><![CDATA[<p>B站：尚硅谷</p><h2 id="什么时候用spark不用hadoop？"><a href="#什么时候用spark不用hadoop？" class="headerlink" title="什么时候用spark不用hadoop？"></a>什么时候用spark不用hadoop？</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240609202013.png"></p><p>spark是一种计算框架，一般用来与hadoop的MapReduce对比（因为MapReduce也是计算框架）spark不管理存储</p><p>hadoop中的MapReduce更倾向于一次性数据计算，不适合机器学习等频繁循环迭代的场景（因为hadoop的形式需要太多次磁盘I&#x2F;O</p><p>spark和hadoop的根本差异是多个作业之间的数据通信问题。spark通信基于内存（更快，快100倍），hadoop基于磁盘。</p><p>不过实际生产环境中如果内存不够可能导致job执行失败，所以spark不能完全取代MapReduce</p><h2 id="什么时候用flink不用spark？"><a href="#什么时候用flink不用spark？" class="headerlink" title="什么时候用flink不用spark？"></a>什么时候用flink不用spark？</h2><p>spark比较适合做离线分析（比如机器学习这些），但是一些对实时性要求比较高的在线业务来说，spark就不太擅长。而flink的相应速度快。<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240609205242.png"><br>理论上只要是实时数据处理方面都可以用flink框架来解决。</p><h2 id="Hive和Hadoop什么关系？"><a href="#Hive和Hadoop什么关系？" class="headerlink" title="Hive和Hadoop什么关系？"></a>Hive和Hadoop什么关系？</h2><p>BV1LU4y1e7Ve</p><p>只能提供离线的数据查询，只能用SQL</p><p>众所周知hadoop中分为存储和计算两大方面，hdfs负责存储，MapReduce负责计算。但是MapReduce需要比较高的计算机水平，所以一些懒人为了在hadoop上也可以使用sql就开发了hive。这样就可以在hadoop上处理结构化数据。hive中的metastore就是用来存储一些表信息。处理的时候其实前半部分和sql语句正常执行无差，也是要进行语法分析和词法分析写成语法树，只是在后面有一些区别。hive的工作实际上就是把sql语句翻译成MapReduce。这样工作人员的开发效率就会提高。不过缺点是相比MapReduce变得不太灵活。所以hive也并不能直接取代hadoop。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库概论2017期末</title>
    <link href="/2024/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA2017%E6%9C%9F%E6%9C%AB/"/>
    <url>/2024/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA2017%E6%9C%9F%E6%9C%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简答题"><a href="#一、简答题" class="headerlink" title="一、简答题"></a>一、简答题</h1><h2 id="1-保证数据质量对-1NF-为什么重要？"><a href="#1-保证数据质量对-1NF-为什么重要？" class="headerlink" title="1. 保证数据质量对 1NF 为什么重要？"></a>1. 保证数据质量对 1NF 为什么重要？</h2><p>消除数据冗余和重复，提高存储效率。<br>提高数据一致性，避免数据不一致问题。<br>增强数据完整性，确保数据验证和校验的有效性。<br>简化查询和维护，提高操作的便捷性。<br>提高数据可扩展性，确保数据库在增长时能够维持高质量的数据结构。</p><h2 id="2-给出一个有三种-BCNF-无损连接分解的关系模式及相应的函数依赖集"><a href="#2-给出一个有三种-BCNF-无损连接分解的关系模式及相应的函数依赖集" class="headerlink" title="2.给出一个有三种 BCNF 无损连接分解的关系模式及相应的函数依赖集."></a>2.给出一个有三种 BCNF 无损连接分解的关系模式及相应的函数依赖集.</h2><p>感觉所谓“三种”本质上是处理顺序的问题？不懂在问什么</p><h2 id="3-比较-3NF-和-BCNF-的优缺点"><a href="#3-比较-3NF-和-BCNF-的优缺点" class="headerlink" title="3. 比较 3NF 和 BCNF 的优缺点."></a>3. 比较 3NF 和 BCNF 的优缺点.</h2><p>第三范式（3NF）：<br>STC(sno,tno,cno)</p><p>优点：<br>更简便，查询性能更好</p><p>缺点：<br>插入异常：如果没有学生选修某位老师的任课，则该老师担任课程的信息就无法插入<br>删除异常：删除学生选课信息，会删除掉老师的任课信息<br>更新异常：如果老师的授课信息有所改动，则所有选修其课程的学生元组都要做改动<br>数据冗余：每位学生都存储了老师的授课信息</p><p>Boyce-Codd范式（BCNF）：<br>ST(sno,tno), TC(tno,cno)</p><p>优点：<br>消除主属性对码的不良依赖</p><p>缺点：<br>BCNF 可能会导致表分的过碎，表的数目过多，可能对一些复杂的查询造成性能上的影响<br>例如原始的 STC 表中是有函数依赖 (sno,cno) -&gt;tno 的，但是分开成 ST、C 两张表之后，这个函数不能体现了。这样我们可以在 ST 表（全码）中随意插入数据，而这样插入的数据可能不不满足函数依赖 (sno,cno) -&gt;tno</p><h2 id="4-叙述-Armstrong-公理系统的三条公理"><a href="#4-叙述-Armstrong-公理系统的三条公理" class="headerlink" title="4. 叙述 Armstrong 公理系统的三条公理."></a>4. 叙述 Armstrong 公理系统的三条公理.</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/Ch4MdFvNln2AUFmFAADYqLFNxAo520.png"></p><h2 id="5-写出两种利用“占用—抢占”-解决死锁的方法"><a href="#5-写出两种利用“占用—抢占”-解决死锁的方法" class="headerlink" title="5. 写出两种利用“占用—抢占” 解决死锁的方法."></a>5. 写出两种利用“占用—抢占” 解决死锁的方法.</h2><p>区分解决死锁与预防死锁！！</p><h3 id="1-资源剥夺法（Resource-Preemption）"><a href="#1-资源剥夺法（Resource-Preemption）" class="headerlink" title="1. 资源剥夺法（Resource Preemption）"></a>1. 资源剥夺法（Resource Preemption）</h3><p>资源剥夺法通过抢占某些资源来打破死锁。当检测到死锁时，系统选择某些事务并强制释放它们所持有的资源。被抢占的事务将被挂起，直到它们所需的资源变得可用。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><p><strong>死锁检测</strong>：</p><ul><li>定期或在某些触发条件下进行死锁检测，确定死锁环。</li></ul></li><li><p><strong>选择事务进行资源抢占</strong>：</p><ul><li>选择一个或多个事务来进行资源剥夺。选择策略可以基于以下因素：<ul><li>事务的优先级。</li><li>事务已经执行的时间。</li><li>事务所持有的资源数量。</li></ul></li></ul></li><li><p><strong>强制释放资源</strong>：</p><ul><li>系统强制中止选定的事务，并释放这些事务所持有的资源。</li></ul></li><li><p><strong>重新调度事务</strong>：</p><ul><li>被中止的事务将重新排队等待，直到它们所需的资源再次可用。然后，它们将重新开始执行。</li></ul></li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong>：<ul><li>可以迅速解决死锁，恢复系统的正常运行。</li></ul></li><li><strong>缺点</strong>：<ul><li>可能会导致事务的部分执行被放弃，需要重新开始，浪费了已经完成的工作。</li><li>选择哪一个事务来中止可能会导致复杂的调度决策。</li></ul></li></ul><h3 id="2-事务回滚法（Transaction-Rollback）"><a href="#2-事务回滚法（Transaction-Rollback）" class="headerlink" title="2. 事务回滚法（Transaction Rollback）"></a>2. 事务回滚法（Transaction Rollback）</h3><p>事务回滚法通过回滚一个或多个事务到之前的某个状态来解决死锁。回滚后，这些事务将重新尝试获取资源，从而打破死锁。</p><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><p><strong>死锁检测</strong>：</p><ul><li>定期或在某些触发条件下进行死锁检测，确定死锁环。</li></ul></li><li><p><strong>选择事务进行回滚</strong>：</p><ul><li>选择一个或多个事务进行回滚。选择策略可以基于以下因素：<ul><li>事务的优先级。</li><li>事务已经执行的时间。</li><li>事务对系统的重要性。</li></ul></li></ul></li><li><p><strong>回滚事务</strong>：</p><ul><li>将选定的事务回滚到之前的某个保存点或重新开始。</li></ul></li><li><p><strong>重新执行事务</strong>：</p><ul><li>被回滚的事务将重新开始执行，并尝试重新获取资源。</li></ul></li></ol><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>优点</strong>：<ul><li>通过回滚，避免了资源的长时间占用，迅速解决死锁。</li><li>不会完全丢弃已经执行的工作，只是重新尝试获取资源。</li></ul></li><li><strong>缺点</strong>：<ul><li>回滚操作可能会带来额外的开销，尤其是对于复杂的事务。</li><li>选择回滚哪个事务可能会带来复杂的调度决策。</li></ul></li></ul><h3 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h3><p>假设有两个事务T1和T2，以及两个资源R1和R2。死锁情况如下：</p><ul><li>T1持有R1，并等待R2。</li><li>T2持有R2，并等待R1。</li></ul><h4 id="资源剥夺法"><a href="#资源剥夺法" class="headerlink" title="资源剥夺法"></a>资源剥夺法</h4><ul><li>系统检测到死锁。</li><li>系统选择T1进行资源剥夺。</li><li>T1被中止并释放R1。</li><li>T2可以继续执行并获得R1，完成操作后释放R2。</li><li>T1重新排队等待资源，并在R2可用时重新开始执行。</li></ul><h4 id="事务回滚法"><a href="#事务回滚法" class="headerlink" title="事务回滚法"></a>事务回滚法</h4><ul><li>系统检测到死锁。</li><li>系统选择T1进行回滚。</li><li>T1回滚到开始状态，释放R1。</li><li>T2可以继续执行并获得R1，完成操作后释放R2。</li><li>T1重新开始执行，并尝试获取R1和R2。</li></ul><p>这两种方法都通过打破资源的占用和等待关系来解决死锁，确保系统可以继续正常运行。</p><h2 id="6-在-IS、-IX、-IU、-U、-X、-SIX-中找出所有与-IS-和与-IX-相容的锁-（这个真的好难，，，"><a href="#6-在-IS、-IX、-IU、-U、-X、-SIX-中找出所有与-IS-和与-IX-相容的锁-（这个真的好难，，，" class="headerlink" title="6. 在 IS、 IX、 IU、 U、 X、 SIX 中找出所有与 IS 和与 IX 相容的锁.（这个真的好难，，，"></a>6. 在 IS、 IX、 IU、 U、 X、 SIX 中找出所有与 IS 和与 IX 相容的锁.（这个真的好难，，，</h2><p>意向锁（I）是表级锁！！<br>事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），这时事务B要给user表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。</p><p>意向锁相互兼容，因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。</p><p>I锁的实施是从根开始，依次占据路径上的所有节点，直至真正要进行显式封锁的节点的父节点为止。</p><p>IS锁：intent shared lock（意向共享锁，表示他的后裔节点（意向）加S锁<br>IX锁：intent exclusive lock（意向排他锁，表示他的后裔节点（意向）加X锁<br>SIX锁：S+IX 要读整个表并且会更新个别元组<br>（SIX非常特殊！他不是常规的表级锁，所以不能像别的意向锁一样直接和意向锁相容</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608233030.png"><br>持有U锁的时候不能做X操作。<br>只有一个事务可以持有U锁，所以U锁之间是不相容的</p><h2 id="7-写出两种预防转换死锁的手段。"><a href="#7-写出两种预防转换死锁的手段。" class="headerlink" title="7. 写出两种预防转换死锁的手段。"></a>7. 写出两种预防转换死锁的手段。</h2><p>死锁发生的四个必要条件是（TP-LINK秋招提前批的时候也考到了）：<br>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>只要发生死锁，上述四个条件一定满足，只要有一个条件不满足，就不会发生死锁</p><p>因此，要避免死锁，只要破坏上述四个条件之一，主要有以下方法：<br>静态分配资源：破坏条件（2）和（4）<br>按序分配资源：破坏条件（4）<br>剥夺式分配：破坏条件（3）</p><p>而互斥地使用资源是多进程能正确工作的前提，是必须保证满足的，不能破坏，否则就会出现问题如读写不一致</p><h2 id="8-描述两段锁协议的内容及作用"><a href="#8-描述两段锁协议的内容及作用" class="headerlink" title="8. 描述两段锁协议的内容及作用"></a>8. 描述两段锁协议的内容及作用</h2><p>增长阶段：事务可以获得锁，但不能释放锁<br>缩减阶段：事务可以释放锁，但不能获得锁</p><p>作用：若一组事务均服从两阶段封锁协议，则它们的调度一定是可串行化</p><h2 id="9-什么是先写日志的原则（WAL）？为什么要遵从这一原则？"><a href="#9-什么是先写日志的原则（WAL）？为什么要遵从这一原则？" class="headerlink" title="9. 什么是先写日志的原则（WAL）？为什么要遵从这一原则？"></a>9. 什么是先写日志的原则（WAL）？为什么要遵从这一原则？</h2><p>write ahead log<br>对于尚未提交的事务，在将DB缓冲区写到外存之前，必须先将日志缓冲区内容写到外存。</p><p>如果先写DB， 则可能在写的中途发生系统崩溃， 导致内存缓冲区内容丢失，而外存DB处于不一致状态，由于日志缓冲区内容已破坏， 导致无法对DB恢复</p><p>WAL可以保证恢复的一致性</p><h2 id="10-检查点的作用是什么？"><a href="#10-检查点的作用是什么？" class="headerlink" title="10. 检查点的作用是什么？"></a>10. 检查点的作用是什么？</h2><p>保证在检查点时刻磁盘上日志文件与数据库的内容是一致的</p><h2 id="11-从并发和恢复的角度描述长事务的危害性"><a href="#11-从并发和恢复的角度描述长事务的危害性" class="headerlink" title="11. 从并发和恢复的角度描述长事务的危害性"></a>11. 从并发和恢复的角度描述长事务的危害性</h2><p>长事务可能会在并发和恢复方面带来一些问题和挑战，以下是从这两个角度描述长事务的危害性：</p><h3 id="1-并发性问题"><a href="#1-并发性问题" class="headerlink" title="1. 并发性问题"></a>1. 并发性问题</h3><ul><li><p><strong>锁竞争</strong>：长事务持有锁的时间较长，可能会导致其他事务在等待该锁时出现阻塞，从而降低系统的并发性能。长事务与其他事务之间的锁竞争会增加系统中锁的数量和锁的持有时间，可能会导致死锁的发生。</p></li><li><p><strong>资源占用</strong>：长事务持有数据库资源（如行级锁、页级锁）的时间较长，可能会阻塞其他事务对相同资源的访问，从而降低系统的并发处理能力。如果长事务占用了大量资源，会导致系统其他部分的性能下降。</p></li><li><p><strong>隔离级别问题</strong>：长事务可能会导致隔离级别的升级，例如将隔离级别从Read Committed提升到Serializable，以确保长事务的数据一致性。这种升级会增加锁的数量和粒度，降低系统的并发性能。</p></li></ul><h3 id="2-恢复性问题"><a href="#2-恢复性问题" class="headerlink" title="2. 恢复性问题"></a>2. 恢复性问题</h3><ul><li><p><strong>事务日志增长</strong>：长事务持续进行期间，数据库系统需要持续记录其操作，这可能导致事务日志的增长。如果事务日志增长过快，可能会占用过多的存储空间，导致存储资源不足。</p></li><li><p><strong>恢复时间延长</strong>：长事务的持续时间较长，一旦发生故障需要进行数据库恢复时，系统需要回滚长事务的操作。由于长事务涉及的操作较多，可能导致恢复时间延长，影响系统的可用性和恢复性能。</p></li><li><p><strong>数据一致性问题</strong>：长事务的持续时间较长，可能会涉及到跨越多个数据库状态的操作。如果在长事务执行过程中发生故障，可能导致数据不一致的情况，需要进行额外的恢复和数据修复工作。</p></li></ul><h2 id="12-写出查询处理中三种连接的方法-哪种最适合两个规模很大的表间的等值连接？"><a href="#12-写出查询处理中三种连接的方法-哪种最适合两个规模很大的表间的等值连接？" class="headerlink" title="12. 写出查询处理中三种连接的方法. 哪种最适合两个规模很大的表间的等值连接？"></a>12. 写出查询处理中三种连接的方法. 哪种最适合两个规模很大的表间的等值连接？</h2><p>嵌套循环连接，块嵌套循环链接，索引嵌套循环连接，<strong>归并连接</strong>，散列连接</p><h2 id="13-列举-RAID1-和-RAID5-适用的数据库应用情景"><a href="#13-列举-RAID1-和-RAID5-适用的数据库应用情景" class="headerlink" title="13. 列举 RAID1 和 RAID5 适用的数据库应用情景"></a>13. 列举 RAID1 和 RAID5 适用的数据库应用情景</h2><p>当写操作较少且数据非常大时，RAID5较优，否则RAID1更优</p><h2 id="14-数据库的行结构填空"><a href="#14-数据库的行结构填空" class="headerlink" title="14. 数据库的行结构填空."></a>14. 数据库的行结构填空.</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240609002645.png"></p><h2 id="15-数据库基本页结构的三个组成部分是什么？"><a href="#15-数据库基本页结构的三个组成部分是什么？" class="headerlink" title="15. 数据库基本页结构的三个组成部分是什么？"></a>15. 数据库基本页结构的三个组成部分是什么？</h2><p>header（id、类型信息）、根据类型变化的内容、page尾部</p><h1 id="二、关系规范化"><a href="#二、关系规范化" class="headerlink" title="二、关系规范化"></a>二、关系规范化</h1><ol><li>给定关系模式 R 和函数依赖集 F.（1） 求所有候选码；（2） 判断 R 的范式级别；（3） 判断R 的一个二元分解是否是无损分解；（4） 求 F 在给定属性集上的投影.</li></ol><h1 id="三、事务调度"><a href="#三、事务调度" class="headerlink" title="三、事务调度"></a>三、事务调度</h1><ol><li>用 SQL 语句给出一个在 read committed 隔离性级别下丢失修改的例子.<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/8062872afcc7fce896f4c83e6074e47.jpg"></li><li>给定一个调度，画出带标记的优先图，并判断是否视图可串行化.<br>优先图无环则是冲突可串行化！！！</li><li>给定一个调度，在基于时间戳的并发控制协议下， 判断数据项最后的值.</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库概论期末复习</title>
    <link href="/2024/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-数据库系统简介"><a href="#第一章-数据库系统简介" class="headerlink" title="第一章 数据库系统简介"></a>第一章 数据库系统简介</h1><h2 id="什么是数据独立性？"><a href="#什么是数据独立性？" class="headerlink" title="什么是数据独立性？"></a>什么是数据独立性？</h2><p>物理独立性（存储结构）+逻辑独立性（逻辑结构）</p><h2 id="文件系统在数据管理方面有哪些不足？"><a href="#文件系统在数据管理方面有哪些不足？" class="headerlink" title="文件系统在数据管理方面有哪些不足？"></a>文件系统在数据管理方面有哪些不足？</h2><ol><li>数据与程序紧密结合：数据逻辑结构改变则必须修改应用程序</li><li>数据分散管理：许多文件，许多数据格式</li><li>数据的语义信息只能由程序解释</li><li>数据共享困难（因为不同应用的语义和数据组织方式不同，需要互相沟通</li><li>数据完整性难以维护（多副本容易造成数据不一致性</li><li>数据查询困难（文件系统眼中的数据是字符流，记录之间无联系，由用户自己编程实现，每个查询都需重新编写</li></ol><h2 id="数据库系统在管理方面的特性？"><a href="#数据库系统在管理方面的特性？" class="headerlink" title="数据库系统在管理方面的特性？"></a>数据库系统在管理方面的特性？</h2><ol><li>面向全组织（支持全企业的应用而不是某一个应用</li><li>数据冗余度小，易扩充</li><li>高数据独立性</li></ol><h2 id="数据模型的概念、种类、特性比较"><a href="#数据模型的概念、种类、特性比较" class="headerlink" title="数据模型的概念、种类、特性比较"></a>数据模型的概念、种类、特性比较</h2><p>概念：数据库系统中用于提供信息表示和操作手段的形式构架</p><p>种类：</p><ol><li>层次模型<br>用树结构表示实体之间联系，树由节点和连线组成，节点代表实体型，连线表示两实体型间的一对多联系。</li><li>网状模型<br>有向图（可以有一个以上的节点无父节点，至少有一个节点有多于一个的父节点（排除树））<br>节点代表实体型， 有向边（从箭尾到箭头）表示两实体型间的一对多联系</li><li>关系模型<br>用二维表来表示实体及其相互联系（逃离指针梦魇）</li><li>对象模型<br>用嵌套表表示复杂实体（我的类型我定义）</li></ol><p>特性比较：</p><p>层次模型：</p><ol><li>结构简单，易于实现</li><li>支持的联系种类太少<br> • 只支持二元一对多联系<br> • 只允许实体集间的一种联系，不支持实体集间的多种联系</li><li>数据操纵不方便<br> • 子结点的存取只能通过父结点来进行<br> • 插入、 删除复杂， 父结点的删除导致子结点的删除， 丢失必要的信息</li></ol><p>网状模型：<br>➢ 表达的联系种类丰富<br>➢ 性能良好， 存取效率高<br>➢ 结构复杂， 语言复杂</p><p>关系模型：</p><ol><li>简单：表的概念直观、单一，用户易理解</li><li>非过程化的数据请求：数据请求可以不指明路径</li><li>数据独立性高：用户只需提出“做什么”，无须说明“怎么做”</li><li>坚实的理论基础</li></ol><h2 id="数据库模式：三级模式、两级映像"><a href="#数据库模式：三级模式、两级映像" class="headerlink" title="数据库模式：三级模式、两级映像"></a>数据库模式：三级模式、两级映像</h2><p>为什么要进行模式分级？<br>• 提高数据的物理独立性和逻辑独立性<br>• 将数据库的用户观点，即用户看到的数据库，与数据库的物理方面，即实际存储的数据库区分开来</p><h3 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a>三级模式</h3><p>外模式（Sub-Schema<br>• 用户的数据视图<br>• 数据的局部逻辑结构，模式的子集</p><p>模式（Schema<br>• 所有用户的公共数据视图<br>• 数据库中全体数据的全局逻辑结构和特性的描述</p><p>内模式（Storage Schema<br>• 存储模式, 数据的物理结构及存储方式<br>• 位置、压缩、分区、合并、索引、列式</p><h3 id="两级映像"><a href="#两级映像" class="headerlink" title="两级映像"></a>两级映像</h3><p>外模式&#x2F;模式映象</p><p>定义某个外模式和模式之间的对应关系，映象定义通常包含在各外模式中<br>当模式改变时，修改外模式&#x2F;模式映象，使外模式保持不变，从而应用程序可以保持不变，称为数据的逻辑独立性<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240615132600.png"><br>模式&#x2F;内模式映象</p><p>定义数据逻辑结构与存储结构之间的对应关系<br>存储结构改变时，修改模式&#x2F;内模式映象，使模式保持不变，从而应用程序可以保持不变，称为数据的物理独立性</p><h2 id="数据库是如何保证数据独立性的？"><a href="#数据库是如何保证数据独立性的？" class="headerlink" title="数据库是如何保证数据独立性的？"></a>数据库是如何保证数据独立性的？</h2><p>数据库通过三级模式两级映像来实现数据独立性。这是一种标准的数据库体系结构，用于分离数据的物理存储、逻辑结构和用户视图，从而实现数据的独立性。具体来说，三级模式包括内部模式（物理层）、概念模式（逻辑层）和外部模式（视图层），两级映像指的是外部&#x2F;概念映像和概念&#x2F;内部映像。</p><h3 id="三级模式体系结构"><a href="#三级模式体系结构" class="headerlink" title="三级模式体系结构"></a>三级模式体系结构</h3><ol><li><p><strong>内部模式（物理层）</strong>：</p><ul><li>描述数据在数据库内部的物理存储结构。它定义了存储方式、文件结构、索引、存取路径等。</li><li>通过概念&#x2F;内部映像实现物理独立性：即使物理存储方式改变，概念模式（逻辑结构）也不受影响。</li></ul></li><li><p><strong>概念模式（逻辑层）</strong>：</p><ul><li>描述整个数据库的逻辑结构和关系。这一层定义了所有的数据库实体、数据类型、关系、约束等。</li><li>通过外部&#x2F;概念映像实现逻辑独立性：即使概念模式改变，外部模式（用户视图）也不受影响。</li></ul></li><li><p><strong>外部模式（视图层）</strong>：</p><ul><li>描述用户或应用程序看到的数据库部分。不同的用户或应用程序可以有不同的视图。</li><li>提供数据的安全性和个性化视图，隐藏了数据的复杂性。</li></ul></li></ol><h3 id="两级映像-1"><a href="#两级映像-1" class="headerlink" title="两级映像"></a>两级映像</h3><ol><li><p><strong>外部&#x2F;概念映像</strong>：</p><ul><li>将外部模式（视图）映射到概念模式（逻辑结构）。外部模式的变更通过这种映像不影响概念模式，确保了逻辑独立性。</li><li>例如，一个用户视图可能只显示特定表的某些列，即使概念模式中的表结构发生变化，只要视图的定义保持不变，用户视图就不会受到影响。</li></ul></li><li><p><strong>概念&#x2F;内部映像</strong>：</p><ul><li>将概念模式（逻辑结构）映射到内部模式（物理存储）。概念模式的变更通过这种映像不影响内部模式，确保了物理独立性。</li><li>例如，数据库管理员可以改变数据的存储方式（如添加索引或分区）以提高性能，而不影响概念模式的定义。</li></ul></li></ol><h2 id="DBMS各项功能"><a href="#DBMS各项功能" class="headerlink" title="DBMS各项功能"></a>DBMS各项功能</h2><ol><li><p>DBMS的数据定义功能<br> DDL语言<br> • Data Description Language<br> • 描述外模式、模式、内模式（源模式）</p><p> 模式翻译程序<br> • 把源模式翻译成目标模式，存入数据字典中</p></li><li><p>DBMS的数据存取功能<br> DML语言<br> • Data manipulation Language<br> • 对数据库进行检索、插入、修改、删除</p><p> DML类型<br> • 宿主型：DML不独立使用，嵌入到高级语言（主语言）程序中使用<br> • 自含型：独立使用，交互式命令方式DML语句</p><p> 执行方式<br> • 宿主型：预编译和增强编译<br> • 自含型：解释执行</p></li><li><p>DBMS的数据控制功能<br> 数据库运行管理<br> • 并发控制、存取控制、完整性约束条件检查和执行，日志组织和管理，事务管理和自动恢复</p><p> 数据组织存储和管理<br> • 用户数据、索引、数据字典的组织、存储和管理，包括文件结构、存取方式、数据之间联系的实现</p><p> 数据库建立和维护功能<br> • 数据的装入、转换、卸出，<br> • 数据库的转储、恢复、性能监视和分析</p></li></ol><h2 id="DBA的职责"><a href="#DBA的职责" class="headerlink" title="DBA的职责"></a>DBA的职责</h2><pre><code class="hljs">建库方面• 确定模式、 外模式、 存储结构、 存取策略• 负责数据的整理和装入用库方面• 定义完整性约束条件• 规定数据的保密级别、 用户权限• 监督和控制数据库的运行情况• 制定后援和恢复策略， 负责故障恢复改进方面• 监督分析系统的性能（空间利用率， 处理效率）• 数据库重组织， 物理上重组织， 以提高性能• 数据库重构造， 设计上较大改动， 模式和内模式修改</code></pre><h1 id="第二章-实体-联系模型"><a href="#第二章-实体-联系模型" class="headerlink" title="第二章 实体-联系模型"></a>第二章 实体-联系模型</h1><p>实体(Entity)：客观存在并可相互区分的事物叫实体</p><p>属性(Attribute)：<br>• 实体所具有的某一特性;<br>• 一个实体可以由若干个属性来刻画</p><p>域(Domain)：属性的取值范围</p><p>联系(Relationship)：实体之间的相互关联</p><p>超码(superkey)：能唯一标识实体的属性或属性组</p><p>候选码(candidate key)：其任意真子集都不能成为超码的最小超码</p><p>主码(primary key)：从所有候选码中选定一个用来区别同一实体集中的不同实体</p><p>联系的种类：实体之间的联系的数量，即一个实体通过一个联系集能与另一实体集相关联的实体的数目（用箭头或线段来表示）</p><p>联系的势：势表达了一个实体出现在联系中的次数（区分可选性和强制性联系）</p><p>弱实体集：一个实体集的所有属性都不足以形成主码</p><p>特化：<br>实体集中某些子集具有区别于该实体集内其它实体的特性，可以根据这些差异特性对实体集进行分组，这一分组的过程称作特化<br>如：银行帐号特化为存款帐号、贷款帐号，学生特化为研究生、 本科生</p><p>概化：<br>特化的逆过程。各个实体集根据共有的性质，合成一个较高层的实体集。 概化是一个高层实体集与若干个低层实体集之间的包含关系</p><p>聚集：<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240615135106.png"></p><h1 id="第三章-关系模型"><a href="#第三章-关系模型" class="headerlink" title="第三章 关系模型"></a>第三章 关系模型</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>笛卡尔积：<br>一组域𝐷1, 𝐷2, … , 𝐷𝑛的笛卡尔积为:<br>𝐷1 × 𝐷2 × ⋯ × 𝐷𝑛 &#x3D; {𝑑1, 𝑑2, … , 𝑑𝑛| 𝑑𝑖 ∈ 𝐷𝑖, 𝑖 &#x3D; 1, … , 𝑛}</p><p>关系模型三要素：</p><ol><li>数据结构<br>单一的数据结构——关系<br>实体集、联系都表示成关系</li><li>数据完整性<br>实体完整性：关系的主码中的属性值不能为空值。（关系对应到现实世界中的实体集， 元组对应到实体， 实体是相互可区分的， 通过主码来唯一标识，若主码为空， 则出现不可标识的实体， 这是不容许的<br>参照完整性：如果关系𝑅2的某个元组𝑡2参照了关系𝑅1的某个元组𝑡1,则𝑡1必须存在， 也即必须与客观存在的实体发生联系（实在不行等于空值也行。但是不能参照某个不存在的实体<br>用户定义完整性：用户针对具体应用环境定义的完整性约束条件（如选课人数不能少于10人， 多于100人</li><li>数据操作<br>关系操作是集合操作，操作的对象及结果都是集合，是一次一集合(Set-at-a-time)的方式<br>非关系型的数据操作方式是一次一记录(Record-at-a-time)</li></ol><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97.jpg"><br>外连接：<br>为避免自然连接时因失配而发生的信息丢失， 可以假定往参与连接的一方表中附加一个取值全为空值的行， 它和参与连接的另一方表中的任何一个未匹配上的元组都能匹配， 称之为外连接</p><p>外连接的形式：左外连接、右外连接、全外连接<br>左外连接 &#x3D; 自然连接 + 左侧表中未匹配元组<br>右外连接 &#x3D; 自然连接 + 右侧表中未匹配元组<br>全外连接 &#x3D; 自然连接 + 两侧表中未匹配元组</p><p>除法运算：<br>（某一篇博客中有具体谈到）<br>在被除表中，同时满足除数表的所有条件，但没有除数表中的字段的新表（如果结果有多条记录要全部列出）。</p><h1 id="第四章-SQL"><a href="#第四章-SQL" class="headerlink" title="第四章 SQL"></a>第四章 SQL</h1><h2 id="数据类型的定义"><a href="#数据类型的定义" class="headerlink" title="数据类型的定义"></a>数据类型的定义</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240615153359.png"></p><h2 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h2><p>关系表是个无序集合</p><p>索引存储结构：B+树</p><p>作用：</p><ol><li>查找元组</li><li>排序</li><li>表连接</li><li>分组</li><li>保证唯一性</li></ol><p>索引碎片：页面逻辑顺序与物理顺序不一致（解决方案：聚簇索引cluster</p><p>聚簇索引：<br>表中元组按索引项的值排序并物理地聚簇在一起<br>一个基本表上只能建一个聚簇索引</p><p>覆盖索引：include<br>把select中的列也包含进索引中， 这样就可以完全基于索引回答查询， 避免回表</p><p>过滤索引：在索引的定义中加入where语句， 索引中只包括那些满足过滤条件的列值</p><p>create index filter_idx1 on R(A) where A is not null</p><p>数据的物理独立性：<br>索引如何使用完全由系统决定</p><p>索引可以提高查询效率<br>耗费空间<br>降低插入、 删除、 更新效率</p><h1 id="第五章-服务器脚本语言"><a href="#第五章-服务器脚本语言" class="headerlink" title="第五章 服务器脚本语言"></a>第五章 服务器脚本语言</h1><p>游标定义：在查询结果的记录集合中移动的指针<br>需要游标的数据操作：当select语句的结果中包含多行时， 使用游标可以逐个存取这些行</p><p>触发器定义：触发器是一条语句，当对数据库做修改时，它自动被系统执行</p><p>约束级别：</p><p>数据库约束级别用于确保数据的完整性和一致性。</p><ol><li><p><strong>域约束（Domain Constraints）</strong>：</p><ul><li>限制列中的数据类型和取值范围。例如，规定某列只能包含整数或日期类型的数据。</li><li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Employees (<br>    EmployeeID <span class="hljs-type">INT</span>,<br>    Name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    Age <span class="hljs-type">INT</span> <span class="hljs-keyword">CHECK</span> (Age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> Age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">65</span>)<br>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>实体完整性约束（Entity Integrity Constraints）</strong>：</p><ul><li>确保表中的每一行都有一个唯一标识符，通常通过主键实现。</li><li>主键（Primary Key）：每个表都应有一个主键，主键列中的值必须唯一且不能为NULL。</li><li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Employees (<br>    EmployeeID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    Name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    Age <span class="hljs-type">INT</span><br>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>参照完整性约束（Referential Integrity Constraints）</strong>：</p><ul><li>确保表之间的关系有效，通过外键实现。</li><li>外键（Foreign Key）：一列或多列在另一表中有对应的主键或唯一键。</li><li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Departments (<br>    DepartmentID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    DepartmentName <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Employees (<br>    EmployeeID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    Name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    DepartmentID <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">FOREIGN</span> KEY (DepartmentID) <span class="hljs-keyword">REFERENCES</span> Departments(DepartmentID)<br>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>唯一性约束（Unique Constraints）</strong>：</p><ul><li>确保某列或某些列的值在表中唯一，类似于主键，但允许NULL值。</li><li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Employees (<br>    EmployeeID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    Email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">UNIQUE</span>,<br>    Name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>检查约束（Check Constraints）</strong>：</p><ul><li>通过特定的条件检查数据的有效性。</li><li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Employees (<br>    EmployeeID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    Name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    Age <span class="hljs-type">INT</span>,<br>    Salary <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>),<br>    <span class="hljs-keyword">CHECK</span> (Salary <span class="hljs-operator">&gt;=</span> <span class="hljs-number">30000</span>)<br>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>非空约束（Not Null Constraints）</strong>：</p><ul><li>确保列中不能有NULL值。</li><li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Employees (<br>    EmployeeID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>    Name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    Age <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br>);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h1 id="第六章-非关系数据"><a href="#第六章-非关系数据" class="headerlink" title="第六章 非关系数据"></a>第六章 非关系数据</h1><p>略</p><h1 id="第七章-关系规范化"><a href="#第七章-关系规范化" class="headerlink" title="第七章 关系规范化"></a>第七章 关系规范化</h1><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240610150742.png"></p><h2 id="数据异常包括哪些？"><a href="#数据异常包括哪些？" class="headerlink" title="数据异常包括哪些？"></a>数据异常包括哪些？</h2><p>信息的不可表示问题</p><p>插入异常：如果没有职工具有8级工资， 则8级工资的工资数额就难以插入<br>删除异常：如果仅有职工赵明具有4级工资， 删除赵明则会将有关4级工资的工资数额信息也一并删除</p><p>信息的冗余问题</p><p>数据冗余：职工很多， 工资级别有限， 每一级别的工资数额反复存储多次<br>更新异常：如果将5级工资的工资数额调为620， 则需要找到每个具有5级工资的职工， 逐一修改</p><p><strong>解决之道：</strong><br>分解！分解！！再分解！！！</p><h2 id="各种依赖的定义"><a href="#各种依赖的定义" class="headerlink" title="各种依赖的定义"></a>各种依赖的定义</h2><p>函数依赖 部分函数依赖 完全函数依赖 传递函数依赖 多值依赖（多对多属性组<br>如果X → Y， Y包含于X， 则称其为平凡的函数依赖。否则称为非平凡的函数依赖<br>如果R(U)的候选码是整个属性集U，这称为全码</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240610151154.png"></p><h2 id="各种NF范式概念"><a href="#各种NF范式概念" class="headerlink" title="各种NF范式概念"></a>各种NF范式概念</h2><p>范式是对关系的不同数据依赖程度的要求<br>1NF：不可再分<br>2NF：1NF消除部分依赖（每个非主属性完全依赖于码<br>3NF：2NF消除传递依赖<br>BCNF：每个非平凡函数依赖的左侧都必须是超键<br>4NF：消除多值依赖</p><h2 id="逻辑蕴含"><a href="#逻辑蕴含" class="headerlink" title="逻辑蕴含"></a>逻辑蕴含</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240615155719.png"></p><h2 id="Armstrong公理"><a href="#Armstrong公理" class="headerlink" title="Armstrong公理"></a>Armstrong公理</h2><p>自反律 增广律 传递律<br>借助逻辑蕴涵定义及自反律实现正确性证明</p><h2 id="函数依赖集等价性以及最小覆盖"><a href="#函数依赖集等价性以及最小覆盖" class="headerlink" title="函数依赖集等价性以及最小覆盖"></a>函数依赖集等价性以及最小覆盖</h2><p><a href="https://blog.csdn.net/icurious/article/details/51240114">csdn链接</a><br><strong>计算最小函数依赖集步骤：</strong><br>① 用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；<br>② 去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，看X+是否包含Y，若是，则去掉X→Y；否则不能去掉，依次做下去。直到找不到冗余的函数依赖；<br>③去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。例如XY→A，若要判Y为多余的，则以X→A代替XY→A是否等价？若A∈(X)+，则Y是多余属性，可以去掉。<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.jpg" alt="最小覆盖"></p><h2 id="关系模式分解"><a href="#关系模式分解" class="headerlink" title="关系模式分解"></a>关系模式分解</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240615160330.png"><br>目标：<br>消除异常：达到更高级范式<br>信息保真：无损连接分解<br>避免违约：保持函数依赖</p><h2 id="保持函数依赖的分解"><a href="#保持函数依赖的分解" class="headerlink" title="保持函数依赖的分解"></a>保持函数依赖的分解</h2><p>tbc</p><h2 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h2><p>tbc</p><h2 id="3NF分解"><a href="#3NF分解" class="headerlink" title="3NF分解"></a>3NF分解</h2><p><a href="https://zhuanlan.zhihu.com/p/538080461">知乎链接</a><br><strong>3NF分解步骤</strong>：</p><ol><li>先求出正则覆盖Fc</li><li>对于Fc里面的所有函数依赖a-&gt;b,均转化为Ri&#x3D;ab</li><li>对于所有的模式Ri<br> ①如果包含候选码，进行4.<br> ②如果都不包含候选码， 将任意一个候选码添加到模式Ri里面</li><li>如果一个模式被另一个模式包含，则去掉此被包含的模式。</li></ol><h2 id="BCNF分解"><a href="#BCNF分解" class="headerlink" title="BCNF分解"></a>BCNF分解</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>输入：关系R0和其上的函数依赖集S0<br>输出：由R0分解出的关系集合，其中每个关系均属于BCNF<br>方法：下列步骤可以被递归地用于任意关系R和FD集合S。初始时，R&#x3D;R0，S&#x3D;S0。</p><p>检验R是否属于BCNF。如果是，不需要做任何事，返回{R}作为结果。<br>如果存在BCNF违例，假设为X→Y。计算X+。选择R1&#x3D;X+作为一个关系模式，并使另一个关系模式R2包含属性X以及那些不在X+中的属性。<br>（对于R2，它将包含所有不在X+中的属性，因此X → Y 的函数依赖不会存在于R2中，因为X已经被分解到了R1中。所以，R2一定是满足BCNF的。）<br>计算R1和R2的FD集，分别记为S1和S2。<br>递归地分解R1和R2。返回这些分解得到的结果集合。</p><h3 id="通俗的描述"><a href="#通俗的描述" class="headerlink" title="通俗的描述"></a>通俗的描述</h3><p>当一个关系模式违反BCNF时，意味着存在非平凡的函数依赖，其左侧不是任何候选键的超键。</p><p>具体来说，一个关系模式违反BCNF的条件是：</p><p>存在一个非平凡的函数依赖X → Y。<br>X 不是任何候选键的超键。<br>如果存在这样的函数依赖，那么该关系模式就违反了BCNF。</p><h3 id="什么是超键"><a href="#什么是超键" class="headerlink" title="什么是超键"></a>什么是超键</h3><p>候选键的超键是以候选键为子集的超键。</p><p>一个候选键是能够唯一标识关系中的每个元组的最小属性集合。而一个超键是能够唯一标识关系中的每个元组的任意属性集合。</p><p>因此，候选键的超键必然包含了候选键本身，以及候选键的任何真子集。因为候选键本身已经能够唯一标识关系中的每个元组，所以任何包含候选键的超键也能够唯一标识关系中的每个元组。</p><p>举个例子，如果 {A, B} 是一个候选键，那么 {A, B} 和 {A, B, C} 都是候选键的超键，因为它们包含了候选键 {A, B}。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://blog.csdn.net/weixin_42319408/article/details/92066595">例题链接跳转</a><br>如：R(A,B,C,D,E) FD{AB→C,DE→C,B→D}<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/BCNF%E5%88%86%E8%A7%A3%E4%BE%8B%E9%A2%98.jpg" alt="BCNF分解例题"><br>R(ABCDE), F &#x3D; { AB → C, B → D, CD →  E , CE → B , AC → B }<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BD%9C%E4%B8%9A%E4%BE%8B%E9%A2%98.jpg"></p><p>更详细的解释：<br>以最后那道例题为例，候选键为AB, AC<br>我们可以发现原来的函数依赖中，B-&gt;D, CD-&gt;E, CE-&gt;B的左侧都不是候选键的超键，所以我们接下来要做的就是消除这些不是超键的非平凡函数依赖，所以我们会采用CD+ CE+去消除掉（其中CE已经是那个子分解的超键了，所以不做处理</p><h1 id="第八章-事务"><a href="#第八章-事务" class="headerlink" title="第八章 事务"></a>第八章 事务</h1><h2 id="事务定义及事务的ACID特性"><a href="#事务定义及事务的ACID特性" class="headerlink" title="事务定义及事务的ACID特性"></a>事务定义及事务的ACID特性</h2><p><strong>事务定义：</strong><br>一系列操作序列构成的执行单元，这些操作要么都做，要么都不做，是一个不可分割的工作单位。</p><p>转账事务必须保证数据完整性</p><p>比如A给B转了250，那么A存款减去250，和B存款加250必须是一个整体！！（不然的话就会出现转账没成功，但是A扣了250，B却没收到钱，大冤种）</p><p><strong>事务基本特性：ACID</strong><br>原子性A：atomicity 由恢复机制实现（要么全做 要么全不做<br>一致性C：事务开始前处于一致性 结束后依然处于一致性（由用户来负责实现，如银行转账前后两个账户金额总和应保持不变<br>隔离性I：和操作系统很像。系统必须保证事务不受其它并发执行事务的影响对任何一对事务T1， T2， 在T1看来，T2要么在T1开始之前已经结束， 要么在T1完成之后再开始执行，隔离性通过并发控制机制实现。<br>持久性D：故障处理。通过恢复机制实现。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> transaction isolation level read committed ;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">update</span> accounts <span class="hljs-keyword">set</span> amounts <span class="hljs-operator">=</span> amounts <span class="hljs-operator">-</span> <span class="hljs-number">50</span> <span class="hljs-keyword">where</span> userId<span class="hljs-operator">=</span><span class="hljs-string">&#x27;A&#x27;</span> ;<br><span class="hljs-keyword">update</span> accounts <span class="hljs-keyword">set</span> amounts <span class="hljs-operator">=</span> amounts <span class="hljs-operator">+</span> <span class="hljs-number">50</span> <span class="hljs-keyword">where</span> userId<span class="hljs-operator">=</span><span class="hljs-string">&#x27;B&#x27;</span> ;<br><span class="hljs-keyword">commit</span>;<br></code></pre></td></tr></table></figure><p>事务执行模式：</p><p>显式事务（事务以begin开始，以commit或rollback结束）<br>隐含事务（sql server，事务自动开始，直到遇到commit或rollback时结束）<br>自动事务（mysql）（set autocommit</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240609140617.png" alt="事务生命周期图"></p><h2 id="可恢复调度与无级联调度"><a href="#可恢复调度与无级联调度" class="headerlink" title="可恢复调度与无级联调度"></a>可恢复调度与无级联调度</h2><p>可恢复调度：<br>一个事务失败了，应该能够撤消该事务对数据库的影响<br>如果有其它事务读取了失败事务写入的数据，则该事务应该撤消</p><p>无级联调度：<br>对于每对事务T1与T2， 如果T2读取了T1所写的数据， 则T1必须先于T2提交<br>无级联调度必是可恢复调度</p><p>级联调度：<br>由于一个事务故障而导致一系列事务回滚</p><h2 id="调度中的四种数据不一致性"><a href="#调度中的四种数据不一致性" class="headerlink" title="调度中的四种数据不一致性"></a>调度中的四种数据不一致性</h2><p>串行调度与并行调度</p><p>串行：<br>一个事务是不可分割的整体。一个事务执行完之后才能执行另一个事务</p><p>并行：<br>来自不同事务的指令可以交叉执行<br>（当并行调度等价于某个串行调度时，则称它为正确的</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240609140950.png" alt="并行与串行的比较"></p><p>并发调度中存在不一致现象</p><ol><li><p>丢失修改：<br>写写不一致<br>两个事务T1和T2读入同一数据并修改， T1提交的结果破坏了T2提交的结果， 导致T2的修改丢失</p></li><li><p>脏读：<br>写读不一致<br>事务T1修改某一数据并将其写回磁盘， 事务T2读取同一数据。此后T1由于某种原因被撤消， 其已修改过的数据恢复原值， 造成T2读到的数据与数据库中数据不一致， 则T2读到的就是脏数据</p></li><li><p>不可重复读：<br>读写不一致<br>事务T2读取某一数据后， 事务T1对其做了修改，当T2再次读取该数据时， 得到与前次不同的值</p></li><li><p>幻读：<br>插读不一致<br>事务T2按一定条件读取某些数据后， 事务T1插入一些满足这些条件的数据， 当T2再次按相同条件读取数据时， 发现多了一些记录</p></li></ol><h2 id="SQL中四个事务隔离性级别定义"><a href="#SQL中四个事务隔离性级别定义" class="headerlink" title="SQL中四个事务隔离性级别定义"></a>SQL中四个事务隔离性级别定义</h2><p>read uncommitted<br>允许读取未提交的记录<br>read committed<br>只允许读取已提交的记录，但不要求可重复读<br>repeatable read<br>只允许读取已提交记录， 并且一个事务对同一记录的两次读取之间，其它事务不能对该记录进行更新<br>serializable 调度的执行必须等价于串行调度<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240609144054.png"></p><p>隔离性级别的内部实现：加锁 S锁和X锁</p><p>补：什么是记录锁<br><a href="https://blog.csdn.net/Tomwildboar/article/details/134342139">csdn链接，mysql中的锁机制</a><br>当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定。如下面语句的id列有唯一索引，此时只会对id值为10的行使用记录锁。<br>记录锁是基于索引记录上的锁，它锁定的行数是固定的、明确的，根据情况它可以是共享锁、排他锁。</p><p>补：什么是间隙锁<br><a href="https://blog.csdn.net/zcl_love_wx/article/details/82382582">csdn链接</a><br>间隙锁的作用<br>保证<strong>某个间隙内的数据</strong>在锁定情况下不会发生任何变化。比如我mysql默认隔离级别下的可重复读（RR）。</p><p>补：什么是临键锁<br>临键锁（Next-key Locks）：等于 记录锁+间隙锁，所以我们只需要知道这两个锁的定义就好了，MySQL默认级别是RR、默认锁上临键锁。</p><p>四种隔离级别用悲观锁具体咋实现的：<br><a href="https://blog.csdn.net/kking_edc/article/details/110848986">csdn链接</a><br>读未提交：<br>执行写操作时加X锁，并且执行完写操作后立即释放，而不像其他隔离级别在事务提交以后释放（就连写写操作都很难引起锁竞争</p><p>读提交：<br>将锁的释放时机延迟到事务提交之后，解决了脏读。但是，锁的释放时机延迟了，不仅写与写操作之间会产生锁竞争，在锁释放之前，也无法执行读操作，这对并发性产生了很大的影响。为了提高并发性，MySQL采用了一种名为MVCC的解决方案：无视当前持有锁的事务，读取最新的历史版本数据。</p><p>在读提交的级别下，我们每次执行select操作时都会通过MVCC获取当前数据的最新快照，不加任何锁，也无视任何锁(因为历史数据是构造出来的，身上不可能有锁)，完美解决读写之间的并发问题，和读未提交的并发性能只差在写写操作上。</p><p>MVCC版本的生成时机: 每次select时生成，这就意味着，如果我们在事务A中执行多次的select，在每次select之间有其他事务更新了我们读取的数据并提交了，那就出现了不可重复读</p><p>锁的范围: 因为没有间隙锁，这就意味着，如果我们在事务A中多次执行select * from user where age&gt;18 and age&lt;30 for update时，其他事务是可以往age为(18,30)这个区间插入&#x2F;删除数据的，那就出现了幻读</p><p>所以，要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」。</p><p>MySQL 在「可重复读」隔离级别下（MySQL InnoDB引擎的默认隔离级别），可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免），所以 MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能。MySQL对于幻读的解决方案有两种：</p><p>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。<br>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</p><p>MySQL的数据存储结构：</p><p>在主键索引形成的B+Tree里面，非叶子结点存储的是主键索引，叶子结点存储的是数据<br>在非主键索引形成的B+Tree里面，非叶子结点存储的是当前索引，叶子结点存储的是主键索引<br>如果没有主键索引，会拿第一个唯一索引来做聚簇索引，如果也没有唯一索引就会创建一个看不见的唯一键。<br>所以当通过非主键索引去找数据的时候，其实是先通过非主键索引找到主键索引，再通过主键索引去找数据，这个过程被称为 回表。</p><p>锁都是基于索引去找到数据记录再加锁的，而索引的规则是：通过其它索引找到主键索引，所以：</p><p>没有使用索引做更新相关操作会锁表。<br>通过唯一&#x2F;主键索引等值加锁，只会锁具体的行，非唯一索引则不一定，SQL优化器会基于数据分布选择记录锁，或临键锁。<br>只有在RR级别下才有间隙锁，目的是为了解决幻读，如果操作的数据是跨多个范围，就会加多个区间的间隙锁。<br>MySQL默认的锁就是【临键锁】，所以在执行SQL的时候，记录锁和间隙锁是会同时存在的。范围是左开右闭的区间。</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240609144248.png"></p><h2 id="快照隔离"><a href="#快照隔离" class="headerlink" title="快照隔离"></a>快照隔离</h2><p>SI：快照隔离，任何读取操作得到事务开始那一刻最近已经提交过的数据版本，属于事务级快照隔离</p><p>其实快照隔离和乐观锁比较类似。不加锁，直接搞版本。悲观锁就是加各种锁预防冲突。</p><p>悲观锁：<br>缺点：<br>基本思想：通过加锁预防冲突（读-写、 写-写）<br>基本机制：事务在进行读写操作之前先申请锁<br>不适合以读为主的冲突几率低的应用场合<br>不必要的预防代价过高（读-读）</p><p>针对读密集应用，不加锁直接访问数据会怎样？<br>• 避免了加锁开销， 直接执行读写操作效率高<br>• 通过回滚一方事务来解决事务间已经发生的冲突</p><p>乐观锁</p><p>在 Snapshot Isolation 下，不会出现脏读、不可重复度和幻读三种读异常。并且读操作不会被阻塞，对于读多写少的应用 Snapshot Isolation 是非常好的选择。并且，在很多应用场景下，Snapshot Isolation 下的并发事务并不会导致数据异常。</p><p>写偏序（write skew）<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240609222658.png"><br>为了避免 write skew，应用程序必须根据具体的情况去做适配，比如使用SELECT … FOR UPDATE，或者在应用层引入写写冲突。这样做相当于把数据库事务的一份工作扔给了应用层。</p><p>SI：快照隔离，任何读取操作得到事务开始那一刻最近已经提交过的数据版本，属于事务级快照隔离</p><p>RCSI：已提交读快照隔离，任何读取操作得到语句开始那一刻最近已经提交过的数据版本，属于语句级快照隔离</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240609223021.png"></p><h2 id="冲突可串行化及其判定"><a href="#冲突可串行化及其判定" class="headerlink" title="冲突可串行化及其判定"></a>冲突可串行化及其判定</h2><p>冲突指令： 两条指令是不同事务在相同数据项上的操作， 并且其中至少有一个是write指令</p><p>非冲突指令交换次序不会影响调度的最终结果</p><p>冲突等价<br>如果调度S可以经过交换一系列非冲突指令转换成调度S’， 则称调度S与S’是冲突等价的</p><p>当一个调度S与一个串行调度冲突等价时，则称该调度是冲突可串行化的</p><p>优先图(precedence graph)<br>调度S的优先图的构造方式：它是一个有向图G &#x3D;(V，E)， V是顶点集， E是边集。 顶点集由所有参与调度的事务组成， 边集由满足下述条件之一的边Ti→Tj组成：</p><p>① 在Tj执行read(Q)之前， Ti执行write(Q)<br>② 在Tj执行write(Q)之前， Ti执行read(Q)<br>③ 在Tj执行write(Q)之前， Ti执行write(Q)</p><p><a href="https://blog.csdn.net/J080624/article/details/84946940">优先图画法csdn链接</a></p><p>就是：i≠j，存在事务Ti中的操作A1和Tj中的操作A2，A1在A2前，且为冲突操作，就将Ti指向Tj</p><p>优先图无环则是冲突可串行化！！！</p><h2 id="视图可串行化及其判定"><a href="#视图可串行化及其判定" class="headerlink" title="视图可串行化及其判定"></a>视图可串行化及其判定</h2><p>从读一致性（两种调度读取的东西是等价的<br>𝑺𝟏 中的从读关系<br>• 𝒓𝟏(𝑨)读取的是数据库中的初值<br>• 𝒓𝟏(𝑩)读取的是数据库中的初值<br>• 𝒓𝟐(𝑨)读取的是𝒘𝟏(𝑨)<br>• 𝒓𝟐(𝑩)读取的是𝒘𝟏(𝑩)<br>𝑺𝟑中的从读关系<br>• 𝒓𝟏(𝑨)读取的是数据库中的初值<br>• 𝒓𝟏(𝑩)读取的是数据库中的初值<br>• 𝒓𝟐(𝑨)读取的是数据库中的初值<br>• 𝒓𝟐(𝑩)读取的是𝒘𝟏(𝑩)<br>（这种就不满足从读一致性</p><p>如果某个调度视图等价于一个串行调度，则称该调度是视图可串行化的</p><p>冲突可串行化调度一定是视图可串行化的，存在视图可串行化但非冲突可串行化的调度</p><p>看不懂那个环的操作，略过吧</p><h1 id="第九章-并发控制（非常重要，17年考了很多）"><a href="#第九章-并发控制（非常重要，17年考了很多）" class="headerlink" title="第九章 并发控制（非常重要，17年考了很多）"></a>第九章 并发控制（非常重要，17年考了很多）</h1><h2 id="各种封锁模式：X锁、S锁、U锁、IS锁、IX锁、SIX锁"><a href="#各种封锁模式：X锁、S锁、U锁、IS锁、IX锁、SIX锁" class="headerlink" title="各种封锁模式：X锁、S锁、U锁、IS锁、IX锁、SIX锁"></a>各种封锁模式：X锁、S锁、U锁、IS锁、IX锁、SIX锁</h2><p>意向锁（I）是表级锁！！<br>事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），这时事务B要给user表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。</p><p>意向锁相互兼容，因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。</p><p>I锁的实施是从根开始，依次占据路径上的所有节点，直至真正要进行显式封锁的节点的父节点为止。</p><p>IS锁：intent shared lock（意向共享锁，表示他的后裔节点（意向）加S锁<br>IX锁：intent exclusive lock（意向排他锁，表示他的后裔节点（意向）加X锁<br>SIX锁：S+IX 要读整个表并且会更新个别元组<br>（SIX非常特殊！他不是常规的表级锁，所以不能像别的意向锁一样直接和意向锁相容</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608233030.png"><br>持有U锁的时候不能做X操作。<br>只有一个事务可以持有U锁，所以U锁之间是不相容的</p><h2 id="两段锁协议内容及其作用"><a href="#两段锁协议内容及其作用" class="headerlink" title="两段锁协议内容及其作用"></a>两段锁协议内容及其作用</h2><p>增长阶段：事务可以获得锁，但不能释放锁<br>缩减阶段：事务可以释放锁，但不能获得锁</p><p>作用：若一组事务均服从两阶段封锁协议，则它们的调度一定是可串行化</p><h2 id="死锁及其解决措施"><a href="#死锁及其解决措施" class="headerlink" title="死锁及其解决措施"></a>死锁及其解决措施</h2><p>详见17年往年题</p><h2 id="基于时间戳的并发控制协议"><a href="#基于时间戳的并发控制协议" class="headerlink" title="基于时间戳的并发控制协议"></a>基于时间戳的并发控制协议</h2><p>◆ 每个事务 𝑻𝒊 进入系统被分配一个时间戳 𝑻𝑺(𝑻𝒊)<br>◆ 如果 𝑻𝒋 晚于 𝑻𝒊进入系统， 𝑻𝑺(𝑻𝒊) &lt; 𝑻𝑺(𝑻𝒋)<br>◆ 回滚的事务重新启动， 分配新的时间戳</p><p>每个数据项 𝑸 有两个时间戳与之联系<br>◆ 𝑾𝑻 𝑸 : 所有执行𝒘𝒓𝒊𝒕𝒆(𝑸)的事务中最大的时间戳<br>◆ 𝑹𝑻 𝑸 : 所有执行𝒓𝒆𝒂𝒅(𝑸)的事务中最大的时间戳</p><p>注意：不是最后执行Read(Q)事务的时间戳，而是所有执行𝒓𝒆𝒂𝒅(𝑸)的事务中<strong>最大</strong>的时间戳<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240610001940.png"><br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240610002038.png"><br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240610002057.png"><br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240610001146.png"></p><h2 id="基于有效性检查的并发控制协议"><a href="#基于有效性检查的并发控制协议" class="headerlink" title="基于有效性检查的并发控制协议"></a>基于有效性检查的并发控制协议</h2><p>读阶段：事务𝑇𝑖在这一阶段中执行。数据项被读入并保存在𝑇𝑖的局部变量中。所有𝑤𝑟𝑖𝑡𝑒操作都是对局部临时变量进行的，并不对数据库进行真正更新<br>有效性检查阶段：𝑇𝑖进行有效性检查， 通过与其他事务的读写集合进行比较， 来判定是否可以将𝑤𝑟𝑖𝑡𝑒操作所更新的临时局部变量值拷入数据库而不违反可串行性<br>写阶段：若𝑇𝑖通过有效性检查，则在本阶段进行实际的数据库更新，否则回滚𝑇𝑖<br>令𝑻𝑺(𝑻𝒊) &#x3D; 𝑽𝒂𝒍𝒊𝒅𝒂𝒕𝒊𝒐𝒏(𝑻𝒊)<br>等价的串行顺序与有效性确认时间戳一致</p><p>检查条件：</p><ol><li>如果有一个事务他开始了但另一个事务还没结束那就违反串行性</li><li>如果有一个事务他还没结束但另一个事务已经在有效性确认了，那就违反串行性</li></ol><h2 id="MySQL-MVCC中的读视图和可见性算法"><a href="#MySQL-MVCC中的读视图和可见性算法" class="headerlink" title="MySQL MVCC中的读视图和可见性算法"></a>MySQL MVCC中的读视图和可见性算法</h2><p>𝒓𝒆𝒂𝒅_𝒗𝒊𝒆𝒘<br>事务在进行快照读的时候会创建一个读视图<br>• 𝒄𝒖𝒓𝒓𝒆𝒏𝒕_𝒕𝒓𝒙_𝒊𝒅 ： 当前事务的id<br>• 𝒂𝒍𝒊𝒗𝒆_𝒕𝒓𝒙_𝒍𝒊𝒔𝒕：读视图生成时刻系统中正在活跃的事务id<br>• 𝒎𝒊𝒏_𝒕𝒓𝒙_𝒊𝒅：上面的 𝒂𝒍𝒊𝒗𝒆_𝒕𝒓𝒙_𝒍𝒊𝒔𝒕 中的最小事务id<br>• 𝒎𝒂𝒙_𝒕𝒓𝒙_𝒊𝒅 ： 读视图生成时刻目前已创建过的事务id最大值+1</p><p>可见性算法<br>当一个事务读取某条记录𝑟𝑒𝑐𝑜𝑟𝑑𝑖时会追溯其undo log版本链， 找到第一个可以访问的版本， 而该记录的某一个版本𝑑𝑏_𝑡𝑟𝑥_𝑖𝑑(𝑟𝑒𝑐𝑜𝑟𝑑𝑖)是否能被这个事务读取到遵循如下可见性算法规则：<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240615220536.png"></p><h1 id="第十章-恢复控制"><a href="#第十章-恢复控制" class="headerlink" title="第十章 恢复控制"></a>第十章 恢复控制</h1><h2 id="故障类型"><a href="#故障类型" class="headerlink" title="故障类型"></a>故障类型</h2><p>事务故障<br>    单个事务的运行没有到达预期的终点就被中止</p><pre><code class="hljs">非预期故障• 不能由事务程序处理的• 如运算溢出， 发生死锁而被选中撤消该事务可预期故障• 应用程序可以发现的事务故障，并且应用程序可以让事务回滚• 如转帐时发现帐面金额不足</code></pre><p>系统故障<br>软故障(soft crash)<br>在硬件故障、软件错误的影响下，虽引起内存信息丢失，但未破坏外存中数据</p><p>介质故障<br>硬故障(hard crash)<br>又称磁盘故障， 破坏外存上的数据库，并影响正在存取这部分数据的所有事务<br>如磁盘的磁头碰撞 瞬时的强磁场干扰</p><h2 id="备份概念及其类型"><a href="#备份概念及其类型" class="headerlink" title="备份概念及其类型"></a>备份概念及其类型</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240615223043.png"></p><h2 id="先写日志的WAL原则"><a href="#先写日志的WAL原则" class="headerlink" title="先写日志的WAL原则"></a>先写日志的WAL原则</h2><p>Write Ahead Log<br>对于尚未提交的事务，在将DB缓冲区写到外存之前，必须先将日志缓冲区内容写到外存去</p><h2 id="检查点概念及其作用"><a href="#检查点概念及其作用" class="headerlink" title="检查点概念及其作用"></a>检查点概念及其作用</h2><p>保证在检查点时刻磁盘上日志文件与数据库的内容是一致的</p><h2 id="基本的故障恢复操作"><a href="#基本的故障恢复操作" class="headerlink" title="基本的故障恢复操作"></a>基本的故障恢复操作</h2><p>➢ 备份<br>➢ 日志<br>➢ WAL<br>➢ 检查点<br>➢ ARIES</p><h2 id="ARIES恢复算法所遵循的原则、三个恢复阶段"><a href="#ARIES恢复算法所遵循的原则、三个恢复阶段" class="headerlink" title="ARIES恢复算法所遵循的原则、三个恢复阶段"></a>ARIES恢复算法所遵循的原则、三个恢复阶段</h2><p>𝑨𝑹𝑰𝑬𝑺遵循“𝑾𝑨𝑳”原则 𝑨𝑹𝑰𝑬𝑺使用模糊检查<br>𝑨𝑹𝑰𝑬𝑺的𝑩𝑴遵循“𝑵𝒐𝒏 − 𝑭𝒐𝒓𝒄𝒆， 𝑺𝒕𝒆𝒂𝒍”<br>𝑨𝑹𝑰𝑬𝑺使用𝑷𝒂𝒈𝒆 − 𝒐𝒓𝒊𝒆𝒏𝒕𝒆𝒅级的𝑹𝒆𝒅𝒐<br>使用𝑳𝒐𝒈𝒊𝒄𝒂𝒍级的𝑼𝒏𝒅𝒐<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240615223535.png"></p><h1 id="第十一章-数据库存储"><a href="#第十一章-数据库存储" class="headerlink" title="第十一章 数据库存储"></a>第十一章 数据库存储</h1><h2 id="RAID1、-RAID5定义及其特性，-所适用的数据库应用场合"><a href="#RAID1、-RAID5定义及其特性，-所适用的数据库应用场合" class="headerlink" title="RAID1、 RAID5定义及其特性， 所适用的数据库应用场合"></a>RAID1、 RAID5定义及其特性， 所适用的数据库应用场合</h2><p>见2017期末</p><h2 id="页结构、行结构"><a href="#页结构、行结构" class="headerlink" title="页结构、行结构"></a>页结构、行结构</h2><p>见2017期末</p><h2 id="位图索引、LSM树和B-树比较"><a href="#位图索引、LSM树和B-树比较" class="headerlink" title="位图索引、LSM树和B+树比较"></a>位图索引、LSM树和B+树比较</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616000650.png"><br><a href="https://www.cnblogs.com/lbser/p/3322630.html">位图索引</a><br>位图索引<strong>适合只有几个固定值</strong>的列，如性别、婚姻状况、行政区等等，而身份证号这种类型不适合用位图索引。</p><p>此外，位图索引<strong>适合静态数据，而不适合索引频繁更新的列</strong>。举个例子，有这样一个字段busy，记录各个机器的繁忙与否，当机器忙碌时，busy为1，当机器不忙碌时，busy为0。</p><p>这个时候有人会说使用位图索引，因为busy只有两个值。好，我们使用位图索引索引busy字段！假设用户A使用update更新某个机器的busy值，比如update table set table.busy&#x3D;1 where rowid&#x3D;100;，但还没有commit，而用户B也使用update更新另一个机器的busy值，update table set table.busy&#x3D;1 where rowid&#x3D;12; 这个时候用户B怎么也更新不了，需要等待用户A commit。</p><p>LSM-Tree的优点是支持高吞吐的写O1，这个特点在分布式系统上更为看重<br>针对读取普通的LSM-Tree结构，读取是On的复杂度<br>在使用索引或者缓存优化后的也可以达到O(logN)的复杂度。<br>适用于写多读少</p><p>B+tree的优点是支持高效的读（稳定的O(logN)）<br>但是在大规模的写请求下（O(LogN)），效率会变得比较低，因为随着insert的操作，为了维护B+树结构，节点会不断的分裂和合并。操作磁盘的随机读写概率会变大，故导致性能降低。<br>适用于写少读多或写读平衡</p><h2 id="按列存储"><a href="#按列存储" class="headerlink" title="按列存储"></a>按列存储</h2><p>优点：<br>◼ 提高带宽利用率：按列存储时， 只有那些被查询访问的属性才会从磁盘读出；按行存储时， 周围属性也被一并读出<br>◼ 提高数据压缩率：将同一个属性域的数据存储在一起， 提高了局部性以及压缩比率， 传输压缩数据同样减少了带宽<br>◼ 提高了cache局部性： cache line比一个元组属性要大， 因此按行存储时 cache line可能会包含不相关的周边属性， 浪费cache的空间减少命中率</p><p>缺点：<br>➢ 增加了磁盘寻道时间：如果需要并行读取多个列， 在各个块读之间需要进行磁盘寻道<br>➢ 增加插入操作的代价：对于插入操作， 按列存储的性能很差，因为对每条插入的元组都需要在磁盘的多个不同位置更新<br>➢ 增加重构元组的代价：按列存储如果想支持标准的关系数据库接口， 就必须将多个列拼合起来， 构成一条元组输出</p><h1 id="第十二章-查询处理"><a href="#第十二章-查询处理" class="headerlink" title="第十二章 查询处理"></a>第十二章 查询处理</h1><h2 id="查询处理的步骤"><a href="#查询处理的步骤" class="headerlink" title="查询处理的步骤"></a>查询处理的步骤</h2><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240616001800.png"></p><h2 id="三种连接算法的实现策略及各自适用场合"><a href="#三种连接算法的实现策略及各自适用场合" class="headerlink" title="三种连接算法的实现策略及各自适用场合"></a>三种连接算法的实现策略及各自适用场合</h2><p>见2017期末</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>经济地理学往年题2013期末</title>
    <link href="/2024/06/08/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6%E5%BE%80%E5%B9%B4%E9%A2%98/"/>
    <url>/2024/06/08/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6%E5%BE%80%E5%B9%B4%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>来不及了还是直接看往年题吧</p><h1 id="一、简答"><a href="#一、简答" class="headerlink" title="一、简答"></a>一、简答</h1><h2 id="经济地理学研究内容"><a href="#经济地理学研究内容" class="headerlink" title="经济地理学研究内容"></a>经济地理学研究内容</h2><p>空间差异：经济活动的空间差异与空间分布规律，是静态的；<br>空间过程：空间差异或空间分布的动态变化；<br>空间相互作用：经济实体之间通过要素及信息交流产生的相互影响；</p><h2 id="原料指数与最小运费原理"><a href="#原料指数与最小运费原理" class="headerlink" title="原料指数与最小运费原理"></a>原料指数与最小运费原理</h2><p><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608212216.png"><br><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608150905.png"></p><h2 id="主导产业选择标准（条件）"><a href="#主导产业选择标准（条件）" class="headerlink" title="主导产业选择标准（条件）"></a>主导产业选择标准（条件）</h2><p>选择主导产业是一个国家或地区制定经济发展战略时的重要步骤。主导产业的选择需要综合考虑多种因素，以确保其能够带动整体经济的发展、提高竞争力，并带来长期的经济效益。以下是选择主导产业的一些关键标准：</p><h3 id="1-资源禀赋"><a href="#1-资源禀赋" class="headerlink" title="1. 资源禀赋"></a>1. <strong>资源禀赋</strong></h3><ul><li><strong>自然资源</strong>：考虑该地区是否拥有丰富的自然资源，如矿产、土地、水资源等，这些资源可以为某些产业提供原材料基础。</li><li><strong>人力资源</strong>：评估该地区的劳动力数量、质量和结构，确保有足够的人才支持产业发展。</li></ul><h3 id="2-技术和创新能力"><a href="#2-技术和创新能力" class="headerlink" title="2. 技术和创新能力"></a>2. <strong>技术和创新能力</strong></h3><ul><li><strong>现有技术基础</strong>：选择具有较强技术基础和研发能力的产业，确保产业能够快速升级和创新。</li><li><strong>创新潜力</strong>：评估该产业的技术创新潜力和产业链延伸能力，以保持长期竞争力。</li></ul><h3 id="3-市场需求"><a href="#3-市场需求" class="headerlink" title="3. 市场需求"></a>3. <strong>市场需求</strong></h3><ul><li><strong>国内市场需求</strong>：分析国内市场对某产业产品或服务的需求情况，选择具有较大市场潜力的产业。</li><li><strong>国际市场需求</strong>：考虑全球市场需求，尤其是出口潜力大的产业，以扩大国际市场份额。</li></ul><h3 id="4-经济效益"><a href="#4-经济效益" class="headerlink" title="4. 经济效益"></a>4. <strong>经济效益</strong></h3><ul><li><strong>投入产出比</strong>：选择投资回报率高、经济效益显著的产业。</li><li><strong>就业创造</strong>：评估该产业对就业的带动作用，优先选择能够创造大量就业机会的产业。</li></ul><h3 id="5-产业链和关联度"><a href="#5-产业链和关联度" class="headerlink" title="5. 产业链和关联度"></a>5. <strong>产业链和关联度</strong></h3><ul><li><strong>产业链完备性</strong>：选择产业链较为完备的产业，确保上下游产业配套齐全，能够形成集群效应。</li><li><strong>产业关联度</strong>：评估该产业与其他产业的关联度和带动作用，选择能够带动相关产业共同发展的主导产业。</li></ul><h3 id="6-政策支持"><a href="#6-政策支持" class="headerlink" title="6. 政策支持"></a>6. <strong>政策支持</strong></h3><ul><li><strong>政府政策</strong>：考虑政府的政策支持力度，包括税收优惠、补贴、技术支持等，优先选择受政策支持力度大的产业。</li><li><strong>法律环境</strong>：评估该产业的法律法规环境，确保有利于产业的长期健康发展。</li></ul><h3 id="7-基础设施"><a href="#7-基础设施" class="headerlink" title="7. 基础设施"></a>7. <strong>基础设施</strong></h3><ul><li><strong>基础设施配套</strong>：评估该地区的基础设施是否能够支持产业发展，包括交通、通讯、能源等。</li><li><strong>物流和供应链</strong>：考虑物流和供应链管理的便捷性和效率，确保产业的高效运作。</li></ul><h3 id="8-环保和可持续发展"><a href="#8-环保和可持续发展" class="headerlink" title="8. 环保和可持续发展"></a>8. <strong>环保和可持续发展</strong></h3><ul><li><strong>环境影响</strong>：评估产业对环境的影响，选择环保型、可持续发展的产业。</li><li><strong>绿色技术</strong>：优先选择使用绿色技术和可再生资源的产业，确保符合可持续发展的要求。</li></ul><h3 id="9-风险评估"><a href="#9-风险评估" class="headerlink" title="9. 风险评估"></a>9. <strong>风险评估</strong></h3><ul><li><strong>市场风险</strong>：分析市场需求波动和产业生命周期，选择市场风险较低、发展前景较好的产业。</li><li><strong>政策风险</strong>：考虑政策变动和国际形势变化对产业的影响，选择政策风险较小的产业。</li></ul><h3 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h3><ol><li><p><strong>中国的高铁产业</strong>：</p><ul><li><strong>资源禀赋</strong>：丰富的工程技术人才和制造基础。</li><li><strong>技术和创新</strong>：具有强大的自主研发和创新能力。</li><li><strong>市场需求</strong>：国内外市场对高效交通工具的需求巨大。</li><li><strong>经济效益</strong>：高投资回报率，带动相关产业发展。</li></ul></li><li><p><strong>美国的硅谷高科技产业</strong>：</p><ul><li><strong>资源禀赋</strong>：集聚了全球顶尖的科技人才和创业者。</li><li><strong>技术和创新</strong>：全球领先的科技创新能力。</li><li><strong>市场需求</strong>：全球对高科技产品和服务的需求持续增长。</li><li><strong>经济效益</strong>：高附加值和强大的经济带动作用。</li></ul></li></ol><h2 id="佩鲁增长极理论"><a href="#佩鲁增长极理论" class="headerlink" title="佩鲁增长极理论"></a>佩鲁增长极理论</h2><p><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608212513.png"><br><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608212556.png"><br><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608212605.png"></p><h1 id="二、论述"><a href="#二、论述" class="headerlink" title="二、论述"></a>二、论述</h1><h2 id="画杜能圈图示，解释其形成机制"><a href="#画杜能圈图示，解释其形成机制" class="headerlink" title="画杜能圈图示，解释其形成机制"></a>画杜能圈图示，解释其形成机制</h2><p><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608154456.png"><br><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608154634.png"></p><h2 id="论述市场原则下的中心地结构形成机制，及其特点。"><a href="#论述市场原则下的中心地结构形成机制，及其特点。" class="headerlink" title="论述市场原则下的中心地结构形成机制，及其特点。"></a>论述市场原则下的中心地结构形成机制，及其特点。</h2><p>中心地数量与其等级有关，等级越低，数量越多；等级越高，数量越少；<br>同一等级的中心地之间有一定距离，这个距离也与等级有关；大城市之间距离远，小城市之间距离近；<br>通过以上概念，通过中心地的等级，把规模、数量和空间关系联系起来；</p><p>中心地理论假设：<br>1、中心地分布区域是均质平原，资源与中心地之外人口均衡分布；居民收入和消费方式相同；<br>2、同级城市交通条件相同，运费与距离成正比；<br>3、同种商品或服务的价格与质量都相同，实际支付价格中包含了交通成本；<br>4、消费者是理性的，以尽最低实际价格购买商品；<br>5、市场竞争使得在给所有居民提供服务的前提下，中心地数量尽可能少；即在没有空白区的前提下使市场区尽可能大；</p><p><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608155502.png"></p><h2 id="上世纪60年代以来纺织服装业的国际转移及其内在机理。"><a href="#上世纪60年代以来纺织服装业的国际转移及其内在机理。" class="headerlink" title="上世纪60年代以来纺织服装业的国际转移及其内在机理。"></a>上世纪60年代以来纺织服装业的国际转移及其内在机理。</h2><p>自20世纪60年代以来，纺织服装业经历了显著的国际转移。这一现象主要是由多种经济、社会和政策因素驱动的。以下是对纺织服装业国际转移的概述及其内在机理的分析。</p><h3 id="纺织服装业国际转移的阶段"><a href="#纺织服装业国际转移的阶段" class="headerlink" title="纺织服装业国际转移的阶段"></a>纺织服装业国际转移的阶段</h3><ol><li><p><strong>20世纪60年代-70年代：从发达国家到亚洲四小龙</strong>：</p><ul><li><strong>背景</strong>：二战后，欧美发达国家的劳动力成本上升，加之本土经济的转型升级，劳动密集型产业逐渐向成本更低的国家转移。</li><li><strong>主要流向</strong>：韩国、台湾、香港和新加坡（亚洲四小龙）。</li><li><strong>原因</strong>：这些地区拥有充足且廉价的劳动力、政府政策支持和较为完善的基础设施。</li></ul></li><li><p><strong>20世纪80年代-90年代：从亚洲四小龙到中国大陆和东南亚</strong>：</p><ul><li><strong>背景</strong>：亚洲四小龙的经济快速发展，劳动力成本开始上升，企业寻求更低成本的生产基地。</li><li><strong>主要流向</strong>：中国大陆、泰国、马来西亚、印度尼西亚等东南亚国家。</li><li><strong>原因</strong>：这些国家提供更低的劳动力成本，政府推行招商引资政策，并且基础设施逐渐完善。</li></ul></li><li><p><strong>21世纪以来：从中国和东南亚向南亚和非洲</strong>：</p><ul><li><strong>背景</strong>：中国和东南亚国家的经济持续增长，劳动力成本增加，环保和劳工法规日益严格。</li><li><strong>主要流向</strong>：印度、孟加拉国、越南、柬埔寨和非洲一些国家（如埃塞俄比亚）。</li><li><strong>原因</strong>：这些地区劳动力成本低，政府提供优惠政策，同时一些国家还享有发达国家的贸易优惠待遇（如GSP）。</li></ul></li></ol><h3 id="纺织服装业国际转移的内在机理"><a href="#纺织服装业国际转移的内在机理" class="headerlink" title="纺织服装业国际转移的内在机理"></a>纺织服装业国际转移的内在机理</h3><ol><li><p><strong>劳动力成本差异</strong>：</p><ul><li>纺织服装业是劳动密集型产业，对劳动力成本非常敏感。企业会倾向于选择劳动力成本低廉的国家和地区进行生产，以降低总成本，提高竞争力。</li></ul></li><li><p><strong>市场准入和贸易政策</strong>：</p><ul><li>发达国家通过贸易协定（如多纤协议、配额制度等）限制进口，促使纺织企业寻找新的生产基地，以规避关税和配额限制。随着全球贸易自由化，企业进一步向发展中国家转移。</li></ul></li><li><p><strong>产业集聚效应</strong>：</p><ul><li>纺织服装业的国际转移通常伴随产业集聚效应。一个地区如果形成了纺织服装产业集群，会吸引更多相关企业进驻，从而形成完整的产业链，提高生产效率，降低物流和配套成本。</li></ul></li><li><p><strong>政府政策和激励措施</strong>：</p><ul><li>许多发展中国家通过税收优惠、土地优惠、出口退税等政策吸引纺织服装企业投资建厂。此外，这些国家通常放松劳动法规和环保要求，降低企业运营成本。</li></ul></li><li><p><strong>技术扩散和生产模式变化</strong>：</p><ul><li>随着生产技术的扩散和全球供应链的发展，纺织服装企业可以更容易地在全球范围内寻找生产基地。这种生产模式的变化加速了产业的国际转移。</li></ul></li><li><p><strong>环境和社会规范</strong>：</p><ul><li>发达国家对环境保护和劳动权益的要求日益严格，导致纺织服装企业生产成本上升。这促使企业将生产转移到环境和社会法规相对宽松的发展中国家。</li></ul></li></ol><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><ol><li><p><strong>中国的崛起</strong>：</p><ul><li>自20世纪80年代改革开放以来，中国凭借廉价劳动力、大规模基础设施投资和政府支持，迅速成为全球纺织服装生产中心。中国不仅生产成本低，还拥有完整的供应链和配套设施。</li></ul></li><li><p><strong>孟加拉国和越南的快速发展</strong>：</p><ul><li>随着中国劳动力成本上升，许多企业将生产转移到孟加拉国和越南。孟加拉国的服装出口在全球市场占据重要地位，而越南通过加入各种自由贸易协定（如CPTPP和EVFTA），吸引大量外资。</li></ul></li></ol><h2 id="东部、中部、西部、东北四个政策地区“经济战略转型”？"><a href="#东部、中部、西部、东北四个政策地区“经济战略转型”？" class="headerlink" title="东部、中部、西部、东北四个政策地区“经济战略转型”？"></a>东部、中部、西部、东北四个政策地区“经济战略转型”？</h2><p>西部开发、东北振兴、中部崛起、东部率先<br><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608211449.png"><br><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608211619.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>经济地理学复习大纲</title>
    <link href="/2024/06/07/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/"/>
    <url>/2024/06/07/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>经济地理学及其研究对象、研究内容等，经济地理学发展历程及理论脉络。</p><h4 id="经济地理学的研究对象"><a href="#经济地理学的研究对象" class="headerlink" title="经济地理学的研究对象"></a>经济地理学的研究对象</h4><p>概括地说是人类经济活动；<br>按实体来说，分为：<br>   要素：经济活动的参与和影响因素；<br>   企业：经济体系中的基本生产单位；<br>   产业（行业）：按生产活动性质的分类；<br>   城市：经济活动在特定空间集聚形成的经济实体；<br>   区域：具有一定经济整体性或者经济联系的特定地域范围；</p><h4 id="经济地理学的研究内容"><a href="#经济地理学的研究内容" class="headerlink" title="经济地理学的研究内容"></a>经济地理学的研究内容</h4><p>空间差异：经济活动的空间差异与空间分布规律，是静态的；<br>空间过程：空间差异或空间分布的动态变化；<br>空间相互作用：经济实体之间通过要素及信息交流产生的相互影响；</p><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h4 id="Primary-和Secondary-Data"><a href="#Primary-和Secondary-Data" class="headerlink" title="Primary 和Secondary Data"></a>Primary 和Secondary Data</h4><p>一手资料：</p><ol><li>参与式观察</li><li>深度访谈</li><li>行动研究</li><li>历史研究</li><li>问卷调查</li></ol><p>二手数据：</p><ol><li>文献</li><li>统计年鉴</li><li>普查资料</li><li>研究报告</li></ol><h4 id="专题地图的地图类型"><a href="#专题地图的地图类型" class="headerlink" title="专题地图的地图类型"></a>专题地图的地图类型</h4><p>等值线地图（Isoline maps）<br>灰阶地图（Choropleth maps）<br>符号地图（Proportional symbol maps）<br>点图（Dot maps）</p><h4 id="归纳和演绎方法"><a href="#归纳和演绎方法" class="headerlink" title="归纳和演绎方法"></a>归纳和演绎方法</h4><p><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240607174133.png"></p><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><h4 id="区位因子"><a href="#区位因子" class="headerlink" title="区位因子"></a>区位因子</h4><p>经济活动区位的影响因素<br>分类：<br>投入因子—生产要素，如土地、资本、劳动<br>市场因子—需求规模与性质、市场竞争等<br>交通因子—将投入、生产与市场联系起来<br>环境因子—自然、制度与社会文化环境</p><h4 id="区位条件"><a href="#区位条件" class="headerlink" title="区位条件"></a>区位条件</h4><p>空间上某一地区区位因子的组合</p><h4 id="资源乐观论与悲观论"><a href="#资源乐观论与悲观论" class="headerlink" title="资源乐观论与悲观论"></a>资源乐观论与悲观论</h4><p>乐观：会减少，但少得不多<br>悲观：会大大大大减少，甚至枯竭</p><h4 id="土地资源的特性及其对产业区位的影响"><a href="#土地资源的特性及其对产业区位的影响" class="headerlink" title="土地资源的特性及其对产业区位的影响"></a>土地资源的特性及其对产业区位的影响</h4><p>土地的定义：土地是指地球表面的固体部分，是人类最基本的生存空间；包括了地表之上的<strong>土壤、植被和气候</strong>，<strong>以及地下的矿产资源</strong>。</p><p>土地的特性：<br>自然特性：自然性、差异性、耐久性、固定性<br>经济特性：必要性、稀缺性、增值性</p><p>对经济活动区位的影响（根据特性一条一条讲）：<br>土壤、水文、气候影响农业生产；（自然<br>矿产资源分布决定了采矿业、进而是相应加工业的区位；（自然<br>土地承载力和地质条件对城市建设和生产建设有重要影响；（差异<br>土地的耐久性使经济活动可在一地持续进行，产生区位惯性（耐久<br>土地的空间固定性使区位选择具有了重要意义。（固定<br>任何经济活动都是在土地上进行的，因而任何经济活动都有区位选择的问题；（必要<br>土地的总量一定，供给非弹性，价格随需求而变化，进而影响到经济活动的成本；（稀缺<br>土地的增值性使土地具有了投资品的特征，未来土地收益成为区位选择的考虑因素之一。（增值</p><h4 id="能源对区位的影响"><a href="#能源对区位的影响" class="headerlink" title="能源对区位的影响"></a>能源对区位的影响</h4><p>任何经济活动都要消耗能源，但消耗的数量不同；耗能大的经济活动要靠近能源产地，如电解铝厂要靠近大电厂；能源价格对企业区位也有影响，如水电比火电便宜，对电解铝更具吸引力；投入品与产出品的可运性也影响区位；</p><h4 id="马尔萨斯人口论"><a href="#马尔萨斯人口论" class="headerlink" title="马尔萨斯人口论"></a>马尔萨斯人口论</h4><p>• 除非受到约束，人口肯定会持续增长，而且以几何级数增长<br>• 人口增长将超过资源容量的扩张<br>• 资源将成为人口数量扩张的约束<br>• 限制人口增长的措施包括私人性的（如道德约束、禁欲等）或者毁灭性的（如战争、贫困、饥饿等</p><h4 id="人口转换模型"><a href="#人口转换模型" class="headerlink" title="人口转换模型"></a>人口转换模型</h4><p>毛出生率（Crude Birth Rate）：单位千人的年出生人口数<br>毛死亡率（Crude Death Rate）：单位千人的年死亡人数<br>人口自然增长率：毛出生率与毛死亡率之差（不考虑人口迁移）<br>总生育率（Total Fertility Rate）：15－29岁妇女平均生育小孩的个数总生育率为2时，人口可以基本维持平衡</p><h4 id="人口迁移和流动因素"><a href="#人口迁移和流动因素" class="headerlink" title="人口迁移和流动因素"></a>人口迁移和流动因素</h4><p>劳动力流动的目的是寻求更高的报酬；因而流动方向就是从低收入区流向高收入区；如发展中国家向发达国家的流动，农村向城市的流动；</p><p>人口迁移有一个明显的规律，就是距离衰减，即相距越远的两地之间人口迁移量越小；人口迁入地还会出现聚居现象，如美国的唐人街。</p><p>人口区际迁移是流出地推力与目的地拉力克服空间距离障碍的共同作用的结果<br>推力：如就业机会、工资低、环境恶化、战争<br>拉力：高就业机会、高工资、优美的环境、宽松的政治气氛等</p><p>人力资本：经过教育和培训形成的劳动技能，其存量影响到劳动者的劳动生产率；人力资本的空间分布会影响到高技术产业的布局</p><h4 id="技术对区位的影响"><a href="#技术对区位的影响" class="headerlink" title="技术对区位的影响"></a>技术对区位的影响</h4><ol><li>生产技术、原材料和能源利用技术对区位的影响<br>改变资源的价值<br>扩大或拓展已有资源量<br>替代现有资源<br>减少了单位产品对能源和原材料的消耗量，降低成本，从而使生产区位发生了变化，或使企业区位选择更具有灵活性</li><li>交通运输技术对区位的影响<br>增加生产要素的全球流动性<br>交通运输技术的进步使运输成本下降，也改变了生产的空间分布；如大型油轮的出现使得沿海港口出现了许多大型炼油企业；<br>管道运输技术的进步使得炼油企业可以靠近消费区；<br>大型集装箱船的出现使得海运成本下降，劳动密集型产业得以向中国转移<br>高铁网络对产业和企业区位的影响显著</li><li>信息技术和数字化技术<br>显著降低交易成本和时间成本（海运运费 空运运费 通讯费用）<br>极大地影响了经济活动的空间格局；<br>从海底电缆、卫星通信到互联网络，信息传递具有即时性；<br>使得跨国公司可以在全球组织生产；资金可以在全球流动；贸易可以在全球展开；距离不再是主要的障碍。<br>新的业态，改变经济地理格局</li></ol><h4 id="投入要素之间的替代性"><a href="#投入要素之间的替代性" class="headerlink" title="投入要素之间的替代性"></a>投入要素之间的替代性</h4><p>资本与劳动，资本与土地，都可以在技术的作用下发生替代；<br>一个国家或地区采用什么样的投入要素组合，要由要素的数量关系来决定；因为要素供给数量决定价格，价格决定成本；要获得高收益就要采用成本最低的要素。<br>一种经济活动的最佳区位是各种要素相互替代的最佳选择</p><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h4 id="市场潜力"><a href="#市场潜力" class="headerlink" title="市场潜力"></a>市场潜力</h4><p>产业集中在市场潜力大的区域<br><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240607203559.png"></p><h4 id="收益递增的定义"><a href="#收益递增的定义" class="headerlink" title="收益递增的定义"></a>收益递增的定义</h4><p>收益递增（Increasing Returns）指的是生产过程中，当投入增加时，产出以更大的比例增加。这意味着，每增加一单位的投入，产出的增加量不仅没有减少，反而增加了。收益递增是与收益递减（Decreasing Returns）和收益不变（Constant Returns）相对的概念。</p><p>在经济学中，收益递增通常与规模经济（Economies of Scale）相关联。规模经济指的是随着生产规模的扩大，平均成本下降的现象。下面是对收益递增的一些具体解释：</p><p><strong>特征和原因</strong></p><ol><li><p><strong>分工与专业化</strong>：</p><ul><li>随着生产规模的扩大，企业可以更细化地分工，提高生产效率。例如，在大规模生产中，不同工人可以专注于不同的生产环节，提升工作效率。</li></ul></li><li><p><strong>技术和设备</strong>：</p><ul><li>大规模生产使得企业有能力投资于更先进的技术和设备，这些技术和设备可以显著提高生产效率。例如，自动化生产线的引入可以大大增加产出。</li></ul></li><li><p><strong>固定成本分摊</strong>：</p><ul><li>大规模生产可以更好地分摊固定成本，如厂房、机器设备和管理费用。随着产量增加，平均固定成本下降，从而降低单位产品的总成本。</li></ul></li><li><p><strong>采购优势</strong>：</p><ul><li>大规模生产的企业在采购原材料时可能享有更大的议价能力，能够以更低的价格购买大批量的原材料，从而降低成本。</li></ul></li><li><p><strong>营销和分销优势</strong>：</p><ul><li>大规模生产的企业可以更有效地进行营销和分销，降低每单位产品的营销和分销成本。</li></ul></li></ol><p>在制造业中，收益递增现象比较常见。一个汽车制造商在生产少量汽车时，单位成本较高。但随着生产规模扩大，厂商可以投资于自动化生产线，提高生产效率，降低单位生产成本。因此，生产更多汽车可以带来更高的总产出，相对于投入的增加，产出增加得更多。</p><p>在高科技产业，如软件开发，收益递增现象也很明显。开发一款软件的初始成本很高（开发、测试、发布），但一旦软件开发完成，复制和分发的边际成本几乎为零。因此，随着用户数量增加，单位成本迅速下降，收益迅速增加。</p><p>如果生产函数 Q &#x3D; f(L, K) 表示产出 Q 是投入要素（如劳动力 L 和资本 K）的函数，那么当存在收益递增时，对于某一比例的投入增加，产出的增加比例更大。即：</p><p>如果对所有投入要素 L 和 K 增加一个比例 t &gt; 1，则产出增加的比例大于 t：</p><p>f(tL, tK) &gt; tf(L, K)</p><p><strong>应用与意义</strong></p><ul><li><strong>市场结构与竞争</strong>：收益递增的存在往往导致市场上自然垄断的形成，因为大规模生产的企业具有显著的成本优势，难以被小规模生产者竞争。</li><li><strong>经济政策</strong>：政府在制定经济政策时需要考虑收益递增的影响，通过促进企业扩大生产规模，实现规模经济，提高整体经济效率。</li><li><strong>区域发展</strong>：在区域经济发展中，中心区域由于集聚效应和收益递增的特征，经济增长更快，吸引更多资源和投资，而外围区域则发展相对缓慢。</li></ul><p>收益递增意味着投入的增加带来更大比例的产出增加，是经济活动中的重要现象。理解收益递增对于分析企业行为、市场结构和经济政策具有重要意义。</p><h4 id="中心—外围模型"><a href="#中心—外围模型" class="headerlink" title="中心—外围模型"></a>中心—外围模型</h4><p>假设一个只有农业和制造业两个部门的经济，其中农业部门是完全竞争的，生产单一的同质产品，而制造业部门是垄断竞争的，供给大量的差异化产品，并具有收益递增的特征。两个部门分别使用一种资源：劳动力。农业雇佣的劳动力要素不可流动，而制造业工人可以自由流动。农产品无运输成本，而制造品则存在“冰山运输成本”（即一部分产品在运输过程中损失）。</p><p><strong>模型概述：</strong></p><ol><li><strong>农业部门</strong>：<ul><li><strong>特征</strong>：完全竞争，生产单一同质产品。</li><li><strong>资源</strong>：使用不可流动的劳动力。</li><li><strong>运输成本</strong>：无运输成本。</li></ul></li><li><strong>制造业部门</strong>：<ul><li><strong>特征</strong>：垄断竞争，生产大量差异化产品，具有收益递增特征。</li><li><strong>资源</strong>：使用可自由流动的劳动力。</li><li><strong>运输成本</strong>：“冰山运输成本”，即一部分产品在运输过程中损失。</li></ul></li></ol><p>在这种经济结构中，我们可以运用中心-外围模型来解释各区域之间的经济活动和发展差异。</p><p><strong>中心区域（Core）</strong>：</p><ul><li><strong>制造业集聚</strong>：由于制造业具有收益递增特征，厂商更愿意集中在一起（集聚效应）。集聚效应包括劳动力市场的集中（便于工人流动和就业匹配）、供应链和市场的集中（减少运输成本）等。</li><li><strong>经济多样化</strong>：制造业的多样化和差异化产品生产使得中心区域的经济活动更加丰富和多样。</li><li><strong>劳动力流动性高</strong>：制造业工人可以自由流动，使得劳动力资源能够更有效地分配到收益更高的部门。</li></ul><p><strong>外围区域（Periphery）</strong>：</p><ul><li><strong>农业主导</strong>：外围区域以农业为主，由于农业的劳动力不可流动性和完全竞争特征，外围区域的经济发展相对单一和缓慢。</li><li><strong>低运输成本的农产品</strong>：外围区域生产的农产品没有运输成本，可以向中心区域供应，满足中心区域的需求。</li><li><strong>缺乏集聚效应</strong>：由于制造业的收益递增特征，外围区域缺乏制造业集聚效应，难以形成多样化的经济活动。</li></ul><p><strong>动态关系</strong>：</p><ol><li><strong>资源流动</strong>：制造业工人的自由流动性使得劳动力向中心区域集中，进一步增强了中心区域的制造业优势。外围区域则主要依赖农业，劳动力不易流动。</li><li><strong>产品流动</strong>：农产品可以无成本地从外围区域运输到中心区域，而制造品存在运输损耗，使得制造业更倾向于在中心区域集聚，以减少运输损耗。</li><li><strong>经济收益</strong>：中心区域由于制造业的集聚效应和收益递增特征，经济增长更快，吸引更多资源和投资。外围区域则由于农业的低收益性，经济增长缓慢。</li></ol><p><strong>政策建议</strong>：</p><p>为了平衡区域发展，政府可以采取以下政策措施：</p><ol><li><strong>基础设施投资</strong>：改善外围区域的基础设施，降低运输成本，促进制造业的发展。</li><li><strong>教育和培训</strong>：提高外围区域劳动力的技能，增强其流动性，使其能够进入收益更高的制造业部门。</li><li><strong>政策支持</strong>：通过税收优惠、补贴等政策，吸引制造业企业在外围区域投资，促进区域经济多样化。</li></ol><h4 id="霍特林的相互依存模型"><a href="#霍特林的相互依存模型" class="headerlink" title="霍特林的相互依存模型"></a>霍特林的相互依存模型</h4><p>霍特林的相互依存模型（Hotelling’s Model of Spatial Competition），又称霍特林线性城市模型，是哈罗德·霍特林（Harold Hotelling）在1929年提出的，用于描述厂商在地理空间上的竞争行为的经济模型。这个模型主要讨论了厂商在一个线性市场（通常被简化为一条线段）上如何选择其位置以最大化市场份额。</p><p><strong>模型假设</strong></p><ol><li><strong>线性市场</strong>：市场被假设为一条线段（通常取为[0, 1]）。</li><li><strong>消费者均匀分布</strong>：消费者均匀分布在这条线段上。</li><li><strong>两家厂商</strong>：市场上只有两家厂商（A和B）。</li><li><strong>产品同质</strong>：两家厂商提供相同的产品。</li><li><strong>运输成本</strong>：消费者选择离自己最近的厂商购买，且运输成本与距离成正比。</li><li><strong>价格相同</strong>：为了简化分析，假设两家厂商的产品价格相同，消费者只考虑运输成本。</li></ol><p><strong>核心思想</strong></p><p>霍特林模型通过分析厂商在市场上的位置选择，展示了厂商之间的相互依存关系以及这种关系如何影响市场结构和消费者行为。</p><p><strong>分析与结论</strong></p><ol><li><p><strong>初始位置选择</strong>：假设两家厂商最初分别位于线段的两端，即A在0点，B在1点。</p></li><li><p><strong>位置移动</strong>：</p><ul><li>如果其中一家厂商移动到离中点更近的位置，它会吸引更多的消费者，因为对于更多的消费者来说，这家厂商更接近，从而运输成本更低。</li><li>另一家厂商也会被迫移动以重新争取更多的市场份额。</li></ul></li><li><p><strong>纳什均衡</strong>：</p><ul><li>最终，两个厂商会在中点汇合，即线段的中点（0.5）。在这种情况下，两家厂商共享整个市场，因为对于任何消费者来说，两个厂商的距离是相等的。</li><li>虽然消费者对这两家厂商的距离相等，但他们的运输成本总和却是最大的。这就是所谓的“最小化消费者福利”的现象，因为两家厂商选择了使自身市场份额最大化的位置，而不是整体福利最大化的位置。</li></ul></li></ol><p><strong>现实意义</strong></p><ol><li><p><strong>零售市场</strong>：</p><ul><li>在现实生活中，这个模型可以解释为什么许多零售店（如便利店、快餐店）往往会集中在同一个区域而不是分散开来。</li><li>这种现象被称为“聚集效应”或“簇状竞争”。</li></ul></li><li><p><strong>政治竞争</strong>：</p><ul><li>在政治竞选中，候选人往往会在政治立场上趋于中间，以吸引更多的选民支持。这与霍特林模型中的厂商位置选择类似。</li></ul></li></ol><p><strong>主要局限</strong></p><ol><li><p><strong>假设过于简化</strong>：</p><ul><li>实际市场上，消费者的分布和偏好并非完全均匀。</li><li>产品差异化和价格竞争在现实中也是重要因素。</li></ul></li><li><p><strong>运输成本假设</strong>：</p><ul><li>运输成本假设过于简单，实际中可能包括多种复杂因素。</li></ul></li></ol><h4 id="帕兰德的市场区划分模型"><a href="#帕兰德的市场区划分模型" class="headerlink" title="帕兰德的市场区划分模型"></a>帕兰德的市场区划分模型</h4><p><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608145735.png"></p><h4 id="其他市场因素的作用"><a href="#其他市场因素的作用" class="headerlink" title="其他市场因素的作用"></a>其他市场因素的作用</h4><p>消费者差异性（如是否挑剔、文化差异）<br>企业作为消费者（中间产品需求）<br>政府作为消费者（政府采购政策）<br>市场一体化程度<br>市场分割（地方保护主义、市场进入成本）<br>市场歧视<br>市场交易成本（道德风险）</p><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><h4 id="举例说明自然环境、制度、社会环境对经济活动的影响，正式制度与非正式制度"><a href="#举例说明自然环境、制度、社会环境对经济活动的影响，正式制度与非正式制度" class="headerlink" title="举例说明自然环境、制度、社会环境对经济活动的影响，正式制度与非正式制度"></a>举例说明自然环境、制度、社会环境对经济活动的影响，正式制度与非正式制度</h4><p>吃高中老本</p><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><h4 id="韦伯工业区位论（概念、假设、论断、局限性等）"><a href="#韦伯工业区位论（概念、假设、论断、局限性等）" class="headerlink" title="韦伯工业区位论（概念、假设、论断、局限性等）"></a>韦伯工业区位论（概念、假设、论断、局限性等）</h4><p>概念：<br>成本最低的区位就是最好的区位</p><p>假设前提：<br>1、完全均质的平原，不存在自然、经济、文化、政治等方面的差异<br>2、企业生产一种产品、销售到一个市场<br>3、已知原料地的空间分布；<br>4、已知产品的消费地与规模；<br>5、已知各区位劳动成本，且劳动力不可以流动</p><p><strong>运费指向</strong>：</p><p>原材料的区分：<br>遍在原料：任何地方都有的原料；<br>限地原料：特定区位才有的原料；<br>纯原料：生产过程中不减重；<br>粗原料：生产过程中减少重量；</p><p>运费主要取决于重量与运距，其它如运输方式、可运性都可换算成重量与运距；<br>运输的物品主要是原材料和产品，重量与其性质有关，而运距与其区位有关；</p><p><img src="/../img/%E7%BB%8F%E6%B5%8E%E5%9C%B0%E7%90%86%E5%AD%A6/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240608150905.png"></p><p>简而言之 做出来的产品重量比限地原料重量轻的话就放在原料地（因为原料运费比产品运费贵</p><p>反之，抑或到处都可以找到原料的产品，那么就放在消费地</p><p><strong>劳动费指向</strong>：</p><p>劳动费指单位重量产品成本中用于劳动的支出，不仅反映工资水平，也体现劳动能力的差异；<br>劳动费在各地区是不同的，但假设它是固定不变的；<br>在运费最低的考虑之上，再加上对劳动费的考虑，寻求新的总费用最低点；<br>只有在最低劳动费区位带来的劳动成本节省额大于离开最低运费区位带来的运费增加额时，劳动费指向才能占主导地位；</p><p><strong>集聚指向</strong>：<br>当集聚带来的成本节省大于运费指向或劳动费指向的增加额时，便会发生集聚；<br>在考虑了运费和劳动费之后找到的最低费用点上，作出综合等费用线；集聚带来的节省额就是临界等费线；在几个企业临界等费线相覆盖的地方，就是企业集聚地；</p><p>韦伯理论的意义在于：<br>1、第一个系统地建立了现代工业区位理论，成为后来区位理论研究的基石；<br>2、把演绎法用于区位研究，为后来的学者提供了方法论；<br>3、对实际工业区位的解释具有很大的说服力，如原料指数与区位指向；</p><p>韦伯理论的局限性在于：<br>1、韦伯的理论是局部均衡理论，即单一企业的区位选择；没有考虑多企业的空间分布，没有考虑需求因素，即一般均衡问题；<br>2、韦伯的理论是静态局部均衡理论，只考虑了现实条件中的总成本最低；而实际的区位决策要考虑多因素未来的变化，是动态均衡；<br>3、其他局限性：没有考虑中间产品作为投入品的企业区位。<br>4、企业是完全抽象的，没有任何社会经济关系；<br>5、交通成本与距离不是线性关系</p><h4 id="胡佛的运费结构与运输方式"><a href="#胡佛的运费结构与运输方式" class="headerlink" title="胡佛的运费结构与运输方式"></a>胡佛的运费结构与运输方式</h4><p>韦伯的运费理论只考虑了线路运营费用；胡佛则把运费分为站场作业费和线路运输费两部分；<br>站场作业费包括了装卸费、仓库费、码头占用费等，与距离无关；<br>在没有中转的情况下，货物要装、卸各一次；在有中转时，站场作业费就更高；<br>运输距离越远，单位距离分摊的站场作业费就越低；为了减少总运费，企业布局要尽量减少货物中转；<br>交通枢纽成为企业的重要区位，尤其是不同运输方式连接的枢纽；</p><p>史密斯的收益空间、举例阐述战略区位选择（环保部门、政府或竞争者）、了解企业集聚理论、企业组织扩张的原因、区分扩张的路径和规律</p><p>第七章跨国公司对外投资动机及其理论、外资投资区位因素、跨国公司空间组织形式、区分生产链类型、跨国公司功能区位选择、理解国际生产一体化，贸易保护主义对跨国公司全球布局的影响</p><p>第八章农业土地利用的影响因素、区分农业生产类型、农业区位论、了解自然和人文因素变化对农作物空间格局的改变</p><p>第九章服务业类型、零售业区位要素（市场、交通、竞争）、零售业集聚与等级结构、了解中心地理论及相关概念、生产者服务业区位特点与要素、金融业空间集聚的解释、金融中心、了解中国物流业空间格局。</p><p>第十章海港区位论、确定交通线路走向、交通网络的刻画、交通网络演化模型及其应用、交通与区域发展的关系、交通需求三因素；认识高铁站选址及高铁建设对地区发展的影响。</p><p>第十一章 区域经济增长理论和发展理论、区域产业结构演进相关理论及区域空间结构、理解中国区域发展演进。</p><p>第十二章 区域分工理论、新型区域分工、区域相互作用、区域发展战略（增长极战略、进口替代战略、出口导向战略、国家竞争优势战略）</p><p>第十三章 经济全球化的特征与表现、经济全球化的主体、推动者与治理者、经济全球化的收益与成本、经济全球化过程中国家角色、理解多维全球网络、了解全球化的风险和悖论；一带一路倡议、国际贸易保护主义等影响。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>博客部署备份</title>
    <link href="/2024/06/03/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%A4%87%E4%BB%BD/"/>
    <url>/2024/06/03/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%A4%87%E4%BB%BD/</url>
    
    <content type="html"><![CDATA[<p><a href="https://pan.baidu.com/s/1DyuE9eFnICTYA06t0vUi8A?pwd=2ekw">这是博客的备份地址</a><br>之前有把以前写的一些技术文档弄丢的经历，，也上传了一些画的图片，但是都不幸丢失了，所以备份一下</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虾皮一面复盘</title>
    <link href="/2024/06/02/%E8%99%BE%E7%9A%AE%E4%B8%80%E9%9D%A2%E5%A4%8D%E7%9B%98/"/>
    <url>/2024/06/02/%E8%99%BE%E7%9A%AE%E4%B8%80%E9%9D%A2%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h2 id="一个一个项目问大概是怎么做的（应该是为了防止项目不是自己做的"><a href="#一个一个项目问大概是怎么做的（应该是为了防止项目不是自己做的" class="headerlink" title="一个一个项目问大概是怎么做的（应该是为了防止项目不是自己做的"></a>一个一个项目问大概是怎么做的（应该是为了防止项目不是自己做的</h2><p><strong>反问：udp如何实现有序传输？</strong><br>（只答了seq ack，其他的在介绍项目的时候也讲了，，不知道他听见了没</p><ol><li>添加seq&#x2F;ack机制<br>在可靠UDP的设计中，我们需要引入类似于TCP的seq&#x2F;ack机制。当发送端发送数据时，为每片数据分配一个唯一的序列号（seq），并在数据中携带该序列号。接收端收到数据后，将其放入缓存中，并发送一个确认（ack）包，其中包含已收到的序列号。通过这种方式，发送端可以知道哪些数据已被成功接收，哪些数据需要重传。</li><li>添加发送和接收缓冲区<br>为了实现数据的可靠传输，我们需要添加发送和接收缓冲区。发送缓冲区用于暂存待发送的数据，接收缓冲区用于暂存收到的数据。当接收端收到数据后，将其放入接收缓冲区中，等待确认。如果发送端收到了确认包，则从发送缓冲区中删除对应的数据。如果长时间未收到确认包，则定时任务会检查是否需要重传数据。</li><li>添加超时重传机制<br>为了处理网络延迟或丢包的情况，我们需要添加超时重传机制。当发送端在规定时间内未收到确认包时，会认为数据丢失或延迟，并触发重传机制。重传机制可以根据实际情况进行设计，比如每次重传的时间间隔递增、重传次数限制等。</li></ol><p><strong>反问：udp的应用场景？</strong></p><p>答：对实时性要求比较高的应用，（讲了音视频和dns解析，面试官补充了广播<br>网上的答案：<br>实时视频流和音频流传输，如在线直播、视频会议等<br>实时游戏中的游戏数据传输<br>DNS解析<br>NTP时间同步<br>广播和多播通信<br>在线游戏、VoIP通信、实时视频流服务、流媒体服务等软件案例</p><p><strong>反问：对除了hadoop以外其他的开源组件的了解</strong><br>kafka<br>（面试官补充：业界上hadoop用的少，spark和flink用的多 离线用spark，在线用flink，hadoop更多作为一个hdfs存储和批处理</p><p>反问：了解过Netty吗？因为Netty也是一个高性能、异步的网络通信框架<br>（面试官补充 可以了解一下BIO NIO AIO<br>（面试官补充 当然你现在在大三 基础知识更扎实也是非常不错的（诶！</p><p><strong>反问：知道mysql的底层存储方式吗</strong><br>（不知道他在问什么所以没答上来，实际上是知道的</p><p>MySQL的底层存储方式涉及多个方面，包括存储引擎、数据文件、索引文件和日志文件等。以下是主要的存储方式和相关组件：</p><h3 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h3><p>MySQL支持多种存储引擎，每种引擎的底层存储实现有所不同。最常用的存储引擎有：</p><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul><li><strong>数据文件</strong>：InnoDB的数据文件通常是.ibd文件，默认情况下，一个表一个.ibd文件，也可以配置为使用共享表空间（系统表空间）。</li><li><strong>索引文件</strong>：InnoDB的索引存储在数据文件中。InnoDB使用B+树作为其主要索引结构。</li><li><strong>日志文件</strong>：InnoDB使用重做日志（redo log）和撤销日志（undo log）来保证数据的一致性和事务的原子性。重做日志用于崩溃恢复，撤销日志用于事务回滚。</li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul><li><strong>数据文件</strong>：MyISAM的数据文件是.MYD文件，每个表对应一个.MYD文件。</li><li><strong>索引文件</strong>：MyISAM的索引存储在.MYI文件中。MyISAM也使用B+树结构来存储索引。</li><li><strong>日志文件</strong>：MyISAM没有内置的事务日志功能，但可以通过MySQL的二进制日志（binlog）来记录SQL语句。</li></ul><h3 id="2-数据存储结构"><a href="#2-数据存储结构" class="headerlink" title="2. 数据存储结构"></a>2. 数据存储结构</h3><ul><li><strong>行格式</strong>：MySQL支持不同的行格式，如Compact、Redundant、Dynamic和Compressed，主要用于InnoDB存储引擎。行格式决定了数据在磁盘上的存储方式和存储效率。</li><li><strong>页（Page）</strong>：数据文件被分成多个页，通常大小为16KB。页是InnoDB存储的基本单位，包括数据页、索引页、Undo页等。</li></ul><h3 id="3-索引结构"><a href="#3-索引结构" class="headerlink" title="3. 索引结构"></a>3. 索引结构</h3><ul><li><strong>B+树索引</strong>：大多数情况下，MySQL使用B+树结构来实现索引，如InnoDB和MyISAM。</li><li><strong>哈希索引</strong>：适用于内存表（MEMORY存储引擎）。</li><li><strong>全文索引</strong>：支持对文本字段的全文搜索，MyISAM和InnoDB都支持。</li><li><strong>空间索引</strong>：用于地理空间数据，InnoDB和MyISAM都支持。</li></ul><h3 id="4-日志文件"><a href="#4-日志文件" class="headerlink" title="4. 日志文件"></a>4. 日志文件</h3><ul><li><strong>二进制日志（binlog）</strong>：记录所有对数据库进行更改的SQL语句，用于主从复制和数据恢复。</li><li><strong>错误日志（error log）</strong>：记录MySQL服务器启动、停止及运行过程中出现的错误信息。</li><li><strong>慢查询日志（slow query log）</strong>：记录执行时间超过阈值的查询语句，用于性能调优。</li><li><strong>通用查询日志（general query log）</strong>：记录所有客户端连接和执行的语句。</li></ul><h3 id="5-表空间"><a href="#5-表空间" class="headerlink" title="5. 表空间"></a>5. 表空间</h3><p>InnoDB支持不同类型的表空间：</p><ul><li><strong>系统表空间</strong>：共享的表空间，存储系统表和用户表。</li><li><strong>独立表空间</strong>：每个表有独立的.ibd文件，便于单表备份和恢复。</li><li><strong>临时表空间</strong>：用于存储临时表和中间结果。</li></ul><h3 id="6-文件系统"><a href="#6-文件系统" class="headerlink" title="6. 文件系统"></a>6. 文件系统</h3><p>MySQL的数据文件、索引文件和日志文件通常存储在文件系统中，支持多种文件系统，如EXT4、XFS等。不同的文件系统在性能和功能上有所不同，选择合适的文件系统有助于提高数据库的性能和可靠性。</p><h2 id="我操他引导了一个问题我没听清"><a href="#我操他引导了一个问题我没听清" class="headerlink" title="我操他引导了一个问题我没听清"></a>我操他引导了一个问题我没听清</h2><p>我操他问我b树和b+树的区别，，我没听见</p><p><strong>反问：redis主从关系主从复制</strong><br>（答了rdb和aof结合，面试官在捧场 他可能觉得我没听懂他在讲什么</p><p>Redis的主从复制（Master-Slave Replication）是一种用于数据复制的机制，可以将数据从一个Redis实例（主节点）复制到一个或多个Redis实例（从节点）。这种机制可以提高数据的可用性和读取性能。下面是关于Redis主从复制的详细介绍：</p><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h3><ul><li><strong>主节点（Master）</strong>：负责处理写操作（写入、更新、删除数据），同时也可以处理读取操作。</li><li><strong>从节点（Slave）</strong>：主要用于处理读取操作，从节点会从主节点复制数据，并保持数据的一致性。多个从节点可以连接到同一个主节点。</li></ul><h3 id="2-配置主从复制"><a href="#2-配置主从复制" class="headerlink" title="2. 配置主从复制"></a>2. 配置主从复制</h3><h4 id="配置主节点"><a href="#配置主节点" class="headerlink" title="配置主节点"></a>配置主节点</h4><p>主节点的配置无需特别设置，只需正常启动Redis服务即可。</p><h4 id="配置从节点"><a href="#配置从节点" class="headerlink" title="配置从节点"></a>配置从节点</h4><p>从节点需要在配置文件中指定主节点的信息，以便从主节点进行数据复制。可以通过以下方式配置从节点：</p><p>在Redis配置文件中（通常是<code>redis.conf</code>），添加或修改以下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">replicaof &lt;master-ip&gt; &lt;master-port&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">replicaof 192.168.1.100 6379<br></code></pre></td></tr></table></figure><p>或者可以在运行时通过命令行配置从节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SLAVEOF &lt;master-ip&gt; &lt;master-port&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SLAVEOF 192.168.1.100 6379<br></code></pre></td></tr></table></figure><h3 id="3-复制过程"><a href="#3-复制过程" class="headerlink" title="3. 复制过程"></a>3. 复制过程</h3><h4 id="初次复制"><a href="#初次复制" class="headerlink" title="初次复制"></a>初次复制</h4><ol><li><strong>全量复制</strong>：<ul><li>当从节点第一次连接到主节点时，会进行全量复制。</li><li>主节点会创建一个RDB快照文件，并将其发送给从节点。</li><li>从节点接收RDB文件后，加载数据到内存中。</li><li>主节点在创建RDB文件的过程中，会将写操作记录在内存缓冲区中（复制积压缓冲区）。</li><li>从节点加载完RDB文件后，主节点会将内存缓冲区中的写操作同步给从节点，从而保证从节点的数据是最新的。</li></ul></li></ol><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><ul><li>在初次复制完成后，从节点会持续从主节点接收新的写操作并应用到自身数据中，从而保持数据的一致性。</li><li>增量复制是基于主节点的命令传播机制进行的，主节点会将写命令发送给所有从节点。</li></ul><h3 id="4-故障恢复"><a href="#4-故障恢复" class="headerlink" title="4. 故障恢复"></a>4. 故障恢复</h3><ul><li><strong>主节点故障</strong>：如果主节点发生故障，可以手动将某个从节点提升为主节点，通过重新配置其他从节点指向新的主节点来恢复集群服务。</li><li><strong>从节点故障</strong>：从节点故障不会影响主节点的正常运行，待从节点恢复后，会自动从主节点重新同步数据。</li></ul><h3 id="5-高级配置"><a href="#5-高级配置" class="headerlink" title="5. 高级配置"></a>5. 高级配置</h3><h4 id="延迟复制"><a href="#延迟复制" class="headerlink" title="延迟复制"></a>延迟复制</h4><p>可以设置从节点的复制延迟，以便在出现问题时有时间窗口进行数据恢复：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">replica-announce-ip &lt;ip&gt;<br>replica-announce-port &lt;port&gt;<br></code></pre></td></tr></table></figure><h4 id="只读从节点"><a href="#只读从节点" class="headerlink" title="只读从节点"></a>只读从节点</h4><p>可以配置从节点为只读模式，防止误写操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">replica-read-only yes<br></code></pre></td></tr></table></figure><h4 id="复制缓冲区大小"><a href="#复制缓冲区大小" class="headerlink" title="复制缓冲区大小"></a>复制缓冲区大小</h4><p>配置复制积压缓冲区的大小，以处理复制过程中可能出现的数据变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">repl-backlog-size &lt;bytes&gt;<br></code></pre></td></tr></table></figure><h3 id="6-监控和管理"><a href="#6-监控和管理" class="headerlink" title="6. 监控和管理"></a>6. 监控和管理</h3><ul><li>使用命令<code>INFO replication</code>查看复制状态和统计信息。</li><li>使用<code>SLAVEOF NO ONE</code>命令将从节点提升为主节点。</li><li>使用<code>DEBUG OBJECT</code>命令查看复制偏移量和积压缓冲区状态。</li></ul><h3 id="7-哨兵模式（Sentinel）"><a href="#7-哨兵模式（Sentinel）" class="headerlink" title="7. 哨兵模式（Sentinel）"></a>7. 哨兵模式（Sentinel）</h3><p>Redis还提供了哨兵（Sentinel）机制，用于自动化主从切换和故障恢复。哨兵会监控Redis实例，自动发现故障并执行主从切换。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis的主从复制机制提供了一种简单而有效的方式来实现数据的高可用性和负载均衡。理解和配置好主从复制可以显著提高Redis集群的稳定性和性能。</p><p>补充：redis在业界中还用的挺多的</p><p><strong>反问：对redis常用的数据结构了解吗</strong><br>Redis支持多种数据结构，每种数据结构都有其独特的底层实现。这些数据结构使Redis不仅仅是一个简单的键值存储，还能处理更复杂的数据操作和查询。以下是Redis主要数据结构及其底层实现的详细介绍：</p><h3 id="1-字符串（String）"><a href="#1-字符串（String）" class="headerlink" title="1. 字符串（String）"></a>1. 字符串（String）</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>字符串</strong>是Redis中最简单的数据类型，可以存储普通字符串、整数、浮点数等。</li></ul><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><strong>SDS（Simple Dynamic String）</strong>：Redis的字符串实现基于SDS，类似于C语言中的动态字符串。SDS不仅保存字符串的内容，还保存字符串的长度，避免了重复计算长度的问题。</li><li><strong>整数编码（Integer Encoding）</strong>：对于可以表示为64位带符号整数的字符串，Redis使用整数编码以减少内存使用。</li></ul><h3 id="2-列表（List）"><a href="#2-列表（List）" class="headerlink" title="2. 列表（List）"></a>2. 列表（List）</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>列表</strong>是一个有序的字符串集合，可以在列表的两端进行添加和删除操作。</li></ul><h4 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><strong>压缩列表（Ziplist）</strong>：用于保存长度较短、元素较少的列表。压缩列表是一种紧凑的、连续内存结构。</li><li><strong>双向链表（Linkedlist）</strong>：用于保存长度较长或元素较多的列表。双向链表可以高效地进行两端操作。</li><li><strong>快速列表（Quicklist）</strong>：Redis 3.2之后引入，结合了压缩列表和双向链表的优点，用于优化内存和性能。</li></ul><h3 id="3-集合（Set）"><a href="#3-集合（Set）" class="headerlink" title="3. 集合（Set）"></a>3. 集合（Set）</h3><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>集合</strong>是一个无序的字符串集合，集合中的每个元素是唯一的。</li></ul><h4 id="底层实现-2"><a href="#底层实现-2" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><strong>整数集合（Intset）</strong>：用于保存小整数集合，内存紧凑。</li><li><strong>哈希表（Hashtable）</strong>：用于保存更大且包含非整数值的集合，提供高效的添加、删除和查找操作。</li></ul><h3 id="4-有序集合（Sorted-Set）"><a href="#4-有序集合（Sorted-Set）" class="headerlink" title="4. 有序集合（Sorted Set）"></a>4. 有序集合（Sorted Set）</h3><h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>有序集合</strong>类似于集合，但每个元素都会关联一个分数，集合中的元素按分数排序。</li></ul><h4 id="底层实现-3"><a href="#底层实现-3" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><strong>跳表（Skiplist）</strong>：用于按分数排序的快速查找。</li><li><strong>哈希表（Hashtable）</strong>：用于元素和分数的快速查找。</li></ul><h3 id="5-哈希（Hash）"><a href="#5-哈希（Hash）" class="headerlink" title="5. 哈希（Hash）"></a>5. 哈希（Hash）</h3><h4 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>哈希</strong>是一个键值对集合，适合用于存储对象。</li></ul><h4 id="底层实现-4"><a href="#底层实现-4" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><strong>压缩列表（Ziplist）</strong>：用于保存小型哈希，内存紧凑。</li><li><strong>哈希表（Hashtable）</strong>：用于保存大型哈希，提供高效的键值对操作。</li></ul><h3 id="6-位图（Bitmap）"><a href="#6-位图（Bitmap）" class="headerlink" title="6. 位图（Bitmap）"></a>6. 位图（Bitmap）</h3><h4 id="数据结构-5"><a href="#数据结构-5" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>位图</strong>将字符串值视为位数组，可以对这些位进行各种位操作。</li></ul><h4 id="底层实现-5"><a href="#底层实现-5" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><strong>字符串底层实现</strong>：位图实际上是字符串的一种使用方式，每个字符对应8个位。</li></ul><h3 id="7-HyperLogLog"><a href="#7-HyperLogLog" class="headerlink" title="7. HyperLogLog"></a>7. HyperLogLog</h3><h4 id="数据结构-6"><a href="#数据结构-6" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>HyperLogLog</strong>是一种基数估计算法，用于估算集合中唯一元素的数量。</li></ul><h4 id="底层实现-6"><a href="#底层实现-6" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><strong>稀疏编码（Sparse Encoding）</strong>：用于保存小型HyperLogLog数据。</li><li><strong>密集编码（Dense Encoding）</strong>：用于保存大型HyperLogLog数据。</li></ul><h3 id="8-Geospatial"><a href="#8-Geospatial" class="headerlink" title="8. Geospatial"></a>8. Geospatial</h3><h4 id="数据结构-7"><a href="#数据结构-7" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>Geospatial</strong>数据结构用于存储地理位置信息，并提供基于位置的操作。</li></ul><h4 id="底层实现-7"><a href="#底层实现-7" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><strong>有序集合（Sorted Set）</strong>：使用有序集合来保存地理位置信息，每个地理位置的分数是其经过GeoHash编码后的值。</li></ul><h3 id="9-Stream"><a href="#9-Stream" class="headerlink" title="9. Stream"></a>9. Stream</h3><h4 id="数据结构-8"><a href="#数据结构-8" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><strong>Stream</strong>是一个日志数据结构，支持附加数据流和消费组。</li></ul><h4 id="底层实现-8"><a href="#底层实现-8" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><strong>列表和哈希表</strong>：用于保存数据条目和消费组信息，提供高效的追加和读取操作。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Redis支持的多种数据结构使其不仅适用于简单的键值存储，还能处理复杂的数据模型和查询需求。每种数据结构都有特定的底层实现，以优化内存使用和操作性能。理解这些数据结构及其实现有助于在不同场景中充分利用Redis的功能和优势。</p><p>编程题1：<br>原地把数组的零移到后面去<br>（双指针，一个cur指向遍历到的非零数，维护一个count作为遍历到的非零数个数，然后把a[cur]直接赋给a[count]，count++，最后把a[count]之后的数全都赋成0</p><p>编程题2：<br>岛屿数量<br>（dfs 没写过 最后搭了个框架没写完整 不过面试官说思路基本对了<br>（想起来了 和另一道最大正方形弄混了<br>（面试官提示 用淹没法<br>（反复沟通中 ···<br>（先处理边界 边界碰到的0与陆地相邻的所有的点都变成水域，因为边界不算封闭岛屿</p><p>相当于两道编程题ak了一道，另一道思路比较完整（在探讨中完善思路嘿嘿</p><p>网上搜了一篇强心剂</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">打住！不要再尴尬了，这样的想法是完全错误的！我们在面试中应该有的心态是：无论是八股文还是算法题还是其他，答不出来是很正常的！我们在面试里要做的是尽量展示自己的优点，为自己寻求面试通过的机会。<br><br>所以首先从心态上纠正自己的学生思维，面试并不是考试！通过了也只不过是找个地方打工罢了。<br><br>关于面试心态和技巧，我会在后续（应该是最后一篇）写一篇文章专门来说如何克服，这里就不再多展开了！（周五偷个懒）<br><br>好了，有点偏题，我们回到算法面试上来，首先我们要想明白，面试官通过算法到底想考察什么？答案是：<br><br>第一，考察代码水平，这里指的是代码规范性和逻辑性，比如<br>变量、函数的命名是否随意，有没有考虑函数边界、有没有抽函数的意识等<br>常见的数据结构是不是了解，会不会用。<br>遇到问题有没有充分思考，写代码有没有逻辑性。千万不要一看到题就写，写到一半发现思路是错的，这是大忌！最好是先说一下自己的思路再写，这样哪怕写错了，也说明你是经过了思考的。<br>遇到困难会不会想办法解决。你可以不会写，但是可以从一些不同的角度说说你认为的可能的解法，这说明你不是遇到困难就退缩的人。<br>沟通能力，这里就很灵活了，如果你沟通能力很强，可以找机会多和面试官讨论，展示你的交流表达能力。<br>第二，才是能不能解出来这道题。<br>根据我过往面试的经验，很多时候写不出算法也能通过面试，这个过程中我会不断的和面试官聊我的思路和困惑，并且尝试根据我的想法来写代码，这本身就展示了我处理问题的方式和能力。<br><br>所以，在算法面试前，不要抱着&quot;我一定要写出来!&quot;的预期，而是&quot;我写出来就血赚!&quot;。尽量避免预期太高、落差太大导致紧张，反而影响口头表达和其他方面的发挥。题目写不出来就努力把上面说的第一点做到，同时多和面试官交流，说说你对这道题的分析和思路，把能够表达的都表达出来就好啦。<br></code></pre></td></tr></table></figure><p>面试官：可能还有一些小瑕疵 我觉得倒不是很影响</p><p><strong>我反问：您对我有什么建议吗？</strong><br>建议？我觉得挺好的<br>大数据相关的生态组件可以多了解一下 spark flink hive kafka（框架 原理 更宏观一点</p><p><strong>我反问：这次面试多久可以出结果？</strong><br>一周以内吧 具体看hr（他：应该还好</p><p><strong>我反问：岗位技术栈就是您刚刚说的spark、flink之类的吗？</strong><br>技术栈 我觉得都还行 因为实习生都要学 之前匹不匹配都无所谓<br>spark flink sql java python（C++用的不是那么多</p><p><strong>面试官反复强调：我觉得还可以</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redis相关</title>
    <link href="/2024/05/30/redis%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/05/30/redis%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1945288">腾讯云文章链接</a></p><p>redis的跳表，就是在一个存储数据的双向链表上建立多级索引链表的结构。<br>每个跳表节点保存了sds ele，score，一个前驱指针和一个level数组，level数组是level节点，每个level节点保存了该level层下一个level节点的指针和跨度。<br>新节点使用一个抛硬币的随机算法确定层数（扔到反面为止，记录扔到正面的次数为层数），最低也有一层，即level0层。<br>最多是32层，<code>#define ZSKIPLIST_MAXLEVEL 32</code><br>level0层和跳表节点存储的obj和score还有前驱指针共同组成了一个双向链表。<br>创建过程就是寻找节点的过程，从最高层level层开始找每层level链表的终点(最大的小于目标值的那个节点)，最终找到目标节点，途中每层的终点记录下来，更新指针和跨度，一个过程顺便记录每层跨度和，最后累加起来就是目标节点的rank。<br>跳表绝大多数情况下性能和平衡树相当，但实现起来比平衡树简单，而且更适合范围查找，更加适合实现zset的结构。<br>zset实际上是跳表加字典，字典用来实现set的功能，跳表用来实现rank的功能</p><h3 id="空跳表的创建"><a href="#空跳表的创建" class="headerlink" title="空跳表的创建"></a>空跳表的创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 创建并返回一个新的跳跃表</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * T = O(1)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">zskiplist *<span class="hljs-title">zslCreate</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    zskiplist *zsl;<br><br>    <span class="hljs-comment">// 分配空间</span><br>    zsl = <span class="hljs-built_in">zmalloc</span>(<span class="hljs-built_in">sizeof</span>(*zsl));<br><br>    <span class="hljs-comment">// 设置高度和起始层数</span><br>    zsl-&gt;level = <span class="hljs-number">1</span>;<br>    zsl-&gt;length = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 初始化表头节点</span><br>    <span class="hljs-comment">// T = O(1)</span><br>    zsl-&gt;header = <span class="hljs-built_in">zslCreateNode</span>(ZSKIPLIST_MAXLEVEL,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;<br>        zsl-&gt;header-&gt;level[j].forward = <span class="hljs-literal">NULL</span>;<br>        zsl-&gt;header-&gt;level[j].span = <span class="hljs-number">0</span>;<br>    &#125;<br>    zsl-&gt;header-&gt;backward = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 设置表尾</span><br>    zsl-&gt;tail = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> zsl;<br>&#125;<br></code></pre></td></tr></table></figure><p>Redis 的跳表（skip list）实现主要用于有序集合（Sorted Set），其源码位于 <code>src/t_zset.c</code> 文件中。跳表是一种概率平衡的数据结构，它允许高效的查找、插入和删除操作。下面我们详细讲解一下跳表节点在 Redis 中的实现。</p><h3 id="跳表节点的数据结构"><a href="#跳表节点的数据结构" class="headerlink" title="跳表节点的数据结构"></a>跳表节点的数据结构</h3><p>在 Redis 中，跳表节点使用 <code>zskiplistNode</code> 结构体表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> &#123;</span><br>    sds ele;                       <span class="hljs-comment">// 元素</span><br>    <span class="hljs-comment">// 比如在微博topK热搜情景下就是热搜标题</span><br>    <span class="hljs-type">double</span> score;                  <span class="hljs-comment">// 分数</span><br>    <span class="hljs-comment">// 比如在微博topK热搜情景下就是具体的热度值</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">backward</span>;</span><span class="hljs-comment">// 后退指针</span><br>    <span class="hljs-comment">// 反向遍历用的</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistLevel</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">forward</span>;</span> <span class="hljs-comment">// 前进指针</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> span;            <span class="hljs-comment">// 跨度</span><br>    &#125; level[];                      <span class="hljs-comment">// 层级数组</span><br>    <span class="hljs-comment">// 每个层级都有对应的前进指针和跨度</span><br>&#125; zskiplistNode;<br></code></pre></td></tr></table></figure><ul><li><code>ele</code>：节点存储的元素，是一个简单动态字符串（simple dynamic string, sds）。</li><li><code>score</code>：节点的分数，用于排序。</li><li><code>backward</code>：指向前一个节点的指针，便于反向遍历。</li><li><code>level</code>：一个数组，包含多个层级，每个层级有一个前进指针 <code>forward</code> 和跨度 <code>span</code>。</li></ul><p>每个 <code>zskiplistNode</code> 包含一个灵活数组 <code>level[]</code>，这个数组的大小取决于节点的层数。</p><h3 id="跳表的数据结构"><a href="#跳表的数据结构" class="headerlink" title="跳表的数据结构"></a>跳表的数据结构</h3><p>跳表本身使用 <code>zskiplist</code> 结构体表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplist</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">zskiplistNode</span> *<span class="hljs-title">header</span>, *<span class="hljs-title">tail</span>;</span> <span class="hljs-comment">// 头节点和尾节点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> length;                <span class="hljs-comment">// 节点总数</span><br>    <span class="hljs-type">int</span> level;                           <span class="hljs-comment">// 跳表的层数</span><br>&#125; zskiplist;<br></code></pre></td></tr></table></figure><ul><li><code>header</code>：指向跳表的头节点。</li><li><code>tail</code>：指向跳表的尾节点。</li><li><code>length</code>：记录跳表的节点总数。</li><li><code>level</code>：记录跳表的当前层数。</li></ul><h3 id="跳表节点的创建"><a href="#跳表节点的创建" class="headerlink" title="跳表节点的创建"></a>跳表节点的创建</h3><p>创建跳表节点的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">zskiplistNode* <span class="hljs-title function_">zslCreateNode</span><span class="hljs-params">(<span class="hljs-type">int</span> level, <span class="hljs-type">double</span> score, sds ele)</span> &#123;<br>    zskiplistNode *zn = zmalloc(<span class="hljs-keyword">sizeof</span>(*zn) + level * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> zskiplistLevel));<br>    zn-&gt;score = score;<br>    zn-&gt;ele = ele;<br>    <span class="hljs-keyword">return</span> zn;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数接收节点的层数、分数和元素，然后分配内存并初始化节点。</p><h3 id="跳表节点的插入"><a href="#跳表节点的插入" class="headerlink" title="跳表节点的插入"></a>跳表节点的插入</h3><p>插入节点是跳表的核心操作之一，下面是插入节点的关键代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">zskiplistNode* <span class="hljs-title function_">zslInsert</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, sds ele)</span> &#123;<br>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rank[ZSKIPLIST_MAXLEVEL];<br>    <span class="hljs-type">int</span> i, level;<br><br>    <span class="hljs-comment">// 初始化更新数组和排名数组</span><br>    x = zsl-&gt;header;<br>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        rank[i] = (i == zsl-&gt;level<span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : rank[i+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp; <br>              (x-&gt;level[i].forward-&gt;score &lt; score || <br>              (x-&gt;level[i].forward-&gt;score == score &amp;&amp; sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>))) &#123;<br>            rank[i] += x-&gt;level[i].span;<br>            x = x-&gt;level[i].forward;<br>        &#125;<br>        update[i] = x;<br>    &#125;<br><br>    <span class="hljs-comment">// 随机生成新节点的层数</span><br>    level = zslRandomLevel();<br>    <span class="hljs-keyword">if</span> (level &gt; zsl-&gt;level) &#123;<br>        <span class="hljs-keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;<br>            rank[i] = <span class="hljs-number">0</span>;<br>            update[i] = zsl-&gt;header;<br>            update[i]-&gt;level[i].span = zsl-&gt;length;<br>        &#125;<br>        zsl-&gt;level = level;<br>    &#125;<br><br>    x = zslCreateNode(level, score, ele);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;<br>        update[i]-&gt;level[i].forward = x;<br><br>        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="hljs-number">0</span>] - rank[i]);<br>        update[i]-&gt;level[i].span = (rank[<span class="hljs-number">0</span>] - rank[i]) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;<br>        update[i]-&gt;level[i].span++;<br>    &#125;<br><br>    x-&gt;backward = (update[<span class="hljs-number">0</span>] == zsl-&gt;header) ? <span class="hljs-literal">NULL</span> : update[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward)<br>        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x;<br>    <span class="hljs-keyword">else</span><br>        zsl-&gt;tail = x;<br><br>    zsl-&gt;length++;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数首先找到需要插入新节点的位置，然后随机生成新节点的层数，并更新相关节点的指针和跨度。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的代码和解释，我们可以看到 Redis 跳表节点的实现细节。跳表节点使用灵活数组来存储每一层的前进指针和跨度。节点的插入操作涉及查找插入位置、创建新节点和更新相关指针。跳表在 Redis 中提供了高效的有序集合操作，支持快速的查找、插入和删除。</p><p>好的，我们通过具体的例子来讲解 Redis 跳表中插入节点和删除节点的过程。假设我们有一个空的跳表，下面是几个操作步骤：</p><h3 id="插入节点过程"><a href="#插入节点过程" class="headerlink" title="插入节点过程"></a>插入节点过程</h3><ol><li><p><strong>插入第一个节点</strong>：</p><ul><li>插入元素 “A”，分数为 1.0。</li><li>随机生成层数为 1。</li></ul><p> 初始化后的跳表结构：<br> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Level <span class="hljs-number">0</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(A, <span class="hljs-number">1.0</span>)</span> -&gt;</span> NULL<br></code></pre></td></tr></table></figure></p></li><li><p><strong>插入第二个节点</strong>：</p><ul><li>插入元素 “B”，分数为 2.0。</li><li>随机生成层数为 2。</li></ul><p> 更新后的跳表结构：<br> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Level <span class="hljs-number">1</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(B, <span class="hljs-number">2.0</span>)</span> -&gt;</span> NULL<br>Level <span class="hljs-number">0</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(A, <span class="hljs-number">1.0</span>)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(B, <span class="hljs-number">2.0</span>)</span> -&gt;</span> NULL<br></code></pre></td></tr></table></figure></p></li><li><p><strong>插入第三个节点</strong>：</p><ul><li>插入元素 “C”，分数为 1.5。</li><li>随机生成层数为 1。</li></ul><p> 更新后的跳表结构：<br> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Level <span class="hljs-number">1</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(B, <span class="hljs-number">2.0</span>)</span> -&gt;</span> NULL<br>Level <span class="hljs-number">0</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(A, <span class="hljs-number">1.0</span>)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(C, <span class="hljs-number">1.5</span>)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(B, <span class="hljs-number">2.0</span>)</span> -&gt;</span> NULL<br></code></pre></td></tr></table></figure></p></li></ol><h3 id="删除节点过程"><a href="#删除节点过程" class="headerlink" title="删除节点过程"></a>删除节点过程</h3><p>假设当前跳表结构如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Level <span class="hljs-number">2</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(D, <span class="hljs-number">3.0</span>)</span> -&gt;</span> NULL<br>Level <span class="hljs-number">1</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(B, <span class="hljs-number">2.0</span>)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(D, <span class="hljs-number">3.0</span>)</span> -&gt;</span> NULL<br>Level <span class="hljs-number">0</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(A, <span class="hljs-number">1.0</span>)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(C, <span class="hljs-number">1.5</span>)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(B, <span class="hljs-number">2.0</span>)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(D, <span class="hljs-number">3.0</span>)</span> -&gt;</span> NULL<br></code></pre></td></tr></table></figure><p>我们要删除节点 “B”，分数为 2.0，删除过程如下：</p><ol><li><p><strong>查找节点 “B” 的位置</strong>：</p><ul><li>从跳表的最高层开始查找，每一层都更新 <code>update</code> 数组记录需要修改的前进指针。</li></ul><p> 查找过程：<br> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Level</span> <span class="hljs-number">2</span>: (Header) -&gt; (D, <span class="hljs-number">3</span>.<span class="hljs-number">0</span>)  (update[<span class="hljs-number">2</span>] = Header)<br><span class="hljs-attribute">Level</span> <span class="hljs-number">1</span>: (Header) -&gt; (B, <span class="hljs-number">2</span>.<span class="hljs-number">0</span>)  (update[<span class="hljs-number">1</span>] = Header)<br><span class="hljs-attribute">Level</span> <span class="hljs-number">0</span>: (Header) -&gt; (A, <span class="hljs-number">1</span>.<span class="hljs-number">0</span>) -&gt; (C, <span class="hljs-number">1</span>.<span class="hljs-number">5</span>) -&gt; (B, <span class="hljs-number">2</span>.<span class="hljs-number">0</span>)  (update[<span class="hljs-number">0</span>] = (C, <span class="hljs-number">1</span>.<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure></p></li><li><p><strong>更新前进指针和跨度</strong>：</p><ul><li>从每一层中删除节点 “B”，更新 <code>update</code> 数组中的前进指针和跨度。</li></ul><p> 更新后的跳表结构：<br> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">Level <span class="hljs-number">2</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(D, <span class="hljs-number">3.0</span>)</span> -&gt;</span> NULL<br>Level <span class="hljs-number">1</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(D, <span class="hljs-number">3.0</span>)</span> -&gt;</span> NULL<br>Level <span class="hljs-number">0</span>: <span class="hljs-function"><span class="hljs-params">(Header)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(A, <span class="hljs-number">1.0</span>)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(C, <span class="hljs-number">1.5</span>)</span> -&gt;</span> <span class="hljs-function"><span class="hljs-params">(D, <span class="hljs-number">3.0</span>)</span> -&gt;</span> NULL<br></code></pre></td></tr></table></figure></p></li><li><p><strong>更新后退指针</strong>：</p><ul><li>更新节点 “C” 和 “D” 的后退指针，确保正确的双向链接。</li><li>减少跳表的节点数量，并调整跳表的层数。</li></ul></li></ol><h3 id="代码实现对比"><a href="#代码实现对比" class="headerlink" title="代码实现对比"></a>代码实现对比</h3><p>假设我们现在插入和删除的节点的实现代码如下：</p><p>**插入节点 “C”**：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c">zskiplistNode* <span class="hljs-title function_">zslInsert</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, sds ele)</span> &#123;<br>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> rank[ZSKIPLIST_MAXLEVEL];<br>    <span class="hljs-type">int</span> i, level;<br><br>    x = zsl-&gt;header;<br>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        rank[i] = (i == zsl-&gt;level<span class="hljs-number">-1</span>) ? <span class="hljs-number">0</span> : rank[i+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;<br>              (x-&gt;level[i].forward-&gt;score &lt; score ||<br>              (x-&gt;level[i].forward-&gt;score == score &amp;&amp; sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>))) &#123;<br>            rank[i] += x-&gt;level[i].span;<br>            x = x-&gt;level[i].forward;<br>        &#125;<br>        update[i] = x;<br>    &#125;<br><br>    level = zslRandomLevel();<br>    <span class="hljs-keyword">if</span> (level &gt; zsl-&gt;level) &#123;<br>        <span class="hljs-keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;<br>            rank[i] = <span class="hljs-number">0</span>;<br>            update[i] = zsl-&gt;header;<br>            update[i]-&gt;level[i].span = zsl-&gt;length;<br>        &#125;<br>        zsl-&gt;level = level;<br>    &#125;<br><br>    x = zslCreateNode(level, score, ele);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;<br>        update[i]-&gt;level[i].forward = x;<br><br>        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="hljs-number">0</span>] - rank[i]);<br>        update[i]-&gt;level[i].span = (rank[<span class="hljs-number">0</span>] - rank[i]) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;<br>        update[i]-&gt;level[i].span++;<br>    &#125;<br><br>    x-&gt;backward = (update[<span class="hljs-number">0</span>] == zsl-&gt;header) ? <span class="hljs-literal">NULL</span> : update[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward)<br>        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x;<br>    <span class="hljs-keyword">else</span><br>        zsl-&gt;tail = x;<br><br>    zsl-&gt;length++;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>**删除节点 “B”**：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">zslDelete</span><span class="hljs-params">(zskiplist *zsl, <span class="hljs-type">double</span> score, sds ele, zskiplistNode **node)</span> &#123;<br>    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;<br>    <span class="hljs-type">int</span> i;<br><br>    x = zsl-&gt;header;<br>    <span class="hljs-keyword">for</span> (i = zsl-&gt;level<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (x-&gt;level[i].forward &amp;&amp;<br>              (x-&gt;level[i].forward-&gt;score &lt; score ||<br>              (x-&gt;level[i].forward-&gt;score == score &amp;&amp; sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="hljs-number">0</span>))) &#123;<br>            x = x-&gt;level[i].forward;<br>        &#125;<br>        update[i] = x;<br>    &#125;<br><br>    x = x-&gt;level[<span class="hljs-number">0</span>].forward;<br>    <span class="hljs-keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="hljs-number">0</span>) &#123;<br>        zslDeleteNode(zsl, x, update);<br>        <span class="hljs-keyword">if</span> (!node)<br>            sdsfree(x-&gt;ele);<br>        zfree(x);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (node) *node = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">zslDeleteNode</span><span class="hljs-params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; zsl-&gt;level; i++) &#123;<br>        <span class="hljs-keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;<br>            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="hljs-number">1</span>;<br>            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            update[i]-&gt;level[i].span -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (x-&gt;level[<span class="hljs-number">0</span>].forward) &#123;<br>        x-&gt;level[<span class="hljs-number">0</span>].forward-&gt;backward = x-&gt;backward;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        zsl-&gt;tail = x-&gt;backward;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (zsl-&gt;level &gt; <span class="hljs-number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="hljs-number">-1</span>].forward == <span class="hljs-literal">NULL</span>)<br>        zsl-&gt;level--;<br><br>    zsl-&gt;length--;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过具体例子和代码实现对比，我们可以更清晰地理解跳表节点插入和删除操作的细节。跳表通过随机层数和灵活的前进&#x2F;后退指针，实现了高效的有序集合操作。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/2024/05/29/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/05/29/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>题目暗藏玄机，，，<br>错误案例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;hash;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">res</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            hash.<span class="hljs-built_in">emplace</span>(nums[i],i);<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(target-nums[i])!=hash.<span class="hljs-built_in">end</span>())&#123;<br>                res[<span class="hljs-number">0</span>]=hash[nums[i]];<br>                res[<span class="hljs-number">1</span>]=hash[target-nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>数组中同一个元素在答案里不能重复出现（过不了案例三：[3,3] target&#x3D;6<br>这样会输出两个零</p><p>所以不要提前emplace进去（顺便记得要写emplace，不是push。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;hash;<br>        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">res</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-comment">// hash.emplace(nums[i],i);</span><br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">find</span>(target-nums[i])!=hash.<span class="hljs-built_in">end</span>())&#123;<br>                res[<span class="hljs-number">0</span>]=i;<br>                res[<span class="hljs-number">1</span>]=hash[target-nums[i]];<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            hash.<span class="hljs-built_in">emplace</span>(nums[i],i);<br>            <span class="hljs-comment">// 最后再放</span><br>            <span class="hljs-comment">// 覆盖重复的也没事</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>平衡二叉树</title>
    <link href="/2024/05/29/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/05/29/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>错误案例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(root-&gt;left),<span class="hljs-built_in">height</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">height</span>(root-&gt;left)&gt;<span class="hljs-built_in">height</span>(root-&gt;right)+<span class="hljs-number">1</span>||<span class="hljs-built_in">height</span>(root-&gt;right)&gt;<span class="hljs-built_in">height</span>(root-&gt;left)+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>错误原因：<br>左子树和右子树也必须是平衡二叉树，不能只看高度</p><p>正确代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">height</span>(root-&gt;left),<span class="hljs-built_in">height</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">bool</span> heightflag = <span class="hljs-built_in">height</span>(root-&gt;left)-<span class="hljs-built_in">height</span>(root-&gt;right)&gt;<span class="hljs-number">1</span>||<span class="hljs-built_in">height</span>(root-&gt;right)-<span class="hljs-built_in">height</span>(root-&gt;left)&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> !heightflag&amp;&amp;<span class="hljs-built_in">isBalanced</span>(root-&gt;left)&amp;&amp;<span class="hljs-built_in">isBalanced</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>求根节点到叶节点数字之和</title>
    <link href="/2024/05/28/%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <url>/2024/05/28/%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> v,TreeNode *l,TreeNode *r)&#123;<br>        value = v;<br>        left = l;<br>        right = r;<br>    &#125;<br>    <br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(TreeNode* cur,<span class="hljs-type">int</span> tmp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (cur==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    tmp = tmp*<span class="hljs-number">10</span>+cur-&gt;value;<br>    <span class="hljs-keyword">if</span> (cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-comment">// 叶子结点</span><br>        result += tmp;<br>    &#125;<br>    <span class="hljs-comment">// else if (cur-&gt;left!=nullptr)&#123;</span><br>    <span class="hljs-comment">//     cal(cur-&gt;left,tmp);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// else&#123;</span><br>    <span class="hljs-comment">//     cal(cur-&gt;right,tmp);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 注释代码是错的！！！要同时遍历左子树和右子树，否则就会出现只遍历了一棵子树的情况</span><br>    <span class="hljs-keyword">if</span> (cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<span class="hljs-built_in">cal</span>(cur-&gt;left,tmp);<br>    <span class="hljs-keyword">if</span> (cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<span class="hljs-built_in">cal</span>(cur-&gt;right,tmp);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    root-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    root-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">cal</span>(root,<span class="hljs-number">0</span>);<br>    cout&lt;&lt;result;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虾皮大数据岗紧急准备</title>
    <link href="/2024/05/28/%E8%99%BE%E7%9A%AE%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B2%97%E7%B4%A7%E6%80%A5%E5%87%86%E5%A4%87/"/>
    <url>/2024/05/28/%E8%99%BE%E7%9A%AE%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B2%97%E7%B4%A7%E6%80%A5%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<p>还以为挂了orz！笔试都考了一周了</p><h3 id="为什么想要了解Kafka？知道其它的消息队列吗？"><a href="#为什么想要了解Kafka？知道其它的消息队列吗？" class="headerlink" title="为什么想要了解Kafka？知道其它的消息队列吗？"></a>为什么想要了解Kafka？知道其它的消息队列吗？</h3><p>（这个字节好像也问过！<br>Kafka 是一个强大的<strong>分布式流处理平台</strong>，它能够与多种不同的技术集成。它可以从数据库如 MySQL <strong>提取实时变更数据</strong>，通过 Kafka Connect 与 Hadoop 集成用于<strong>大数据存储和处理</strong>，并与 Redis 集成实现<strong>实时缓存和快速数据访问</strong>。</p><h3 id="配置-hadoop-集群的时候遇到的问题"><a href="#配置-hadoop-集群的时候遇到的问题" class="headerlink" title="配置 hadoop 集群的时候遇到的问题"></a>配置 hadoop 集群的时候遇到的问题</h3><p>我复制了好多台虚拟机来配这个 hadoop 集群（额如果他真的要共享屏幕的话就说不在这台电脑里好力），配置SSH无密码公钥验证<br><strong>原理：</strong><br>NameNode（master）上要先生成一个密钥对，包含一个公钥和一个私钥，然后把所有的公钥复制到datanode（slave）上，namenode通过ssh连接datanode时，Salve就会生成一个随机数并用Master的公钥对随机数进行加密，并发送给Master。Master收到加密数之后再用私钥解密，并将解密数回传给Slave，Slave确认解密数无误之后就允许Master进行连接了。这就是一个公钥认证过程，其间不需要用户手工输入密码。重要过程是将客户端Master复制到Slave上。</p><p><strong>步骤：</strong><br>先修改一下authorized_keys文件权限，终端运行命令ssh keygen生成密码对，把id_rsa.pub加到授权的key里面去</p><p><strong>遇到的问题：</strong><br>修改了之后仍然让我输密码</p><p><strong>解决方案：</strong><br>用root用户登录服务器修改SSH配置文件，启用RSA认证和公钥私钥配对认证方式，并配置了公钥文件路径，重启ssh服务，然后再完成上面的复制步骤就好了，我用cat命令把id_rsa.pub里面的内容追加（使用&gt;&gt;记号），slave无密码登录master也同理的，就是重复刚才的步骤，每个slave本地自己生成密钥对，然后分别复制就好了。</p><h3 id="字节问的：hadoop一个块默认多大"><a href="#字节问的：hadoop一个块默认多大" class="headerlink" title="字节问的：hadoop一个块默认多大"></a>字节问的：hadoop一个块默认多大</h3><p>128mb（hdfs-site里面可以调）</p><h3 id="进程线程协程的区别"><a href="#进程线程协程的区别" class="headerlink" title="进程线程协程的区别"></a>进程线程协程的区别</h3><p>进程、线程和协程是计算机程序执行的三种不同单位。它们在操作系统资源管理、调度和执行上有不同的特点和用途。以下是对它们的详细比较和区别：</p><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li><strong>定义</strong>：进程是一个程序的实例，是操作系统进行资源分配和调度的基本单位。</li><li><strong>独立性</strong>：进程之间是独立的，每个进程都有自己独立的内存空间、全局变量、文件句柄等资源。</li><li><strong>通信</strong>：进程间通信（IPC）需要通过操作系统提供的机制（如管道、信号、共享内存、消息队列等），这些机制通常比较复杂和耗时。</li><li><strong>开销</strong>：进程的创建和切换开销较大，因为涉及到资源的分配、内存的管理以及上下文的切换。</li><li><strong>并行</strong>：进程可以在多核系统中并行执行。</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li><strong>定义</strong>：线程是进程中的一个执行单元，是操作系统调度的基本单位。</li><li><strong>共享性</strong>：线程共享同一个进程的内存空间、全局变量、文件句柄等资源，但每个线程有自己的堆栈和寄存器。</li><li><strong>通信</strong>：由于线程共享同一进程的地址空间，线程间通信（如通过共享变量）比进程间通信更高效，但需要注意同步和互斥，防止竞争条件和死锁。</li><li><strong>开销</strong>：线程的创建和切换开销比进程小，但仍然涉及内核的调度和管理。</li><li><strong>并行</strong>：线程可以在多核系统中并行执行。</li></ul><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul><li><strong>定义</strong>：协程是一种比线程更轻量级的执行单元，协程由程序员在用户空间进行调度，而不是由操作系统内核进行调度。</li><li><strong>共享性</strong>：协程通常在单个线程内运行，共享线程的资源。</li><li><strong>通信</strong>：协程间通信非常高效，因为它们运行在同一线程中，通常通过共享内存和局部变量进行通信。</li><li><strong>开销</strong>：协程的创建和切换开销极小，因为切换只是局部状态的保存和恢复，不涉及内核的上下文切换。</li><li><strong>并发</strong>：协程通过让出（yield）和恢复（resume）来实现协作式并发，而不是抢占式并行。协程适合 I&#x2F;O 密集型和高并发任务，但不适合 CPU 密集型任务。</li><li><strong>并行</strong>：协程不能并行执行，因为它们运行在单个线程中，但可以与多线程结合使用，实现更复杂的并行和并发模型。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>特性</th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>定义</td><td>操作系统资源分配和调度的基本单位</td><td>进程中的执行单元</td><td>用户空间内的轻量级执行单元</td></tr><tr><td>独立性</td><td>独立内存空间</td><td>共享进程内存空间</td><td>共享线程内存空间</td></tr><tr><td>通信</td><td>复杂，使用 IPC 机制</td><td>共享内存，需同步和互斥</td><td>共享内存，通信高效</td></tr><tr><td>创建和切换开销</td><td>高</td><td>较低</td><td>最低</td></tr><tr><td>调度</td><td>由操作系统内核调度</td><td>由操作系统内核调度</td><td>由用户程序调度</td></tr><tr><td>并发和并行</td><td>并发和并行</td><td>并发和并行</td><td>并发，不支持并行（单线程内）</td></tr><tr><td>适用场景</td><td>独立运行的应用程序</td><td>CPU 密集型和 I&#x2F;O 密集型任务</td><td>高并发和 I&#x2F;O 密集型任务，事件驱动</td></tr></tbody></table><p>进程、线程和协程各有优缺点，选择使用哪种执行单元取决于具体的应用场景和需求。进程适用于需要强隔离的独立任务，线程适用于需要并行处理的 CPU 密集型任务，而协程适用于高并发的 I&#x2F;O 密集型任务。</p><h3 id="什么是野指针？如何避免？"><a href="#什么是野指针？如何避免？" class="headerlink" title="什么是野指针？如何避免？"></a>什么是野指针？如何避免？</h3><p>野指针（Dangling Pointer）是指向已被释放或无效内存区域的指针。使用野指针会导致不可预测的行为，通常会引起程序崩溃、数据损坏或者安全漏洞。</p><h4 id="野指针的成因"><a href="#野指针的成因" class="headerlink" title="野指针的成因"></a>野指针的成因</h4><ol><li><p><strong>指针未初始化</strong>：指针声明后未被初始化，指向一个未知的内存地址。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p;  <span class="hljs-comment">// p 未初始化，指向未知地址</span><br>*p = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 未定义行为</span><br></code></pre></td></tr></table></figure></li><li><p>**内存释放后未将指针置为 <code>nullptr</code>**：动态分配内存后释放内存，但未将指针置为 <code>nullptr</code>，导致指针仍指向原来的（但已释放的）内存地址。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">delete</span> p;  <span class="hljs-comment">// 释放内存</span><br><span class="hljs-comment">// p 现在是野指针，因为它仍指向已释放的内存地址</span><br></code></pre></td></tr></table></figure></li><li><p><strong>栈上的指针引用已经结束的变量</strong>：函数返回局部变量的地址或引用，离开作用域后该地址可能被其他数据覆盖。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">getPointer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> &amp;x;  <span class="hljs-comment">// 返回局部变量的地址</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> *p = <span class="hljs-built_in">getPointer</span>();  <span class="hljs-comment">// p 是野指针</span><br>    <span class="hljs-comment">// 使用 p 会导致未定义行为</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>指针运算错误</strong>：指针运算导致指向非法内存区域。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> *p = arr;<br>p += <span class="hljs-number">10</span>;  <span class="hljs-comment">// p 指向了数组边界之外</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="检测和防止野指针"><a href="#检测和防止野指针" class="headerlink" title="检测和防止野指针"></a>检测和防止野指针</h4><ol><li><p><strong>指针初始化</strong>：声明指针时初始化它，最好将其初始化为 <code>nullptr</code>。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></li><li><p>**内存释放后将指针置为 <code>nullptr</code>**：在释放动态分配的内存后，将指针置为 <code>nullptr</code>。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 避免野指针</span><br></code></pre></td></tr></table></figure></li><li><p><strong>智能指针</strong>：使用 C++ 的智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>）来自动管理内存，防止内存泄漏和野指针。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 自动管理内存，不会出现野指针</span><br></code></pre></td></tr></table></figure></li><li><p><strong>避免返回局部变量的地址</strong>：不要返回局部变量的地址或引用。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">getPointer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 使用静态变量而不是局部变量</span><br>    <span class="hljs-keyword">return</span> &amp;x;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>指针运算谨慎</strong>：在进行指针运算时，要确保指针始终指向有效的内存区域。</p></li></ol><h4 id="示例代码：避免野指针"><a href="#示例代码：避免野指针" class="headerlink" title="示例代码：避免野指针"></a>示例代码：避免野指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>  <span class="hljs-comment">// 引入智能指针</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; p = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 使用智能指针管理内存</span><br>    std::cout &lt;&lt; *p &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 无需显式 delete，智能指针会在作用域结束时自动释放内存</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">process</span>();<br><br>    <span class="hljs-type">int</span> *arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">delete</span>[] arr;<br>    arr = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 避免野指针</span><br><br>    <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 初始化指针</span><br>    <span class="hljs-keyword">if</span> (p) &#123;<br>        *p = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 只有在 p 非空时才使用</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过正确的指针管理和良好的编程习惯，可以有效避免野指针的产生，确保程序的稳定性和安全性。</p><h3 id="Kafka-和-MySQL"><a href="#Kafka-和-MySQL" class="headerlink" title="Kafka 和 MySQL"></a>Kafka 和 MySQL</h3><ol><li><strong>数据集成与ETL</strong>：<ul><li><strong>Kafka Connect</strong>：Kafka Connect 是 Kafka 的一个组件，可以用于连接不同的数据源和目标。它有许多现成的连接器，包括 MySQL。你可以<strong>使用 Kafka Connect 从 MySQL 中提取数据，并将其写入 Kafka 主题</strong>。</li><li>**数据变更捕获 (CDC)**：通过工具如 Debezium，可以捕获 MySQL 数据库中的数据变更，并将变更事件流式传输到 Kafka。这对于实时数据同步和事件驱动架构非常有用。</li></ul></li></ol><h3 id="Kafka-和-Hadoop"><a href="#Kafka-和-Hadoop" class="headerlink" title="Kafka 和 Hadoop"></a>Kafka 和 Hadoop</h3><ol><li><p><strong>数据湖集成</strong>：</p><ul><li><strong>HDFS Connector</strong>：使用 Kafka Connect 的 HDFS 连接器，可以将 Kafka 中的数据写入 HDFS（Hadoop Distributed File System），<strong>将实时数据流保存到 Hadoop 数据湖</strong>中。</li><li><strong>Spark Streaming</strong>：Apache Spark 可以直接从 Kafka 主题读取数据，进行实时数据处理和分析。处理后的数据可以保存回 HDFS 或其他存储系统。</li></ul></li><li><p><strong>批处理和流处理的结合</strong>：</p><ul><li><strong>Lambda 架构</strong>：使用 Kafka 作为数据的<strong>实时流处理层</strong>，Hadoop 作为<strong>批处理层</strong>，可以<strong>实现 Lambda 架构</strong>，<strong>结合实时和批处理的数据处理优势</strong>。</li></ul></li></ol><h3 id="Kafka-和-Redis"><a href="#Kafka-和-Redis" class="headerlink" title="Kafka 和 Redis"></a>Kafka 和 Redis</h3><ol><li><p><strong>缓存和数据存储</strong>：</p><ul><li><strong>实时数据处理</strong>：Kafka 可以与 Redis 集成，用于实时数据流的缓存和处理。例如，可以使用 Kafka 处理实时事件流，并<strong>将处理结果缓存到 Redis 以供快速访问</strong>。</li><li><strong>事件驱动架构</strong>：在事件驱动架构中，Kafka 可以作为<strong>事件流平台，而 Redis 可以作为事件的快速存储和检索数据库</strong>。</li></ul></li><li><p><strong>消息队列和缓存结合</strong>：</p><ul><li><strong>数据流管道</strong>：使用 Kafka 作为消息队列，将数据流传输到 Redis 中进行进一步的处理和缓存。例如，实时数据流可以通过 Kafka 传输到 Redis，提供低延迟的实时数据访问。</li></ul></li></ol><h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><ol><li><p><strong>什么是 Kafka？</strong></p><ul><li>Kafka 是一个分布式流处理平台，用于构建实时数据管道和流应用程序。它的核心组件包括生产者、消费者、主题、分区和 broker。</li></ul></li><li><p><strong>Kafka 的核心组件有哪些？</strong></p><ul><li><strong>生产者（Producer）</strong>：向 Kafka 主题发送消息。</li><li><strong>消费者（Consumer）</strong>：从 Kafka 主题读取消息。</li><li><strong>主题（Topic）</strong>：消息的分类和存储单元。</li><li><strong>分区（Partition）</strong>：主题的逻辑分片，允许并行处理。</li><li><strong>broker</strong>：Kafka 集群中的服务器，负责存储和传输消息。</li><li><strong>Zookeeper</strong>：用于协调和管理 Kafka 集群。</li></ul></li><li><p><strong>Kafka 的典型用例有哪些？</strong></p><ul><li>实时流处理、日志聚合、消息队列、事件驱动架构、监控和指标收集等。</li></ul></li></ol><h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><ol start="4"><li><p><strong>生产者如何确保消息的可靠性？</strong></p><ul><li>配置 <code>acks</code> 参数：<code>acks=all</code> 确保所有副本都确认消息写入。</li><li>配置重试机制：<code>retries</code> 参数设置生产者的重试次数。</li><li>配置 <code>linger.ms</code> 和 <code>batch.size</code> 优化消息批处理。</li></ul></li><li><p><strong>消费者组（Consumer Group）是什么？</strong></p><ul><li>消费者组是一组消费者，共同从一个或多个主题读取消息，每个分区的消息只能由消费者组中的一个消费者处理，确保消息不会被重复处理。</li></ul></li><li><p><strong>Kafka 中的 offset 是什么？</strong></p><ul><li>offset 是分区中消息的唯一标识符，消费者通过管理 offset 确定从哪里读取消息。</li></ul></li></ol><h3 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h3><ol start="7"><li><p><strong>什么是 ISR（In-Sync Replicas）？</strong></p><ul><li>ISR 是一组与 leader 副本保持同步的 follower 副本。Kafka 通过 ISR 确保消息的高可用性和可靠性。</li></ul></li><li><p><strong>Kafka 如何实现消息的持久化？</strong></p><ul><li>Kafka 将消息写入磁盘的日志文件中，并可以配置日志文件的滚动策略和保留策略，确保数据持久化。</li></ul></li><li><p><strong>如何保证 Kafka 中的消息顺序？</strong></p><ul><li>在分区级别，消息是按顺序存储和消费的。生产者可以通过使用相同的分区键确保相同的消息发送到同一个分区，从而保证顺序。</li></ul></li><li><p><strong>Kafka 的副本机制是如何工作的？</strong></p><ul><li>每个分区可以有多个副本（包括一个 leader 和多个 follower）。leader 负责所有读写操作，follower 从 leader 复制数据。Kafka 通过副本机制提供高可用性和故障恢复。</li></ul></li></ol><h3 id="性能与调优"><a href="#性能与调优" class="headerlink" title="性能与调优"></a>性能与调优</h3><ol start="11"><li><p><strong>Kafka 的性能调优有哪些方法？</strong></p><ul><li>调整批量大小（<code>batch.size</code>）和延迟（<code>linger.ms</code>）。</li><li>优化压缩类型（<code>compression.type</code>），如 snappy 或 lz4。</li><li>调整分区数和副本数。</li><li>调整生产者和消费者的缓冲区大小和并发量。</li></ul></li><li><p><strong>Kafka 的吞吐量和延迟如何优化？</strong></p><ul><li>通过增加分区数量提高并行处理能力。</li><li>使用合适的压缩算法减少网络带宽使用。</li><li>调整 <code>replica.lag.time.max.ms</code> 和 <code>replica.fetch.max.bytes</code> 参数优化副本同步。</li></ul></li></ol><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><ol start="13"><li><p><strong>Kafka 的故障恢复机制是什么？</strong></p><ul><li>Kafka 自动检测和处理 broker、分区和副本的故障。通过 ISR 机制和 Zookeeper 的协调，Kafka 能够自动恢复故障的分区和重新选举 leader。</li></ul></li><li><p><strong>如何处理 Kafka 消费者再均衡？</strong></p><ul><li>再均衡是指消费者组成员发生变化时，Kafka 会重新分配分区给消费者。再均衡可能会导致短暂的消息处理中断。使用 <code>ConsumerRebalanceListener</code> 可以在再均衡发生前后执行一些清理和初始化操作。</li></ul></li><li><p><strong>如何保障 Kafka 消息的 Exactly Once 语义？</strong></p><ul><li>通过启用幂等生产者（<code>enable.idempotence=true</code>）和事务（<code>transactional.id</code>）实现 Exactly Once 语义。消费者也需要在读消息时处理偏移量的事务性提交。</li></ul></li></ol><h3 id="实践问题"><a href="#实践问题" class="headerlink" title="实践问题"></a>实践问题</h3><ol start="16"><li><p><strong>如何在 Kubernetes 中部署 Kafka？</strong></p><ul><li>使用 Helm Chart 部署 Kafka。</li><li>定义 StatefulSet 和 PersistentVolume 保持数据持久性。</li><li>配置 Zookeeper 集群，确保 Kafka 的协调和管理。</li></ul></li><li><p><strong>如何监控 Kafka 集群的健康状态？</strong></p><ul><li>使用 Kafka 自带的 JMX 监控指标。</li><li>使用 Prometheus 和 Grafana 收集和展示 Kafka 的性能指标。</li><li>监控关键指标如 ISR、消息吞吐量、延迟、分区副本状态等。</li></ul></li></ol><h3 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h3><ol start="18"><li><p><strong>Kafka 和传统消息队列（如 RabbitMQ、ActiveMQ）的区别是什么？</strong></p><ul><li>Kafka 侧重于高吞吐量、可扩展性和持久化，适合大规模的实时数据流处理。</li><li>传统消息队列（如 RabbitMQ、ActiveMQ）侧重于复杂路由和可靠性，适合需要高级消息传递功能的场景。</li></ul></li><li><p><strong>Kafka 和其他流处理平台（如 Apache Flink、Apache Storm）的关系？</strong></p><ul><li>Kafka 通常用于消息存储和传递，而 Flink、Storm 等流处理平台用于处理 Kafka 中的数据流。Kafka Streams 提供了轻量级的流处理 API，可以直接在 Kafka 上进行流处理。</li></ul></li></ol><p>这些问题涵盖了 Kafka 的基本概念、架构设计、性能调优和实际应用等方面。熟悉这些问题及其答案，可以帮助你在 Kafka 面试中表现得更加出色。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票三连</title>
    <link href="/2024/05/28/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E4%B8%89%E8%BF%9E/"/>
    <url>/2024/05/28/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E4%B8%89%E8%BF%9E/</url>
    
    <content type="html"><![CDATA[<h3 id="股票一"><a href="#股票一" class="headerlink" title="股票一"></a>股票一</h3><h3 id="股票二"><a href="#股票二" class="headerlink" title="股票二"></a>股票二</h3><p>买卖无数次，同一天最多持有一只股票<br>动规：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dp[n][<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// dp[x][0] 第x天未持有</span><br>        <span class="hljs-comment">// dp[x][1] 第x天持有</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=-prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 记得初始化</span><br>        <span class="hljs-type">int</span> maxp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">// 考虑边界，i从1开始</span><br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]+prices[i]);<br>            dp[i][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]-prices[i],dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 只需要0状态，因为最后股票一定卖出了</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>优化一下空间复杂度（因为每次之和前一个有关所以不用存一个数组，存两个变量就行</p><h3 id="股票三"><a href="#股票三" class="headerlink" title="股票三"></a>股票三</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>碎碎念</title>
    <link href="/2024/05/28/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <url>/2024/05/28/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>又投了三个日常实习orz，，希望能有人快点联系我面试啊啊啊不要再给我发笔试邮件力</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>最大数</title>
    <link href="/2024/05/27/%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
    <url>/2024/05/27/%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>巧用lambda表达式，string头文件中有可以直接将数字转为字符串的方法！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;a=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">100</span>,<span class="hljs-number">92</span>&#125;;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),[](<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n)&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(m)+<span class="hljs-built_in">to_string</span>(n)&gt;<span class="hljs-built_in">to_string</span>(n)+<span class="hljs-built_in">to_string</span>(m);&#125;);<br>    string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++)&#123;<br>        res+=<span class="hljs-built_in">to_string</span>(a[i]);<br>    &#125;<br>    cout&lt;&lt;res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="/2024/05/27/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2024/05/27/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<p>上次虾皮考的就是这道，服啦！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">parse_input</span>(string s)&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;res;<br>    vector&lt;<span class="hljs-type">int</span>&gt;tmp;<br>    <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-comment">// 注意从1算到len-1</span><br>        <span class="hljs-keyword">if</span> (s[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            temp = temp*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27;,&#x27;</span>&amp;&amp;s[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>            <span class="hljs-comment">// 注意这里的前提条件是逗号是数字的分隔符,而不是括号之间的间隔符</span><br>            tmp.<span class="hljs-built_in">push_back</span>(temp);<br>            temp = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27;]&#x27;</span>)&#123;<br>            tmp.<span class="hljs-built_in">push_back</span>(temp);<br>            temp=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 注意这里也要对temp进行处理</span><br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>            tmp.<span class="hljs-built_in">clear</span>();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_arrays</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;res.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;res[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>            cout&lt;&lt;res[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    cout&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sparrow_matrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; a)</span></span>&#123;<br>    <span class="hljs-type">int</span> row = a.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (row==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]; <br>    <span class="hljs-comment">// 牛客网上写了一下，发现对边界条件考虑不周</span><br>    <span class="hljs-type">int</span> column = a[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = column<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> up = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> down = row<span class="hljs-number">-1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">res</span>(row*column);<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (left&lt;=right&amp;&amp;up&lt;=down)&#123;<br>        <span class="hljs-comment">// go right-&gt;go down-&gt;go left-&gt;go up</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=left;i&lt;=right;i++)&#123;<br>            res[cur] = a[up][i];<br>            cout&lt;&lt;res[cur]&lt;&lt;endl;<br>            cur++;<br>        &#125;<br>        <span class="hljs-comment">// up++;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=up+<span class="hljs-number">1</span>;i&lt;=down;i++)&#123;<br>            res[cur] = a[i][right];<br>            cout&lt;&lt;res[cur]&lt;&lt;endl;<br>            cur++;<br>        &#125;<br>        <span class="hljs-comment">// right--;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=right<span class="hljs-number">-1</span>;i&gt;=left;i--)&#123;<br>            res[cur] = a[down][i];<br>            cout&lt;&lt;res[cur]&lt;&lt;endl;<br>            cur++;<br>        &#125;<br>        <span class="hljs-comment">// down--;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=down<span class="hljs-number">-1</span>;i&gt;=up+<span class="hljs-number">1</span>;i--)&#123;<br>            res[cur] = a[i][left];<br>            cout&lt;&lt;res[cur]&lt;&lt;endl;<br>            cur++;<br>        &#125;<br>        up++;right--;down--;left++;<br>        <span class="hljs-comment">// 虽然不知道为什么全放在底下就能过，提前处理就不能过，不过还是直接死记吧！</span><br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_vector</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;a)</span></span>&#123;<br>    <span class="hljs-type">int</span> len =a.<span class="hljs-built_in">size</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;the vector size is: &quot;</span>&lt;&lt;len&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// string s=&quot;[[1,2,3],[4,5,6],[7,8,9]]&quot;;</span><br>    string s = <span class="hljs-string">&quot;[[1],[2],[3]]&quot;</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;res = <span class="hljs-built_in">parse_input</span>(s);<br>    <span class="hljs-built_in">print_arrays</span>(res);<br>    vector&lt;<span class="hljs-type">int</span>&gt;result = <span class="hljs-built_in">sparrow_matrix</span>(res);<br>    <span class="hljs-built_in">print_vector</span>(result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/2024/05/27/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <url>/2024/05/27/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>给定一个32位的有符号整数num，将num中的数字部分反转，最后返回反转的结果</p><ol><li>只反转数字部分，符号位部分不反转</li><li>反转后整数num超过 32 位的有符号整数的范围 [−231,  231 − 1] ，返回 0</li><li>假设本题不允许存储 64 位整数(有符号或无符号，即C++不能使用long long ，Java不能使用long等)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverseint</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (res &gt; INT32_MAX / <span class="hljs-number">10</span> || res &lt; INT32_MIN / <span class="hljs-number">10</span>)  &#123;<br>            <span class="hljs-comment">// 要提前预判</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        res = res*<span class="hljs-number">10</span>+n%<span class="hljs-number">10</span>;<br>        n=n/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">2123456789</span>;<br>    cout&lt;&lt;<span class="hljs-built_in">reverseint</span>(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>接雨水</title>
    <link href="/2024/05/27/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2024/05/27/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p>字节臭名昭著接雨水</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 臭名昭著接雨水</span><br>    <span class="hljs-comment">// 用双指针做</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;height = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> size=height.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = size<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> leftMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rightMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>        leftMax = <span class="hljs-built_in">max</span>(leftMax,height[left]);<br>        rightMax = <span class="hljs-built_in">max</span>(rightMax,height[right]);<br>        <span class="hljs-keyword">if</span> (rightMax&gt;leftMax)&#123;<br>            res+=leftMax-height[left];<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res+=rightMax-height[right];<br>            right--;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>括号生成</title>
    <link href="/2024/05/27/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2024/05/27/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>其实就是卡塔兰数，不过还是用dfs写了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;string&gt;res;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> remain, string &amp;tmp)</span></span>&#123;<br>    <span class="hljs-comment">// remain代表左括号比右括号多出的个数</span><br>    <span class="hljs-comment">// tmp要加引用符号</span><br>    <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">length</span>()==n*<span class="hljs-number">2</span>&amp;&amp;remain==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 注意一下有个条件是remain==0，过滤非法结果：即已经有2n个括号但是左括号比右括号多的情况</span><br>        res.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">length</span>()==n*<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 过滤非法结果</span><br>    <span class="hljs-keyword">if</span> (remain&lt;n)&#123;<br>        tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(n,remain+<span class="hljs-number">1</span>,tmp);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-comment">// 记得pop掉</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (remain&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 注意remain边界条件</span><br>        tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(n,remain<span class="hljs-number">-1</span>,tmp);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printres</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> size = res.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (size==<span class="hljs-number">0</span>) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;no result&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;total nums:&quot;</span>&lt;&lt;size&lt;&lt;endl;<br>        <span class="hljs-comment">// 卡塔兰数</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        cout&lt;&lt;res[i]&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string tmp;<br>    <span class="hljs-type">int</span> n =<span class="hljs-number">6</span>;<br>    <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,tmp);<br>    <span class="hljs-built_in">printres</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>合并K个升序链表</title>
    <link href="/2024/05/27/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/05/27/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> v,ListNode *n)&#123;<br>        value = v;<br>        next = n;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printlist</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;head-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        head=head-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ListNode *head1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>);<br>    head1-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>);<br>    head1-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>);<br>    ListNode *head2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>);<br>    head2-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>);<br>    head2-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">printlist</span>(head1);<br>    <span class="hljs-built_in">printlist</span>(head2);<br>    <span class="hljs-keyword">auto</span> cmp = [](ListNode *a, ListNode *b)&#123;<span class="hljs-keyword">return</span> a-&gt;value&gt;b-&gt;value;&#125;;<br>    <span class="hljs-comment">// 请注意这里符号填的是大于（好反人类</span><br>    priority_queue&lt;ListNode *,vector&lt;ListNode *&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt;<span class="hljs-built_in">q</span>(cmp);<br>    <span class="hljs-comment">// 这两个语句背下来orz</span><br>    q.<span class="hljs-built_in">push</span>(head1);<br>    q.<span class="hljs-built_in">push</span>(head2);<br>    ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>,<span class="hljs-literal">nullptr</span>);<br>    ListNode *cur = dummy;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        ListNode *tmp = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cur-&gt;next = tmp;<br>        cur = tmp;<br>        <span class="hljs-keyword">if</span> (tmp-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-comment">// 这个非空条件很重要！</span><br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;next);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-built_in">printlist</span>(dummy-&gt;next);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-13</title>
    <link href="/2024/05/26/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-13/"/>
    <url>/2024/05/26/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-13/</url>
    
    <content type="html"><![CDATA[<h3 id="进程有多少种状态，如何转换？"><a href="#进程有多少种状态，如何转换？" class="headerlink" title="进程有多少种状态，如何转换？"></a>进程有多少种状态，如何转换？</h3><p><strong>三种状态</strong>：<br>阻塞、就绪、运行。<br><strong>四种转换</strong>：<br>阻塞-&gt;就绪：当一个进程等待的事件发生或资源可用时，它会从阻塞状态转换回就绪状态，等待被调度执行。<br>运行-&gt;阻塞：当一个进程需要等待某个事件发生或等待某个资源时，它会从运行状态转换到阻塞状态。<br>运行-&gt;就绪：当一个运行中的进程的时间片用完或被操作系统抢占，它返回到就绪状态，等待下一次调度。<br>就绪-&gt;运行：调度器选择一个就绪进程并分配CPU给它，进程进入运行状态。</p><h3 id="哪些问题是HTTPS无法解决的？"><a href="#哪些问题是HTTPS无法解决的？" class="headerlink" title="哪些问题是HTTPS无法解决的？"></a>哪些问题是HTTPS无法解决的？</h3><ol><li>Http是基于<strong>TCP协议的，在网络层的传输耗时比较长</strong>，https没有解决这个问题；</li><li>http<strong>头是不能压缩</strong>的，每次要传递很大的数据包，<strong>每个连接也只能支持一个请求</strong>。</li><li>同时https应用了很多<strong>加密算法</strong>，这些算法的执行也是会<strong>影响速度</strong>的。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>速通KMP算法</title>
    <link href="/2024/05/24/%E9%80%9F%E9%80%9AKMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/24/%E9%80%9F%E9%80%9AKMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E7%AE%97%E6%B3%95/kmp%E7%AE%97%E6%B3%95.png" alt="为什么要用KMP算法"><br><a href="https://zhuanlan.zhihu.com/p/83334559?utm_psn=1777131874840141824">知乎链接</a><br><img src="/../img/%E7%AE%97%E6%B3%95/581e5a8571eeb0cc180801a1d145db9.jpg" alt="笔记"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">200</span>][<span class="hljs-number">256</span>];<br><span class="hljs-comment">// dp[x][y]=z表示状态x下遇到y字符（y是ascii码值）会转到z状态</span><br><span class="hljs-type">int</span> next[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_statement</span><span class="hljs-params">(string pat)</span></span>&#123;<br>    <span class="hljs-type">int</span> patlen = pat.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-comment">// int base = 0;</span><br>    <span class="hljs-type">int</span> X = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 影子状态</span><br>    dp[<span class="hljs-number">0</span>][pat[<span class="hljs-number">0</span>]]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;patlen;i++)&#123;<br>        <span class="hljs-comment">// 注意这里直接从状态1开始算，并且不包括最后一个状态</span><br>        <span class="hljs-comment">// 因为如果dp到最后一个状态说明就可以了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">256</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span> (j==pat[i])dp[i][j]=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> dp[i][j]=dp[X][j];<br>        &#125;<br>        X=dp[X][pat[i]];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(string pat, string txt)</span></span>&#123;<br>    <span class="hljs-type">int</span> patlen = pat.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> txtlen = txt.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span> ; <br>    <span class="hljs-comment">// 表示初始状态为0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;txtlen;i++)&#123;<br>        cur=dp[cur][txt[i]];<br>        <span class="hljs-keyword">if</span> (cur==patlen) <span class="hljs-keyword">return</span> i-patlen+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string pat=<span class="hljs-string">&quot;ababc&quot;</span>;<br>    string txt=<span class="hljs-string">&quot;bbcabbsaababcabbbac&quot;</span>;<br>    <span class="hljs-built_in">build_statement</span>(pat);<br>    cout&lt;&lt;<span class="hljs-built_in">search</span>(pat, txt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>看别人面经冲刺中</title>
    <link href="/2024/05/23/%E7%9C%8B%E5%88%AB%E4%BA%BA%E9%9D%A2%E7%BB%8F%E5%86%B2%E5%88%BA%E4%B8%AD/"/>
    <url>/2024/05/23/%E7%9C%8B%E5%88%AB%E4%BA%BA%E9%9D%A2%E7%BB%8F%E5%86%B2%E5%88%BA%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL的MVCC机制"><a href="#MySQL的MVCC机制" class="headerlink" title="MySQL的MVCC机制"></a>MySQL的MVCC机制</h2><p>MySQL 的 MVCC（多版本并发控制，Multi-Version Concurrency Control）机制是一种用于处理并发访问数据库的技术，主要应用于 InnoDB 存储引擎。它通过创建数据的多个版本来实现事务的隔离性和一致性，从而提高数据库的并发性能。MVCC 机制主要依赖于隐藏的列和快照来实现。这些隐藏列包括两个时间戳，分别是 <code>trx_id</code>（事务 ID）和 <code>roll_pointer</code>（回滚指针）。</p><h3 id="MVCC-的工作原理"><a href="#MVCC-的工作原理" class="headerlink" title="MVCC 的工作原理"></a>MVCC 的工作原理</h3><ol><li><p><strong>隐藏列</strong>:</p><ul><li><code>trx_id</code>: 每次事务对数据进行修改时，都会生成一个唯一的事务 ID，并将其赋值给修改后的数据行。</li><li><code>roll_pointer</code>: 指向该数据行在回滚段中的上一版本，用于实现数据的多版本控制和回滚操作。</li></ul></li><li><p><strong>快照读（Snapshot Read）</strong>:<br> 快照读是指读取数据库中的一致性快照，即读取数据行在某个时间点的版本。这种读取方式不会加锁，可以提高读取的并发性。具体来说，InnoDB 在读取数据时会根据当前事务的隔离级别和数据行的 <code>trx_id</code> 判断是否可以读取该版本的数据。</p></li><li><p><strong>当前读（Current Read）</strong>:<br> <strong>当前读是指读取最新版本的数据，并且会对读取的数据加锁</strong>，防止其他事务同时修改这些数据。例如，<code>SELECT ... FOR UPDATE</code> 和 <code>SELECT ... LOCK IN SHARE MODE</code> 都属于当前读。</p></li></ol><h3 id="事务隔离级别与-MVCC"><a href="#事务隔离级别与-MVCC" class="headerlink" title="事务隔离级别与 MVCC"></a>事务隔离级别与 MVCC</h3><p>MVCC 在不同的事务隔离级别下有不同的表现：</p><ol><li><p><strong>读未提交（Read Uncommitted）</strong>:<br> 事务可以读取其他未提交事务的数据修改。此隔离级别不使用 MVCC。</p></li><li><p><strong>读已提交（Read Committed）</strong>:<br> 事务只能读取已提交事务的数据修改。每次读取操作都会读取最新的已提交版本。</p></li><li><p><strong>可重复读（Repeatable Read）</strong>:<br> 在同一个事务中，多次读取同一数据行，返回的结果始终一致，即使其他事务已经提交了对该数据行的修改。InnoDB 通过创建事务开始时的快照来实现这一点。</p></li><li><p><strong>串行化（Serializable）</strong>:<br> 强制事务按顺序执行，类似于在每个读取的数据行上加锁，以实现最高级别的隔离性。</p></li></ol><h3 id="MVCC-的优势"><a href="#MVCC-的优势" class="headerlink" title="MVCC 的优势"></a>MVCC 的优势</h3><ol><li><p><strong>提高并发性能</strong>:<br> 通过快照读实现读写分离，读取操作无需加锁，从而大大提高了数据库的并发性能。</p></li><li><p><strong>避免幻读</strong>:<br> 在可重复读隔离级别下，MVCC 可以有效避免幻读问题，因为事务读取的是一致性快照，而不是实时数据。</p></li><li><p><strong>回滚方便</strong>:<br> 通过 <code>roll_pointer</code>，可以方便地回滚到数据行的前一个版本，支持事务的撤销操作。</p></li></ol><h3 id="MVCC-的实现细节"><a href="#MVCC-的实现细节" class="headerlink" title="MVCC 的实现细节"></a>MVCC 的实现细节</h3><p>在 InnoDB 中，每个数据行有两个隐藏的列：<code>DB_TRX_ID</code> 和 <code>DB_ROLL_PTR</code>。<code>DB_TRX_ID</code> 存储最近一次对该行进行修改的事务 ID，<code>DB_ROLL_PTR</code> 指向该行的上一版本。通过这些隐藏列，InnoDB 能够跟踪和管理多个版本的数据，从而实现 MVCC。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL 的 MVCC 机制通过维护数据行的多个版本以及利用事务的快照，能够在提高并发性能的同时保证数据的一致性和隔离性。这使得 MySQL 能够在高并发环境下，提供高效和可靠的数据访问服务。</p><h2 id="路由器和交换机区别"><a href="#路由器和交换机区别" class="headerlink" title="路由器和交换机区别"></a>路由器和交换机区别</h2><p>路由器（Router）和交换机（Switch）是网络中常见的两种设备，它们在网络中扮演着不同的角色，有着不同的工作原理和功能。以下是它们的主要区别：</p><ol><li><p><strong>工作层次</strong>：</p><ul><li><strong>路由器</strong>：工作在 OSI 模型的网络层（第三层），负责根据目标 IP 地址将数据包从一个网络路由到另一个网络。路由器能够理解 IP 地址和路由表，根据网络地址进行数据包转发。</li><li><strong>交换机</strong>：通常工作在 OSI 模型的数据链路层（第二层），负责在局域网内部进行数据包的转发和交换。交换机主要根据 MAC 地址学习和转发数据包，以实现局域网内部设备之间的通信。</li></ul></li><li><p><strong>转发方式</strong>：</p><ul><li><strong>路由器</strong>：根据目标 IP 地址来决定数据包的转发路径，需要进行 IP 地址的查找和路由表的查询，可以跨越不同网络进行数据包转发。</li><li><strong>交换机</strong>：根据数据包的目标 MAC 地址进行转发，通过学习和维护 MAC 地址表来实现数据包的快速转发，主要用于局域网内部的通信。</li></ul></li><li><p><strong>范围</strong>：</p><ul><li><strong>路由器</strong>：通常用于连接不同的网络，如连接局域网与广域网、不同的子网等，用于<strong>跨越不同网络的数据包转发</strong>。</li><li><strong>交换机</strong>：主要用于<strong>局域网内部</strong>，连接局域网中的多台计算机、打印机等设备，用于实现局域网内的数据包交换和通信。</li></ul></li><li><p><strong>决策方式</strong>：</p><ul><li><strong>路由器</strong>：基于 <strong>IP 地址</strong>进行决策，根据<strong>网络地址和路由表来选择最佳路径</strong>进行数据包转发。</li><li><strong>交换机</strong>：基于 <strong>MAC 地址</strong>进行决策，根据学习到的 MAC 地址和 MAC 地址表来实现数据包的转发。</li></ul></li><li><p><strong>处理能力</strong>：</p><ul><li><strong>路由器</strong>：通常拥有更复杂的处理能力，可以实现网络层的功能，如<strong>路由选择、分割广播域</strong>等，处理更多协议类型的数据包。</li><li><strong>交换机</strong>：主要用于数据链路层的转发，处理更多的是局域网内部的数据包转发，对于网络层及以上层次的协议不具备处理能力。</li></ul></li></ol><h2 id="什么是路由选择？"><a href="#什么是路由选择？" class="headerlink" title="什么是路由选择？"></a>什么是路由选择？</h2><p>路由选择（Routing）是指在计算机网络中，确定数据包从源节点传输到目标节点的最佳路径的过程。这个过程是由路由器或者路由器算法来完成的。路由选择是计算机网络中的关键部分，它影响了网络的性能、可用性和可靠性。</p><p>路由选择的过程通常包括以下几个步骤：</p><ol><li><p><strong>路由器学习网络拓扑</strong>：路由器需要学习整个网络的拓扑结构，包括了哪些节点（主机、路由器等）以及它们之间的连接方式。</p></li><li><p><strong>收集网络信息</strong>：路由器需要收集网络的相关信息，比如链路状态、带宽、延迟、拥塞情况等。</p></li><li><p><strong>构建路由表</strong>：根据收集到的信息，路由器构建路由表。路由表中记录了到达目的地的不同路径及其相关信息，比如下一跳路由器、跳数（跳数表示从源节点到目标节点经过的路由器数量）、路由的开销等。</p></li><li><p><strong>选择最佳路径</strong>：当一个数据包到达路由器时，路由器根据路由表选择最佳的路径将数据包转发给下一个节点。选择最佳路径的标准可以是多样化的，常见的标准包括最短路径、最快路径、最稳定路径等。</p></li><li><p><strong>数据包转发</strong>：根据选择的路径，路由器将数据包转发给下一个节点。这个过程通常涉及到修改数据包的目标地址和 TTL（生存时间）字段，并将数据包发送到下一跳路由器。</p></li><li><p><strong>更新路由表</strong>：定期或根据网络状态的变化，路由器需要更新自己的路由表，以反映网络拓扑的变化，确保选择的路径是最佳的。</p></li></ol><p>路由选择算法的设计和实现对于网络的性能和可靠性有着重要的影响。常见的路由选择算法包括静态路由、距离矢量路由（如 RIP）、链路状态路由（如 OSPF）、路径向量路由（如 BGP）等。这些算法在考虑到网络拓扑、链路状态、路由器开销等因素的基础上，通过不同的策略选择最佳路径。</p><h2 id="MTU的作用"><a href="#MTU的作用" class="headerlink" title="MTU的作用"></a>MTU的作用</h2><p>MTU（Maximum Transmission Unit）是指在计算机网络中，数据链路层可以传输的最大数据包大小。MTU的大小是由网络硬件或网络协议确定的，通常以字节为单位。</p><p>MTU的作用主要体现在以下几个方面：</p><ol><li><p><strong>最大利用带宽</strong>：传输的数据包越大，携带的有效数据就越多，从而可以更有效地利用网络带宽。减少数据包的数量可以降低网络的拥塞程度，提高网络的吞吐量。</p></li><li><p><strong>降低开销</strong>：每个数据包在传输过程中都会带有一定的开销，如头部信息、校验和等。通过增大MTU，可以减少传输的数据包数量，从而减少了网络传输的开销。</p></li><li><p><strong>减少碎片</strong>：当数据包的大小超过某些网络设备或网络链路的最大传输单元时，数据包就会被分割成更小的片段进行传输，这称为碎片化。增大MTU可以减少碎片的产生，提高网络的性能和效率。</p></li><li><p><strong>提高效率</strong>：MTU的调整可以根据网络的实际情况进行优化，从而提高网络的效率和性能。例如，在局域网中，可以设置较大的MTU来提高数据传输的效率；而在广域网中，由于网络环境的复杂性，可能需要设置较小的MTU来减少传输时的延迟和丢包率。</p></li></ol><p>总的来说，MTU的作用是优化网络传输的效率和性能，通过调整MTU的大小，可以最大程度地利用网络带宽，减少网络开销，降低碎片化，提高网络的吞吐量和响应速度。</p><h2 id="ISO五层模型？"><a href="#ISO五层模型？" class="headerlink" title="ISO五层模型？"></a>ISO五层模型？</h2><p>应用层 传输层 网络层 数据链路层 物理层</p><h2 id="MySQL存储高精度数据适用的数据类型"><a href="#MySQL存储高精度数据适用的数据类型" class="headerlink" title="MySQL存储高精度数据适用的数据类型"></a>MySQL存储高精度数据适用的数据类型</h2><p>在MySQL中存储高精度数据（例如货币金额、科学计数等）时，可以使用以下几种数据类型：</p><ol><li><p><strong>DECIMAL</strong>：DECIMAL 类型是一种精确的定点数数据类型，用于存储固定精度的数字。它可以存储非常大的数字，并且可以指定小数点后的位数。DECIMAL 类型通常用于存储货币金额等需要精确计算的数据。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">DECIMAL</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)</span></span><br></code></pre></td></tr></table></figure><p>这表示一个精度为 10，小数点后 2 位的固定精度的数字。</p></li><li><p><strong>NUMERIC</strong>：NUMERIC 类型与 DECIMAL 类型类似，也是一种精确的定点数数据类型。它用法与 DECIMAL 完全相同，但在某些MySQL版本中，DECIMAL 和 NUMERIC 可能是同义词。</p></li><li><p><strong>FLOAT</strong>：FLOAT 类型是一种近似数值数据类型，用于存储单精度浮点数。它可以存储较大范围的数字，但是精度相对较低。FLOAT 类型通常用于科学计算等场景，不适合精确计算。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">FLOAT</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)</span></span><br></code></pre></td></tr></table></figure><p>这表示一个单精度浮点数，总共 10 位数字，其中小数点后有 2 位。</p></li><li><p><strong>DOUBLE</strong>：DOUBLE 类型是一种近似数值数据类型，用于存储双精度浮点数。它的范围比 FLOAT 类型更大，精度也更高，但仍然是一种近似值。DOUBLE 类型通常用于存储科学计算等需要较高精度的数据。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">DOUBLE</span><span class="hljs-params">(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>)</span></span><br></code></pre></td></tr></table></figure><p>这表示一个双精度浮点数，总共 15 位数字，其中小数点后有 5 位。</p></li></ol><p>总的来说，DECIMAL 和 NUMERIC 类型适用于需要精确计算的场景，而 FLOAT 和 DOUBLE 类型适用于科学计算等场景，其中 DOUBLE 类型的精度更高，但也会占用更多的存储空间。在选择数据类型时，需要根据具体的业务需求和数据特性来决定。</p><h2 id="MySQL索引组织方式"><a href="#MySQL索引组织方式" class="headerlink" title="MySQL索引组织方式"></a>MySQL索引组织方式</h2><p>在MySQL中，索引是用于加速数据检索的关键技术之一。MySQL支持多种索引组织方式，其中最常见的包括：</p><ol><li><p><strong>B树索引</strong>：</p><ul><li>B树索引是MySQL中最常用的索引类型，用于快速定位数据记录。B树索引按照一定的规则将数据分层存储在树结构中，使得在查找过程中可以通过多次二分查找来快速定位目标数据。</li><li>在MySQL中，InnoDB存储引擎默认使用B树索引。</li></ul></li><li><p><strong>B+树索引</strong>：</p><ul><li>B+树索引是B树索引的一种改进版本，它将数据记录只存储在叶子节点上，非叶子节点只存储索引信息，这样可以减少索引树的高度，提高了数据的检索效率。</li><li>在MySQL中，MyISAM存储引擎使用B+树索引。</li></ul></li><li><p><strong>哈希索引</strong>：</p><ul><li>哈希索引使用哈希算法将索引键映射到存储位置，然后直接在该位置查找目标数据记录，具有查找速度快的优点。但是哈希索引在范围查询和排序方面性能不如B树索引。</li><li>在MySQL中，Memory存储引擎支持哈希索引。</li></ul></li><li><p><strong>全文索引</strong>：</p><ul><li>全文索引用于对文本字段进行全文搜索，可以快速定位包含指定关键词的数据记录。全文索引不同于普通索引，它不是直接定位数据记录，而是通过分析文本内容建立反向索引来实现全文搜索。</li><li>在MySQL中，MyISAM和InnoDB存储引擎都支持全文索引，但实现方式和性能有所不同。</li></ul></li></ol><p>每种索引组织方式都有其优缺点，适用于不同的场景和需求。在选择索引组织方式时，需要根据具体的应用场景和查询需求来进行权衡和选择。</p><h2 id="MySQL事务的使用场景"><a href="#MySQL事务的使用场景" class="headerlink" title="MySQL事务的使用场景"></a>MySQL事务的使用场景</h2><p>事务是数据库管理系统中常用的概念，用于保证数据库操作的原子性、一致性、隔离性和持久性（ACID特性）。使用事务可以确保一系列数据库操作要么全部成功执行，要么全部失败回滚，从而保证数据的完整性和一致性。以下是一些常见的 MySQL 事务使用场景：</p><ol><li><p><strong>银行系统</strong>：在银行系统中，转账操作是一个典型的事务场景。一个完整的转账过程包括从一个账户扣款并向另一个账户存款，这两个操作必须同时成功或同时失败，以避免出现账户余额不一致的情况。</p></li><li><p><strong>电子商务系统</strong>：在电子商务系统中，订单处理是一个常见的事务场景。当用户下订单时，需要对订单进行创建、库存扣减、支付处理等一系列操作，这些操作必须保证原子性，以避免订单数据不一致或支付异常等问题。</p></li><li><p><strong>在线游戏系统</strong>：在在线游戏系统中，玩家之间的交易或资源交换是一个典型的事务场景。例如，玩家之间进行道具交易，需要同时扣除一个玩家的道具并增加另一个玩家的道具，这些操作必须原子执行，以避免资源丢失或重复扣减等问题。</p></li><li><p><strong>企业级应用</strong>：在企业级应用中，复杂的业务流程往往涉及多个数据库操作，例如订单处理、库存管理、客户资料更新等。这些操作需要在同一个事务中执行，以确保数据的一致性和完整性。</p></li></ol><p>总的来说，任何需要保证数据操作原子性、一致性和完整性的场景都适合使用事务。事务可以有效地处理复杂的业务逻辑，并确保数据的正确性和可靠性。</p><h2 id="查索引的过程"><a href="#查索引的过程" class="headerlink" title="查索引的过程"></a>查索引的过程</h2><ol><li>索引扫描：遍历索引树，找到满足查询条件的索引条目。</li><li>获取数据行：一旦索引扫描找到了满足查询条件的索引条目，MySQL 将会根据索引条目中的指针（或者叫做 RID，行标识符）来获取相应的数据行。</li><li>返回结果</li></ol><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><p>ACID（重点：你要知道事务特性是ACID</p><p>事务具有四个主要的特性，通常被称为 ACID 特性，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）：</p><ol><li><p><strong>原子性（Atomicity）</strong>：</p><ul><li>原子性指的是事务是一个不可分割的工作单元，要么全部执行成功，要么全部执行失败。即使在事务执行过程中发生了错误，也要保证事务中的所有操作都被回滚，数据库状态要回到事务开始之前的状态。</li></ul></li><li><p><strong>一致性（Consistency）</strong>：</p><ul><li>一致性指的是事务执行后，数据库从一个一致性状态转变到另一个一致性状态。事务中的操作应该满足数据库的约束和规则，确保数据的完整性和一致性。即使事务失败，也不会破坏数据库的一致性。</li></ul></li><li><p><strong>隔离性（Isolation）</strong>：</p><ul><li>隔离性指的是多个事务并发执行时，各个事务的操作彼此之间是相互隔离的，互不干扰。即使多个事务同时访问同一数据，也不会相互影响。隔离性可以防止并发执行事务时出现数据不一致的情况。</li></ul></li><li><p><strong>持久性（Durability）</strong>：</p><ul><li>持久性指的是事务一旦提交成功，其结果就应该永久保存在数据库中，并且不会丢失。即使系统发生故障，例如断电或者崩溃，数据库也应该能够恢复到事务提交后的状态，保证数据的持久性。</li></ul></li></ol><p>这些特性确保了事务的可靠性和数据的完整性，使得数据库操作可以更安全和可靠。在实际应用中，需要根据具体的业务需求和数据库系统的支持情况来选择合适的事务隔离级别和持久化机制，以确保数据的安全性和一致性。</p><h2 id="Linux中的ps和find命令"><a href="#Linux中的ps和find命令" class="headerlink" title="Linux中的ps和find命令"></a>Linux中的ps和find命令</h2><p><code>ps</code> 和 <code>find</code> 是 Linux 中两个常用的命令，用于查找和管理进程以及文件。</p><ol><li><p><strong>ps 命令</strong>：</p><ul><li><code>ps</code> 命令用于显示当前系统中正在运行的进程信息。可以显示系统中的所有进程或者指定用户的进程。</li><li>常用选项包括：<ul><li><code>-ef</code>：显示所有进程的完整信息。</li><li><code>-aux</code>：显示所有进程的详细信息，包括用户、CPU 使用情况等。</li><li><code>-u username</code>：显示指定用户的进程。</li><li><code>-p PID</code>：显示指定进程号（PID）的进程信息。</li></ul></li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef<br>ps -u username<br>ps -p 12345<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>find 命令</strong>：</p><ul><li><code>find</code> 命令用于在指定目录下查找文件或者目录，并可以根据各种条件来过滤搜索结果。</li><li>常用选项包括：<ul><li><code>-name filename</code>：按照文件名查找文件。</li><li><code>-type type</code>：按照文件类型（文件、目录、符号链接等）查找。</li><li><code>-user username</code>：按照文件所属用户查找。</li><li><code>-size size</code>：按照文件大小查找。</li><li><code>-exec command &#123;&#125; \;</code>：对搜索到的文件执行指定的命令。</li></ul></li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /path/to/directory -name <span class="hljs-string">&quot;*.txt&quot;</span><br>find /path/to/directory -<span class="hljs-built_in">type</span> f -user username<br>find /path/to/directory -size +1M<br>find /path/to/directory -name <span class="hljs-string">&quot;*.log&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> &#123;&#125; \;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>这些命令在 Linux 系统中经常被用于管理和搜索文件以及查找进程信息，是系统管理和运维工作中的常用工具。</p><h2 id="select-poll-epoll的区别与联系？"><a href="#select-poll-epoll的区别与联系？" class="headerlink" title="select poll epoll的区别与联系？"></a>select poll epoll的区别与联系？</h2><p>select, poll和epoll都是I&#x2F;O多路复用技术，它们用于同时处理多个I&#x2F;O操作，特别是在高并发网络编程中。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select是最早的I&#x2F;O多路复用技术，它可以同时监视多个文件描述符（file descriptor, FD）的I&#x2F;O状态（如可读、可写、异常等）。select函数使用一个文件描述符集合（通常是一个位图）来表示要监视的文件描述符，当有I&#x2F;O事件发生时，select会返回对应的文件描述符集合。</p><p>select的主要限制如下：</p><p>文件描述符数量限制：select使用一个位图来表示文件描述符集合，这限制了它能够处理的文件描述符数量（通常是1024个）。<br>效率问题：当文件描述符数量较大时，select需要遍历整个文件描述符集合来查找就绪的文件描述符，这会导致较低的效率。<br>非实时性：每次调用select时，需要重新设置文件描述符集合，这会增加函数调用的开销。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll是为了克服select的限制而引入的一种I&#x2F;O多路复用技术。poll使用一个文件描述符数组（通常是一个结构体数组）来表示要监视的文件描述符。与select类似，poll可以监视多个文件描述符的I&#x2F;O状态。</p><p>poll的优点如下：</p><p>文件描述符数量不受限制：由于poll使用一个动态数组来表示文件描述符，因此它可以处理任意数量的文件描述符。<br>效率相对较高：poll在查找就绪的文件描述符时，只需要遍历实际使用的文件描述符数组，而不是整个文件描述符集合。<br>然而，poll仍然存在一些问题：</p><p>效率问题：尽管poll相对于select具有较高的效率，但当文件描述符数量很大时，它仍然需要遍历整个文件描述符数组。<br>非实时性：与select类似，每次调用poll时，需要重新设置文件描述符数组。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是Linux特有的一种高效I&#x2F;O多路复用技术，它克服了select和poll的主要限制。epoll使用一个事件驱动（event-driven）的方式来处理I&#x2F;O操作，它只会返回就绪的文件描述符，而不是遍历整个文件描述符集合。</p><p>epoll的主要优点如下：</p><p>高效：epoll使用事件驱动的方式来处理I&#x2F;O操作，因此它在处理大量文件描述符时具有很高的效率。当有I&#x2F;O事件发生时，epoll可以立即得到通知，而无需遍历整个文件描述符集合。这使得epoll在高并发场景中具有更好的性能。<br>可扩展性：与poll类似，epoll可以处理任意数量的文件描述符，因为它使用一个动态数据结构来表示文件描述符。<br>实时性：epoll使用一个内核事件表来记录要监视的文件描述符和事件，因此在每次调用epoll时无需重新设置文件描述符集合。这可以减少函数调用的开销，并提高实时性。<br>epoll具有诸多优点，但它目前仅在Linux平台上可用。对于其他平台，可能需要使用类似的I&#x2F;O多路复用技术，如BSD中的kqueue。</p><p>总结：select是最早的I&#x2F;O多路复用技术，但受到文件描述符数量和效率方面的限制。poll克服了文件描述符数量的限制，但仍然存在一定的效率问题。epoll是一种高效的I&#x2F;O多路复用技术，尤其适用于高并发场景，但它仅在Linux平台上可用。一般来说，epoll的效率是要比select和poll高的，但是对于活动连接较多的时候，由于回调函数触发的很频繁，其效率不一定比select和poll高。所以epoll在连接数量很多，但活动连接较小的情况性能体现的比较明显。</p><h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS(SSL+HTTP)数据传输过程是加密的，安全性较好。</p><p>使用 HTTPS 协议需要到 CA 申请证书。</p><p>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，而 HTTPS除了 TCP 的三个包，还要加上SSL握手的消耗。</p><p>用的端口也不一样，前者是 80，后者是 443。</p><p>HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p><h2 id="GDB常见调试命令"><a href="#GDB常见调试命令" class="headerlink" title="GDB常见调试命令"></a>GDB常见调试命令</h2><p>GDB（GNU Debugger）是一个强大的调试工具，广泛用于调试 C 和 C++ 程序。以下是一些常用的 GDB 调试命令及其功能：</p><p>gdb xxx.exe（可执行文件名：启动gdb<br>gdb q：退出gdb<br>gdb r arg1 arg2：运行程序（传递命令行参数<br>gdb b 文件:行  ：在某某文件的第几行打个断点<br>gdb b 函数名   ：在某个函数打个断点<br>gdb i b ：列出所有断点<br>gdb c ：继续执行到下一个断点<br>gdb s ：进入函数内部单步执行一行<br>gdb n ：不进入函数内部单步执行一行<br>gdb p 变量名：打印这个变量的值<br>gdb i r ：查看寄存器值</p><h3 id="启动和退出-GDB"><a href="#启动和退出-GDB" class="headerlink" title="启动和退出 GDB"></a>启动和退出 GDB</h3><ul><li><p><strong>启动 GDB</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gdb &lt;executable&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gdb ./my_program<br></code></pre></td></tr></table></figure></li><li><p><strong>退出 GDB</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">quit<br>或<br>q<br></code></pre></td></tr></table></figure></li></ul><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><ul><li><p><strong>运行程序</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">run<br>或<br>r<br></code></pre></td></tr></table></figure><p>可以传递命令行参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">run arg1 arg2<br></code></pre></td></tr></table></figure></li><li><p><strong>重启程序</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">run<br></code></pre></td></tr></table></figure></li></ul><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul><li><p><strong>在某行设置断点</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">break</span> &lt;file&gt;:&lt;line&gt;<br>或<br>b &lt;file&gt;:&lt;line&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">break</span> main.cpp:10<br></code></pre></td></tr></table></figure></li><li><p><strong>在某函数设置断点</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">break</span> &lt;<span class="hljs-keyword">function</span>&gt;<br>或<br>b &lt;<span class="hljs-keyword">function</span>&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">break</span> main<br></code></pre></td></tr></table></figure></li><li><p><strong>列出所有断点</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">info breakpoints<br>或<br>i b<br></code></pre></td></tr></table></figure></li><li><p><strong>删除断点</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">delete &lt;breakpoint-number&gt;<br>或<br>d &lt;breakpoint-number&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">delete 1<br></code></pre></td></tr></table></figure></li></ul><h3 id="控制程序执行"><a href="#控制程序执行" class="headerlink" title="控制程序执行"></a>控制程序执行</h3><ul><li><p><strong>继续执行到下一个断点</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">continue</span><br>或<br>c<br></code></pre></td></tr></table></figure></li><li><p><strong>单步执行一行源代码（进入函数内部）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">step<br>或<br>s<br></code></pre></td></tr></table></figure></li><li><p><strong>单步执行一行源代码（不进入函数内部）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">next<br>或<br>n<br></code></pre></td></tr></table></figure></li><li><p><strong>执行到当前函数返回</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">finish<br></code></pre></td></tr></table></figure></li><li><p><strong>跳过当前循环的剩余部分</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">until &lt;location&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="检查程序状态"><a href="#检查程序状态" class="headerlink" title="检查程序状态"></a>检查程序状态</h3><ul><li><p><strong>打印变量值</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">print</span> &lt;variable&gt;<br>或<br>p &lt;variable&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">print</span> x<br></code></pre></td></tr></table></figure></li><li><p><strong>打印局部变量值</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">info locals<br></code></pre></td></tr></table></figure></li><li><p><strong>查看当前栈帧</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">info frame<br>或<br>i f<br></code></pre></td></tr></table></figure></li><li><p><strong>查看调用栈</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">backtrace<br>或<br>bt<br></code></pre></td></tr></table></figure></li><li><p><strong>切换栈帧</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">frame &lt;frame-number&gt;<br>或<br>f &lt;frame-number&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="修改程序状态"><a href="#修改程序状态" class="headerlink" title="修改程序状态"></a>修改程序状态</h3><ul><li><strong>修改变量值</strong><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> variable &lt;variable&gt; = &lt;value&gt;<br></code></pre></td></tr></table></figure>例如：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> variable x = 42<br></code></pre></td></tr></table></figure></li></ul><h3 id="其它有用命令"><a href="#其它有用命令" class="headerlink" title="其它有用命令"></a>其它有用命令</h3><ul><li><p><strong>重新编译并重新加载可执行文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make<br></code></pre></td></tr></table></figure></li><li><p><strong>列出源代码</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">list &lt;location&gt;<br>或<br>l &lt;location&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">list main<br></code></pre></td></tr></table></figure></li><li><p><strong>显示寄存器值</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">info registers<br>或<br>i r<br></code></pre></td></tr></table></figure></li></ul><h3 id="示例调试会话"><a href="#示例调试会话" class="headerlink" title="示例调试会话"></a>示例调试会话</h3><p>假设我们有一个简单的 C++ 程序 <code>main.cpp</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">foo</span>(a);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们编译并启动 GDB：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ -g -o my_program main.cpp<br>gdb ./my_program<br></code></pre></td></tr></table></figure><p>在 GDB 中设置断点并运行程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sh">(gdb) <span class="hljs-built_in">break</span> main<br>Breakpoint 1 at 0x4006d2: file main.cpp, line 9.<br><br>(gdb) run<br>Starting program: /path/to/my_program<br>Breakpoint 1, main () at main.cpp:9<br>9       int a = 5;<br><br>(gdb) next<br>10      foo(a);<br><br>(gdb) step<br>foo (x=5) at main.cpp:4<br>4       std::cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; <span class="hljs-string">x &lt;&lt; std::endl;</span><br><span class="hljs-string"></span><br><span class="hljs-string">(gdb) continue</span><br><span class="hljs-string">Continuing.</span><br><span class="hljs-string">x</span> = 5<br>[Inferior 1 (process 12345) exited normally]<br><br>(gdb) quit<br></code></pre></td></tr></table></figure><p>通过这些命令，您可以有效地调试和检查 C 和 C++ 程序的执行过程。</p><h2 id="STL的组成部分"><a href="#STL的组成部分" class="headerlink" title="STL的组成部分"></a>STL的组成部分</h2><p>一共有六大部分：容器、算法、迭代器、仿函数、适配器、空间配置器<br>容器：用来存放数据的各种数据结构，比如vector、deque、list、set和map等，是一种类模板<br>算法：各种常用的算法，比如排序算法，拷贝算法、查找算法等，是一种函数模板<br>迭代器：容器与算法间的粘合剂，共有五种类型，重载了指针相关的各种操作，比如operator++、operator–等，是一种类模板<br>仿函数：行为类似函数，可以作为算法的某种策略，从实现角度来看，它是重载了operator()的一种类模板<br>适配器：用来修饰容器、仿函数和迭代器的接口<br>空间配置器：负责空间的配置与管理。配置器实现了动态空间分配、管理与释放的类模板。</p><p>它们间的交互关系：容器通过空间配置器取得数据存储空间；算法通过迭代器来存储容器中的内容；<br>仿函数可以协助算法实现不同的策略；适配器可以修饰仿函数。</p><h2 id="乐观锁悲观锁"><a href="#乐观锁悲观锁" class="headerlink" title="乐观锁悲观锁"></a>乐观锁悲观锁</h2><p>乐观锁和悲观锁是两种并发控制的策略，用于处理多线程或多进程环境下的数据竞争问题。它们有不同的应用场景和实现方式，下面分别介绍。</p><h3 id="悲观锁（Pessimistic-Locking）"><a href="#悲观锁（Pessimistic-Locking）" class="headerlink" title="悲观锁（Pessimistic Locking）"></a>悲观锁（Pessimistic Locking）</h3><p><strong>悲观锁</strong>假设每次操作都会发生冲突，因此每次操作前都会先获取锁，以避免冲突和数据不一致问题。</p><ul><li><p><strong>特点</strong>：</p><ul><li>在读取或写入数据前，先获取锁。</li><li>获取锁的操作会阻塞其他线程或进程，直到锁被释放。</li><li>适用于写操作较多，冲突频繁的场景。</li></ul></li><li><p><strong>实现方式</strong>：</p><ul><li>数据库层面：使用数据库的锁机制，如行锁、表锁等。例如，MySQL中的<code>FOR UPDATE</code>语句。</li><li>应用程序层面：使用互斥锁（mutex）、读写锁（read-write lock）等同步机制。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::mutex mtx;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">critical_section</span><span class="hljs-params">()</span> </span>&#123;<br>    mtx.<span class="hljs-built_in">lock</span>();    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-comment">// 临界区代码</span><br>    mtx.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h3><p><strong>乐观锁</strong>假设冲突很少发生，因此每次操作不加锁，而是在提交时检查冲突，如果发现冲突则重试。</p><ul><li><p><strong>特点</strong>：</p><ul><li>在读取和写入数据时不加锁。</li><li>在提交更新时，检查是否有其他线程或进程修改了数据。</li><li>适用于读操作多、写操作少，冲突概率低的场景。</li></ul></li><li><p><strong>实现方式</strong>：</p><ul><li>数据库层面：使用版本号或时间戳机制。例如，每次读取数据时获取当前版本号，更新时检查版本号是否改变。</li><li>应用程序层面：比较并交换（Compare-and-Swap, CAS）操作。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VersionedData</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> version;<br>    <span class="hljs-type">int</span> data;<br><br>    <span class="hljs-built_in">VersionedData</span>(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> d) : <span class="hljs-built_in">version</span>(v), <span class="hljs-built_in">data</span>(d) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">update</span><span class="hljs-params">(VersionedData &amp;record, <span class="hljs-type">int</span> newData)</span> </span>&#123;<br>    <span class="hljs-type">int</span> oldVersion = record.version;<br>    <span class="hljs-comment">// 尝试更新数据</span><br>    <span class="hljs-keyword">if</span> (record.version == oldVersion) &#123;<br>        record.data = newData;<br>        record.version = oldVersion + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 版本号不匹配，更新失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="应用场景对比"><a href="#应用场景对比" class="headerlink" title="应用场景对比"></a>应用场景对比</h3><ul><li><p><strong>悲观锁</strong>：</p><ul><li>适用于<strong>高并发写操作</strong>，数据冲突较多的场景。</li><li>由于加锁会阻塞其他操作，可能会导致性能下降。</li><li>常用于<strong>银行转账、订单处理等需要强一致性</strong>的场景。</li></ul></li><li><p><strong>乐观锁</strong>：</p><ul><li>适用于<strong>高并发读操作</strong>，数据冲突较少的场景。</li><li>不加锁操作性能较高，但需要处理<strong>冲突重试的逻辑</strong>。</li><li>常用于<strong>社交媒体、数据分析等读多写少的场景</strong>。</li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>悲观锁</strong>：通过<strong>锁机制</strong>避免冲突，但可能会引起阻塞，适合写多读少的场景。</li><li><strong>乐观锁</strong>：假设冲突少，通过<strong>版本控制</strong>或CAS操作来检测冲突，适合读多写少的场景。</li></ul><p>选择使用哪种锁取决于具体的应用场景和数据访问模式。合理使用这两种锁可以有效提高系统的并发性能和数据一致性。</p><h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><p>数组和链表是两种基本的数据结构，它们在<strong>存储方式、访问方式、插入和删除操作</strong>等方面都有显著的区别。下面是它们的主要区别：</p><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><ul><li><p><strong>数组（Array）</strong>：</p><ul><li><strong>连续存储</strong>：数组在内存中是连续分配的，每个元素占用相同的大小。</li><li><strong>固定大小</strong>：数组的大小在声明时确定，不能动态改变。</li></ul></li><li><p><strong>链表（Linked List）</strong>：</p><ul><li><strong>非连续存储</strong>：链表中的元素（节点）在内存中可以是非连续分配的，每个节点包含数据部分和指向下一个节点的指针（或者上一个节点的指针）。</li><li><strong>动态大小</strong>：链表可以动态增长或缩减，不需要预先指定大小。</li></ul></li></ul><h3 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h3><ul><li><p><strong>数组</strong>：</p><ul><li><strong>随机访问</strong>：可以通过索引直接访问任意元素，时间复杂度为 (O(1))。</li><li><strong>效率高</strong>：由于是连续存储，CPU缓存命中率高，访问速度快。</li></ul></li><li><p><strong>链表</strong>：</p><ul><li><strong>顺序访问</strong>：访问某个元素需要从头部开始遍历，时间复杂度为 (O(n))。</li><li><strong>效率低</strong>：由于不是连续存储，CPU缓存命中率低，访问速度相对较慢。</li></ul></li></ul><h3 id="插入和删除操作"><a href="#插入和删除操作" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h3><ul><li><p><strong>数组</strong>：</p><ul><li><strong>插入和删除</strong>：在数组中间插入或删除元素需要移动其他元素，时间复杂度为 (O(n))。</li><li><strong>效率低</strong>：由于需要移动大量数据，插入和删除操作相对较慢。</li></ul></li><li><p><strong>链表</strong>：</p><ul><li><strong>插入和删除</strong>：在链表中插入或删除元素只需改变指针，时间复杂度为 (O(1))（在已知位置的情况下）。</li><li><strong>效率高</strong>：只需要调整指针即可，不需要移动其他数据，插入和删除操作相对较快。</li></ul></li></ul><h3 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h3><ul><li><p><strong>数组</strong>：</p><ul><li><strong>内存连续</strong>：需要一块连续的内存空间，容易造成内存碎片。</li><li><strong>固定大小</strong>：内存分配固定，一旦定义，<strong>大小不可变</strong>。</li></ul></li><li><p><strong>链表</strong>：</p><ul><li><strong>内存非连续</strong>：内存分配是动态的，<strong>可以有效利用内存，减少碎片</strong>。</li><li><strong>动态大小</strong>：根据需要动态分配或释放内存。</li></ul></li></ul><h3 id="空间效率"><a href="#空间效率" class="headerlink" title="空间效率"></a>空间效率</h3><ul><li><p><strong>数组</strong>：</p><ul><li><strong>空间效率高</strong>：没有额外的内存开销。</li><li><strong>大小固定</strong>：可能会导致<strong>空间浪费</strong>（如果预分配的空间很大而实际使用的很少）。</li></ul></li><li><p><strong>链表</strong>：</p><ul><li><strong>空间效率低</strong>：每个节点需要<strong>额外存储指针</strong>（通常是指向下一个节点的指针）。</li><li><strong>动态分配</strong>：可以根据实际需求动态分配内存，减少空间浪费。</li></ul></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>数组</strong>适合频繁随机访问元素且元素个数固定的场景，如用于实现查找表、缓存等。</li><li><strong>链表</strong>适合频繁插入和删除操作的场景，如用于实现队列、栈等。</li></ul><p>根据实际需求选择合适的数据结构，可以有效提高程序的性能和内存使用效率。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目捶打</title>
    <link href="/2024/05/23/%E9%A1%B9%E7%9B%AE%E6%8D%B6%E6%89%93/"/>
    <url>/2024/05/23/%E9%A1%B9%E7%9B%AE%E6%8D%B6%E6%89%93/</url>
    
    <content type="html"><![CDATA[<p>复盘了一下字节的面经，感觉已经无懈可击（误</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>面试官您好，我是xxx，我来自北京大学信息科学技术学院计算机科学与技术方向，现在读大三，很荣幸可以参加贵公司的面试。我是一个做事踏实认真负责，善于沟通交流合作的人。我在大一的时候学习了数据结构与算法等专业基础课程，了解了大部分常用的数据结构以及应用场景。上个学期学了计算机网络和操作系统的基础知识，对计算机的基本组成以及运行有了更深的认识。这个学期学习了数据库概论这门课，学习了mysql关系型数据库的使用。我是一个自我要求严格的人，在小组合作中，我的代码风格比较良好，注重细节。真诚地期待可以成为贵公司的一员。</p><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>把计网的两个课设项目重新敲打一下（</p><p>我的第一个项目是基于tcp协议，实现了一个简单的 FTP Server 和 FTP Client CLI (CLI指命令行界面)。</p><p>支持的命令有：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">open</span> <span class="hljs-symbol">&lt;IP&gt;</span> <span class="hljs-symbol">&lt;port&gt;</span>: 建立一个到 <span class="hljs-symbol">&lt;IP&gt;</span>:<span class="hljs-symbol">&lt;port&gt;</span> 的连接<br><span class="hljs-keyword">ls</span>: 通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，获取server当前运行目录下的文件列表。<br><span class="hljs-built_in">get</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Server 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Client 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中，支持ASCII和二进制文件，并且此命令会覆盖目录中的现有文件。<br><span class="hljs-keyword">put</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Client 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Server 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中，支持ASCII和二进制文件。<br><span class="hljs-built_in">sha256</span> <span class="hljs-symbol">&lt;filename&gt;</span>：文件在传输的过程中可能发生错误，我们可以利用校验码来检查传输结果是否正常。通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，在 Server 运行目录中查询某个文件的 <span class="hljs-built_in">sha256</span> 值，若不存在则返回不存在。<br><span class="hljs-keyword">quit</span>: 如有连接则断开连接，回到 <span class="hljs-keyword">open</span> 前的状态；如果已经是 <span class="hljs-keyword">open</span> 前的状态，则关闭 Client。<br></code></pre></td></tr></table></figure><p>我的第二个项目是基于UDP构建一个简单可靠的传输协议RTP，并且我的sender端和receiver端支持两种传输数据的策略，分别是回退N和选择重传算法。</p><p>我在这两个端都分别维护了滑动窗口，其中，receiver端只接受编号在窗口内的数据报文。假设当前编号不大于y的数据报文都已被确认，且编号为y+1的数据报文未被确认，那么当前滑动窗口的编号范围是[y+1, y+window_size]。如果Receiver收到了窗口“左侧”（编号小的一侧）一个或多个报文，则此时可以更新滑动窗口的范围。</p><p>我还实现了超时重传的机制，如果滑动窗口在一定的时间（100ms）内没有更新，Sender需要重传没有被确认的数据报文。对于回退N算法，Sender每次重传当前窗口的所有报文。对于选择重传算法，Sender只重传窗口内没有被确认的报文。</p><p>除此之外，我还实现了错误处理功能，即便出现诸如网络错误、丢包、延迟、损坏、复制和重排序等事件，依然能提供有序、可靠的UDP数据报传递。</p><h3 id="你是如何利用TCP实现FTP的？具体来说，你是如何实现LS、PUT、OPEN、GET、SHA256、QUIT等功能的？"><a href="#你是如何利用TCP实现FTP的？具体来说，你是如何实现LS、PUT、OPEN、GET、SHA256、QUIT等功能的？" class="headerlink" title="你是如何利用TCP实现FTP的？具体来说，你是如何实现LS、PUT、OPEN、GET、SHA256、QUIT等功能的？"></a>你是如何利用TCP实现FTP的？具体来说，你是如何实现LS、PUT、OPEN、GET、SHA256、QUIT等功能的？</h3><p>我通过设置不同的报文头部来区分不同的任务类型，总共有13种type，除了上面每一种功能有REQUEST报文和REPLY报文以外，还有FILE_DATA报文，专门用来标识文件数据的。client和server在收到报文的时候会首先对头部进行解析，分辨是哪一种任务类型。<br>client启动不需要参数，直接在build目录下终端运行.&#x2F;ftp_client运行可执行文件就行，过程中采用自定义函数get_string来解析client cli的命令以及参数。<br>server启动需要参数，在build目录下终端运行<code>./ftp_server 127.0.0.1 12323</code>(该 Server 监听 127.0.0.1:12323)以参数IP和port为server要监听的ip和端口。<br><strong>open：</strong><br>client:</p><ol><li>创建client套接字 socket()</li><li>客户端发送请求 connect()</li><li>send OPEN_CONN_REQUEST</li></ol><p>server:</p><ol><li>创建服务器套接字 socket()</li><li>设置服务器地址信息</li><li>将服务器套接字绑定到地址 bind()</li><li>开始监听连接请求 listen()</li><li>接受客户端连接请求 accept()</li><li>send OPEN_CONN_REPLY</li></ol><p><strong>get：</strong><br>假设用户想从 Server 上下载一个文件，然后他发出了一个命令 get FILE , 其中 FILE 是要下载的文件的名称。<br>然后，Client 将向 Server 发送一个协议消息 GET_REQUEST。Server 将首先检查该文件在其资源库目录中是否可用。<br>如果文件不存在，Server 将回复一个协议消息 GET_REPLY，m_status 设置为 0。<br>如果文件存在，Server 将回复一个协议消息 GET_REPLY，m_status 设置为 1。<br>以及一个包含文件内容的 FILE_DATA 消息。<br><strong>ls：</strong><br>要在Server端读取目录，使用popen获取Linux中ls程序执行的返回结果，并将其结果返回，注意返回的内容结尾应当增加一个\0以表示内容结束。<br><strong>sha256：</strong><br>假设用户想查询 Server 上目录下某个文件的 sha256 校验值，他发出一个命令 sha256 FILE，其中 FILE 是想要查询校验码的文件名称。<br>然后，Client 将向 Server 发送一个协议消息 SHA_REQUEST。Server 将首先检查该文件在其资源库目录中是否可用。<br>如果文件不存在，Server 将回复一个协议消息 SHA_REPLY，m_status 设置为 0。 如果文件存在，Server 将回复一个协议消息 SHA_REPLY，m_status 设置为 1。 以及一个包含关于需要查询的文件的 sha256 校验码的 FILE_DATA 消息。<br>如果文件存在，Client 需要将接收到的 sha256 校验码输出到屏幕。<br>类似 ls 命令，要在 Server 端计算 sha256 校验码，你可以使用popen获取 Linux 中sha256sum FILE 程序执行的返回结果（其中 FILE 为需要查询的文件名），并将其结果返回，注意返回的内容结尾应当增加一个\0以表示内容结束。<br><strong>put：</strong><br>假设用户想上传一个文件到 Server。然后，他发出一个命令 put FILE ,其中 FILE 是要上传的文件的名称。<br>首先，Client 将检查该文件是否存在于本地（即在 Client）。如果不存在，Client 将显示一个错误消息，说明该文件不存在。<br>如果文件在本地存在，那么 Client 将向 Server 发送一个协议消息 PUT_REQUEST。<br>Server将回复一个协议消息 PUT_REPLY 并等待文件。然后，Client 将发送一个包含文件内容和FILE_DATA 消息。</p><p>这里，我们假设上传的文件与 Client 程序驻留在同一目录下。<br>另外，在用户发出下一个命令之前，每次只上传一个文件。<br>最后，Server 将上传的文件存储在其工作目录下，使用用户提供的名称。<br>注意，Server 可能会覆盖现有的文件。</p><h3 id="身份认证在你的实现中起到了什么作用？你采用了什么样的身份认证机制？"><a href="#身份认证在你的实现中起到了什么作用？你采用了什么样的身份认证机制？" class="headerlink" title="身份认证在你的实现中起到了什么作用？你采用了什么样的身份认证机制？"></a>身份认证在你的实现中起到了什么作用？你采用了什么样的身份认证机制？</h3><p>身份认证起到了确保连接安全性的作用。通过要求用户在建立连接之前输入用户名和密码，你可以验证用户的身份，并确保只有经过身份验证的用户才能访问FTP服务器上的文件。<strong>这有助于防止未经授权的用户访问敏感数据或进行未经授权的操作</strong>。</p><p>我采用了基本的<strong>用户名密码认证机制</strong>。具体来说，用户在连接服务器之前需要提供其用户名和密码，服务器会对这些凭据进行验证。如果凭据验证成功，用户将被授予访问FTP服务器的权限，否则连接将被拒绝。</p><h3 id="在实现过程中，你遇到了哪些挑战？你是如何解决这些挑战的？有没有一些特别困难的问题需要特别的技巧来解决？"><a href="#在实现过程中，你遇到了哪些挑战？你是如何解决这些挑战的？有没有一些特别困难的问题需要特别的技巧来解决？" class="headerlink" title="在实现过程中，你遇到了哪些挑战？你是如何解决这些挑战的？有没有一些特别困难的问题需要特别的技巧来解决？"></a>在实现过程中，你遇到了哪些挑战？你是如何解决这些挑战的？有没有一些特别困难的问题需要特别的技巧来解决？</h3><p>（最害怕的问题出现了<br>在实现UDP可靠传输的过程中，我遇到了几个挑战：</p><ol><li><p><strong>丢包和重复</strong>：UDP协议下的数据传输容易受到网络丢包和重复的影响，这会导致数据的丢失或重复传输。解决这个问题的关键是设计合适的确认机制和重传策略，以确保数据的可靠传输。</p></li><li><p><strong>超时处理</strong>：在UDP协议下，没有内置的超时机制，因此需要自己设计超时处理机制。如何设置合适的超时时间以及如何处理超时事件是一个挑战。</p></li><li><p><strong>网络延迟</strong>：网络延迟可能导致数据包在传输过程中的顺序发生变化，这会影响到数据的接收顺序。为了解决这个问题，需要设计合适的排序和缓冲机制。</p></li></ol><p>为了解决这些挑战，我采取了以下策略：</p><ol><li><p><strong>设计合适的协议和算法</strong>：我仔细设计了协议和算法，包括确认机制、重传策略、超时处理等，以确保数据的可靠传输。</p></li><li><p><strong>调试和测试</strong>：我进行了大量的调试和测试工作，模拟不同网络条件下的数据传输情况，发现和解决了一些潜在的问题。</p></li><li><p><strong>优化性能</strong>：我对传输过程进行了性能优化，包括减少重传次数、降低超时时间、优化缓冲管理等，以提高传输效率和可靠性。</p></li></ol><p>特别困难的问题需要特别的技巧来解决，我认为在处理UDP可靠传输时，对网络丢包和重复的处理是一个相对困难的问题。为了解决这个问题，我采用了一些高级的技术，如序列号和确认号的设计、拥塞控制算法的优化等，以确保数据的可靠传输。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>中缀表达式求值</title>
    <link href="/2024/05/22/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2024/05/22/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>好像知道为什么当时面字节的时候没写出来了，，，因为不会中缀转后缀</p><p>中缀表达式转后缀表达式步骤：<br>只需要设立一个栈存符号<br>if 数字 直接输出<br>if 左括号 直接入栈<br>if 栈空 or 栈顶为左括号 or 当前优先级大于栈顶优先级<br>    入栈<br>else 依次弹出栈顶直到满足条件 然后入栈<br>if 右括号 依次弹出栈顶直到遇到左括号 把左括号也pop掉</p><p>后缀表达式求值步骤：<br>只需要一个数字栈<br>碰到数字 入栈<br>碰到符号，从数字栈弹出两个值计算，将得到的值压栈</p><p>贴个中缀转后缀的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">(<span class="hljs-type">char</span> sym)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (sym==<span class="hljs-string">&#x27;+&#x27;</span>||sym==<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (sym==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-comment">// 请务必注意return 0这一点！！！</span><br>&#125;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s_mid;<br>    s_mid=<span class="hljs-string">&quot;1+(2+3)*2&quot;</span>;<br>    string s_back;<br>    stack&lt;<span class="hljs-type">char</span>&gt;symbol;<br>    <span class="hljs-type">int</span> len =s_mid.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <br>        <span class="hljs-comment">// if (symbol.empty()) symbol.push(s_mid[i]);</span><br>        <span class="hljs-comment">// 这是错的！！！要先判断它是不是数字！！！</span><br>        <span class="hljs-keyword">if</span> (s_mid[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s_mid[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)  s_back = s_back + s_mid[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol.<span class="hljs-built_in">empty</span>()) symbol.<span class="hljs-built_in">push</span>(s_mid[i]);<br>        <span class="hljs-comment">// 数字直接输出</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s_mid[i]==<span class="hljs-string">&#x27;(&#x27;</span>) symbol.<span class="hljs-built_in">push</span>(s_mid[i]);<br>        <span class="hljs-comment">// 左括号直接入栈</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s_mid[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span> (symbol.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;top:&quot;</span>&lt;&lt;symbol.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>                s_back = s_back + symbol.<span class="hljs-built_in">top</span>();<br>                cout&lt;&lt;s_back&lt;&lt;endl;<br>                symbol.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            symbol.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 最后将左括号也pop掉</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span> (!symbol.<span class="hljs-built_in">empty</span>()&amp;&amp;<span class="hljs-built_in">priority</span>(s_mid[i])&lt;=<span class="hljs-built_in">priority</span>(symbol.<span class="hljs-built_in">top</span>()))&#123;<br>                s_back = s_back+symbol.<span class="hljs-built_in">top</span>();<br>                symbol.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            symbol.<span class="hljs-built_in">push</span>(s_mid[i]);<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span> (!symbol.<span class="hljs-built_in">empty</span>())&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;symbol.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;<span class="hljs-string">&quot;stack is empty.&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <br>        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;s_back&lt;&lt;endl;<br>        <br>    &#125;<br>    <span class="hljs-keyword">while</span> (!symbol.<span class="hljs-built_in">empty</span>())&#123;<br>        s_back = s_back + symbol.<span class="hljs-built_in">top</span>();<br>        symbol.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout&lt;&lt;s_back&lt;&lt;endl;<br>    <span class="hljs-comment">// 至此最难的部分：中缀转后缀完成</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-12</title>
    <link href="/2024/05/22/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-12/"/>
    <url>/2024/05/22/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-12/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍一下信号量"><a href="#介绍一下信号量" class="headerlink" title="介绍一下信号量"></a>介绍一下信号量</h2><p>信号量（Semaphore）是一种用于管理多线程或多进程<strong>并发访问共享资源</strong>的同步工具。它通过<strong>维护一个计数器来跟踪可用资源的数量</strong>，从而控制多个线程或进程对共享资源的访问。信号量在操作系统和并发编程中起着关键作用，广泛应用于<strong>避免竞争条件和确保资源的合理分配</strong>。</p><h3 id="信号量的类型"><a href="#信号量的类型" class="headerlink" title="信号量的类型"></a>信号量的类型</h3><ol><li><p><strong>二进制信号量（Binary Semaphore）</strong>：也称为<strong>互斥锁（Mutex）</strong>，其计数器只有两个值0和1。主要用于实现互斥访问，即保证同一时间只有一个线程可以访问共享资源。</p></li><li><p><strong>计数信号量（Counting Semaphore）</strong>：计数器可以大于1，<strong>允许多个线程同时访问有限数量的共享资源</strong>。例如，限制某个资源同时只能有N个线程访问。</p></li></ol><h3 id="信号量的基本操作"><a href="#信号量的基本操作" class="headerlink" title="信号量的基本操作"></a>信号量的基本操作</h3><p>信号量通常提供两个主要操作：</p><ul><li><strong>P（Proberen）操作</strong>：也叫wait、down或decrement操作，表示请求资源。如果信号量的计数器大于0，则减1；<strong>如果计数器为0，则线程会被阻塞，直到计数器大于0</strong>。</li><li><strong>V（Verhogen）操作</strong>：也叫signal、up或increment操作，表示释放资源。将信号量的计数器加1，<strong>如果有被阻塞的线程，则唤醒其中一个</strong>。</li></ul><h3 id="使用信号量的场景"><a href="#使用信号量的场景" class="headerlink" title="使用信号量的场景"></a>使用信号量的场景</h3><ol><li><strong>资源池管理</strong>：限制对有限资源（如数据库连接、线程池）的并发访问数量。</li><li><strong>生产者-消费者问题</strong>：确保生产者和消费者对共享缓冲区的正确访问，避免缓冲区溢出或空读。</li><li><strong>同步操作</strong>：保证多线程环境中操作的顺序性，防止数据不一致。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>根据之前的模拟面试记录复盘了一下</title>
    <link href="/2024/05/22/%E6%A0%B9%E6%8D%AE%E4%B9%8B%E5%89%8D%E7%9A%84%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E5%A4%8D%E7%9B%98%E4%BA%86%E4%B8%80%E4%B8%8B/"/>
    <url>/2024/05/22/%E6%A0%B9%E6%8D%AE%E4%B9%8B%E5%89%8D%E7%9A%84%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E5%A4%8D%E7%9B%98%E4%BA%86%E4%B8%80%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>肉眼可见地多掌握了好多</p><p>udp首部：源port（可选），目的port（必须），长度（最小为header长度8字节），校验和（总是忘<br>其中记得是port不是ip</p><p>http1.x和2.x区别：传输数据类型，服务器主动推送，多路复用（流ID），头部压缩</p><p>IO 模型：异步io 阻塞io 非阻塞io 信号<strong>驱动</strong>io 多路复用io</p><p>udp是什么：UDP 是一个简单的传输层协议，为网络层以上和应用层以下的程序<strong>提供了接口</strong>，他<strong>不保证传输的可靠性</strong>，网络交互和协议栈处理<strong>开销比较小</strong>，适用于对<strong>耗时要求较高但对报文可靠性要求不高</strong>的应用程序使用。 （传输层，接口，不可靠，尽力而为，开销小，高实时）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-11</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-11/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-11/</url>
    
    <content type="html"><![CDATA[<h3 id="谈谈InnoDB引擎中的锁"><a href="#谈谈InnoDB引擎中的锁" class="headerlink" title="谈谈InnoDB引擎中的锁"></a>谈谈InnoDB引擎中的锁</h3><p>在InnoDB存储引擎中，锁是实现并发控制和事务隔离的重要机制之一。InnoDB引擎提供了多种锁类型，包括共享锁、排他锁和意向锁等。</p><p>共享锁（Shared Lock）：允许多个事务同时读取同一行数据，但是不允许对该行数据进行修改。当一个事务持有共享锁时，其他事务可以获取共享锁，但是不能获取排他锁。多个事务可以同时持有共享锁，不会互相阻塞。</p><p>排他锁（Exclusive Lock）：只允许一个事务独占一行数据，其他事务不能获取共享锁或排他锁，直到该事务释放排他锁。当一个事务持有排他锁时，其他事务无法获取任何类型的锁，必须等待该事务释放锁。</p><p>意向锁（Intention Lock）：用于协调共享锁和排他锁之间的竞争。当一个事务获取共享锁或排他锁时，必须先获取对应的意向锁。意向锁是一种轻量级锁，不会阻塞其他事务的读取操作，只会阻塞其他事务的修改操作。</p><p>InnoDB引擎中还有其他类型的锁，例如行锁、表锁和间隙锁等，它们也都有各自的特点和应用场景。在实际开发中，需要根据具体的需求选择合适的锁类型，以保证并发控制和事务隔离的正确性和性能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-10</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-10/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-10/</url>
    
    <content type="html"><![CDATA[<h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><p>在 C 和 C++ 中，<code>static</code> 关键字有多种用途，具体作用取决于它应用的上下文。主要有以下几种：</p><h3 id="1-在函数内部的作用"><a href="#1-在函数内部的作用" class="headerlink" title="1. 在函数内部的作用"></a>1. <strong>在函数内部的作用</strong></h3><p>当 <code>static</code> 用于函数内部的变量时，这个变量的生命周期将延续到程序结束，而不仅仅局限于函数调用期间。它在首次调用时被初始化，以后的每次调用都会使用上一次调用结束时的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br>    counter++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, counter);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    count(); <span class="hljs-comment">// 输出 1</span><br>    count(); <span class="hljs-comment">// 输出 2</span><br>    count(); <span class="hljs-comment">// 输出 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-在文件作用域的作用"><a href="#2-在文件作用域的作用" class="headerlink" title="2. 在文件作用域的作用"></a>2. <strong>在文件作用域的作用</strong></h3><p>当 <code>static</code> 用于文件作用域（即在函数外部定义的变量或函数）时，该变量或函数的作用域仅限于定义它的源文件。这可以防止其他文件访问该变量或函数，实现了内部链接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// file1.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    count++;<br>&#125;<br><br><span class="hljs-comment">// file2.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    increment();<br>    <span class="hljs-comment">// 无法直接访问 file1.c 中的 count 变量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>count</code> 变量和 <code>increment</code> 函数只能在 <code>file1.c</code> 中访问，而不能在其他文件中访问。</p><h3 id="3-在类中的作用（C-）"><a href="#3-在类中的作用（C-）" class="headerlink" title="3. 在类中的作用（C++）"></a>3. <strong>在类中的作用（C++）</strong></h3><p>在 C++ 中，<code>static</code> 关键字可以用于类成员，表示这些成员属于类本身，而不是某个具体对象。具体表现为以下几种情况：</p><h4 id="3-1-静态数据成员"><a href="#3-1-静态数据成员" class="headerlink" title="3.1. 静态数据成员"></a>3.1. <strong>静态数据成员</strong></h4><p>静态数据成员在所有对象之间共享，只占用一份存储空间。它们可以在类外部定义和初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-built_in">MyClass</span>() &#123;<br>        count++;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1;<br>    MyClass obj2;<br>    std::cout &lt;&lt; MyClass::count &lt;&lt; std::endl; <span class="hljs-comment">// 输出 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-静态成员函数"><a href="#3-2-静态成员函数" class="headerlink" title="3.2. 静态成员函数"></a>3.2. <strong>静态成员函数</strong></h4><p>静态成员函数只能访问静态数据成员和其他静态成员函数，不能访问非静态成员。它们可以通过类名直接调用，而不需要对象实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">displayCount</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; count &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass::count = <span class="hljs-number">5</span>;<br>    MyClass::<span class="hljs-built_in">displayCount</span>(); <span class="hljs-comment">// 输出 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>函数内部的静态变量</strong>：生命周期贯穿程序整个运行周期，但作用域仅限于函数内部。</li><li><strong>文件作用域的静态变量和函数</strong>：只在定义它们的文件内部可见，实现内部链接。</li><li><strong>类中的静态成员（C++）</strong>：属于类本身，而不是某个对象，可以在所有对象间共享，或直接通过类名访问。</li></ul><p>这些特性使 <code>static</code> 关键字在控制变量的作用域和生命周期、实现封装和数据共享方面非常有用。</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>一、堆栈空间分配区别：<br>    1、栈（操作系统）：由操作系统自动分配释放<br>，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；<br>    2、堆（操作系统）： 一般由程序员分配释放，<br>若程序员不释放，程序结束时可能由os回收，分配方式倒是类似于链表。<br>二、堆栈缓存方式区别：<br>    1、栈使用的是一级缓存，<br>他们通常都是被调用时处于存储空间中，调用完毕立即释放；<br>    2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。<br>    三、堆栈数据结构区别：<br>    堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>    栈（数据结构）：一种先进后出的数据结构。</p><h2 id="滑动窗口找最大值"><a href="#滑动窗口找最大值" class="headerlink" title="滑动窗口找最大值"></a>滑动窗口找最大值</h2><p>给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</p><p>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>窗口大于数组长度或窗口长度为0的时候，返回空。<br>gpt生成的：以后验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">windowValue</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> window)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    deque&lt;<span class="hljs-type">int</span>&gt; dq; <span class="hljs-comment">// 存储数组元素的索引</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-comment">// 移除不在当前窗口的元素</span><br>        <span class="hljs-keyword">if</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() == i - window) &#123;<br>            dq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 移除所有小于当前元素的元素</span><br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; arr[dq.<span class="hljs-built_in">back</span>()] &lt;= arr[i]) &#123;<br>            dq.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 添加当前元素的索引到双端队列</span><br>        dq.<span class="hljs-built_in">push_back</span>(i);<br><br>        <span class="hljs-comment">// 当前窗口的最大值就是双端队列的头部</span><br>        <span class="hljs-keyword">if</span> (i &gt;= window - <span class="hljs-number">1</span>) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(arr[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> window = <span class="hljs-number">3</span>;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">windowValue</span>(arr, n, window);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : result) &#123;<br>        cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-9</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-9/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-9/</url>
    
    <content type="html"><![CDATA[<h3 id="IP协议的首部结构"><a href="#IP协议的首部结构" class="headerlink" title="IP协议的首部结构"></a>IP协议的首部结构</h3><p>（每次问每次不会）<br>首部协议一共是20个字节（固定）<br>第一个4字节： 版本号；<strong>首部长度</strong>； <strong>服务类型</strong>；<strong>总长度</strong>；<br>第二个4字节：<strong>标识（便于正确组装）；标志（表示是否分片 以及后面还有没有分片）；片偏移；</strong><br>第三个4字节：<strong>生存时间</strong>；<strong>协议（8表示TCP,17表示UDP）；校验和</strong>；<br>第四个4字节：源ip地址；<br>第五个4字节：目的ip地址；</p><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p>先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。<br>短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。<br>时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br><strong>多级反馈队列调度算法</strong>：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。<br><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p><h3 id="合并两个有序数组到A"><a href="#合并两个有序数组到A" class="headerlink" title="合并两个有序数组到A"></a>合并两个有序数组到A</h3><p>给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组<br><img src="/../img/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%88%B0A.png" alt="合并两个有序数组到A"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">i从A的末尾，j从B末尾开始，两两比较，大的放在末端。</span><br><span class="hljs-comment">比如A[4,5,7] B[1,2,6],。</span><br><span class="hljs-comment">7比6大，A[5]处放置7，然后i前移。</span><br><span class="hljs-comment">再次比较5 和6,6放在A[4]处。</span><br><span class="hljs-comment">如此类推如果A穷尽，把B元素依次放进A的前几个位置，如果B穷尽，正好结束。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> B[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;B.length;k++)<br>                A[k]=B[k];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> i=m<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> s=m+n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;i&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(A[i]&gt;B[j])<br>                A[s--]=A[i--];<br>            <span class="hljs-keyword">else</span><br>                    A[s--]=B[j--];<br>        &#125;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">for</span>(;j&gt;=<span class="hljs-number">0</span>;j--)<br>                    A[j]=B[j];<br>        &#125; <br>        &#125;<br>       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-8</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-8/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-8/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议的缓存策略？"><a href="#HTTP协议的缓存策略？" class="headerlink" title="HTTP协议的缓存策略？"></a>HTTP协议的缓存策略？</h3><p>HTTP协议的缓存策略有两种，分别是强制缓存和协商缓存，强制缓存的优先级大于协商缓存。强制缓存是服务器告诉浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行协商缓存策略。协商缓存是让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified字段通过请求发送给服务器，由服务器校验。如果文件没有改变，那么直接返回304状态，继续使用浏览器缓存。</p><p>加分回答</p><p>HTTP协议的缓存策略是浏览器每次发起请求时，<strong>先在本地缓存中查找结果以及缓存标识</strong>，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存，否则，则向服务器发起请求并携带缓存标识。HTTP协议的缓存策略分两种：强制缓存和协商缓存，<strong>而强制缓存优先级大于协商缓存</strong>。</p><p>强制缓存：服务器告诉浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，<strong>不在时间内，执行比较缓存策略</strong>。<br>协商缓存：让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified<br>通过请求发送给服务器，由服务器校验。如果文件没有改变，那么直接返回304状态，继续使用浏览器缓存。<br><strong>HTTP缓存都是从第二次请求开始的</strong>：</p><p>第一次请求资源时，服务器返回资源，并在响应头首部中回传资源的缓存策略。<br>第二次请求时，浏览器判断这些请求参数，击中强缓存就直接返回状态码200，否则就把请求参数加到请求头首部中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。<br>延伸阅读<br>强制缓存：</p><p>强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory或者from disk。<br>控制强制缓存的字段有：Cache-Control（http1.1）和Expires（http1.0）。<br>Cache-control是一个相对时间，用以表达<strong>自上次请求正确的资源之后的多少秒的时间段内缓存有效</strong>。<br>Expires是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求。<br><strong>Cache-Control的优先级比Expires的优先级高</strong>。前者的出现是为了解决Expires在浏览器时间被手动更改导致缓存判断错误的问题。如果同时存在则使用Cache-control。<br>协商缓存：</p><p>协商缓存的状态码由服务器决策返回200或者304<br>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since或者 If-None-Match的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified或者ETag属性。<br>对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此在响应体体积上的节省是它的优化点。<br>协商缓存有2组字段(不是两个)，控制协商缓存的字段有：Last-Modified&#x2F;If-Modified-since（http1.0）和Etag&#x2F;If-None-match（http1.1）。<br>Last-Modified&#x2F;If-Modified-since表示的是服务器的资源最后一次修改的时间。Etag&#x2F;If-None-match表示的是服务器资源的唯一标识，只要资源变化，Etag就会重新生成。<br>Etag&#x2F;If-None-match的优先级比Last-Modified&#x2F;If-Modified-since高。</p><h3 id="C-11的新特性"><a href="#C-11的新特性" class="headerlink" title="C++11的新特性"></a>C++11的新特性</h3><p>auto类型推导（给变量做类型推导，需要初始值<br>decltype类型推导（类似与sizeof，不过decltype的推导过程是在编译期完成的，并且不会真正计算表达式的值<br>四种cast类型转换（static_cast, dynamic_cast, const_cast, reinterpret_cast）<br>智能指针<br>try_catch抛出异常<br>lambda表达式</p><h3 id="静态变量、全局变量、局部变量的特点"><a href="#静态变量、全局变量、局部变量的特点" class="headerlink" title="静态变量、全局变量、局部变量的特点"></a>静态变量、全局变量、局部变量的特点</h3><p>从所在位置、作用域、内存位置、生命周期来说一说静态变量、全局变量、局部变量的特点：</p><p>位置</p><p>局部变量：在函数中或者方法中，函数的参数，局部代码块中。</p><p>全局变量：在文件中，函数外。</p><p>静态变量：使用 static 修饰，可以是局部、全局或者修饰类成员。</p><p>作用域</p><p>局部变量：<strong>作用域</strong>为<strong>局部</strong>，也就是函数或方法中，出了作用域就不能访问，<strong>同一作用域不能有同名的变量</strong>，如果全局变量和局部变量同名，则访问时采用<strong>就近原则</strong>。</p><p>全局变量：作用域为<strong>全局</strong>，在<strong>本文件或者其它文件中都可以访问</strong>，在其它文件中访问可以通过 <strong>extern</strong> 进行声明，表示使用外部的全部变量。</p><p>静态变量：静态局部变量作用域为<strong>局部</strong>，静态全局变量作用域为所在文件中，<strong>其它文件中访问不了</strong>。</p><p>内存位置</p><p>局部变量：存储在<strong>栈内存</strong>中。</p><p>全局变量&#x2F;全局变量：存储在<strong>静态存储区</strong>中，如果未初始化或者初始化为0，在BSS段，初始化了在DATA段。</p><p>生命周期</p><p>局部变量：出了作用域销毁。</p><p>全局变量&#x2F;静态变量：程序结束销毁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-7</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-7/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-7/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示</p><p>面向过程和面向对象的区别</p><p>面向过程：根据业务逻辑从上到下写代码</p><p>面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程</p><h3 id="说说你对MySQL引擎的理解"><a href="#说说你对MySQL引擎的理解" class="headerlink" title="说说你对MySQL引擎的理解"></a>说说你对MySQL引擎的理解</h3><p>mysql 有两种数据库引擎</p><p>一种是 MyISAM,一种是 InnoDB</p><p>MyISAM 发音为 “my-z[ei]m”;</p><p>InnoDB 发音为 “in-no-db”</p><p><img src="/../img/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/MySQL%E5%BC%95%E6%93%8E.png" alt="mysql引擎"></p><h3 id="Linux中fork-函数的作用"><a href="#Linux中fork-函数的作用" class="headerlink" title="Linux中fork()函数的作用"></a>Linux中fork()函数的作用</h3><p>fork函数是在已经存在的进程中创建一个子进程，其中这个已经存在的这个进程被称为父进程</p><h3 id="数字字符串转IP地址"><a href="#数字字符串转IP地址" class="headerlink" title="数字字符串转IP地址"></a>数字字符串转IP地址</h3><p>当时没写完 因为对string库函数用的不熟练<br>substr和atoi<br>注意不能出现连续的0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param s string字符串</span><br><span class="hljs-comment">     * @return string字符串vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;string&gt;result;<br>        <span class="hljs-type">int</span> len =s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len1 = <span class="hljs-number">1</span>; len1 &lt;= <span class="hljs-number">3</span>; len1++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len2 = <span class="hljs-number">1</span>; len2 &lt;= <span class="hljs-number">3</span>; len2++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len3 = <span class="hljs-number">1</span>; len3 &lt;= <span class="hljs-number">3</span>; len3++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len4 = <span class="hljs-number">1</span>; len4 &lt;= <span class="hljs-number">3</span>; len4++)<br>                        <span class="hljs-keyword">if</span> (len1 + len2 + len3 + len4 == len) &#123;<br>                            string temp;<br>                            <span class="hljs-comment">// for (int i=0;i&lt;len1;i++)&#123;</span><br>                            <span class="hljs-comment">//     temp = temp+s[i];</span><br>                            <span class="hljs-comment">// &#125;</span><br>                            string tmp1 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, len1);<br>                            <span class="hljs-keyword">if</span> (len1!=<span class="hljs-number">1</span>&amp;&amp;tmp1[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-type">int</span> t1 = <span class="hljs-built_in">stoi</span>(tmp1);<br>                            string tmp2 = s.<span class="hljs-built_in">substr</span>(len1, len2);<br>                            <span class="hljs-keyword">if</span> (len2!=<span class="hljs-number">1</span>&amp;&amp;tmp2[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-type">int</span> t2 = <span class="hljs-built_in">stoi</span>(tmp2);<br>                            string tmp3 = s.<span class="hljs-built_in">substr</span>(len1 + len2, len3);<br>                            <span class="hljs-keyword">if</span> (len3!=<span class="hljs-number">1</span>&amp;&amp;tmp3[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-type">int</span> t3 = <span class="hljs-built_in">stoi</span>(tmp3);<br>                            string tmp4 = s.<span class="hljs-built_in">substr</span>(len1 + len2 + len3, len4);<br>                            <span class="hljs-keyword">if</span> (len4!=<span class="hljs-number">1</span>&amp;&amp;tmp4[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-type">int</span> t4 = <span class="hljs-built_in">stoi</span>(tmp4);<br>                            <span class="hljs-keyword">if</span> (t1 &gt; <span class="hljs-number">255</span> || t2 &gt; <span class="hljs-number">255</span> || t3 &gt; <span class="hljs-number">255</span> || t4 &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">continue</span>;<br><br>                            temp = tmp1 + <span class="hljs-string">&#x27;.&#x27;</span> + tmp2 + <span class="hljs-string">&#x27;.&#x27;</span> + tmp3 + <span class="hljs-string">&#x27;.&#x27;</span> + tmp4;<br>                            result.<span class="hljs-built_in">push_back</span>(temp);<br><br><br>                        &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虾皮笔试-我被恶心的输入机制害惨啦</title>
    <link href="/2024/05/21/%E8%99%BE%E7%9A%AE%E7%AC%94%E8%AF%95-%E6%88%91%E8%A2%AB%E6%81%B6%E5%BF%83%E7%9A%84%E8%BE%93%E5%85%A5%E6%9C%BA%E5%88%B6%E5%AE%B3%E6%83%A8%E5%95%A6/"/>
    <url>/2024/05/21/%E8%99%BE%E7%9A%AE%E7%AC%94%E8%AF%95-%E6%88%91%E8%A2%AB%E6%81%B6%E5%BF%83%E7%9A%84%E8%BE%93%E5%85%A5%E6%9C%BA%E5%88%B6%E5%AE%B3%E6%83%A8%E5%95%A6/</url>
    
    <content type="html"><![CDATA[<p>战绩：一道90% 一道AK 一道0%<br>谁家好人直接用字符串读入一个二维数组，，，要死了<br>案例输入：<br>[[0]]<br>[[1,2,3],[4,5,6],[7,8,9]]<br>[[1,2,3,4]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-6</title>
    <link href="/2024/05/20/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-6/"/>
    <url>/2024/05/20/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-6/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是野指针？如何避免？"><a href="#什么是野指针？如何避免？" class="headerlink" title="什么是野指针？如何避免？"></a>什么是野指针？如何避免？</h3><p>野指针是指指向无效内存地址的指针。这种指针通常是未初始化的、已经被释放的或者指向无效内存的指针。在访问野指针所指向的内存时，会导致未定义的行为，可能导致程序崩溃、数据损坏或安全漏洞。</p><p>野指针通常是由于以下原因导致的：</p><ol><li>未初始化：指针变量被声明但未被赋值，指向一个随机的内存地址。</li><li>已释放：指针指向的内存已经被释放，但指针本身并没有置为 <code>nullptr</code> 或 <code>NULL</code>。</li><li>悬空：指针指向的内存已经不再有效，可能是因为它指向的对象已经被销毁或超出了作用域。</li></ol><p>为了避免野指针导致的问题，程序员应该养成良好的指针管理习惯，包括在声明指针时初始化为 <code>nullptr</code> 或 <code>NULL</code>、及时释放动态分配的内存、避免悬空指针等。</p><h3 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h3><p>C&#x2F;C++的内存分配主要包括以下几个部分：栈（Stack）、堆（Heap）和静态存储区（Static Storage Area）。这些部分的功能和特点如下：</p><ol><li>栈（Stack）： 栈是一种用于存储局部变量和函数调用信息的内存区域。它是一种后进先出（LIFO）的数据结构，每当一个函数被调用时，都会在栈上创建一个栈帧（Stack Frame）。栈帧中包含了局部变量、函数参数以及其他与函数调用相关的信息。函数调用结束后，分配的内存会自动释放。栈的内存分配和释放速度非常快，但由于栈的大小有限，不能用于存储大量或运行时确定大小的数据。</li><li>堆（Heap）： 堆是一种用于动态分配内存的内存区域。在C++中，可以使用new和delete操作符（或new[]和delete[]操作符）在堆上分配和释放内存。堆内存的分配和释放需要在运行时进行，速度相对较慢，且需要程序员手动管理内存的生命周期。不正确地管理堆内存可能导致内存泄漏或悬挂指针等问题。由于堆的大小远大于栈，可以用于存储大量或运行时确定大小的数据。</li><li>静态存储区（Static Storage Area）： 静态存储区是一种用于存储全局变量、静态变量和常量的内存区域。静态存储区的内存分配在编译时就确定，程序的整个生命周期内都存在，直到程序结束。静态存储区的内存分配速度快，但分配的内存大小在编译时就确定，不能在运行时改变。</li></ol><h3 id="TCP怎么保证有效传输"><a href="#TCP怎么保证有效传输" class="headerlink" title="TCP怎么保证有效传输"></a>TCP怎么保证有效传输</h3><p>首先通过三次握手建立连接<br>建立连接的时候交换序列号<br>发送方每次发送包的时候会带上序列号<br>接收方收到包后检验数据是否正确，确认后发送确认的序列号给发送方<br>发送方没有收到确认的序列号的包，就会重写发送</p><p>1、确认和重传<br>2、数据校验<br>3、流量控制<br>4、拥赛控制</p><h3 id="IP协议首部结构"><a href="#IP协议首部结构" class="headerlink" title="IP协议首部结构"></a>IP协议首部结构</h3><p>IP（Internet Protocol）协议首部是互联网协议栈中的核心部分之一，它负责在网络中传输数据包。以下是IPv4协议首部的结构：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section"> 0      4      8     16     19     31</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">| Version  |  IHL | Type of Service |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|         Total Length               |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|       Identification              |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|Flags| Fragment Offset             |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|  Time to Live | Protocol         |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|         Header Checksum           |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|       Source Address              |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|    Destination Address            |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|   Options and Padding             |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>Version (4 bits)</strong>: 指定IP协议的版本。IPv4协议的版本为4。</p></li><li><p><strong>IHL (Internet Header Length) (4 bits)</strong>: 表示IP首部的长度，以32位字为单位。因为IP首部的长度可变，所以该字段用来指示首部的长度。</p></li><li><p><strong>Type of Service (8 bits)</strong>: 服务类型字段用来指定数据包的服务质量，如优先级、延迟、吞吐量等。</p></li><li><p><strong>Total Length (16 bits)</strong>: 指定整个IP数据报的长度，包括IP首部和数据部分，以字节为单位。</p></li><li><p><strong>Identification (16 bits)</strong>: 用于标识IP数据报的唯一标识符。</p></li><li><p><strong>Flags (3 bits)</strong>: 标识数据报是否被分片，分片相关的标志位。</p></li><li><p><strong>Fragment Offset (13 bits)</strong>: 指定分片相对于原始数据报的偏移量，以8字节为单位。</p></li><li><p><strong>Time to Live (TTL) (8 bits)</strong>: 表示数据报在网络中的生存时间（跳数），每经过一个路由器，该字段的值减1，当该字段的值为0时，数据报会被丢弃。</p></li><li><p><strong>Protocol (8 bits)</strong>: 表示IP数据报携带的上层协议类型，如TCP、UDP等。</p></li><li><p><strong>Header Checksum (16 bits)</strong>: 校验和字段用来检查IP首部在传输过程中是否发生了错误。</p></li><li><p><strong>Source Address (32 bits)</strong>: 源IP地址，指定数据报的发送者。</p></li><li><p><strong>Destination Address (32 bits)</strong>: 目标IP地址，指定数据报的接收者。</p></li><li><p><strong>Options and Padding</strong>: 可选字段，用于指定一些附加的选项信息，如记录路由、时间戳等。如果选项字段不存在，首部会通过填充字段使其对齐到32位字边界。</p></li></ul><p>这是IPv4协议首部的基本结构，IPv6协议首部有所不同。</p><p>IPv6和IPv4首部在结构上有一些不同之处，主要体现在IPv6相对于IPv4的改进和扩展。以下是IPv6协议首部的结构：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section"> 0      4      8     16     19     31</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">| Version  | Traffic Class | Flow Label |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|         Payload Length             |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|  Next Header  |   Hop Limit       |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br>|                                   |<br><span class="hljs-code">+           Source Address          +</span><br>|                                   |<br><span class="hljs-code">+------+</span>--    --<span class="hljs-code">+------+</span>------<span class="hljs-code">+------+</span><br>|                                   |<br><span class="hljs-code">+        Destination Address        +</span><br><span class="hljs-section">|                                   |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br></code></pre></td></tr></table></figure><p>与IPv4首部相比，IPv6首部的主要变化如下：</p><ul><li><p><strong>Version (4 bits)</strong>: 同样指定IP协议的版本，IPv6协议的版本为6。</p></li><li><p><strong>Traffic Class (8 bits)</strong>: 类似于IPv4中的服务类型字段，但Traffic Class字段更加灵活，可以支持更多的服务质量标记。</p></li><li><p><strong>Flow Label (20 bits)</strong>: IPv6引入的新特性，用于标识数据流。流标签用于标识需要特殊处理的数据流，如实时流媒体等。</p></li><li><p><strong>Payload Length (16 bits)</strong>: 指定数据报的有效载荷长度，包括扩展首部和数据部分，以字节为单位。</p></li><li><p><strong>Next Header (8 bits)</strong>: 类似于IPv4中的Protocol字段，但Next Header字段更加通用，可以指示下一个扩展首部或上层协议。</p></li><li><p><strong>Hop Limit (8 bits)</strong>: 类似于IPv4中的Time to Live字段，但Hop Limit字段更名为跳限，表示数据报在网络中最多可以经过的路由器数量。</p></li><li><p><strong>Source Address (128 bits)</strong>: IPv6地址长度为128位，比IPv4的32位地址更长。</p></li><li><p><strong>Destination Address (128 bits)</strong>: 目标IPv6地址，同样长度为128位。</p></li></ul><p>IPv6的首部相比IPv4首部更加简洁和灵活，增加了一些新的字段以支持新的功能和特性。IPv6的地址长度增加为128位，提供了更大的地址空间，以应对互联网中设备数量的增长。同时，IPv6还引入了流标签等新特性，以提升数据传输的效率和安全性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-5</title>
    <link href="/2024/05/20/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-5/"/>
    <url>/2024/05/20/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-5/</url>
    
    <content type="html"><![CDATA[<h3 id="说一说你对SQL注入的理解"><a href="#说一说你对SQL注入的理解" class="headerlink" title="说一说你对SQL注入的理解"></a>说一说你对SQL注入的理解</h3><p>SQL注入是一种常见的网络安全攻击，通过利用应用程序对用户输入数据的处理不当，从而使攻击者可以执行未经授权的SQL查询。攻击者通过向应用程序发送恶意的SQL查询语句，然后利用应用程序对这些查询的处理方式，来实现对数据库的非法操作。</p><p>SQL注入攻击通常发生在存在动态SQL查询的应用程序中，例如Web应用程序。攻击者可以利用输入表单、URL参数或其他用户输入渠道注入恶意的SQL代码。一旦成功注入，攻击者可以执行各种恶意操作，包括但不限于：</p><ol><li>数据库信息泄露：通过SQL注入，攻击者可以获取数据库中的敏感信息，如用户凭据、个人数据等。</li><li>数据库修改：攻击者可以修改数据库中的数据，例如删除数据、插入虚假数据等。</li><li>拒绝服务攻击（Denial of Service，DoS）：通过执行耗费大量资源的查询，攻击者可以使数据库服务器过载，从而拒绝正常用户的服务。</li></ol><p>为了防止SQL注入攻击，开发人员应该使用参数化查询或预编译语句等安全的数据库访问方式，并严格验证和过滤所有用户输入数据。此外，还可以使用安全编码实践、漏洞扫描和Web应用程序防火墙等技术来增强应用程序的安全性。</p><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>浅拷贝<strong>只复制指向某个对象的指针，而不复制对象本身</strong>，新旧对象还是<strong>共享同一块内存</strong>。但深拷贝会<strong>另外创造一个一模一样的</strong>对象，新对象跟原对象<strong>不共享内存</strong>，修改新对象<strong>不会改到</strong>原对象。</p><h3 id="C-中的内存对齐"><a href="#C-中的内存对齐" class="headerlink" title="C++中的内存对齐"></a>C++中的内存对齐</h3><p>内存对齐是计算机系统中的一种优化技术，它指的是将数据存储在内存中的地址开始位置按照特定的规则对齐到某个边界上的过程。在大多数计算机体系结构中，内存对齐是默认的行为，即数据类型在内存中的存储位置通常是按照其大小和特定的对齐规则来确定的。</p><p><strong>内存对齐的原因</strong>：</p><ol><li><strong>提高访问效率</strong>：当数据按照规定的对齐方式存储在内存中时，CPU可以更快地访问内存，因为对齐的数据<strong>可以直接通过单个内存访问周期进行读取</strong>，而不需要多次读取。</li><li><strong>硬件要求</strong>：某些硬件体系结构要求数据按照特定的边界对齐，否则可能会导致硬件故障或性能下降。</li></ol><p><strong>内存对齐的规则</strong>：</p><ol><li><strong>字节对齐</strong>：基本数据类型的存储起始地址必须是其<strong>长度的整数倍</strong>。例如，一个4字节的整数应该从内存地址的4的倍数位置开始存储，一个8字节的双精度浮点数应该从内存地址的8的倍数位置开始存储。</li><li><strong>结构体对齐</strong>：结构体中的每个成员变量都要遵循字节对齐规则。结构体的起始地址必须是结构体中最大成员变量的大小的整数倍，并且结构体中的每个成员变量都要按照其大小进行对齐。</li><li><strong>数组对齐</strong>：数组的每个元素都要按照其数据类型的大小进行对齐。</li></ol><p>总之，内存对齐是一种提高计算机系统性能和兼容性的重要优化技术，它通过合理地安排数据在内存中的存储位置，减少了内存访问的时间和开销，提高了系统的整体性能。</p><h3 id="TCP协议的特点？"><a href="#TCP协议的特点？" class="headerlink" title="TCP协议的特点？"></a>TCP协议的特点？</h3><p>1.TCP是面向连接的<strong>传输层</strong>的协议<br>也就是说，应用程序在使用TCP协议之前，必须<strong>先建立</strong>TCP连接。数据传输完毕以后，必须<strong>释放</strong>已经建立的TCP的连接<br>2.每一条TCP连接必须是<strong>一对一</strong>的<br>3.TCP提供<strong>可靠交付</strong>的服务。通过TCP连接传输的数据，不丢失、不重复、无差错，并且按需到达。<br>4.TCP提供<strong>全双工</strong>通信。TCP允许通信双方的应用程序<strong>在任何时候都能发送数据</strong>。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据存入缓存，上层的应用程序在合适的时候读取缓存中的数据。<br>5.面向<strong>字节流</strong>。TCP中“流(Stream)”指的是<strong>流入到进程或从进程流出的字节序列</strong>。<br>面向字节流的含义是：虽然应用程序和TCP的交互式一次一个数据块(大小不等)，但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流</p><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><p>一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M &gt;&#x3D;0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）（如n&#x3D;6，m&#x3D;2，从123456变成561234）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 旋转数组</span><br><span class="hljs-comment">     * @param n int整型 数组长度</span><br><span class="hljs-comment">     * @param m int整型 右移距离</span><br><span class="hljs-comment">     * @param a int整型vector 给定数组</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || (m %= n) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">begin</span>() + n - m);<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>() + n - m, a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>模拟面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-4</title>
    <link href="/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-4/"/>
    <url>/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-4/</url>
    
    <content type="html"><![CDATA[<h2 id="常见的HTTP协议请求头有哪些？"><a href="#常见的HTTP协议请求头有哪些？" class="headerlink" title="常见的HTTP协议请求头有哪些？"></a>常见的HTTP协议请求头有哪些？</h2><p>（答三个差不多得了<br>host（目标主机和端口号）、指定可以处理、可以接受的balabala、cookie、if modified since…<br>HTTP协议请求头（HTTP request headers）是客户端发送给服务器的附加信息，用于描述请求的细节。以下是一些常见的HTTP请求头及其作用：</p><h3 id="通用头字段（General-Header-Fields）"><a href="#通用头字段（General-Header-Fields）" class="headerlink" title="通用头字段（General Header Fields）"></a>通用头字段（General Header Fields）</h3><ul><li><strong>Host</strong>：指定请求的目标主机和端口号。例如：<code>Host: www.example.com</code></li><li><strong>User-Agent</strong>：包含发出请求的客户端应用程序的信息。例如：<code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)</code></li><li><strong>Accept</strong>：指定客户端可处理的内容类型。例如：<code>Accept: text/html,application/xhtml+xml</code></li><li><strong>Accept-Language</strong>：指定客户端可接受的语言。例如：<code>Accept-Language: en-US,en;q=0.5</code></li><li><strong>Accept-Encoding</strong>：指定客户端可接受的内容编码（压缩方式）。例如：<code>Accept-Encoding: gzip, deflate, br</code></li><li><strong>Connection</strong>：控制连接的行为。常见值有<code>keep-alive</code>和<code>close</code>。例如：<code>Connection: keep-alive</code></li><li><strong>Referer</strong>：包含发出请求的页面的地址，用于告诉服务器该请求来自哪个页面。例如：<code>Referer: https://www.google.com/</code></li><li><strong>Cache-Control</strong>：用于指定请求和响应的缓存机制。例如：<code>Cache-Control: no-cache</code></li></ul><h3 id="请求方法特定头字段（Request-Method-Specific-Header-Fields）"><a href="#请求方法特定头字段（Request-Method-Specific-Header-Fields）" class="headerlink" title="请求方法特定头字段（Request Method Specific Header Fields）"></a>请求方法特定头字段（Request Method Specific Header Fields）</h3><ul><li><strong>Content-Type</strong>：指示请求体的媒体类型。例如：<code>Content-Type: application/json</code></li><li><strong>Content-Length</strong>：指示请求体的长度（以字节为单位）。例如：<code>Content-Length: 348</code></li><li><strong>Authorization</strong>：包含认证信息，用于验证客户端的身份。例如：<code>Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</code></li><li><strong>Cookie</strong>：包含存储在客户端的Cookie信息。用于在客户端和服务器之间传递状态信息。例如：<code>Cookie: sessionId=abc123</code></li><li><strong>If-Modified-Since</strong>：允许服务器返回自指定日期以来未修改的资源。例如：<code>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</code></li><li><strong>If-None-Match</strong>：允许服务器返回资源的ETag（实体标签），如果资源未修改，服务器会返回304（Not Modified）状态码。例如：<code>If-None-Match: &quot;xyzzy&quot;</code></li></ul><h3 id="特定场景的头字段"><a href="#特定场景的头字段" class="headerlink" title="特定场景的头字段"></a>特定场景的头字段</h3><ul><li><strong>Range</strong>：请求资源的部分内容。例如：<code>Range: bytes=500-999</code></li><li><strong>Expect</strong>：指示客户端期望服务器的行为，例如100-continue。例如：<code>Expect: 100-continue</code></li><li><strong>Upgrade</strong>：用于请求服务器升级到另一个协议。例如：<code>Upgrade: websocket</code></li><li>**TE (Transfer-Encoding)**：指定传输编码。例如：<code>TE: trailers, deflate</code></li></ul><h3 id="示例HTTP请求"><a href="#示例HTTP请求" class="headerlink" title="示例HTTP请求"></a>示例HTTP请求</h3><p>以下是一个带有多个请求头的HTTP GET请求示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64)<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US,en;q=0.5<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>https://www.google.com/<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123<br></code></pre></td></tr></table></figure><h2 id="常见的HTTP协议响应头有哪些？"><a href="#常见的HTTP协议响应头有哪些？" class="headerlink" title="常见的HTTP协议响应头有哪些？"></a>常见的HTTP协议响应头有哪些？</h2><ol><li><code>Content-Type</code>：指定响应的媒体类型（例如：text&#x2F;html、application&#x2F;json）。</li><li><code>Content-Length</code>：指定响应正文的长度（以字节为单位）。</li><li><code>Server</code>：指定服务器软件的名称和版本。</li><li><code>Date</code>：指定响应生成的日期和时间。</li><li><code>Last-Modified</code>：指定资源的最后修改日期和时间。</li><li><code>ETag</code>：指定资源的实体标识符，用于缓存验证。</li><li><code>Expires</code>：指定响应的过期日期和时间。</li><li><code>Cache-Control</code>：指定缓存机制的控制指令。</li><li><code>Location</code>：指定重定向的目标 URL。</li><li><code>Set-Cookie</code>：在客户端保存一个或多个 cookie。</li><li><code>Access-Control-Allow-Origin</code>：指定允许访问资源的域名。</li><li><code>Content-Encoding</code>：指定响应正文的编码方式（例如：gzip、deflate）。</li><li><code>Content-Disposition</code>：指定响应正文的处理方式（例如：inline、attachment）。</li></ol><h2 id="软链接和硬链接的区别"><a href="#软链接和硬链接的区别" class="headerlink" title="软链接和硬链接的区别"></a>软链接和硬链接的区别</h2><p><img src="/../img/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/%E7%A1%AC%E9%93%BE%E6%8E%A5%E8%BD%AF%E8%BF%9E%E6%8E%A5.png" alt="硬链接软连接"></p><h2 id="STL中常见容器的实现原理"><a href="#STL中常见容器的实现原理" class="headerlink" title="STL中常见容器的实现原理"></a>STL中常见容器的实现原理</h2><p>C++标准模板库（STL）提供了一系列强大的容器，用于存储和管理数据。这些容器各有不同的实现方式，适用于不同的应用场景。以下是STL中常见容器的实现原理：</p><h3 id="1-std-vector"><a href="#1-std-vector" class="headerlink" title="1. std::vector"></a>1. <code>std::vector</code></h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>动态数组</strong>：<code>std::vector</code> 底层使用<strong>动态数组</strong>实现，支持随机访问。</li><li><strong>内存管理</strong>：<ul><li><strong>容量和大小</strong>：<code>std::vector</code> 有两个重要属性：容量（capacity）和大小（size）。容量是分配的存储空间，大小是当前元素个数。</li><li><strong>动态扩展</strong>：当元素超过容量时，<code>std::vector</code> 会分配更大的内存块（通常是当前容量的两倍），并将现有元素复制到新内存中。</li></ul></li><li><strong>优势</strong>：<ul><li>支持快速的随机访问（O(1)）。</li><li>动态扩展，避免手动管理内存。</li></ul></li></ul><h3 id="2-std-list"><a href="#2-std-list" class="headerlink" title="2. std::list"></a>2. <code>std::list</code></h3><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>双向链表</strong>：<code>std::list</code> 底层实现为<strong>双向链表</strong>，每个节点包含指向前后节点的指针。</li><li><strong>内存管理</strong>：每个元素都分配独立的内存，因此插入和删除操作不会导致整体移动。</li><li><strong>优势</strong>：<ul><li>常数时间的插入和删除操作（在任意位置）。</li><li>遍历性能较好，但随机访问性能较差（O(n)）。</li></ul></li></ul><h3 id="3-std-deque"><a href="#3-std-deque" class="headerlink" title="3. std::deque"></a>3. <code>std::deque</code></h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>分段连续存储</strong>：<code>std::deque</code> 使用一系列固定大小的数组块（或称为“缓冲区”）来存储元素，每个数组块称为一个“缓冲区”。</li><li><strong>双端队列</strong>：支持在头尾两端高效插入和删除。</li><li><strong>内存管理</strong>：<strong>分段连续存储方式</strong>使其既可以高效进行头尾插入，又可以支持快速的随机访问。</li><li><strong>优势</strong>：<ul><li>双端高效操作。</li><li>适用于需要频繁头尾操作的场景。</li></ul></li></ul><h3 id="4-std-stack-和-std-queue"><a href="#4-std-stack-和-std-queue" class="headerlink" title="4. std::stack 和 std::queue"></a>4. <code>std::stack</code> 和 <code>std::queue</code></h3><h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>适配器容器</strong>：<code>std::stack</code> 和 <code>std::queue</code> 是基于其他容器（如 <code>std::deque</code> 或 <code>std::list</code>）的适配器。</li><li><strong>LIFO 和 FIFO</strong>：<ul><li><code>std::stack</code>：后进先出（LIFO），通常基于 <code>std::vector</code> 或 <code>std::deque</code>。</li><li><code>std::queue</code>：先进先出（FIFO），通常基于 <code>std::deque</code>。</li></ul></li><li><strong>优势</strong>：<ul><li>简化特定操作（如堆栈和队列操作）。</li></ul></li></ul><h3 id="5-std-set-和-std-map"><a href="#5-std-set-和-std-map" class="headerlink" title="5. std::set 和 std::map"></a>5. <code>std::set</code> 和 <code>std::map</code></h3><h4 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>平衡二叉树</strong>：通常实现为<strong>红黑树</strong>，每次插入、删除和查找操作都是 O(log n) 时间复杂度。</li><li><strong>键值存储</strong>：<ul><li><code>std::set</code>：只存储键，键唯一且有序。</li><li><code>std::map</code>：存储键值对，键唯一且有序。</li></ul></li><li><strong>内存管理</strong>：每个节点独立分配内存，节点间通过指针连接。</li><li><strong>优势</strong>：<ul><li>有序存储，快速查找、插入和删除。</li></ul></li></ul><h3 id="6-std-unordered-set-和-std-unordered-map"><a href="#6-std-unordered-set-和-std-unordered-map" class="headerlink" title="6. std::unordered_set 和 std::unordered_map"></a>6. <code>std::unordered_set</code> 和 <code>std::unordered_map</code></h3><h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>哈希表</strong>：底层使用<strong>哈希表</strong>实现，支持平均 O(1) 时间复杂度的查找、插入和删除。</li><li><strong>哈希函数和冲突解决</strong>：通过哈希函数计算键的位置，使用链地址法（链表）或开放地址法解决哈希冲突。</li><li><strong>键值存储</strong>：<ul><li><code>std::unordered_set</code>：只存储键，无序且键唯一。</li><li><code>std::unordered_map</code>：存储键值对，无序且键唯一。</li></ul></li><li><strong>内存管理</strong>：哈希表中的每个桶可能包含链表（链地址法）。</li><li><strong>优势</strong>：<ul><li>高效的查找、插入和删除，无需保持顺序。</li></ul></li></ul><h3 id="7-std-array"><a href="#7-std-array" class="headerlink" title="7. std::array"></a>7. <code>std::array</code></h3><h4 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>静态数组</strong>：<code>std::array</code> 是固定大小的数组，大小在编译时确定。</li><li><strong>内存管理</strong>：在栈上分配内存，支持随机访问。</li><li><strong>优势</strong>：<ul><li>简单高效，大小固定无需动态分配。</li><li>全部功能和普通C数组一致，但提供了STL容器接口。</li></ul></li></ul><p>这些容器的设计各有特点，适用于不同的使用场景。选择合适的容器可以大大提高程序的性能和可维护性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重排链表</title>
    <link href="/2024/05/19/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/05/19/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>很经典的一道题目<br>注意分解为一个一个函数，并且通过输出来debug（当然正式写的时候可能没时间debug了，所以还是要常写常新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> v,ListNode* n)&#123;<br>        value = v;<br>        next = n;<br>    &#125;<br>&#125;;<br><span class="hljs-function">ListNode* <span class="hljs-title">find_mid</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>    <span class="hljs-comment">// 这个的版本是：如果有两个都是中间，返回前面那个</span><br>    <span class="hljs-comment">// 如果要返回后面那个，得fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr</span><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span> (fast-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">reverse_list</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* nxt = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>            nxt = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_list</span><span class="hljs-params">(ListNode* head1,ListNode* head2)</span></span>&#123;<br>        ListNode* cur1 = head1;<br>        ListNode* cur2 = head2;<br>        ListNode* nxt1 = <span class="hljs-literal">nullptr</span>;<br>        ListNode* nxt2 = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur1!=<span class="hljs-literal">nullptr</span>&amp;&amp;cur2!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <br>            nxt1 = cur1-&gt;next;<br>            nxt2 = cur2-&gt;next;<br>            cur1-&gt;next = cur2;<br>            cur1 = nxt1;<br>            cur2-&gt;next = nxt1;<br>            cur2 = nxt2;<br>            <br>        &#125;<br>        <br><br>    &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;head-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        head=head-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">4</span>,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-comment">// head-&gt;next-&gt;next-&gt;next-&gt;next = new ListNode(5,nullptr);</span><br>    ListNode* mid = <span class="hljs-built_in">find_mid</span>(head);<br>    ListNode*new_head = <span class="hljs-built_in">reverse_list</span>(mid-&gt;next);<br>    mid-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 这一步很重要！！！！</span><br><br>    <span class="hljs-comment">// cout&lt;&lt;&quot;mid=&quot;&lt;&lt;mid-&gt;value&lt;&lt;endl;</span><br>    <br>    <span class="hljs-built_in">merge_list</span>(head,new_head);<br>    <span class="hljs-built_in">print_list</span>(head);<br>    <span class="hljs-comment">// print_list(new_head);</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-3</title>
    <link href="/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-3/"/>
    <url>/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-3/</url>
    
    <content type="html"><![CDATA[<h3 id="UDP（用户数据报协议）是什么？"><a href="#UDP（用户数据报协议）是什么？" class="headerlink" title="UDP（用户数据报协议）是什么？"></a>UDP（用户数据报协议）是什么？</h3><p>UDP是<strong>传输层协议</strong>，是面向用户数据报协议，不保证可靠交付，<strong>没用TCP的拥塞控制和三次握手的机制保证可靠传输（虽然我的项目里写了但是那个是可靠udp！udp本身没有拥塞控制），UDP尽最大努力交付</strong>。最少只有8个字节。UDP支持单播、组播、广播，UDP相对TCP更简单，传输的速率更快，所以通常可以<strong>用在实时性比较强的需求上</strong>，比如视频会议等。</p><h3 id="如何实现可靠udp"><a href="#如何实现可靠udp" class="headerlink" title="如何实现可靠udp"></a>如何实现可靠udp</h3><p>（这不就是我的项目吗！！！！）<br>实现可靠UDP（User Datagram Protocol）的方法通常涉及在应用层增加逻辑来处理数据包的丢失、重传、排序和确认。以下是一些实现可靠UDP的关键步骤：</p><ol><li><p><strong>数据包编号（Sequence Numbering）</strong>：</p><ul><li>在发送每个数据包时分配一个<strong>唯一的序列号</strong>。接收方可以使用这个序列号来检测丢失的数据包并按正确的顺序重组数据。</li></ul></li><li><p><strong>确认机制（Acknowledgment Mechanism）</strong>：</p><ul><li>接收方在收到数据包后<strong>发送确认包（ACK）</strong>回发送方，告知其数据包已成功接收。如果发送方在一定时间内未收到ACK，则认为该数据包丢失，需要重传。</li></ul></li><li><p><strong>重传机制（Retransmission Mechanism）</strong>：</p><ul><li>发送方在一定时间内未收到ACK时，<strong>重传</strong>未被确认的数据包。这个时间可以是固定的，也可以根据网络状况进行调整。</li></ul></li><li><p><strong>超时和重试次数（Timeout and Retry Count）</strong>：</p><ul><li>设置<strong>超时重传的时间间隔和重试的次数。如果超过重试次数仍未收到ACK，可以认为连接断开。</strong></li></ul></li><li><p><strong>滑动窗口（Sliding Window）</strong>：</p><ul><li>为了提高传输效率，可以实现<strong>滑动窗口协议，允许发送方在等待ACK的同时继续发送一定数量的数据包。</strong></li></ul></li><li><p><strong>流量控制和拥塞控制（Flow Control and Congestion Control）</strong>：</p><ul><li>实现流量控制机制以避免发送方过快发送数据导致接收方缓冲区溢出。拥塞控制机制可以帮助在网络拥堵时调整发送速率。</li></ul></li></ol><h3 id="HTTPS（安全超文本传输协议）是什么"><a href="#HTTPS（安全超文本传输协议）是什么" class="headerlink" title="HTTPS（安全超文本传输协议）是什么"></a>HTTPS（安全超文本传输协议）是什么</h3><p>标准回答</p><p>HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的HTTP通道，在HTTP的基础上通过<strong>身份认证和传输加密</strong>阶段保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入TLS（Transport Layer Security 安全传输层协议）&#x2F;SSL（Secure Sockets Layer 安全套接层协议），HTTPS 的安全基础是 TLS&#x2F;SSL，因此加密就需要TLS&#x2F; SSL。HTTPS的特点是：<strong>内容加密、身份验证、数据完整性</strong>。</p><p>加分回答</p><p>HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的HTTP通道，在HTTP的基础上通过身份认证和传输加密阶段保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入TLS（Transport Layer Security 安全传输层协议）&#x2F;SSL（Secure Sockets Layer 安全套接层协议），HTTPS 的安全基础是 TLS&#x2F;SSL，因此加密就需要TLS&#x2F; SSL。</p><p>SSL的全称为Secure Sockets Layer，安全套接层协议。是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL。</p><p>TLS的全称是Transport Layer Security，安全传输层协议。是SSL3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。</p><p>在HTTPS数据传输的过程中，需要用TLS&#x2F;SSL对数据进行加密，然后通过HTTP对加密后的密文进行传输，可以看出HTTPS的通信是由HTTP和TLS&#x2F;SSL配合完成的。</p><p>HTTPS的特点：</p><p>内容加密：<strong>混合加密方式，对称加密和非对称加密</strong>。<br>验证身份：通过<strong>证书认证</strong>客户端访问的是正确的服务器。<br>数据完整性：<strong>防止传输的数据被中间人篡改</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-2</title>
    <link href="/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-2/"/>
    <url>/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-2/</url>
    
    <content type="html"><![CDATA[<h3 id="C-中的四种类型转换"><a href="#C-中的四种类型转换" class="headerlink" title="C++ 中的四种类型转换"></a>C++ 中的四种类型转换</h3><p><a href="https://zhuanlan.zhihu.com/p/258975506">知乎链接</a><br>1、static_cast</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">static_cast</span>&lt;<span class="hljs-keyword">type</span>&gt;(expression)<br></code></pre></td></tr></table></figure><p>该运算符把 expression 转换为 type 类型，主要用于基本数据类型之间的转换，如把 uint 转换为 int，把 int 转换为 double 等。<br>需要注意的是：static_cast 会进行一些类型检查，但是没有运行时检查来保证转换的安全性，需要程序员来判断转换是否安全。</p><p>2、dynamic_cast</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">dynamic_cast</span>&lt;<span class="hljs-keyword">type</span>&gt;(expression)<br></code></pre></td></tr></table></figure><p>dynamic_cast 主要用于类层次间的上行转换或下行转换。在进行上行转换（派生类-&gt;基类）时，dynamic_cast 和 static_cast 的效果是一样的，但在下行转换（基类-&gt;派生类）时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。</p><p>3、const_cast</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">const_cast</span>&lt;<span class="hljs-keyword">type</span>&gt;(expression)<br></code></pre></td></tr></table></figure><p>用于去除 const 属性，去掉类型的 const 或者 volatile 属性，将 const 类型的指针变为非 const 类型的指针。</p><p>4、reinterpret_cast<br>reinterpret_cast <strong>不进行任何类型安全检查</strong>，直接将位模式解释为目标类型。这意味着它可以将任何指针类型转换为其他任何指针类型，而不考虑它们之间是否有合理的转换关系。</p><h3 id="HTTP-1-X-和-HTTP-2-X-的区别"><a href="#HTTP-1-X-和-HTTP-2-X-的区别" class="headerlink" title="HTTP 1.X 和 HTTP 2.X 的区别"></a>HTTP 1.X 和 HTTP 2.X 的区别</h3><p>（1）.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。</p><p><strong>二进制传送的单位是帧和流</strong>。帧组成了流，同时流还有<strong>流ID</strong>标示</p><p>（2）.HTTP2<strong>支持多路复用</strong></p><p>因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求</p><p>（3）.HTTP2<strong>头部压缩</strong></p><p>HTTP2通过gzip和compress<strong>压缩头部</strong>然后再发送，<strong>同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值</strong></p><p>（4）.HTTP2<strong>支持服务器推送</strong></p><p>HTTP2支持在未经客户端许可的情况下，主动向客户端推送内容</p><h3 id="介绍一下几种IO模型"><a href="#介绍一下几种IO模型" class="headerlink" title="介绍一下几种IO模型"></a>介绍一下几种IO模型</h3><p>阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO</p><h3 id="如何判断大端和小端"><a href="#如何判断大端和小端" class="headerlink" title="如何判断大端和小端"></a>如何判断大端和小端</h3><p><a href="https://blog.csdn.net/weixin_38184628/article/details/136305592">csdn链接</a><br>Big-Endian（大端字节序） 和Little-Endian。<br>a) Little-Endian 高位字节在前，低位字节在后。<br>b) Big-Endian 低位字节在前，高位字节在后。<br>c) 网络字节序：TCP&#x2F;IP各层协议将字节序定义为Big-Endian，因此TCP&#x2F;IP协议中使用的字节序通常称之为网络字节序。</p><p>假设有一个 int 类型的数据，值为 0x12345678，保存在地址 0x400 ~ 0x403 这 4 个字节的位置。</p><p>大端：</p><p>在大端 cpu 上，存储情况如下图所示，高位存储在低地址。0x12 是高位，存储在地址 0x400 上；0x78 是低位，存储才 0x403 上。</p><p>小端：</p><p>小端与大端相反，高位存储在高地址。0x12 是高位，存储在 0x403；0x78 是低位，存储在 0x400。</p>]]></content>
    
    
    
    <tags>
      
      <tag>模拟面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-1</title>
    <link href="/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-1/"/>
    <url>/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-1/</url>
    
    <content type="html"><![CDATA[<h3 id="C和C-中struct的区别"><a href="#C和C-中struct的区别" class="headerlink" title="C和C++中struct的区别"></a>C和C++中struct的区别</h3><p>1.C的结构体不允许有成员函数，<strong>C++允许，并且还可以是虚函数</strong>。</p><p>2.<strong>C的结构体没有权限这个说法，默认public</strong>；C++的结构体就<strong>和类一样，有权限，默认是public</strong>。</p><p>3.C的结构体可以继承,C++的结构体可以和其他结构体或类继承</p><p>4.<strong>C++的结构体可以初始化</strong>，而C不可以</p><p>5.C要加上<strong>struct关键字或者使用typedef取别名来使用</strong>，而C++直接使用结构体名字。</p><h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><p>1.struct一般用于描述数据的集合，class是<strong>对一个对象数据的封装</strong></p><p>2.struct<strong>默认权限</strong>是public，class默认权限是private</p><p>3.<strong>继承方式，struct默认公有继承，而class默认是私有继承</strong></p><p>4.class关键字可以用来<strong>定义模板</strong>，struct不可以。</p><h3 id="简述一下linux中的零拷贝"><a href="#简述一下linux中的零拷贝" class="headerlink" title="简述一下linux中的零拷贝"></a>简述一下linux中的零拷贝</h3><p><a href="https://blog.csdn.net/YL3126/article/details/117468640">csdn链接</a><br>传统 IO 执行的话需要 <strong>4 次上下文切换（用户态 -&gt; 内核态 -&gt; 用户态 -&gt; 内核态 -&gt; 用户态）和 4 次拷贝（磁盘文件 DMA 拷贝到内核缓冲区，内核缓冲区 CPU 拷贝到用户缓冲区，用户缓冲区 CPU 拷贝到 Socket 缓冲区，Socket 缓冲区 DMA 拷贝到协议引擎）</strong>。</p><p>mmap 将磁盘文件映射到内存，支持读和写，对内存的操作会反映在磁盘文件上，适合小数据量读写，需要 4 次上下文切换（用户态 -&gt; 内核态 -&gt; 用户态 -&gt; 内核态 -&gt; 用户态）和<strong>3 次拷贝</strong>（磁盘文件DMA拷贝到内核缓冲区，内核缓冲区 CPU 拷贝到 Socket 缓冲区，Socket 缓冲区 DMA 拷贝到协议引擎）<strong>（少了内核缓冲区拷贝到用户缓冲区，直接拷贝到socket缓冲区</strong>。</p><p>sendfile 是将读到内核空间的数据，转到 socket buffer，进行网络发送，适合大文件传输，只需要 2 次上下文切换（用户态 -&gt; 内核态 -&gt; 用户态）和 2 次拷贝（磁盘文件 DMA 拷贝到内核缓冲区，内核缓冲区 DMA 拷贝到协议引擎）（kafka就用了sendfile）。</p><p>什么是零拷贝</p><p>零拷贝（Zero-Copy）就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术，是指<strong>将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手</strong>。</p><p>零拷贝的好处</p><p>内核与内核：避免操作系统<strong>内核缓冲区之间</strong>进行数据拷贝操作<br>内核与用户：避免<strong>操作系统内核和用户应用程序地址空间</strong>这两者之间进行数据拷贝操作<br>硬件与OS：用户应用程序可以<strong>避开操作系统直接访问硬件存储</strong><br><strong>避免不必要的系统调用和上下文切换</strong><br>数据传输尽量让 DMA 来做，需要拷贝的数据可以先被缓存起来，对数据进行处理尽量让硬件来做<br>Linux中零拷贝实现</p><p>Linux 中零拷贝技术实现方式通常有 2 种：</p><p><strong>mmap() + write()</strong><br><strong>sendfile()</strong><br>零拷贝的实现原理</p><h4 id="mmap-write-："><a href="#mmap-write-：" class="headerlink" title="mmap() + write()："></a>mmap() + write()：</h4><p><strong>mmap 相比于传统的 IO 来说，其实就是少了 1 次 CPU 拷贝而已</strong></p><p>mmap() 系统调用函数会<strong>直接把内核缓冲区里的数据映射到用户空间</strong>，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。具体过程：</p><p>应用进程调用了 mmap() 后，<strong>DMA</strong> 会把磁盘的数据拷贝到内核的缓冲区里，接着应用进程跟操作系统内核共享这个缓冲区<br>应用进程再调用 write()，操作系统<strong>直接将内核缓冲区的数据拷贝到 socket 缓冲区中</strong>，这一切都发生在内核态，由 <strong>CPU</strong> 来搬运数据<br>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 <strong>DMA</strong> 搬运的</p><p>传统 IO 里面从内核缓冲区到用户缓冲区有一次 CPU 拷贝，从用户缓冲区到 Socket 缓冲区又有一次 CPU 拷贝。mmap 则一步到位，<strong>直接基于 CPU 将内核缓冲区的数据拷贝到了 Socket 缓冲区</strong>。</p><p>之所以能够减少一次拷贝，就是因为 mmap 直接将磁盘文件数据映射到内核缓冲区，这个映射的过程是基于 DMA 拷贝的，同时用户缓冲区是跟内核缓冲区共享一块映射数据的，建立共享映射之后，就不需要从内核缓冲区拷贝到用户缓冲区了。</p><p>虽然减少了一次拷贝，但是上下文切换的次数还是没变。</p><p>sendfile()：</p><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用 sendfile()。具体过程：<br>可以看到在图中，已经没有了用户缓冲区，因为用户缓冲区是在用户空间的，所以没有了用户缓冲区也就意味着不需要上下文切换了，就省略了这一步的从内核态切换为用户态。</p><p>同时也不需要基于 CPU 将内核缓冲区的数据拷贝到 Socket 缓冲区了，只需要从内核缓冲区拷贝一些 offset 和 length 到 Socket 缓冲区。</p><p>接着从内核态切换到用户态，从内核缓冲区直接把数据拷贝到网络协议引擎里去；同时从 Socket 缓冲区里拷贝一些 offset 和 length 到网络协议引擎里去，但是这个 offset 和 length 的量很少，几乎可以忽略。</p><p>sendFile 整个过程只有两次上下文切换和两次 DMA 拷贝，很重要的一点是这里完全不需要 CPU 来进行拷贝了，所以才叫做零拷贝，这里的拷贝指的就是操作系统的层面。</p><h3 id="MySQL的ACID特性分别是怎么实现的？"><a href="#MySQL的ACID特性分别是怎么实现的？" class="headerlink" title="MySQL的ACID特性分别是怎么实现的？"></a>MySQL的ACID特性分别是怎么实现的？</h3><p>标准回答</p><p>以InnoDB引擎为例，事务的四个特性主要由<strong>锁和日志</strong>来实现，锁用来保证事务的隔离性，undo log用来保证事务的一致性（一致性是指<strong>数据满足所有数据库的条件，比如字段约束，外键约束，触发器</strong>等。 数据库事务需要满足一致性，就是值一个事务从一致性开始，必须一致性结束），redo log用来保证事务的持久性（数据持久性是指在计算机系统中，<strong>将数据保存在磁盘等非易失性存储介质中，以确保在系统崩溃或断电等异常情况下，数据不会丢失或损坏，</strong>能够在系统恢复后仍然可以正常使用）。</p><p>加分回答</p><p>InnoDB引擎通过Record Lock、Gap Lock、Next-Key Lock三种算法，实现了<strong>四种隔离级别</strong>：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ（默认）、SERIALIZABLE，并且在REPEATABLE READ级别就解决了脏读、不可重复读、幻读等问题。</p><p>redo log用来实现事务的持久性，即事务ACID中的D。其由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），其是持久的。InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到redo log文件进行持久化，待事务的COMMIT操作完成才算完成。</p><p>事务有时还需要进行回滚操作，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。</p><h3 id="UDP协议的首部结构"><a href="#UDP协议的首部结构" class="headerlink" title="UDP协议的首部结构"></a>UDP协议的首部结构</h3><p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节<br>1.源端口号： 可有可无，需要对方回信时选用，不需要时全部置0。<br>2.目的端口号：必须有，在终点交付报文的时候需要用到。<br>3.长度：UDP的数据报的长度（包括首部和数据）其最小值为8字节（只有首部）。<br>4.校验和：检测UDP数据报在传输中是否有错，有错则丢弃。</p>]]></content>
    
    
    
    <tags>
      
      <tag>模拟面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转变</title>
    <link href="/2024/05/18/%E8%BD%AC%E5%8F%98/"/>
    <url>/2024/05/18/%E8%BD%AC%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<p>这个博客的初衷是撒糖哈哈，不过最近变成技术博客了orz</p><p>Q: 和天天在一起带来最大的改变是什么？</p><p>大概是我切身地体会到：</p><p>我不需要再像以前那样通过自我贬低的愤怒来获得前进的动力</p><p>原来生命的动力来源也可以是积极的，原来我可以笑着向前走</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>放个shoppee笔试合集吧方便复习</title>
    <link href="/2024/05/18/%E6%94%BE%E4%B8%AAshoppee%E7%AC%94%E8%AF%95%E5%90%88%E9%9B%86%E5%90%A7%E6%96%B9%E4%BE%BF%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/05/18/%E6%94%BE%E4%B8%AAshoppee%E7%AC%94%E8%AF%95%E5%90%88%E9%9B%86%E5%90%A7%E6%96%B9%E4%BE%BF%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>每次笔试前（这次有笔试吗？zjt说没有）编译器就必定会出幺蛾子，幸好他推荐给我一个网站：<a href="https://vscch.guyutongxue.site/">https://vscch.guyutongxue.site/</a><br>（感谢谷雨同学！！！救大命了）<br>下载一个这个编译器就可以运行</p><p>请注意！！！一定要按F6，不要去戳那个右上角的运行按钮！！！（终于能跑通了呜呜呜，而且不用加system(“pause”)，太牛了，，，</p><p>5.18二更：真的有笔试啊，，幸好事先调好了</p><h3 id="一、最大整数"><a href="#一、最大整数" class="headerlink" title="一、最大整数"></a>一、最大整数</h3><p>给定一个int数组nums，排列每个数的顺序（每个数不可拆分，比如12不能拆成1和2），使之组成一个最大的整数。<br>注意：输出结果可能非常大，所以返回一个字符串而不是整数。<br>输入样例：[10,2]<br>输出样例：“210”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string a,string b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b &gt; b+a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>    vector&lt;string&gt;strnum;<br>    <span class="hljs-comment">// int cur = 0;</span><br>    string temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>|| s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            <span class="hljs-comment">// 非数字字符，忽略</span><br>            strnum.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-comment">// cur = cur + 1;</span><br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp=temp+s[i];<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-type">int</span> size = strnum.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// for (int i=0;i&lt;size;i++)&#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;strnum[i]&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-built_in">sort</span>(strnum.<span class="hljs-built_in">begin</span>(),strnum.<span class="hljs-built_in">end</span>(),cmp);<br>    string result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        result = result + strnum[i];<br><br>    &#125;<br>    cout&lt;&lt;result;<br>    <span class="hljs-comment">// system(&quot;pause&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、LOL买英雄"><a href="#二、LOL买英雄" class="headerlink" title="二、LOL买英雄"></a>二、LOL买英雄</h3><p>用金币购买英雄联盟英雄的最大个数，要求给出具体方案。<br>输入描述：给出每个英雄联盟的价格和持有的金币数。<br>输入样例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[2,1,3,4,5]</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[2,1,3,4]</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">bool</span> flag[<span class="hljs-number">10000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hero</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> price;<br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-built_in">hero</span>(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> i)&#123;<br>        price = p;<br>        index = i;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(hero a,hero b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.price!=b.price) <span class="hljs-keyword">return</span> a.price&lt;b.price;<br>    <span class="hljs-keyword">return</span> a.index&lt;b.index;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    <span class="hljs-type">int</span> coin;<br>    cin&gt;&gt;s&gt;&gt;coin;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>    <br>    vector&lt;hero&gt;heroes;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]&gt;<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            temp = temp*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            heroes.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">hero</span>(temp,index));<br>            temp = <span class="hljs-number">0</span>;<br>            index = index+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;hero&gt;<span class="hljs-built_in">ori_heroes</span>(heroes);<br>    <span class="hljs-built_in">sort</span>(heroes.<span class="hljs-built_in">begin</span>(),heroes.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cur_i = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (cur+heroes[cur_i].price&lt;=coin)&#123;<br>        cur = cur +heroes[cur_i].price;<br>        flag[heroes[cur_i].index]=<span class="hljs-number">1</span>;<br>        cur_i=cur_i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// [0,cur_i-1]都是买过了的</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;[&quot;</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;index;i++)&#123;<br>        <span class="hljs-keyword">if</span> (flag[i]&amp;&amp;count&lt;cur_i<span class="hljs-number">-1</span>)&#123;<br>            cout&lt;&lt;ori_heroes[i].price&lt;&lt;<span class="hljs-string">&#x27;,&#x27;</span>;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag[i]&amp;&amp;count==cur_i<span class="hljs-number">-1</span>)&#123;<br>            cout&lt;&lt;ori_heroes[i].price&lt;&lt;<span class="hljs-string">&#x27;]&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、反转语句"><a href="#三、反转语句" class="headerlink" title="三、反转语句"></a>三、反转语句</h3><p>将指定字符串中每个单词的字符顺序反转，需要保留空格和单词的初始顺序不变。<br>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。<br>输入样例：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;hello world, my friends&quot;</span><br></code></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;olleh ,dlrow ym sdneirf&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    string result;<br>    <span class="hljs-built_in">getline</span>(cin,s);<br>    <span class="hljs-comment">// 注意读入一整行的写法</span><br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    string temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            result = result + temp + s[i];<br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp = s[i]+temp;<br>        &#125;<br>    &#125;<br>    result = <span class="hljs-string">&#x27;&quot;&#x27;</span>+result + temp + <span class="hljs-string">&#x27;&quot;&#x27;</span>;<br>    cout&lt;&lt;result;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、0到n中包含2的数字个数"><a href="#四、0到n中包含2的数字个数" class="headerlink" title="四、0到n中包含2的数字个数"></a>四、0到n中包含2的数字个数</h3><p>给定一个正整数n，其取值范围为(0,999999],计算出[0,n]之间包含2的数字出现的次数。<br>样例输入：20<br>样例输出：3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_2_num</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (n%<span class="hljs-number">10</span>==<span class="hljs-number">2</span>)&#123;<br>            count++;<br>        &#125;<br>        n=n/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        sum += <span class="hljs-built_in">count_2_num</span>(i);<br>    &#125;<br>    cout&lt;&lt;sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化了一下，感觉重复计算太多了，采用数组进行记忆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> count[<span class="hljs-number">1000000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">count_2_num</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (n%<span class="hljs-number">10</span>==<span class="hljs-number">2</span>)&#123;<br>        count[n]=count[n/<span class="hljs-number">10</span>]+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        count[n]=count[n/<span class="hljs-number">10</span>];<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">count_2_num</span>(i);<br>        sum += count[i];<br>    &#125;<br>    cout&lt;&lt;sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二战xhs笔试</title>
    <link href="/2024/05/14/%E4%BA%8C%E6%88%98xhs%E7%AC%94%E8%AF%95/"/>
    <url>/2024/05/14/%E4%BA%8C%E6%88%98xhs%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>后续：三道编程题，第一道是签到题（和上次考的第一道一模一样，就是给一堆浏览记录，然后去重，根据第一次浏览的顺序打印，100%AK</p><p>第二道是新书推广计划（漏看的条件和上次考的时候一模一样，，也是最后15分钟突然发现，<br>【最好笑的是除了第一个样例以外其他的都过了，幸好克服了心态问题，试着提交了，91%，下次记得多留存档】<br>【甚至下面写的代码样例也是审题审错了的版本</p><p>第三道是遗失的记忆（回溯，没复习到，考前仓促看了一点思路，现写的，正确率15%以下</p><h3 id="1-博主送礼物"><a href="#1-博主送礼物" class="headerlink" title="1. 博主送礼物"></a>1. 博主送礼物</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E5%8D%9A%E4%B8%BB%E9%80%81%E7%A4%BC%E7%89%A9.png" alt="博主送礼物"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 定义一个类，比结构体好用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fan</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-comment">// sum=like+star*2</span><br>    <span class="hljs-type">int</span> like;<br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-comment">// 定义一个fan的构造函数</span><br>    <span class="hljs-built_in">fan</span>(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> i)&#123;<br>        sum = s;<br>        like = l;<br>        index = i;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(fan a, fan b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.sum != b.sum)&#123;<br>        <span class="hljs-keyword">return</span> a.sum&gt;b.sum;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a.like != b.like)&#123;<br>        <span class="hljs-keyword">return</span> a.like&gt;b.like;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.index&lt;b.index;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    <span class="hljs-type">int</span> like,star,sum;<br>    <span class="hljs-comment">// n=4;</span><br>    <span class="hljs-comment">// k=2;</span><br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-comment">// vector&lt;fan&gt;fans(n);</span><br>    <span class="hljs-comment">// 采用这一条会报错是因为没有对于空值的构造函数，所以慢慢push_back就好</span><br>    vector&lt;fan&gt;fans;<br>    vector&lt;<span class="hljs-type">int</span>&gt;num;<br><br>    <span class="hljs-comment">// fans[1]=fan(1+2*2,1,1);</span><br>    <span class="hljs-comment">// fans[2]=fan(2+1*2,2,2);</span><br>    <span class="hljs-comment">// fans[3]=fan(3,3,3);</span><br>    <span class="hljs-comment">// fans[4]=fan(1+2*3,1,4);</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;like&gt;&gt;star;<br>        sum = like+star*<span class="hljs-number">2</span>;<br>        fans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">fan</span>(sum,like,i+<span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(fans.<span class="hljs-built_in">begin</span>(),fans.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-comment">// 记得sort的时候要写begin end</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-comment">// 最后编号也要按升序输出，所以要再处理一下</span><br>        <span class="hljs-comment">// cout&lt;&lt;fans[i].index&lt;&lt;endl;</span><br>        num.<span class="hljs-built_in">push_back</span>(fans[i].index);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(),num.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        cout&lt;&lt;num[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-H小姐的新书推广计划"><a href="#2-H小姐的新书推广计划" class="headerlink" title="2. H小姐的新书推广计划"></a>2. H小姐的新书推广计划</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E6%96%B0%E4%B9%A6%E6%8E%A8%E5%B9%BF%E8%AE%A1%E5%88%92.png" alt="新书推广计划"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">a</span>(n);<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">t</span>(n);<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(x+<span class="hljs-number">1</span>,INT_MAX);<br>    <span class="hljs-comment">// vector数组在定义的时候就可以初始化</span><br>    <br>    <span class="hljs-comment">// 调试数据</span><br>    <span class="hljs-comment">// n=5;</span><br>    <span class="hljs-comment">// x=8;</span><br>    <span class="hljs-comment">// vector&lt;int&gt;a=&#123;1,2,3,4,10&#125;;</span><br>    <span class="hljs-comment">// vector&lt;int&gt;t=&#123;0,1,1,2,5&#125;;</span><br>    <br>    <br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 达到0粉丝数成本为0</span><br>    <span class="hljs-comment">// 不需要赋值dp[a[i]],dp[t[i]]，让他们全都回归初心就行 </span><br>    <span class="hljs-comment">// 我们不需要给a[i]、t[i]排序，只需要减一下就行，而且只减一遍！！！</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">// 逆序遍历即可，记得加前置条件，否则会计算溢出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y=x;y&gt;=t[i];y--)&#123;<br>            <span class="hljs-keyword">if</span> (dp[y - t[i]] != INT_MAX) dp[y]=<span class="hljs-built_in">min</span>(dp[y],dp[y-t[i]]+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y=x;y&gt;=a[i];y--)&#123;<br>            <span class="hljs-comment">// 记得循环遍历的边界条件要等于a[i]，，太好笑了</span><br>             <span class="hljs-keyword">if</span> (dp[y - a[i]] != INT_MAX) dp[y]=<span class="hljs-built_in">min</span>(dp[y],dp[y-a[i]]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>    &#125;<br>    cout&lt;&lt;dp[x]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-H小姐的旅行笔记"><a href="#3-H小姐的旅行笔记" class="headerlink" title="3. H小姐的旅行笔记"></a>3. H小姐的旅行笔记</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E6%97%85%E8%A1%8C%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%89.png" alt="旅行笔记精选"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-comment">// 记得priorityqueue头文件</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">article</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 记得写public</span><br>    <span class="hljs-type">int</span> like;<br>    <span class="hljs-type">int</span> comment;<br>    <span class="hljs-built_in">article</span>(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> c)&#123;<br>        like=l;<br>        comment=c;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(article a,article b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.comment&gt;b.comment;<br>    <span class="hljs-comment">// 记得降序</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">likes</span>(n);<br>    <span class="hljs-type">int</span> comment;<br>    vector&lt;article&gt;articles;<br>    <span class="hljs-comment">// 记得不要直接声明大小，没有空值的构造函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;likes[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;comment;<br>        articles.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">article</span>(likes[i],comment));<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(articles.<span class="hljs-built_in">begin</span>(),articles.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-comment">// 记得格式</span><br>    priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt;pq;<br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> best = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>()&lt;k)&#123;<br>            pq.<span class="hljs-built_in">push</span>(articles[i].like);<br>            total+=articles[i].like;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">top</span>()&lt;articles[i].like)&#123;<br>            total+=articles[i].like-pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(articles[i].like);<br>            best = <span class="hljs-built_in">max</span>(best,total*articles[i].comment);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;best&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-点赞数之和最小"><a href="#4-点赞数之和最小" class="headerlink" title="4. 点赞数之和最小"></a>4. 点赞数之和最小</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E7%82%B9%E8%B5%9E%E6%95%B0%E4%B9%8B%E5%92%8C.png" alt="点赞数之和"><br>来不及写了，看一下二分思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> total_likes = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max_likes = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">likes</span><span class="hljs-params">(n)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; likes[i];<br>        total_likes += likes[i];<br>        max_likes = <span class="hljs-built_in">max</span>(max_likes, likes[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> like : likes) &#123;<br>            <span class="hljs-keyword">if</span> (like != max_likes)<br>                cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; like &lt;&lt; endl;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (likes[i] == max_likes)<br>                <span class="hljs-comment">// 有一篇和他一样也行，也算最大</span><br>                cout &lt;&lt; total_likes &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> L = max_likes;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> R = <span class="hljs-number">1e12</span>;<br>                <span class="hljs-comment">// mid值是该博客最后要达到的点赞值</span><br>                <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = (L + R) / <span class="hljs-number">2</span>;<br>                    <span class="hljs-comment">// 这个条件是说 博客还需要点赞的次数是点赞其他博客总次数+1</span><br>                    <span class="hljs-comment">// 而点赞其他博客的总次数肯定小于等于（记得这里有等于）把每篇都点到mid（最大值）的次数</span><br>                    <span class="hljs-keyword">if</span> (mid - likes[i] &lt;= mid * (n - <span class="hljs-number">1</span>) - (total_likes - likes[i]) + <span class="hljs-number">1</span>)<br>                        R = mid;<br>                    <span class="hljs-keyword">else</span><br>                        L = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>                cout &lt;&lt; total_likes + (L - likes[i]) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>xhs笔试复盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苯人第一次面试-字节复盘</title>
    <link href="/2024/05/13/%E8%8B%AF%E4%BA%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E5%A4%8D%E7%9B%98/"/>
    <url>/2024/05/13/%E8%8B%AF%E4%BA%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p>结果出了！10：20醒，10：08收到了感谢信，流程推进的很快，总比吊着好！</p><p>字节面试凉（凉？凉！）经一面，不知道到底是凉了还是过了呢？先做个总结吧，实在不行去美团接开水（当当）！当做锻炼机会也不是不可</p><p>面试评价：体验很好，题目挺简单的，面试官人很好一直在捞</p><p><strong>个人总结：</strong><br>基础知识有点不扎实，有点不自信（）毕竟是第一次面试也是情有可原，下次要自信！</p><p><strong>zjt评价：</strong><br>术语太少了感觉像唠嗑，，下次要多记术语，多输出，不要尬笑 底气不足</p><p><strong>面试官评价：</strong><br>在分析问题上面挺好的，但是有几个点我觉得还是需要后面去重点的去回忆一下（回忆？补强！）。</p><ol><li>就是针对于基础知识的一些掌握，因为学校里面有一些基础课程其实是很有意义很有价值的。很多原理性的东西几乎都是源于这个基础知识的演变跟演化，所以把基础的知识了解一下。（您说的对我之前太混了啊啊啊</li><li>可以额外的去了解一下，因为我们是后端开发的一个工作，可以了解一下后端开发的一些工程上的知识，比如说我刚刚给你提到的是<strong>软件工程</strong>相关的一些知识，可以系统的去了解一下，你们有这个课程我知道，所以也可以就直接去看一下他的一些教材或者教案相关的东西了解一下。</li><li>代码这一块，我看你写代码还算比较流利，然后思考问题的话也还算ok，但是有一个点就是你再去编码的时候，<strong>要注意对一些关键环节上面的一些信息的输出，就是通过日志或者通过一些关键环节去整理出来就行了，</strong>主要是这三块（这一点帮助了我xhs的第二次笔试，虽然不知道过了没</li><li>不用太紧张（面试经验不足导致的，多锤几次就好了</li></ol><h1 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h1><p>（唠嗑）</p><h1 id="2-项目经历"><a href="#2-项目经历" class="headerlink" title="2.项目经历"></a>2.项目经历</h1><p>（讲了myftp的项目，面试官尽力在救【试图往udp上引，奈何苯人没有面试经验，救不回来】）<br>（myftp的项目也说得太简单了，要说的详细一点）<br>（下次顺带着把udp的项目也讲了！！！）<br>（malloc说成memset了，我的锅）</p><h1 id="3-项目拓展"><a href="#3-项目拓展" class="headerlink" title="3.项目拓展"></a>3.项目拓展</h1><p>（以后反正也会问到，觉得这一部分特别重要</p><h2 id="Q1-具体是怎么去做的文件的切分？"><a href="#Q1-具体是怎么去做的文件的切分？" class="headerlink" title="Q1:具体是怎么去做的文件的切分？"></a>Q1:具体是怎么去做的文件的切分？</h2><p>凉经案例：只说了把大文件分割成固定大小的块进行传输，而且把字节说成了比特。</p><p><strong>问了gpt：</strong><br>我采用的策略是将一个大文件分割成固定大小的块进行传输，比如1024字节。</p><p>还可以根据网络带宽和延迟动态调整文件块的大小。在这种策略中，服务器端根据当前网络条件动态地调整文件块的大小，以提高传输效率。例如，如果网络带宽较大，可以增大文件块的大小以减少传输次数；如果网络延迟较高，可以减小文件块的大小以降低传输延迟。</p><p>除了以上两种策略，还可以根据具体应用场景和需求设计其他的文件切分策略，例如按照文件类型、内容等进行切分。</p><h2 id="Q2-这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战"><a href="#Q2-这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战" class="headerlink" title="Q2:这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战"></a>Q2:这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战</h2><p>凉经案例：只说了连接管理和文件切分</p><p><strong>问了gpt：</strong></p><ol><li>连接管理：需要处理客户端和服务器端的连接管理，包括建立连接、维护连接状态、处理连接断开等情况。</li><li>文件切分和传输：需要实现文件切分和传输功能，包括将大文件切分成多个小块、传输文件块、重组文件块等操作。</li><li><strong>并发处理</strong>：需要处理多个客户端同时连接的情况，保证并发访问的正确性和性能。</li><li><strong>错误处理和恢复</strong>：需要处理各种错误情况，包括网络异常、文件传输中断、客户端或服务器崩溃等，保证系统的稳定性和可靠性。</li><li><strong>安全性</strong>：需要考虑数据传输的安全性，包括加密传输、身份认证、访问控制等机制。</li></ol><h1 id="4-八股"><a href="#4-八股" class="headerlink" title="4.八股"></a>4.八股</h1><p>面试官可能比较无语（嘿嘿）所以问了一些八股，但是答得也不咋地</p><h2 id="TCP和udp的区别？"><a href="#TCP和udp的区别？" class="headerlink" title="TCP和udp的区别？"></a>TCP和udp的区别？</h2><p>把没有提到的标粗了（我草怎么这么多标粗，感情一共六条就讲了两条</p><ul><li>tcp是面向连接的可靠传输服务；udp不需要建立连接，尽力而为，不保证可靠传输。</li><li><strong>tcp是点对点连接，udp则是支持一对多、多对一、多对多</strong></li><li><strong>udp对系统资源要求较少，而且首部较短节省开销；tcp比较庞大，开销比较大</strong></li><li>tcp是流式传输，没有边界，但是顺序可靠；udp是一个包一个包传输，可能有丢包和乱序</li><li><strong>tcp在传输层进行分片，udp在ip层进行分片</strong></li><li><strong>tcp用于FTP、HTTP等；udp用于dns、smtp、音视频等多媒体</strong><br>（顺带一提 面试官想从这里引到udp来着，太紧张硬生生被我憋回去了，卒</li></ul><h2 id="文件存储的具体的格式？"><a href="#文件存储的具体的格式？" class="headerlink" title="文件存储的具体的格式？"></a>文件存储的具体的格式？</h2><p>（完全不知道是什么东西orz）</p><p>文件通常以二进制形式存储在文件系统中。具体来说，文件的存储格式通常分为两部分，由文件内容和元数据组成：</p><ol><li><p><strong>文件内容</strong>：文件内容以二进制形式存储在文件系统中。对于文本文件，内容可以直接以字符流的形式存储；对于二进制文件，内容则是原始的二进制数据。</p></li><li><p><strong>文件元数据</strong>：文件元数据包括文件的名称、大小、权限、创建时间、修改时间等信息。这些元数据通常会以特定的格式存储在文件系统中，以便文件系统能够快速地识别和管理文件。</p></li></ol><h2 id="问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的"><a href="#问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的" class="headerlink" title="问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的"></a>问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的</h2><p>128M</p><h2 id="进程跟线程的区别？"><a href="#进程跟线程的区别？" class="headerlink" title="进程跟线程的区别？"></a>进程跟线程的区别？</h2><p>凉经案例：只讲了第一点资源分配</p><p><strong>问了gpt：</strong><br>进程（Process）和线程（Thread）是操作系统中两个重要的概念，它们之间有以下几点区别：</p><p>第一点，他们在xxxx方面存在区别，进程……，线程……</p><ol><li><p>资源分配：</p><ul><li>进程是<strong>程序的执行实例</strong>，是<strong>系统中的一个独立单位</strong>，拥有独立的<strong>内存空间、文件描述符、堆栈</strong>等资源。</li><li>线程是<strong>进程的执行单元</strong>，是 <strong>CPU 调度的基本单位</strong>，同一进程内的线程共享进程的内存空间和其他资源。</li></ul></li><li><p><strong>调度和切换</strong>：</p><ul><li>进程之间的切换开销比较大，因为需要<strong>保存和恢复整个进程的上下文信息</strong>。</li><li>线程之间的切换开销相对较小，因为<strong>线程共享进程的地址空间</strong>，只需要保存和恢复线程的上下文信息。</li></ul></li><li><p><strong>通信机制</strong>：</p><ul><li>进程之间通信需要使用<strong>IPC（Inter-Process Communication）机制</strong>，例如管道、消息队列、信号量等。</li><li>线程之间通信可以直接<strong>共享进程的地址空间，通过共享变量进行通信</strong>。</li></ul></li><li><p><strong>创建和销毁</strong>：</p><ul><li>进程的创建和销毁开销比较大，因为需要<strong>分配和释放独立的内存空间</strong>。</li><li>线程的创建和销毁开销相对较小，因为线程共享进程的资源，只需要分配和释放<strong>线程的控制块</strong>。</li></ul></li><li><p><strong>并发性</strong>：</p><ul><li>进程之间的并发性较低，因为进程间<strong>切换开销大</strong>。</li><li>线程之间的<strong>并发性较高</strong>，因为线程间切换开销小，<strong>可以更快地响应用户的请求</strong>。</li></ul></li></ol><h2 id="进程间通信方式（IPC）"><a href="#进程间通信方式（IPC）" class="headerlink" title="进程间通信方式（IPC）"></a>进程间通信方式（IPC）</h2><p>凉经：只答了管道、pv信号量（答的时候忘记是信号量了，只记得pv操作）、把共享内存说成了共享变量（共享变量是线程的orz</p><p>IPC的实质：<br>进程与进程之间是相互独立的，各自运行在自己的虚拟内存中。要想在进程与进程间建立联系，需要通过内核，<strong>在内核中开辟一块缓冲区</strong>，两个进程的信息在缓冲区中进行交换或者传递。</p><p>进程间通信（IPC）的不同方式各有其优缺点，适用于不同的应用场景。下面是常见的几种IPC方式及其优缺点：</p><h3 id="1-管道（Pipes）"><a href="#1-管道（Pipes）" class="headerlink" title="1. 管道（Pipes）"></a>1. 管道（Pipes）</h3><p><a href="https://blog.csdn.net/studyhardi/article/details/89852839">csdn详细链接：管道通信实验</a></p><p>管道又分为匿名管道和命名管道。其中，匿名管道只能用于父子进程等具有亲缘关系的进程，命名管道则存在于文件系统中，可以用于任何进程之间的通信，具有比较好的持久性。管道的优点是创建和使用非常简单，并且数据在管道中的顺序由操作系统来保证，不需要显式同步。但是他也有一些缺点，第一点，管道是<strong>半双工</strong>的，需要两个管道才能实现双向通信。第二点，<strong>读取时如果没有数据会阻塞进程</strong>。</p><p>匿名管道通信步骤：<br>①父进程调用pipe()函数创建管道，参数是一个指向fd[2]（文件描述符）数组的指针，其中fd[0]是读端，fd[1]是写端<br>②父进程调用fork()函数创建子进程，子进程的fd[0]也是读端，fd[1]是写端<br>③两个进程分别关闭读端和写端，即一个close(fd[0])，一个close(fd[1])，就可以调用read、write函数进行读写。</p><h3 id="2-消息队列（Message-Queues）"><a href="#2-消息队列（Message-Queues）" class="headerlink" title="2. 消息队列（Message Queues）"></a>2. 消息队列（Message Queues）</h3><p><strong>优点</strong>：</p><ul><li>支持无亲缘关系的进程通信。</li><li>灵活的消息格式：<strong>可以发送和接收不同类型和优先级的消息</strong>。</li><li>非阻塞操作：可以设置为<strong>非阻塞模式</strong>，避免进程挂起。</li></ul><p><strong>缺点</strong>：</p><ul><li>复杂性：使用和管理相对复杂，需要显式创建和销毁。</li><li>消息大小限制：消息队列<strong>有最大消息大小限制，可能不适合传输大数据</strong>。</li></ul><h3 id="3-共享内存（Shared-Memory）"><a href="#3-共享内存（Shared-Memory）" class="headerlink" title="3. 共享内存（Shared Memory）"></a>3. 共享内存（Shared Memory）</h3><p><strong>优点</strong>：</p><ul><li>高效：直接在内存中进行数据读写，<strong>速度快</strong>，<strong>适合大数据量通信</strong>。</li><li>灵活：可以在共享内存区域内自由读写数据。</li></ul><p><strong>缺点</strong>：</p><ul><li>同步问题：需要<strong>显式同步机制（如信号量）</strong>来保证数据一致性。</li><li>安全性：需要确保访问权限和数据完整性，<strong>避免数据竞争和破坏</strong>。</li></ul><h3 id="4-信号量（Semaphores）"><a href="#4-信号量（Semaphores）" class="headerlink" title="4. 信号量（Semaphores）"></a>4. 信号量（Semaphores）</h3><p>与“信号”要做区别！！！<br><strong>优点</strong>：</p><ul><li>用于进程同步：非常适合解决进程间的<strong>同步和资源竞争</strong>问题。</li><li>灵活：可以用于多种同步场景，支持复杂的同步操作。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>不直接传递数据</strong>：只用于同步，不用于数据传输。</li><li>复杂性：使用和管理相对复杂，需理解信号量机制。</li></ul><h3 id="5-套接字（Sockets）"><a href="#5-套接字（Sockets）" class="headerlink" title="5. 套接字（Sockets）"></a>5. 套接字（Sockets）</h3><p><strong>优点</strong>：</p><ul><li>通用性强：不仅用于<strong>本地进程间通信</strong>，还可以用于<strong>网络通信</strong>。</li><li>灵活：<strong>支持多种通信协议（TCP&#x2F;UDP）</strong>，适合多种通信需求。</li></ul><p><strong>缺点</strong>：</p><ul><li>复杂性：<strong>使用和管理较复杂，需要处理连接、数据流控制等</strong>。</li><li>性能：比共享内存等方式稍<strong>慢</strong>，尤其是在本地通信时。</li></ul><h3 id="6-信号（Signals）"><a href="#6-信号（Signals）" class="headerlink" title="6. 信号（Signals）"></a>6. 信号（Signals）</h3><p><strong>优点</strong>：</p><ul><li>简单：发送和处理信号非常简单，<strong>适合简单的通知和事件处理</strong>。</li><li>异步：信号处理可以<strong>异步进行</strong>，响应事件及时。</li></ul><p><strong>缺点</strong>：</p><ul><li>功能有限：信号<strong>只能传递简单的信息，无法传递复杂数据</strong>。</li><li><strong>易忽略</strong>：进程可能忽略或阻塞信号，需要小心处理。</li></ul><h3 id="7-内存映射文件（Memory-Mapped-Files）"><a href="#7-内存映射文件（Memory-Mapped-Files）" class="headerlink" title="7. 内存映射文件（Memory-Mapped Files）"></a>7. 内存映射文件（Memory-Mapped Files）</h3><p><strong>优点</strong>：</p><ul><li><strong>高效</strong>：通过文件映射到内存，实现快速的数据共享。</li><li><strong>持久性</strong>：数据存储在文件中，具有持久性。</li></ul><p><strong>缺点</strong>：</p><ul><li>同步问题：需要<strong>显式同步机制</strong>来保证数据一致性。</li><li><strong>平台依赖</strong>：不同操作系统对内存映射文件的支持和实现有所不同。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>管道</strong>适合<strong>简单的父子进程</strong>间通信，匿名管道用于亲缘关系进程，命名管道用于无亲缘关系进程。</li><li><strong>消息队列</strong>适合需要<strong>灵活消息传递</strong>的场景，但有<strong>消息大小</strong>限制。</li><li><strong>共享内存</strong>适合<strong>大数据量、高效通信</strong>，但需要<strong>显式同步机制</strong>。</li><li><strong>信号量</strong>用于进程<strong>同步</strong>，解决资源竞争问题，但<strong>不用于数据传输</strong>。</li><li><strong>套接字</strong>通用性强，适合本地和网络通信，但使用复杂。</li><li><strong>信号</strong>适合<strong>简单的通知和事件处理</strong>，但无法传递复杂数据。</li><li><strong>内存映射文件</strong>高效且具有持久性，但需要同步机制，且<strong>平台依赖性较强</strong>。</li></ul><p>选择哪种进程间通信方式取决于具体的应用需求、数据量、性能要求和实现复杂性。</p><p>进程间通信（Inter-Process Communication, IPC）是指在操作系统中，不同进程之间进行数据交换和同步的一系列机制。常见的进程间通信方式包括：</p><h3 id="1-管道（Pipes）具体代码"><a href="#1-管道（Pipes）具体代码" class="headerlink" title="1. 管道（Pipes）具体代码"></a>1. 管道（Pipes）具体代码</h3><p>管道是一种半双工的通信方式，分为匿名管道和命名管道。</p><ul><li><p><strong>匿名管道</strong>：只能用于具有亲缘关系的进程间通信（如父子进程）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">pipe</span>(pipefd);<br><span class="hljs-comment">// pipefd[0] 用于读，pipefd[1] 用于写</span><br></code></pre></td></tr></table></figure></li><li><p><strong>命名管道（FIFO）</strong>：可以用于无亲缘关系的进程间通信。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-built_in">mkfifo</span>(<span class="hljs-string">&quot;/tmp/myfifo&quot;</span>, <span class="hljs-number">0666</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-消息队列（Message-Queues）具体代码"><a href="#2-消息队列（Message-Queues）具体代码" class="headerlink" title="2. 消息队列（Message Queues）具体代码"></a>2. 消息队列（Message Queues）具体代码</h3><p>消息队列允许进程以消息的形式进行通信，可以实现多个进程之间的消息传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg_buffer</span> &#123;<br>    <span class="hljs-type">long</span> msg_type;<br>    <span class="hljs-type">char</span> msg_text[<span class="hljs-number">100</span>];<br>&#125;;<br><br><span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;progfile&quot;</span>, <span class="hljs-number">65</span>);<br><span class="hljs-type">int</span> msgid = <span class="hljs-built_in">msgget</span>(key, <span class="hljs-number">0666</span> | IPC_CREAT);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg_buffer</span> message;<br>message.msg_type = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">strcpy</span>(message.msg_text, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-built_in">msgsnd</span>(msgid, &amp;message, <span class="hljs-built_in">sizeof</span>(message), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="3-共享内存（Shared-Memory）具体代码"><a href="#3-共享内存（Shared-Memory）具体代码" class="headerlink" title="3. 共享内存（Shared Memory）具体代码"></a>3. 共享内存（Shared Memory）具体代码</h3><p>共享内存是最快的一种进程间通信方式，允许多个进程直接访问同一块内存区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><br><span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;shmfile&quot;</span>, <span class="hljs-number">65</span>);<br><span class="hljs-type">int</span> shmid = <span class="hljs-built_in">shmget</span>(key, <span class="hljs-number">1024</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br><span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">shmat</span>(shmid, (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-built_in">shmdt</span>(str);<br></code></pre></td></tr></table></figure><h3 id="4-信号量（Semaphores）具体代码"><a href="#4-信号量（Semaphores）具体代码" class="headerlink" title="4. 信号量（Semaphores）具体代码"></a>4. 信号量（Semaphores）具体代码</h3><p>信号量是一种用于进程同步的机制，用于解决进程间的资源竞争问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><br><span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;semfile&quot;</span>, <span class="hljs-number">65</span>);<br><span class="hljs-type">int</span> semid = <span class="hljs-built_in">semget</span>(key, <span class="hljs-number">1</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> sb = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// P操作</span><br><span class="hljs-built_in">semop</span>(semid, &amp;sb, <span class="hljs-number">1</span>);<br>sb.sem_op = <span class="hljs-number">1</span>; <span class="hljs-comment">// V操作</span><br><span class="hljs-built_in">semop</span>(semid, &amp;sb, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="5-套接字（Sockets）具体代码"><a href="#5-套接字（Sockets）具体代码" class="headerlink" title="5. 套接字（Sockets）具体代码"></a>5. 套接字（Sockets）具体代码</h3><p>套接字不仅可以用于网络通信，也可以用于本地进程间通信（Unix域套接字）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/un.h&gt;</span></span><br><br><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_un</span> addr;<br>addr.sun_family = AF_UNIX;<br><span class="hljs-built_in">strcpy</span>(addr.sun_path, <span class="hljs-string">&quot;/tmp/mysocket&quot;</span>);<br><span class="hljs-built_in">bind</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br><span class="hljs-built_in">listen</span>(sockfd, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h3 id="6-信号（Signals）具体代码"><a href="#6-信号（Signals）具体代码" class="headerlink" title="6. 信号（Signals）具体代码"></a>6. 信号（Signals）具体代码</h3><p>信号是一种用于通知进程某个事件发生的机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d\n&quot;</span>, sig);<br>&#125;<br><br><span class="hljs-built_in">signal</span>(SIGINT, signal_handler);<br><span class="hljs-built_in">raise</span>(SIGINT);<br></code></pre></td></tr></table></figure><h3 id="7-内存映射文件（Memory-Mapped-Files）具体代码"><a href="#7-内存映射文件（Memory-Mapped-Files）具体代码" class="headerlink" title="7. 内存映射文件（Memory-Mapped Files）具体代码"></a>7. 内存映射文件（Memory-Mapped Files）具体代码</h3><p>内存映射文件允许进程通过映射文件到内存地址空间来共享文件的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, O_RDWR);<br><span class="hljs-type">char</span> *data = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">strcpy</span>(data, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-built_in">munmap</span>(data, <span class="hljs-number">4096</span>);<br><span class="hljs-built_in">close</span>(fd);<br></code></pre></td></tr></table></figure><p>每种进程间通信方式都有其优缺点，选择哪种方式取决于具体的应用需求。例如，共享内存虽然速度最快，但需要注意同步和并发控制；而套接字虽然速度较慢，但具有更高的灵活性和适用范围。</p><h2 id="什么是页面置换？"><a href="#什么是页面置换？" class="headerlink" title="什么是页面置换？"></a>什么是页面置换？</h2><p>凉经案例：<br>把那些不太常用的页给替换成另一个页（<strong>你空间够的话换个p啊，所以本质还是空间不够</strong></p><p><strong>问了gpt：</strong></p><p>页面置换（Page Replacement）是指操作系统在虚拟内存管理中，<strong>当内存中的页面不足以容纳所有正在运行的进程所需的页面时，需要将一些页面从内存中换出到磁盘上，以便为新的页面腾出空间</strong>。这个过程就是页面置换。</p><p>在虚拟内存管理中，每个进程通常拥有自己的<strong>虚拟地址空间</strong>，而实际的<strong>物理内存空间有限</strong>（面试官特地强调了这一点）。当进程需要访问的页面不在内存中时，操作系统会发生<strong>缺页中断（Page Fault），此时就需要进行页面置换</strong>。操作系统会根据一定的<strong>置换算法</strong>选择要置换出去的页面，以便将新的页面加载到内存中。</p><p>常见的页面置换算法包括（加粗的是没答的，不过这个无关紧要，他后来问了LRU：</p><ol><li><p><strong>最佳（Optimal）置换算法</strong>：选择在未来最长时间内不再访问的页面进行置换。这是一种理想情况下的算法，但由于无法预知未来的页面访问情况，因此很难实现。</p></li><li><p>先进先出（FIFO）置换算法：选择最早进入内存的页面进行置换。这是一种简单而直观的置换算法，但可能会导致“Belady异常”，即增加页面数目时，缺页次数反而增多。</p></li><li><p>最近最少使用（LRU）置换算法：选择最近最少被使用的页面进行置换。这是一种较为实用的置换算法，但需要维护页面访问的顺序，实现相对复杂。</p></li><li><p>时钟（Clock）置换算法：结合 FIFO 算法和 LRU 算法，使用一个时钟指针来模拟页面的访问情况。当时钟指针指向一个页面时，如果该页面未被访问，则选择该页面进行置换；否则，将该页面的访问位清零，继续检查下一个页面。</p></li><li><p><strong>最不经常使用（LFU）置换算法</strong>：选择最近使用频率最低的页面进行置换。这是一种根据页面使用频率来进行置换的算法，适用于某些特定场景。</p></li></ol><p>页面置换算法的选择取决于系统的需求和性能要求，不同的置换算法有不同的优缺点，需要根据具体情况进行权衡和选择。</p><h2 id="FIFO的缺点"><a href="#FIFO的缺点" class="headerlink" title="FIFO的缺点"></a>FIFO的缺点</h2><p>凉经案例：<br>用很通俗的语言只讲了一点（页面串扰</p><p><strong>问了gpt：</strong></p><ol><li><p><strong>Belady异常</strong>：FIFO 算法可能会出现 Belady 异常，即增加页面数目时，缺页次数反而增多。这是因为 FIFO 算法只考虑了页面进入内存的顺序，而没有考虑页面的使用频率。当内存中的页面数目增多时，先进入内存的页面可能会被频繁置换出去，导致缺页次数增加。</p></li><li><p><strong>局部性原理不符</strong>：FIFO 算法不符合局部性原理，即程序访问内存时存在时间和空间局部性的倾向。由于 FIFO 算法只考虑了页面进入内存的顺序，而没有考虑页面的使用情况，因此可能会导致页面置换不够有效，无法利用程序的局部性原理。</p></li><li><p><strong>未利用页面的使用情况</strong>：FIFO 算法没有考虑页面的使用情况，即便某些页面可能长时间未被访问，也会被保留在内存中。这样会导致内存资源没有得到充分利用，降低了内存的利用率。</p></li><li><p><strong>容易受到页面串扰影响</strong>：FIFO 算法容易受到页面串扰的影响，即当一些页面由于访问频繁而常驻内存时，可能会导致其他页面被频繁置换出去，影响系统的整体性能。</p></li></ol><p>综上所述，FIFO 算法虽然简单直观，但在实际应用中可能会存在一些缺点，特别是在面对局部性原理、程序访问模式的变化时，可能会导致性能下降或者系统资源的浪费。因此，在选择页面置换算法时，需要根据具体情况权衡各种因素，选择适合系统需求的算法。</p><h2 id="如何实现一个基于lru算法的页面置换算法？"><a href="#如何实现一个基于lru算法的页面置换算法？" class="headerlink" title="如何实现一个基于lru算法的页面置换算法？"></a>如何实现一个基于lru算法的页面置换算法？</h2><p>实现一个基于LRU（Least Recently Used）算法的页面置换算法可以通过维护一个缓存结构来跟踪最近使用的页面。当缓存满了，需要替换一个页面时，选择最久未使用的页面进行替换。常见的实现思路包括使用双向链表和哈希表的组合，以达到高效的插入、删除和访问操作。</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol><li><p><strong>数据结构选择</strong>：</p><ul><li><strong>双向链表</strong>：用于维护页面的访问顺序，最近使用的页面在链表头部，最久未使用的页面在链表尾部。</li><li><strong>哈希表</strong>：用于实现页面在双向链表中的快速定位，从而在O(1)时间内进行查找、插入和删除操作。</li></ul></li><li><p><strong>基本操作</strong>：</p><ul><li><strong>访问页面</strong>：<ul><li>如果页面在缓存中（命中），则将该页面移到链表头部。</li><li>如果页面不在缓存中（未命中），则将页面添加到链表头部。如果缓存已满，需要移除链表尾部的页面。</li></ul></li><li><strong>插入页面</strong>：<ul><li>将新页面插入到链表头部，同时在哈希表中添加对应的键值对。</li></ul></li><li><strong>删除页面</strong>：<ul><li>从链表尾部删除页面，并在哈希表中移除对应的键值对。</li></ul></li></ul></li></ol><h2 id="HTTP常用方法"><a href="#HTTP常用方法" class="headerlink" title="HTTP常用方法"></a>HTTP常用方法</h2><p>HTTP（超文本传输协议）定义了一组请求方法来指示特定的操作以执行资源。这些方法在HTTP&#x2F;1.1规范中有详细的定义。以下是常用的HTTP方法：</p><ol><li><p><strong>GET</strong>：</p><ul><li><strong>用途</strong>：从服务器获取资源。</li><li><strong>幂等性</strong>：幂等（多次请求的结果相同）。</li><li><strong>副作用</strong>：无副作用（安全）。</li><li><strong>示例</strong>：获取网页内容或API数据。</li><li><strong>请求示例</strong>：<code>GET /index.html HTTP/1.1</code></li></ul></li><li><p><strong>POST</strong>：</p><ul><li><strong>用途</strong>：向服务器提交数据，通常用于表单提交或文件上传。</li><li><strong>幂等性</strong>：非幂等（多次请求可能产生不同结果）。</li><li><strong>副作用</strong>：有副作用（不安全）。</li><li><strong>示例</strong>：提交表单数据或创建新资源。</li><li><strong>请求示例</strong>：<code>POST /submit-form HTTP/1.1</code></li></ul></li><li><p><strong>PUT</strong>：</p><ul><li><strong>用途</strong>：向服务器上传资源或更新资源。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：有副作用。</li><li><strong>示例</strong>：上传文件或更新数据库中的记录。</li><li><strong>请求示例</strong>：<code>PUT /user/123 HTTP/1.1</code></li></ul></li><li><p><strong>DELETE</strong>：</p><ul><li><strong>用途</strong>：从服务器删除资源。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：有副作用。</li><li><strong>示例</strong>：删除数据库中的记录或文件。</li><li><strong>请求示例</strong>：<code>DELETE /user/123 HTTP/1.1</code></li></ul></li><li><p><strong>HEAD</strong>：</p><ul><li><strong>用途</strong>：与GET相同，但只返回响应的头部，不返回主体内容。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：无副作用。</li><li><strong>示例</strong>：检查资源是否存在或获取资源的元数据。</li><li><strong>请求示例</strong>：<code>HEAD /index.html HTTP/1.1</code></li></ul></li><li><p><strong>OPTIONS</strong>：</p><ul><li><strong>用途</strong>：获取服务器支持的通信选项和请求方法。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：无副作用。</li><li><strong>示例</strong>：查看服务器允许的HTTP方法。</li><li><strong>请求示例</strong>：<code>OPTIONS /index.html HTTP/1.1</code></li></ul></li><li><p><strong>PATCH</strong>：</p><ul><li><strong>用途</strong>：对资源进行部分修改。</li><li><strong>幂等性</strong>：非幂等。</li><li><strong>副作用</strong>：有副作用。</li><li><strong>示例</strong>：更新资源的部分属性。</li><li><strong>请求示例</strong>：<code>PATCH /user/123 HTTP/1.1</code></li></ul></li><li><p><strong>TRACE</strong>：</p><ul><li><strong>用途</strong>：回显服务器收到的请求，用于诊断。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：无副作用。</li><li><strong>示例</strong>：用于调试请求路径。</li><li><strong>请求示例</strong>：<code>TRACE /index.html HTTP/1.1</code></li></ul></li></ol><h3 id="不常用的方法"><a href="#不常用的方法" class="headerlink" title="不常用的方法"></a>不常用的方法</h3><ol><li><strong>CONNECT</strong>：<ul><li><strong>用途</strong>：用于将请求连接转换为透明的TCP&#x2F;IP隧道，通常用于HTTPS。</li><li><strong>幂等性</strong>：非幂等。</li><li><strong>副作用</strong>：有副作用。</li><li><strong>示例</strong>：代理服务器设置隧道以进行SSL（HTTPS）连接。</li><li><strong>请求示例</strong>：<code>CONNECT www.example.com:443 HTTP/1.1</code></li></ul></li></ol><h3 id="幂等性和安全性"><a href="#幂等性和安全性" class="headerlink" title="幂等性和安全性"></a>幂等性和安全性</h3><ul><li><strong>幂等性</strong>：指多次执行相同的操作，结果应保持不变（GET、PUT、DELETE、HEAD、OPTIONS）。</li><li><strong>安全性</strong>：指操作不会更改服务器状态（GET、HEAD、OPTIONS、TRACE）。</li></ul><p>了解这些HTTP方法及其特性有助于更好地设计和实现基于HTTP的客户端和服务器应用程序。</p><h2 id="MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？"><a href="#MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？" class="headerlink" title="MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？"></a>MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？</h2><h3 id="1-存储引擎选择"><a href="#1-存储引擎选择" class="headerlink" title="1. 存储引擎选择"></a>1. 存储引擎选择</h3><p>MySQL提供了多种存储引擎，其中InnoDB是最常用的高并发支持引擎。InnoDB支持行级锁定和外键约束，具有较好的并发处理能力和崩溃恢复功能。</p><ul><li><strong>InnoDB:</strong> 适用于大多数高并发场景，支持事务、行级锁、外键等特性。</li><li><strong>MyISAM:</strong> 虽然查询性能较高，但不支持事务和行级锁，通常不推荐用于高并发写操作的场景。（读法：My Eye sam）</li></ul><h3 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2. 索引优化"></a>2. 索引优化</h3><p>合理使用索引可以显著提高查询速度。常见的索引类型有：</p><ul><li><strong>B树索引:</strong> 适用于大多数查询。</li><li><strong>全文索引:</strong> 适用于文本搜索。</li><li><strong>哈希索引:</strong> 适用于精确匹配查询。</li></ul><h3 id="3-查询优化"><a href="#3-查询优化" class="headerlink" title="3. 查询优化"></a>3. 查询优化</h3><p>优化SQL查询是提高并发性能的关键。包括：</p><ul><li>避免使用SELECT *，尽量只查询必要的字段。</li><li>使用EXPLAIN分析查询计划，优化慢查询。</li><li>使用合适的WHERE条件，减少扫描行数。</li></ul><h3 id="4-数据库设计"><a href="#4-数据库设计" class="headerlink" title="4. 数据库设计"></a>4. 数据库设计</h3><p>良好的数据库设计对高并发支持至关重要。</p><ul><li><strong>规范化:</strong> 减少数据冗余，避免更新异常。</li><li><strong>反规范化:</strong> 在读操作频繁的场景下适当反规范化，减少联表查询。</li></ul><h3 id="5-连接池和缓存"><a href="#5-连接池和缓存" class="headerlink" title="5. 连接池和缓存"></a>5. 连接池和缓存</h3><ul><li><strong>连接池:</strong> 复用数据库连接，减少连接建立的开销。</li><li><strong>缓存:</strong> 使用Redis或Memcached缓存热点数据，减轻数据库压力。</li></ul><h3 id="6-配置优化"><a href="#6-配置优化" class="headerlink" title="6. 配置优化"></a>6. 配置优化</h3><p>MySQL配置参数的优化可以显著提高性能。</p><ul><li><strong>innodb_buffer_pool_size:</strong> 设置为物理内存的60-80%，以增加缓存命中率。</li><li><strong>query_cache_size:</strong> 控制查询缓存大小（需要权衡开销和收益）。</li><li><strong>max_connections:</strong> 设置合适的最大连接数，避免过多连接导致资源耗尽。</li></ul><h3 id="7-水平扩展"><a href="#7-水平扩展" class="headerlink" title="7. 水平扩展"></a>7. 水平扩展</h3><p>当单一MySQL实例无法满足高并发需求时，可以考虑通过水平扩展来分担负载。</p><ul><li><strong>主从复制:</strong> 配置多个从库，分担读取压力。</li><li><strong>分片:</strong> 将数据拆分到多个数据库实例上。</li></ul><h2 id="什么是脏读？什么是幻读？"><a href="#什么是脏读？什么是幻读？" class="headerlink" title="什么是脏读？什么是幻读？"></a>什么是脏读？什么是幻读？</h2><p>在数据库系统中，脏读和幻读是两种不同的并发事务问题，通常会在不同的隔离级别下发生。</p><h3 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h3><p>脏读是指一个事务能够读到另一个事务尚未提交的修改。这种情况可能会导致数据不一致，因为读到的数据可能会在后续被回滚。脏读发生在最低的隔离级别，即<strong>读未提交（Read Uncommitted）</strong>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol><li>事务A开始，并更新了一条记录的值，但尚未提交。</li><li>事务B读取了这条记录，得到事务A更新后的值。</li><li>如果事务A回滚，那么事务B读取的数据就是无效的。</li></ol><h3 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h3><p>幻读是指在一个事务中，两次读取同一个条件的数据集时，由于另一个事务插入了新的数据，导致两次读取的数据集不一致。这通常发生在隔离级别较低的情况下，例如<strong>可重复读（Repeatable Read）</strong>和<strong>读已提交（Read Committed）</strong>。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol><li>事务A开始，并读取满足某个条件的一组数据。</li><li>事务B插入了一条满足相同条件的新记录，<strong>并提交</strong>。</li><li>事务A再次读取相同条件的数据集时，会发现多了一条记录。</li></ol><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>为了避免这些并发问题，SQL标准定义了四种隔离级别，每种隔离级别能避免不同类型的并发问题：</p><ol><li><strong>读未提交（Read Uncommitted）</strong>：<ul><li>可能出现脏读、不可重复读和幻读。</li></ul></li><li><strong>读已提交（Read Committed）</strong>：<ul><li>避免脏读，但可能出现不可重复读和幻读。</li></ul></li><li><strong>可重复读（Repeatable Read）</strong>：<ul><li>避免脏读和不可重复读，但可能出现幻读。</li></ul></li><li><strong>可串行化（Serializable）</strong>：<ul><li>避免脏读、不可重复读和幻读，是最严格的隔离级别。</li></ul></li></ol><p>通过选择适当的隔离级别，可以在性能和数据一致性之间取得平衡。通常情况下，<strong>读已提交</strong>和<strong>可重复读</strong>是实际应用中最常用的隔离级别。</p><h2 id="数据库范式？"><a href="#数据库范式？" class="headerlink" title="数据库范式？"></a>数据库范式？</h2><p>数据库范式（Normalization）是用于数据库设计的一组规则和标准，旨在减少数据冗余和提高数据完整性。以下是常见的几种范式：</p><h3 id="1-第一范式（1NF）"><a href="#1-第一范式（1NF）" class="headerlink" title="1. 第一范式（1NF）"></a>1. 第一范式（1NF）</h3><p>第一范式的目标是确保每个列的值都是原子的，即不可再分。要达到1NF，数据库表中的每个字段都应该包含单一的值，不允许有重复的组或多值字段。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>每个列都应包含原子值。</li><li>每个列都只包含一种类型的数据。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>如果有一个表如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">学生    课程<br>张三    数学, 英语<br>李四    物理<br></code></pre></td></tr></table></figure><p>为满足1NF，应改成：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">学生    课程<br>张三    数学<br>张三    英语<br>李四    物理<br></code></pre></td></tr></table></figure><h3 id="2-第二范式（2NF）"><a href="#2-第二范式（2NF）" class="headerlink" title="2. 第二范式（2NF）"></a>2. 第二范式（2NF）</h3><p>第二范式在满足1NF的基础上，还要求消除部分依赖，即表中的非主键字段必须完全依赖于主键，而不是主键的一部分。通常在有复合主键的表中会考虑2NF。</p><h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足1NF。</li><li>所有非主键字段都必须<strong>完全依赖</strong>于主键，而<strong>不能依赖于主键的一部分</strong>。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>考虑一个有复合主键的表：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">学生ID    课程ID    成绩    课程名称<br>1        <span class="hljs-number"> 101 </span>     <span class="hljs-number"> 90 </span>     数学<br>1        <span class="hljs-number"> 102 </span>     <span class="hljs-number"> 85 </span>     英语<br>2        <span class="hljs-number"> 101 </span>     <span class="hljs-number"> 88 </span>     数学<br></code></pre></td></tr></table></figure><p>在这个表中，课程名称只依赖于课程ID而不是整个主键，因此应分解成两个表：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">学生ID    课程ID    成绩<br>1        <span class="hljs-number"> 101 </span>      90<br>1        <span class="hljs-number"> 102 </span>      85<br>2        <span class="hljs-number"> 101 </span>      88<br><br>课程ID    课程名称<br>101       数学<br>102       英语<br></code></pre></td></tr></table></figure><h3 id="3-第三范式（3NF）"><a href="#3-第三范式（3NF）" class="headerlink" title="3. 第三范式（3NF）"></a>3. 第三范式（3NF）</h3><p>第三范式在满足2NF的基础上，要求消除传递依赖，即非主键字段之间不能有依赖关系。</p><h4 id="规则-2"><a href="#规则-2" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足2NF。</li><li>所有<strong>非主键字段都必须直接依赖于主键，而不能通过其他非主键字段间接依赖</strong>。</li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>考虑以下表：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">学生ID    学生姓名    学院ID    学院名称<br>1         张三       <span class="hljs-number"> 10 </span>       计算机学院<br>2         李四       <span class="hljs-number"> 20 </span>       数学学院<br></code></pre></td></tr></table></figure><p>在这个表中，学院名称依赖于学院ID，而学院ID依赖于学生ID，因此应分解成两个表：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">学生ID    学生姓名    学院ID<br>1         张三        10<br>2         李四        20<br><br>学院ID    学院名称<br>10        计算机学院<br>20        数学学院<br></code></pre></td></tr></table></figure><h3 id="4-BC范式（BCNF）"><a href="#4-BC范式（BCNF）" class="headerlink" title="4. BC范式（BCNF）"></a>4. BC范式（BCNF）</h3><p>Boyce-Codd范式是3NF的一个更严格版本，它要求每个非平凡函数依赖的左侧都必须是<strong>超键</strong>（即唯一标识表中记录的属性集）。</p><h4 id="规则-3"><a href="#规则-3" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足3NF。</li><li>对于每一个非平凡函数依赖X → Y，X必须是超键。</li></ul><h3 id="5-第四范式（4NF）"><a href="#5-第四范式（4NF）" class="headerlink" title="5. 第四范式（4NF）"></a>5. 第四范式（4NF）</h3><p>第四范式要求<strong>消除多值依赖</strong>，即一个表中不能存在多对多关系的属性组。</p><h4 id="规则-4"><a href="#规则-4" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足BCNF。</li><li>没有非平凡的多值依赖。</li></ul><h3 id="6-第五范式（5NF）"><a href="#6-第五范式（5NF）" class="headerlink" title="6. 第五范式（5NF）"></a>6. 第五范式（5NF）</h3><p>第五范式要求消除连接依赖，即表应该能够自然分解，而不导致信息丢失。</p><h4 id="规则-5"><a href="#规则-5" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足4NF。</li><li>每个非平凡的连接依赖必须由候选键隐含。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过这些范式，数据库设计者可以在减少数据冗余、消除异常和提高数据完整性之间找到平衡。在实际应用中，通常会<strong>根据需求选择适当的范式</strong>，而不一定严格地应用所有的范式。</p><h2 id="真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？"><a href="#真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？" class="headerlink" title="真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？"></a>真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？</h2><p>在实际项目中，特别是ERP系统或其他大型数据库应用中，严格遵循数据库范式的设计原则是非常重要的，能够帮助减少数据冗余、避免数据异常并保持数据一致性。然而，实际情况往往比理论复杂，在某些情况下，违反范式的设计可能是更好的选择。以下是一些违反范式的常见场景和理由：</p><h3 id="1-性能优化"><a href="#1-性能优化" class="headerlink" title="1. 性能优化"></a>1. 性能优化</h3><p>在高并发、大量数据读写的场景中，性能往往是优先考虑的因素。以下是一些常见的违反范式的情况：</p><h4 id="读优化"><a href="#读优化" class="headerlink" title="读优化"></a>读优化</h4><ul><li><strong>反规范化（Denormalization）</strong>：为了减少联表查询的次数，可以将相关数据冗余存储在一个表中。例如，在一个订单系统中，客户信息可以直接存储在订单表中，而不是每次查询订单都去联接客户表。</li></ul><h4 id="写优化"><a href="#写优化" class="headerlink" title="写优化"></a>写优化</h4><ul><li><strong>预计算和缓存（Precomputed Values and Caching）</strong>：为了加速查询，可以存储预先计算好的结果，如总金额、统计数据等，尽管这些数据可以通过计算得到，但这样可以减少实时计算的负担。</li></ul><h3 id="2-简化查询"><a href="#2-简化查询" class="headerlink" title="2. 简化查询"></a>2. 简化查询</h3><p>在某些业务场景中，简单、快速的查询比严格的范式化设计更重要。例如：</p><ul><li><strong>报表和分析系统</strong>：为了便于生成报表和进行数据分析，可能需要违反范式，将数据冗余地存储在一个表中，简化复杂的查询逻辑。</li></ul><h3 id="3-数据一致性和完整性"><a href="#3-数据一致性和完整性" class="headerlink" title="3. 数据一致性和完整性"></a>3. 数据一致性和完整性</h3><p>在有些情况下，为了保持数据的一致性和完整性，违反范式是必要的。例如：</p><ul><li><strong>历史数据存储</strong>：在审计和追踪历史数据的场景中，可能需要在一个表中存储数据快照，这样尽管增加了冗余，但可以确保数据的不可变性和一致性。</li></ul><h3 id="4-实际开发和维护"><a href="#4-实际开发和维护" class="headerlink" title="4. 实际开发和维护"></a>4. 实际开发和维护</h3><p>在实际开发过程中，开发和维护的复杂性也是一个重要的考虑因素：</p><ul><li><strong>开发便利性</strong>：有时候，简单、直观的表结构可以减少开发和维护的复杂性，即使这意味着违反某些范式。例如，团队可能决定在一个表中存储更多信息，以避免频繁的联表操作。</li></ul><h3 id="具体场景示例"><a href="#具体场景示例" class="headerlink" title="具体场景示例"></a>具体场景示例</h3><h4 id="示例1：订单系统"><a href="#示例1：订单系统" class="headerlink" title="示例1：订单系统"></a>示例1：订单系统</h4><p>在一个订单系统中，订单表通常会涉及多个关联表，如客户表、产品表、地址表等。严格的范式化设计可能如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">订单表(Order)<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>客户ID<br><span class="hljs-bullet">- </span>总金额<br><span class="hljs-bullet">- </span>创建日期<br><br>客户表(Customer)<br><span class="hljs-bullet">- </span>客户ID<br><span class="hljs-bullet">- </span>客户姓名<br><span class="hljs-bullet">- </span>联系方式<br><br>订单项表(OrderItem)<br><span class="hljs-bullet">- </span>订单项ID<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>产品ID<br><span class="hljs-bullet">- </span>数量<br><span class="hljs-bullet">- </span>单价<br></code></pre></td></tr></table></figure><p>然而，为了提高查询性能，尤其是查询订单时避免多次联表，可以采取反规范化设计：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">订单表(Order)<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>客户ID<br><span class="hljs-bullet">- </span>客户姓名<br><span class="hljs-bullet">- </span>联系方式<br><span class="hljs-bullet">- </span>总金额<br><span class="hljs-bullet">- </span>创建日期<br><br>订单项表(OrderItem)<br><span class="hljs-bullet">- </span>订单项ID<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>产品ID<br><span class="hljs-bullet">- </span>产品名称<br><span class="hljs-bullet">- </span>数量<br><span class="hljs-bullet">- </span>单价<br></code></pre></td></tr></table></figure><p>这种设计牺牲了一些规范性，但在性能和查询简便性方面有很大提升。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>虽然范式化设计是数据库设计的指导原则，但在实际项目中，特别是在性能、查询简便性、开发和维护复杂性方面，违反范式是常见的。设计数据库时，应在范式化和实际需求之间找到平衡，具体问题具体分析，根据实际情况采取适当的设计策略。</p><h2 id="什么叫回表？"><a href="#什么叫回表？" class="headerlink" title="什么叫回表？"></a>什么叫回表？</h2><p>在数据库系统中，<strong>回表（Index Lookup Back to Table）</strong> 是指数据库在使用索引查询数据时，由于<strong>索引不包含所需的所有列，必须回到数据表中去获取完整的记录</strong>。这种情况常见于关系型数据库如MySQL。</p><h3 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h3><p>当执行查询时，如果使用的索引中不包含查询所需的所有字段，数据库首先通过索引定位到符合条件的记录，然后<strong>再通过索引中的指针访问实际的数据表以获取缺失的字段</strong>。这种从索引跳回数据表获取完整数据的操作称为回表。</p><h3 id="回表的示例"><a href="#回表的示例" class="headerlink" title="回表的示例"></a>回表的示例</h3><p>假设有一张用户表 <code>users</code>，包含如下字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">users</span> (<span class="hljs-built_in">id</span>, name, email, age)<br></code></pre></td></tr></table></figure><p>并且在 <code>email</code> 字段上建立了索引：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_email <span class="hljs-keyword">ON</span> users(email);<br></code></pre></td></tr></table></figure><p>现在执行一个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, email <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;example@example.com&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="索引覆盖和回表"><a href="#索引覆盖和回表" class="headerlink" title="索引覆盖和回表"></a>索引覆盖和回表</h3><p>在这个查询中，数据库可以通过 <code>idx_email</code> 索引快速定位到符合条件的记录，但是：</p><ul><li>如果索引中只包含 <code>email</code> 字段，那么数据库需要通过回表操作，从实际的数据表中获取 <code>name</code> 字段的值。</li><li>如果索引包含 <code>email</code> 和 <code>name</code> 字段（称为<strong>覆盖索引</strong>），则不需要回表，因为索引已经包含了查询所需的所有字段。</li></ul><h3 id="避免回表的方法"><a href="#避免回表的方法" class="headerlink" title="避免回表的方法"></a>避免回表的方法</h3><ol><li><p><strong>使用覆盖索引（Covering Index）</strong>：</p><ul><li><strong>创建包含查询中所有字段的索引</strong>。例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_email_name <span class="hljs-keyword">ON</span> users(email, name);<br></code></pre></td></tr></table></figure>这样，在上面的查询中，数据库不需要回表即可获取所有数据。</li></ul></li><li><p><strong>减少查询字段</strong>：</p><ul><li>只查询索引中已有的字段，避免回表。</li></ul></li></ol><h3 id="回表的影响"><a href="#回表的影响" class="headerlink" title="回表的影响"></a>回表的影响</h3><ul><li><strong>性能开销</strong>：回表操作会<strong>增加I&#x2F;O开销</strong>，因为需要额外访问数据表，尤其是在查询结果集较大时。</li><li><strong>查询效率</strong>：对频繁执行的查询，回表可能显著<strong>影响性能</strong>，因此需要根据查询模式和频率优化索引设计。</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>回表是数据库优化中的一个重要概念，通过合理设计索引（如使用覆盖索引），可以减少回表操作，从而提高查询性能。在数据库设计和查询优化中，应仔细分析查询需求和数据访问模式，权衡索引的维护开销与查询性能之间的关系。</p><h2 id="索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？"><a href="#索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？" class="headerlink" title="索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？"></a>索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？</h2><p>索引是数据库管理系统中的一种数据结构，可以提高数据检索速度。索引的核心作用是减少数据库在查找数据时需要扫描的数据量，从而提高查询效率。在没有索引的情况下，数据库系统执行查询操作时可能需要执行全表扫描，即逐行检查表中的每一行数据，直到找到符合查询条件的数据。这种方法在数据量小的时候还可以接受，但随着数据量的增加，查询效率会显著下降。</p><h3 id="索引的主要类型："><a href="#索引的主要类型：" class="headerlink" title="索引的主要类型："></a>索引的主要类型：</h3><ol><li><p><strong>B树索引</strong>：最常见的索引类型，尤其适用于等值查询和范围查询。B树索引通过维护一个多层级的树形结构来存储数据，每个节点都是有序的，这样可以非常快速地通过分裂和合并来维持树的平衡。</p></li><li><p><strong>哈希索引</strong>：适用于快速查找操作，特别是等值查询。它通过哈希表实现，其中键通过哈希函数直接映射到表中一个位置。</p></li><li><p><strong>全文索引</strong>：专门为处理文本数据设计，可以快速从大量文本中找到关键词。例如，搜索引擎常用的倒排索引就是一种全文索引。</p></li><li><p><strong>空间索引</strong>：如R树，用于空间数据查询，如地图位置的检索。</p></li></ol><h3 id="索引提高查询效率的原理："><a href="#索引提高查询效率的原理：" class="headerlink" title="索引提高查询效率的原理："></a>索引提高查询效率的原理：</h3><ol><li><p><strong>减少查找范围</strong>：例如，B树索引通过树形结构，使得每次查询都能在树的每个级别上排除大量不符合条件的数据，迅速缩小查找范围。</p></li><li><p><strong>避免全表扫描</strong>：索引可以直接指向表中的具体行，无需逐行扫描整个表来查找数据。</p></li><li><p><strong>排序和快速访问</strong>：索引通常以某种顺序存储数据，使得范围查询更为高效。同时，索引结构通常设计为易于在内存中快速访问的形式。</p></li></ol><h3 id="使用索引的代价："><a href="#使用索引的代价：" class="headerlink" title="使用索引的代价："></a>使用索引的代价：</h3><p>尽管索引可以显著提高查询速度，但也有其代价和限制：</p><ul><li><strong>空间消耗</strong>：索引本身需要占用存储空间。</li><li><strong>维护成本</strong>：每次数据更新（插入、删除、修改）时，相关的索引也需要更新，这会增加操作的开销。</li><li><strong>设计和管理复杂性</strong>：合理设计和维护索引需要精确考虑数据使用模式，不当的索引可能导致性能下降而非提升。</li></ul><p>总之，索引是优化数据库查询性能的重要工具，但需要根据实际的数据量和查询需求来合理设计和使用。</p><h2 id="为什么实际用B-树用的更多？"><a href="#为什么实际用B-树用的更多？" class="headerlink" title="为什么实际用B+树用的更多？"></a>为什么实际用B+树用的更多？</h2><p>在数据库索引的实现中，实际上 B+树 更常被用作索引结构而不是 B树。虽然两者都是平衡树结构，用于提高数据的检索效率，但 B+树 相对于 B树 有几个特点使其更适合用于数据库索引：</p><h3 id="1-所有键值对都在叶节点："><a href="#1-所有键值对都在叶节点：" class="headerlink" title="1. 所有键值对都在叶节点："></a>1. <strong>所有键值对都在叶节点</strong>：</h3><p>B+树的所有键值对都存储在叶节点，而非叶节点仅存储键值的副本以用于导航。这种结构使得叶节点形成了一个有序链表，适合进行范围查询。范围查询是数据库常见的操作，比如查询所有在某个日期范围内的记录。在 B树 中，数据分散在整个树中，不容易直接支持高效的范围查询。</p><h3 id="2-非叶节点仅用于索引："><a href="#2-非叶节点仅用于索引：" class="headerlink" title="2. 非叶节点仅用于索引："></a>2. <strong>非叶节点仅用于索引</strong>：</h3><p>在 B+树 中，非叶节点的作用仅是索引，不存储实际数据。这意味着非叶节点更小，树可以更高效地加载更多的索引键到内存中，从而降低树的高度，提高查询速度。</p><h3 id="3-叶节点的链表结构："><a href="#3-叶节点的链表结构：" class="headerlink" title="3. 叶节点的链表结构："></a>3. <strong>叶节点的链表结构</strong>：</h3><p>B+树的叶节点之间是相连的，这样可以快速进行顺序访问。对于数据库系统中常见的顺序扫描操作，这种结构显著提高了效率。</p><h3 id="4-更少的指针跳转："><a href="#4-更少的指针跳转：" class="headerlink" title="4. 更少的指针跳转："></a>4. <strong>更少的指针跳转</strong>：</h3><p>由于非叶节点不含实际数据，对数据的访问总是会到达叶节点，这种一致的访问模式意味着缓存更为有效，减少了指针跳转和磁盘I&#x2F;O操作。</p><h3 id="5-磁盘I-x2F-O优化："><a href="#5-磁盘I-x2F-O优化：" class="headerlink" title="5. 磁盘I&#x2F;O优化："></a>5. <strong>磁盘I&#x2F;O优化</strong>：</h3><p>数据库系统通常与磁盘操作密切相关，而 B+树 结构可以减少磁盘读写次数。B+树的设计使得它可以很好地适应磁盘的页结构，每个节点大小通常与磁盘页大小相匹配，这减少了节点分裂时的磁盘I&#x2F;O需求。</p><p>因此，虽然“B树索引”这个术语在通话中可能被泛泛地使用，实际上在现代数据库系统中，B+树索引因其对于磁盘存储和数据检索操作优化更胜一筹，从而被广泛采用。</p><h2 id="hashmap的数据结构？"><a href="#hashmap的数据结构？" class="headerlink" title="hashmap的数据结构？"></a>hashmap的数据结构？</h2><p>底层使用哈希表（hash table）来存储数据（key-value对），元素无序存储。每个key的数量唯一。</p><p>哈希函数：使用哈希函数将键映射到哈希表中的位置。C++标准库提供了一些默认的哈希函数，例如针对整型、字符串等常见类型的哈希函数。用户也可以提供自定义的哈希函数。</p><p>哈希冲突解决：由于哈希函数可能会将不同的键映射到同一个位置（即哈希冲突），std::unordered_map 使用了链地址法（separate chaining）来解决冲突。具体做法是，每个哈希表的桶（bucket）中存储一个链表，当多个键映射到同一个桶时，这些键值对会被存储在该桶的链表中。</p><p>负载因子和重新哈希：负载因子是<strong>哈希表中元素数量与桶数量的比值</strong>。当负载因子超过一定阈值时，哈希表会进行重新哈希，即增加桶的数量并重新分配所有元素到新的桶中。这个过程确保哈希表的性能不随着元素数量的增加而显著下降。</p><h2 id="hashmap的扩容"><a href="#hashmap的扩容" class="headerlink" title="hashmap的扩容"></a>hashmap的扩容</h2><p>在 C++ STL 中，std::unordered_map 和 std::unordered_set 是两个使用哈希表 (hash table) 作为其底层实现的容器。</p><p>当哈希表的元素数量增长到某个阈值时，就需要进行扩容。这个阈值通常是哈希表容量（bucket count）和装载因子（load factor）的乘积。装载因子是一个浮点数，它决定了哈希表元素数与容量之间的比例。默认装载因子通常是1.0。</p><p>当需要扩容时，STL会执行以下步骤：</p><p>1.创建一个新的、更大的哈希表。新的大小通常是原来大小的两倍。</p><p>2.遍历原有哈希表中的所有元素，并重新计算它们在新哈希表中的位置（这个位置由元素的哈希值和新的哈希表大小决定）。</p><p>3.将每个元素从旧的哈希表移动到新的哈希表的对应位置。</p><p>这个过程被称为 rehashing。这是一个相当消耗资源的操作，因为它涉及到重新计算每个元素的哈希值，并可能涉及到大量的内存操作。但是，通过这种方式，可以保证哈希表的性能，因为它能保证元素在哈希表中的分布更均匀，减少哈希冲突，提高查找效率。</p><p>注意，虽然扩容可以提高哈希表的性能，但是频繁的扩容操作会消耗大量的资源，影响程序的性能。因此，如果你预先知道哈希表需要存储大量的元素，可以通过 rehash 或 reserve 方法预先分配足够的空间，避免频繁的扩容操作。</p><h2 id="什么是哈希冲突？如何解决？"><a href="#什么是哈希冲突？如何解决？" class="headerlink" title="什么是哈希冲突？如何解决？"></a>什么是哈希冲突？如何解决？</h2><p>哈希冲突是在使用哈希表或哈希映射时发生的一种情况，其中两个或更多的输入值（键）被哈希函数映射到同一个哈希值（即同一个桶或位置）上。哈希表是一种数据结构，它提供了非常快速的数据查找速度。哈希函数的作用是将输入值（通常是一个字符串或其他数据）转换成一个整数，这个整数然后用来计算在哈希表中的存储位置。</p><h3 id="哈希冲突的产生原因"><a href="#哈希冲突的产生原因" class="headerlink" title="哈希冲突的产生原因"></a>哈希冲突的产生原因</h3><p>哈希冲突的产生通常是由于以下几个原因：</p><ol><li><strong>哈希函数设计</strong>：如果哈希函数<strong>没有很好地分散</strong>各种不同的输入值到不同的哈希码，就更容易发生冲突。</li><li><strong>哈希表的大小</strong>：哈希表的<strong>大小是有限</strong>的，而且可能小于可能的输入值的数量，所以即使是理想的哈希函数也无法避免冲突。</li><li><strong>输入数据的分布</strong>：如果输入<strong>数据本身</strong>具有一定的模式或规律，可能导致哈希函数产生<strong>非均匀的哈希值分布</strong>。</li></ol><h3 id="解决哈希冲突的常见方法"><a href="#解决哈希冲突的常见方法" class="headerlink" title="解决哈希冲突的常见方法"></a>解决哈希冲突的常见方法</h3><p>解决哈希冲突主要有几种常用的策略：</p><ol><li><strong>开放寻址法</strong>：当发生冲突时，尝试在哈希表中找到另一个空闲的桶来存储当前的元素。这种方法可能会采用线性探测、二次探测或双重散列等策略。</li><li><strong>链表法</strong>（拉链法）：每个哈希表的桶或位置实际上存储的是一个链表的头节点。所有映射到该位置的元素都会被加入到这个链表中。因此，查找、插入和删除操作需要遍历链表。</li><li><strong>再哈希法</strong>：设计多个哈希函数，当第一个哈希函数导致冲突时，尝试第二个哈希函数，以此类推。</li></ol><h3 id="哈希冲突的影响"><a href="#哈希冲突的影响" class="headerlink" title="哈希冲突的影响"></a>哈希冲突的影响</h3><p>虽然哈希表在最佳情况下可以提供接近 O(1) 的平均时间复杂度，但是哈希冲突会增加这些操作的时间复杂度。尤其是当使用链表法处理冲突时，如果冲突非常频繁，链表可能变得非常长，这会导致接近于线性搜索的性能，即平均时间复杂度接近 O(n)。</p><p>因此，选择合适的哈希函数和冲突解决机制对于哈希表的性能至关重要。理想的哈希函数应该易于计算，且能将输入均匀分布到所有的哈希值上，最小化冲突的可能性。</p><h2 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h2><p>线性探测是解决哈希表冲突的一种开放寻址策略。它的基本思想很简单：当插入一个元素时，如果计算出的哈希表位置已经被占用（即发生冲突），则探测下一个位置，直到找到一个空的位置来放置这个新元素。这个“下一个位置”是指当前位置的直接后续位置。</p><h3 id="线性探测的工作原理"><a href="#线性探测的工作原理" class="headerlink" title="线性探测的工作原理"></a>线性探测的工作原理</h3><ol><li><p><strong>插入操作</strong>：</p><ul><li>使用哈希函数计算数据项的哈希值，得到其应当存储的位置。</li><li>如果该位置已被占用，则检查下一个连续的位置（即当前位置加1，考虑数组边界可能需要取模操作）。</li><li>重复这个过程直到找到一个空闲位置。</li></ul></li><li><p><strong>查找操作</strong>：</p><ul><li>使用同样的哈希函数计算数据项的哈希值，得到其应当存储的初始位置。</li><li>如果该位置上的元素不匹配，则继续检查下一个位置，直到找到匹配的元素或遇到一个空位置（空位置意味着元素不存在）。</li></ul></li><li><p><strong>删除操作</strong>：</p><ul><li>直接从哈希表中删除元素可能会中断探测序列，使得之后的元素无法被正确找到。因此，一种常见的做法是使用一个特殊标记来表示“已删除”的状态，而不是真的从哈希表中去除元素。</li><li>查找和插入操作需要对这种“已删除”标记进行处理，确保它们的正确运行。</li></ul></li></ol><h3 id="线性探测的优点与缺点"><a href="#线性探测的优点与缺点" class="headerlink" title="线性探测的优点与缺点"></a>线性探测的优点与缺点</h3><p><strong>优点</strong>：</p><ul><li>实现简单。</li><li>不需要额外的数据结构（如链表）来存储冲突的元素，节省空间。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>聚集问题</strong>：线性探测的一个主要缺点是它倾向于在哈希表中形成聚集区域，即连续占用的序列，这会影响性能。当哈希表填充率高时，聚集现象尤其严重。</li><li><strong>性能下降</strong>：随着填充率的增加，插入和搜索的平均时间成本增加，因为需要探测更多的位置才能找到空闲位置或目标元素。</li></ul><h3 id="应用建议"><a href="#应用建议" class="headerlink" title="应用建议"></a>应用建议</h3><p>线性探测比较适合于元素数量相对固定，且哈希表负载因子较低的应用场景。在设计哈希表时，应该合理设置哈希表的大小和负载因子，以及及时调整哈希表大小（通过再哈希等手段）来优化性能。对于高冲突环境，可能需要考虑其他冲突解决策略，如二次探测或双重哈希，来减少聚集问题的影响。</p><h2 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h2><p>二次探测是开放寻址法处理哈希表中冲突的一种方法，它是线性探测的一个变体。线性探测在发现冲突时会简单地检查下一个连续的槽位。与之不同，二次探测则会在原始位置的基础上增加一个增长的平方项来找到新的槽位，这可以在一定程度上减少聚集问题。</p><h3 id="二次探测的工作原理"><a href="#二次探测的工作原理" class="headerlink" title="二次探测的工作原理"></a>二次探测的工作原理</h3><p>二次探测的基本思想是在原始哈希位置基础上探测新位置时，步长是探测次数的平方。具体过程如下：</p><ol><li><p><strong>插入操作</strong>：</p><ul><li>使用哈希函数计算数据项的原始哈希值 <code>h(x)</code>。</li><li>如果该位置已经被占用，则探测新位置 <code>h(x) + 1^2, h(x) + 2^2, h(x) + 3^2, ...</code> 直到找到一个空闲位置。</li><li>步长（即平方项）会随着每次冲突递增，因此探测的位置迅速分散，有助于减少聚集。</li></ul></li><li><p><strong>查找操作</strong>：</p><ul><li>查找开始于数据项的原始哈希值 <code>h(x)</code>。</li><li>如果该位置的元素不匹配，则按 <code>1^2, 2^2, 3^2, ...</code> 的步长继续查找，直到找到目标元素或遇到一个空槽位（空槽位意味着元素不存在）。</li></ul></li><li><p><strong>删除操作</strong>：</p><ul><li>和线性探测一样，删除操作通常不会直接从表中移除元素，而是将其标记为“已删除”，以保持探测连续性，避免断开查找链。</li></ul></li></ol><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>减少聚集</strong>：二次探测相比线性探测，能更好地减少主聚集（primary clustering）现象，因为它探测的位置不再是连续的，而是跳跃式增加。</li><li><strong>实现简单</strong>：二次探测相对于其他一些复杂的冲突解决策略（如双重哈希）来说，实现起来依然简单。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>次级聚集</strong>：虽然解决了主聚集问题，二次探测依然存在次级聚集（secondary clustering）。不同的键可能以相同的序列探测空槽位，特别是当表中有多个数据项冲突时。</li><li><strong>表的利用率</strong>：当哈希表填充度较高时，二次探测可能找不到空槽位，即使表中实际上还有空闲位置。</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>二次探测提供了一种相对于线性探测更高效的冲突解决方法，尤其在减少聚集方面表现更好。然而，随着表的填充度增加，其性能可能受到影响，因此需要合理设定哈希表的大小和负载因子，或者考虑通过再哈希等方式调整哈希表大小。在选择哈希冲突解决策略时，需要根据具体应用的需求和特点来决定使用哪种方法。</p><h2 id="双重哈希"><a href="#双重哈希" class="headerlink" title="双重哈希"></a>双重哈希</h2><p>双重哈希是处理哈希表中冲突的另一种开放寻址技术。它使用两个独立的哈希函数来计算数据项的存储位置，当第一个哈希函数计算的位置已经被占用时，它将使用第二个哈希函数来帮助找到一个空闲位置。这种方法旨在减少聚集问题，提高哈希表的性能。</p><h3 id="双重哈希的工作原理"><a href="#双重哈希的工作原理" class="headerlink" title="双重哈希的工作原理"></a>双重哈希的工作原理</h3><p>双重哈希的基本过程包括：</p><ol><li><p><strong>初始化</strong>：</p><ul><li>定义两个哈希函数：<code>h1(x)</code> 和 <code>h2(x)</code>。这两个函数对于表中的每个元素都应该返回一个哈希值。</li></ul></li><li><p><strong>插入操作</strong>：</p><ul><li>使用第一个哈希函数 <code>h1(x)</code> 计算元素 x 的初始位置。</li><li>如果该位置已被占用，则计算一个新位置：<code>(h1(x) + i * h2(x)) % table_size</code>，其中 i 是探测的次数，从 1 开始。</li><li>继续探测，增加 i 的值，直到找到一个空闲位置。</li></ul></li><li><p><strong>查找操作</strong>：</p><ul><li>查找开始于使用 <code>h1(x)</code> 计算的位置。</li><li>如果该位置上的元素不是目标元素，则使用 <code>(h1(x) + i * h2(x)) % table_size</code> 进行下一次探测，直到找到元素或遇到空位置。</li></ul></li><li><p><strong>删除操作</strong>：</p><ul><li>类似于其他开放寻址技术，删除操作通常不是直接从表中移除元素，而是将其标记为已删除，这样不会破坏查找过程中的探测链。</li></ul></li></ol><h3 id="设计哈希函数"><a href="#设计哈希函数" class="headerlink" title="设计哈希函数"></a>设计哈希函数</h3><p>为了使双重哈希有效，第二个哈希函数 <code>h2(x)</code> 的设计至关重要。理想的 <code>h2(x)</code> 应满足以下条件：</p><ul><li><code>h2(x)</code> 应始终返回一个非零的正整数，因为如果 <code>h2(x)</code> 返回零，探测序列将不会改变，无法找到新的空位。</li><li><code>h2(x)</code> 应尽量保证返回的值能均匀分布在哈希表的整个空间中。</li></ul><h3 id="优点与缺点-1"><a href="#优点与缺点-1" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>减少聚集</strong>：与线性探测和二次探测相比，双重哈希能更有效地减少聚集问题，因为它通过两个独立的函数来探测空闲位置。</li><li><strong>灵活性和可靠性</strong>：通过适当选择两个哈希函数，双重哈希方法可以适应各种数据分布，提高哈希表的整体性能。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>计算复杂性</strong>：使用两个哈希函数可能会增加计算的复杂性，尤其是在插入和查找操作中。</li><li><strong>设计挑战</strong>：设计两个好的哈希函数需要一定的技术知识和经验，以确保它们独立并均匀地分散冲突。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>双重哈希是一个强大的技术，适用于那些对查找性能要求较高的应用场景。正确实施时，它可以提供较高的效率和良好的加载因子性能，但需要确保哈希函数的选择和实现得当。</p><h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><p>链表法，也称为拉链法，是解决哈希表冲突的一种常用方法。与开放寻址法不同，其中尝试找到空闲位置来存储每个冲突的元素，链表法在哈希表的每个槽位（或桶）中存储一个指向链表的指针。当多个元素的哈希值指向同一个槽位时，这些元素会被组织在同一链表中。</p><h3 id="链表法的工作原理"><a href="#链表法的工作原理" class="headerlink" title="链表法的工作原理"></a>链表法的工作原理</h3><p>链表法的基本步骤包括：</p><ol><li><p><strong>初始化</strong>：</p><ul><li>哈希表由一系列槽位组成，每个槽位初始时可能是空的或指向一个链表的头节点。</li></ul></li><li><p><strong>插入操作</strong>：</p><ul><li>对元素 x 应用哈希函数 <code>h(x)</code>，计算出该元素应存储在哈希表的哪个槽位。</li><li>如果该槽位为空，则在该位置创建一个新的链表，并将 x 作为链表的第一个元素。</li><li>如果该槽位已经链接到一个链表，则将 x 添加到链表的末尾（或头部，具体实现可能有所不同）。</li></ul></li><li><p><strong>查找操作</strong>：</p><ul><li>使用相同的哈希函数 <code>h(x)</code> 定位元素 x 应在的槽位。</li><li>遍历该槽位的链表，逐个检查链表中的元素，直到找到 x 或链表结束。</li></ul></li><li><p><strong>删除操作</strong>：</p><ul><li>定位元素 x 应在的槽位。</li><li>遍历该槽位的链表，找到 x 并从链表中移除。</li></ul></li></ol><h3 id="优点与缺点-2"><a href="#优点与缺点-2" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>处理冲突灵活</strong>：链表法可以容纳数量不定的冲突元素，只要链表可以继续扩展。</li><li><strong>性能稳定</strong>：只要哈希函数选得好，保证分布均匀，每个槽位的链表长度通常不会很长，从而保持操作的效率。</li><li><strong>动态扩展</strong>：相比于开放寻址法，链表法可以更容易地处理大量数据，因为链表本身没有固定的大小限制。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>空间利用率低</strong>：每个元素需要额外的空间来存储指针，尤其是在存储小型数据项时，这种额外成本较为显著。</li><li><strong>缓存不友好</strong>：链表节点可能在内存中不连续存储，从而导致较差的缓存性能，影响整体速度。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>链表法非常适合于那些冲突可能较多的环境，例如，在一个大型哈希表中存储大量数据时。此外，由于其处理冲突的灵活性，它在实际应用中非常受欢迎，例如在编程语言中的散列表实现或在数据库的索引中。</p><h2 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h2><p>设计模式是在软件设计中经常出现的问题的解决方案的模板。它们提供了一种通用的方法来解决常见的设计问题，并鼓励面向对象编程中的可重用性、可维护性和灵活性。以下是一些常见的设计模式：</p><ol><li><p><strong>单例模式（Singleton Pattern）</strong>：</p><ul><li>保证一个类只有一个实例，并提供全局访问点。</li></ul></li><li><p><strong>工厂模式（Factory Pattern）</strong>：</p><ul><li>定义一个用于创建对象的接口，但是由子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</li></ul></li><li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：</p><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li></ul></li><li><p><strong>建造者模式（Builder Pattern）</strong>：</p><ul><li>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li></ul></li><li><p><strong>原型模式（Prototype Pattern）</strong>：</p><ul><li>通过复制现有对象来创建新对象，而不是使用构造函数。</li></ul></li><li><p><strong>适配器模式（Adapter Pattern）</strong>：</p><ul><li>将一个类的接口转换成客户端所期待的另一个接口。适配器让原本接口不兼容的类可以合作无间。</li></ul></li><li><p><strong>装饰器模式（Decorator Pattern）</strong>：</p><ul><li>动态地将责任附加到对象上。装饰器提供了一种灵活地扩展功能的方式。</li></ul></li><li><p><strong>代理模式（Proxy Pattern）</strong>：</p><ul><li>为其他对象提供一种代理以控制对这个对象的访问。</li></ul></li><li><p><strong>观察者模式（Observer Pattern）</strong>：</p><ul><li>定义对象之间的一对多依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。</li></ul></li><li><p><strong>策略模式（Strategy Pattern）</strong>：</p><ul><li>定义一系列算法，将每个算法封装起来，并使它们可以互相替换。</li></ul></li><li><p><strong>模板方法模式（Template Method Pattern）</strong>：</p><ul><li>定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法的某些步骤。</li></ul></li><li><p><strong>状态模式（State Pattern）</strong>：</p><ul><li>允许对象在内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</li></ul></li><li><p><strong>读者-写者模式（Reader-Writer Pattern）</strong>：</p><ul><li>解决多个读操作和写操作同时对共享资源进行访问的问题。它允许多个读操作同时进行，但写操作必须互斥执行。</li></ul></li><li><p><strong>订阅者模式（Subscriber Pattern）</strong>：</p><ul><li>也称为发布-订阅模式，定义了一种一对多的关系，当一个对象的状态发生变化时，所有依赖于它的对象都会收到通知并自动更新。</li></ul></li><li><p><strong>工厂模式（Factory Pattern）</strong>：</p><ul><li>提供一个创建对象的接口，但是允许子类决定实例化哪个类。它将对象的实例化过程延迟到子类中进行，从而提高了代码的灵活性和可维护性。</li></ul></li><li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：</p><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。它可以看作是多个工厂方法的集合，用于创建一组相关的对象。</li></ul></li><li><p><strong>建造者模式（Builder Pattern）</strong>：</p><ul><li>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。它通过一个指导者来组装具体的构建者，从而实现了构建过程的灵活性。</li></ul></li><li><p><strong>原型模式（Prototype Pattern）</strong>：</p><ul><li>通过复制现有对象来创建新对象，而不是使用构造函数。它通常适用于创建成本较高的对象，或者当创建过程涉及复杂的初始化逻辑时。</li></ul></li></ol><p>这些设计模式都是为了解决软件开发中常见的设计问题而提出的，并且在实际项目中都有着广泛的应用。通过理解和运用这些设计模式，开发人员可以更加高效地设计、编写和维护高质量的软件系统。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hyx的面试之路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>停水时间到</title>
    <link href="/2024/05/12/%E5%81%9C%E6%B0%B4%E6%97%B6%E9%97%B4%E5%88%B0/"/>
    <url>/2024/05/12/%E5%81%9C%E6%B0%B4%E6%97%B6%E9%97%B4%E5%88%B0/</url>
    
    <content type="html"><![CDATA[<p>一天中最喜欢的就是洗澡的时间<br>和等待洗澡的时间<br>我躲在帘子后面轻声哼唱<br>（空荡的易碎品）<br>脑袋空空循环播放着旋律<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>要多少才叫足够<br>怎样才能真正满意<br>我追逐着一些很重要的东西<br>也有一些没有那么重要的东西<br>“菜就多练”  他们是这么讲的<br>明明那些都属于我<br>我讨厌夺走 夺走<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>我追逐着他们的背影<br>他们告诉我该这样做该那样做<br>什么时候才可以不用撒谎呢<br>什么时候才可以分享快乐呢<br>什么时候才能不孤独呢<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>无比渴望存在证明<br>我的耳朵停止了吼叫<br>也许这样已经足够了吧<br>（呀 停水时间到）</p>]]></content>
    
    
    
    <tags>
      
      <tag>写点歌词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载知乎-kafka面试题</title>
    <link href="/2024/05/10/%E8%BD%AC%E8%BD%BD%E7%9F%A5%E4%B9%8E-kafka%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/05/10/%E8%BD%AC%E8%BD%BD%E7%9F%A5%E4%B9%8E-kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-为什么要使用-kafka，为什么要使用消息队列？"><a href="#1-为什么要使用-kafka，为什么要使用消息队列？" class="headerlink" title="1. 为什么要使用 kafka，为什么要使用消息队列？"></a>1. 为什么要使用 kafka，为什么要使用消息队列？</h3><p>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。<br>解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。<br>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。<br>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。<br>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h3 id="2-Kafka的常用组件有哪些？"><a href="#2-Kafka的常用组件有哪些？" class="headerlink" title="2. Kafka的常用组件有哪些？"></a>2. Kafka的常用组件有哪些？</h3><p>producer：消息的生产者, 自己决定哪个 partions 中生产消息, 两种机制:hash 与 轮询。<br>consumer：通过 zookeeper 进行维护消费者偏移量, consumer有自己的消费组,不同组之间维护同一个 topic 数据,互不影响.相同组的不同 consumer消费同一个 topic,这个 topic相同的数据只被消费一次。<br>broker：broker 组成 kafka 集群的节点,之间没有主从关系, 依赖 zookeeper进行协调, broker 负责消息的读写与存储, 一个 broker可以管理读个 partionstopic：一类消息的总称&#x2F;消息队里, topic是由 partions组成, 一个 topic 由多台 server 里的 partions 组成。zookeeper 协调 kafka broker,存储元数据, consumer的 offset+ broker 信息 +topic信息+ partions信息partions 组成 topic 的单元, 每个 topic有副本(创建 topic 指定), 每个 partions 只能有有个 broker管理</p><h3 id="3-数据传输的事物定义有哪三种"><a href="#3-数据传输的事物定义有哪三种" class="headerlink" title="3. 数据传输的事物定义有哪三种?"></a>3. 数据传输的事物定义有哪三种?</h3><p>数据传输的事务定义通常有以下三种级别：</p><p>最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输。<br>最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输。<br>精确的一次(Exactly once): 不会漏传输也不会重复传输,每个消息都传输被一次而 且仅仅被传输一次，这是大家所期望的。</p><h3 id="4-ZooKeeper在Kafka中的作用是什么？"><a href="#4-ZooKeeper在Kafka中的作用是什么？" class="headerlink" title="4. ZooKeeper在Kafka中的作用是什么？"></a>4. ZooKeeper在Kafka中的作用是什么？</h3><p>Apache Kafka是一个使用Zookeeper构建的分布式系统。虽然，Zookeeper的主要作用是在集群中的不同节点之间建立协调。但是，如果任何节点失败，我们还使用Zookeeper从先前提交的偏移量中恢复，因为它做周期性提交偏移量工作。</p><h3 id="5-没有ZooKeeper可以使用Kafka吗？"><a href="#5-没有ZooKeeper可以使用Kafka吗？" class="headerlink" title="5. 没有ZooKeeper可以使用Kafka吗？"></a>5. 没有ZooKeeper可以使用Kafka吗？</h3><p>zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖。但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等。</p><h3 id="6-Kafka-判断一个节点是否还活着有那两个条件"><a href="#6-Kafka-判断一个节点是否还活着有那两个条件" class="headerlink" title="6. Kafka 判断一个节点是否还活着有那两个条件?"></a>6. Kafka 判断一个节点是否还活着有那两个条件?</h3><p>节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接。<br>如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太久。</p><h3 id="7-解释偏移的作用。"><a href="#7-解释偏移的作用。" class="headerlink" title="7. 解释偏移的作用。"></a>7. 解释偏移的作用。</h3><p>给分区中的消息提供了一个顺序ID号，我们称之为偏移量。因此，为了唯一地识别分区中的每条消息，我们使用这些偏移量。</p><h3 id="8-producer-是否直接将数据发送到-broker-的-leader-主节点"><a href="#8-producer-是否直接将数据发送到-broker-的-leader-主节点" class="headerlink" title="8. producer 是否直接将数据发送到 broker 的 leader(主节点)?"></a>8. producer 是否直接将数据发送到 broker 的 leader(主节点)?</h3><p>producer 直接将数据发送到 broker 的 leader(主节点)，不需要在多个节点进行分发，为了 帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知:哪些节点是活动的，目标topic 目标分区的 leader 在哪。这样 producer 就可以直接将消息发送到目的地了。</p><h3 id="9-Kafa-consumer-是否可以消费指定分区消息"><a href="#9-Kafa-consumer-是否可以消费指定分区消息" class="headerlink" title="9. Kafa consumer 是否可以消费指定分区消息?"></a>9. Kafa consumer 是否可以消费指定分区消息?</h3><p>Kafa consumer 消费消息时，向 broker 发出”fetch”请求去消费特定分区的消息，consumer指定消息在日志中的偏移量(offset)，就可以消费从这个位置开始的消息，customer 拥有 了 offset 的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的。</p><h3 id="10-Kafka-存储在硬盘上的消息格式是什么"><a href="#10-Kafka-存储在硬盘上的消息格式是什么" class="headerlink" title="10. Kafka 存储在硬盘上的消息格式是什么?"></a>10. Kafka 存储在硬盘上的消息格式是什么?</h3><p>消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和 CRC32校验码。</p><p>消息长度: 4 bytes (value: 1+4+n)<br>版本号: 1 byte<br>CRC 校验码: 4 bytes<br>具体的消息: n bytes<br>11. kafka follower如何与leader同步数据？<br>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。<br>12. Kafka 高效文件存储设计特点:</p><p>Kafka 把 topic 中一个 parition 大文件分成多个小文件段，通过多个小文件段，就容易定 期清除或删除已经消费完文件，减少磁盘占用。<br>通过索引信息可以快速定位 message 和确定 response 的最大大小。<br>通过 index 元数据全部映射到 memory，可以避免 segment file 的 IO 磁盘操作。<br>通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小。<br>13. Kafka 与传统消息系统之间有三个关键区别</p><p>Kafka 持久化日志，这些日志可以被重复读取和无限期保留<br>Kafka 是一个分布式系统:它以集群的方式运行，可以灵活伸缩，在内部通过复制数据 提升容错能力和高可用性<br>Kafka 支持实时的流式处理<br>14. Kafka为什么那么快？</p><p>Cache Filesystem Cache PageCache缓存<br>顺序写 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。<br>Zero-copy 零拷技术减少拷贝次数<br>Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。<br>Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符。<br>15. 什么情况下一个 broker 会从 isr中踢出去？<br>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除 。<br>16. kafka producer如何优化打入速度？</p><p>增加线程<br>提高 batch.size<br>增加更多 producer 实例<br>增加 partition 数<br>设置 acks&#x3D;-1 时，如果延迟增大：可以增大 num.replica.fetchers（follower 同步数据的线程数）来调解；<br>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。</p><ol start="17"><li>kafka producer 打数据，ack 为 0， 1， -1 的时候代表啥（ack机制）， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了？</li></ol><p>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。<br>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的。<br>-1 producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。<br>18. Kafka中的消息是否会丢失和重复消费？<br>要确定Kafka的消息是否丢失或重复，从两个方面分析入手：消息发送和消息消费。</p><ol><li>消息发送<br>Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。Kafka通过配置request.required.acks属性来确认消息的生产：</li></ol><p>0—表示不进行消息接收是否成功的确认；<br>1—表示当Leader接收成功时确认；<br>-1—表示Leader和Follower都接收成功时确认；<br>综上所述，有6种消息生产的情况，下面分情况来分析消息丢失的场景：<br>（1）acks&#x3D;0，不和Kafka集群进行消息接收确认，则当网络异常. 缓冲区满了等情况时，消息可能丢失；<br>（2）acks&#x3D;1. 同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失；<br>2. 消息消费<br>Kafka消息消费有两个consumer接口，Low-level API和High-level API：</p><p>Low-level API：消费者自己维护offset等值，可以实现对Kafka的完全控制；<br>High-level API：封装了对parition和offset的管理，使用简单；<br>如果使用高级接口High-level API，可能存在一个问题就是当消息消费者从集群中把消息取出来. 并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就“诡异”的消失了；<br>解决办法：</p><p>针对消息丢失：同步模式下，确认机制设置为-1，即让消息写入Leader和Follower之后再确认消息发送成功；异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时让生产者一直处于阻塞状态；<br>针对消息重复：将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可。<br>消息重复消费及解决参考：<a href="https://www.javazhiyin.com/22910.html">https://www.javazhiyin.com/22910.html</a></p><ol start="19"><li>为什么Kafka不支持读写分离？<br>在 Kafka 中，生产者写入消息. 消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。<br>Kafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:</li></ol><p>数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。<br>延时问题。类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经 历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。<br>20. Kafka中是怎么体现消息顺序性的？<br>kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。<br>整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.<br>21. 消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?<br>offset+1<br>22. kafka如何实现延迟队列？<br>Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty. Akka. Quartz. Zookeeper等组件中都存在时间轮的踪影。<br>底层使用数组实现，数组中的每个元素可以存放一个TimerTaskList对象。TimerTaskList是一个环形双向链表，在其中的链表项TimerTaskEntry中封装了真正的定时任务TimerTask.<br>Kafka中到底是怎么推进时间的呢？Kafka中的定时器借助了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList都会加入到DelayQueue中。<br>Kafka中的TimingWheel专门用来执行插入和删除TimerTaskEntry的操作，而DelayQueue专门负责时间推进的任务。再试想一下，DelayQueue中的第一个超时任务列表的expiration为200ms，第二个超时任务为840ms，这里获取DelayQueue的队头只需要O(1)的时间复杂度。<br>如果采用每秒定时推进，那么获取到第一个超时的任务列表时执行的200次推进中有199次属于“空推进”，而获取到第二个超时任务时有需要执行639次“空推进”，这样会无故空耗机器的性能资源，这里采用DelayQueue来辅助以少量空间换时间，从而做到了“精准推进”。Kafka中的定时器真可谓是“知人善用”，用TimingWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，相辅相成。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>myftp项目介绍</title>
    <link href="/2024/05/10/myftp%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/05/10/myftp%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>计算机网络的课程项目：基于tcp协议，实现了一个简单的 FTP Server 和 FTP Client CLI (CLI指命令行界面)。</p><p>支持的命令有：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">open</span> <span class="hljs-symbol">&lt;IP&gt;</span> <span class="hljs-symbol">&lt;port&gt;</span>: 建立一个到 <span class="hljs-symbol">&lt;IP&gt;</span>:<span class="hljs-symbol">&lt;port&gt;</span> 的连接<br><span class="hljs-keyword">ls</span>: 通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，获取server当前运行目录下的文件列表。<br><span class="hljs-built_in">get</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Server 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Client 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中。<br><span class="hljs-keyword">put</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Client 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Server 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中。<br><span class="hljs-built_in">sha256</span> <span class="hljs-symbol">&lt;filename&gt;</span>：通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，在 Server 运行目录中查询某个文件的 <span class="hljs-built_in">sha256</span> 值，若不存在则返回不存在。<br><span class="hljs-keyword">quit</span>: 如有连接则断开连接，回到 <span class="hljs-keyword">open</span> 前的状态；如果已经是 <span class="hljs-keyword">open</span> 前的状态，则关闭 Client。<br></code></pre></td></tr></table></figure><p>（如果问到popen函数和system函数的区别，就说system函数的返回值五花八门，而popen返回值只有非空和空值，更好处理；而且调用system函数会阻塞进程，调用popen函数不会阻塞进程，也就是说用户可以继续运行主进程）</p><p>我觉得我的项目主要的亮点在于实现大文件的传输。其中有一个测试点是要实现1MB的文件的上传与下载。我一开始想通过开一个数组来实现，但是发现这样行不通，最后经过修改之后决定通过malloc分配出一段空间，然后将文件分片后传输，最后在另一端重新组合起来。</p><p>在这段代码中，文件的传输是按照一块一块来发送的，但是只有第一块设置了头部信息。头部信息包含了整个文件的长度，所以只需要在第一块传输时发送文件的长度信息即可，后续的块不需要再发送头部信息。</p><p>在GET_REQUEST中，第一块数据发送前，服务器端会发送一个含有文件长度信息的头部信息给客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置文件传输的头部信息</span><br>set_header(&amp;header, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, HEADER_LENGTH + statbuf.st_size);<br>send(client, &amp;header, HEADER_LENGTH, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>接着，服务器端开始逐块发送文件内容，后续的块不需要再发送头部信息，只需要发送文件内容即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 打开文件并逐块发送文件内容</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> temp[<span class="hljs-number">1024</span>];<br>FILE *fp = fopen(filename,<span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    length = fread(temp,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>),<span class="hljs-number">1024</span>,fp);<br>    <span class="hljs-keyword">if</span>(length == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    send(client,temp,length,<span class="hljs-number">0</span>);<br>&#125;<br>fclose(fp);<br></code></pre></td></tr></table></figure><p>因此，只有第一块设置了头部信息，后续的块不需要再设置头部信息。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字节面试准备</title>
    <link href="/2024/05/10/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2024/05/10/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<p>看了同岗位别人的一些面经x</p><p>字节国际电商后端一面<br>写在前面：八股很少，更多的是考察我们对八股文理解能力</p><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><h3 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h3><p>（1）给你一个表，(id, userid, amount, month, day)，筛选出所有的日期在3.1-3.10且累计金额大于等于100w的数据<br>（2）select * from table where b&#x3D;xx 和 select id from table where b&#x3D;xx的区别是什么</p><h3 id="3-C-访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？"><a href="#3-C-访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？" class="headerlink" title="3. C++访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？"></a>3. C++访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？</h3><p>当你尝试在C++中访问空指针时，实际上你在尝试访问一个未分配给你的内存地址。操作系统为每个进程分配一定范围的虚拟内存空间，并且对这些内存地址进行了合理的管理。然而，当你尝试使用空指针时，你实际上是在尝试访问地址0附近的内存，这是一个特殊的情况，通常是由操作系统所保留的，以防止应用程序错误地引用未分配的内存。</p><p>当你尝试访问空指针时，操作系统会检测到这个非法的内存访问，因为它监视着进程的内存访问情况。操作系统会触发一个信号，通常是称为”<strong>Segmentation Fault</strong>“（段错误）或”Access Violation”（访问违规），表示程序试图访问未分配的内存。</p><p>这时，操作系统会终止该进程，并生成一个核心转储文件（core dump），其中包含了导致程序崩溃的内存和程序状态信息。核心转储文件对于调试应用程序非常有用，因为它可以帮助开发人员追踪程序崩溃的原因。</p><p>终止进程的方法通常是通过发送一个<strong>信号</strong>来实现。在发生段错误时，操作系统会向进程发送一个信号，通常是<strong>SIGSEGV</strong>。操作系统会在接收到这个信号后，终止该进程的执行。</p><p>操作系统知道这段地址不合理是因为在内存管理中，<strong>每个页面都有自己的状态，操作系统会跟踪哪些页面是已分配的，哪些是空闲的，以及哪些是保留的。</strong>当程序访问一个未分配的或者无效的地址时，操作系统会检测到这个异常情况，并采取适当的措施，例如终止进程。</p><h3 id="4-C-内存分区是怎样的"><a href="#4-C-内存分区是怎样的" class="headerlink" title="4. C++内存分区是怎样的"></a>4. C++内存分区是怎样的</h3><p>在C++中，内存通常被划分为以下几个主要区域：</p><ol><li><p><strong>栈（Stack）</strong>：</p><ul><li>栈是用于存储函数调用的局部变量和函数参数的内存区域。</li><li>当一个函数被调用时，其局部变量和参数会被存储在栈上，并在函数返回时被自动释放。</li><li>栈是一种后进先出（LIFO）的数据结构，它的大小是固定的。</li></ul></li><li><p><strong>堆（Heap）</strong>：</p><ul><li>堆是动态分配内存的区域，用于存储程序运行时动态分配的对象。</li><li>堆的大小没有固定限制，它的大小取决于程序运行时的需求和系统资源。</li><li>堆上分配的内存需要手动释放，否则会导致内存泄漏。</li></ul></li><li><p><strong>全局&#x2F;静态存储区（Global&#x2F;Static Storage Area）</strong>：</p><ul><li>全局存储区用于存储全局变量和静态变量。</li><li>全局变量在程序的整个生命周期内都存在，静态变量在声明时初始化，在程序的整个生命周期内存在。</li><li>全局&#x2F;静态存储区在程序启动时被分配，在程序结束时被释放。</li></ul></li><li><p><strong>常量存储区（Constant Storage Area）</strong>：</p><ul><li>常量存储区用于存储常量值，例如字符串常量。</li><li>这部分内存通常是只读的，不能被修改。</li></ul></li><li><p><strong>代码区（Code Area）</strong>：</p><ul><li>代码区存储程序的可执行代码。</li><li>这部分内存通常是只读的，存储程序的指令。</li></ul></li></ol><p>这些内存区域在程序运行时起着不同的作用，并且由编译器和操作系统进行管理。程序员需要了解这些内存区域的特点和使用方式，以便正确地分配和管理内存，避免内存泄漏和其他内存相关的问题。</p><h3 id="5-linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用"><a href="#5-linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用" class="headerlink" title="5. linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用"></a>5. linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用</h3><p>当你在Linux终端输入一个命令时，操作系统会执行以下步骤来处理：</p><ol><li><p><strong>解析命令</strong>：</p><ul><li>操作系统首先会解析你输入的命令，确定你想要执行的程序或者脚本的路径。</li><li>如果输入的命令是一个内置命令（例如<code>cd</code>、<code>echo</code>等），则不需要进一步解析，而是直接调用相应的内置功能。</li></ul></li><li><p><strong>查找可执行文件</strong>：</p><ul><li>操作系统会搜索环境变量 <code>$PATH</code> 中列出的目录，以查找你输入的命令对应的可执行文件。</li><li>如果找到了对应的可执行文件，操作系统会准备执行它。</li></ul></li><li><p><strong>创建进程</strong>：</p><ul><li>操作系统会创建一个新的进程来执行你输入的命令。这个新进程是通过 <code>fork()</code> 系统调用创建的，然后调用 <code>exec()</code> 系统调用来加载并执行命令对应的可执行文件。</li></ul></li><li><p><strong>加载程序</strong>：</p><ul><li>在创建的新进程中，操作系统会加载你输入的命令对应的可执行文件到进程的内存空间中。</li></ul></li><li><p><strong>执行程序</strong>：</p><ul><li>一旦程序被加载到内存中，操作系统会开始执行它。程序的执行可能涉及到多个系统调用，具体取决于程序的功能和实现。</li></ul></li><li><p><strong>等待程序执行完成</strong>：</p><ul><li>操作系统会等待程序执行完成。如果程序是一个交互式程序，操作系统会将终端的输入输出连接到程序的标准输入输出上，以便你与程序进行交互。</li><li>如果程序执行完成并退出，操作系统会关闭该进程，并返回控制权给终端。</li></ul></li></ol><p>在这个过程中，涉及到的系统调用可能包括：</p><ul><li><code>fork()</code>：用于创建新的进程。</li><li><code>exec()</code>：用于加载并执行新的程序。</li><li><code>wait()</code> 或 <code>waitpid()</code>：用于等待子进程的退出。</li><li><code>open()</code>、<code>close()</code>、<code>read()</code> 和 <code>write()</code>：用于打开文件、关闭文件以及读写文件描述符，这些系统调用用于标准输入、输出和错误的重定向。</li><li>其他可能涉及到的系统调用，具体取决于命令执行过程中涉及的具体操作和功能。</li></ul><h3 id="6-讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？"><a href="#6-讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？" class="headerlink" title="6. 讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？"></a>6. 讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？</h3><p>内存管理是操作系统的重要功能之一，它负责管理计算机系统的物理内存，以便有效地分配和利用内存资源。内存管理的主要目的包括：</p><ol><li><strong>内存分配与回收</strong>：分配内存给进程使用，并在进程终止时回收已使用的内存，以便其他进程使用。</li><li><strong>内存保护</strong>：确保进程只能访问自己分配的内存空间，防止程序越界访问和恶意代码攻击。</li><li><strong>内存共享</strong>：允许多个进程共享内存区域，以提高系统性能和节省内存空间。</li><li><strong>内存虚拟化</strong>：提供每个进程独立的虚拟地址空间，使每个进程都认为自己在使用整个计算机的内存。</li></ol><p>不同的操作系统采用不同的内存管理方式，以下是主流操作系统的内存管理方式：</p><ol><li><p><strong>单一连续内存管理</strong>（Single Contiguous Memory Management）：</p><ul><li>在早期的操作系统中，使用了单一连续内存管理方式。在这种方式下，整个物理内存被视为一个连续的字节序列，进程被分配到内存的连续区域中。</li><li><strong>MS-DOS 是一个使用单一连续内存管理方式的操作系统的例子</strong>。</li></ul></li><li><p><strong>分页式内存管理</strong>（Paging）：</p><ul><li>在分页式内存管理中，物理内存被分割成固定大小的页面（page），通常为4KB或者更大。</li><li>进程的虚拟地址空间也被分成相同大小的页面。操作系统负责将虚拟页面映射到物理页面，从而实现了内存虚拟化。</li><li>当进程访问一个尚未加载到内存的虚拟页面时，操作系统会触发页面错误（page fault），将对应的页面从磁盘加载到内存中。</li><li>UNIX、Linux 和 Windows 等操作系统采用了分页式内存管理。</li></ul></li><li><p><strong>段式内存管理</strong>（Segmentation）：</p><ul><li>在段式内存管理中，虚拟地址空间被分成不同大小的段（segment），<strong>每个段代表一个逻辑单位，如代码段、数据段等</strong>。</li><li>物理内存也被分成相应的段，每个段可以有不同的大小和属性。</li><li>段式内存管理可以更灵活地管理内存，但也更复杂。现代操作系统往往结合分页和分段的方式来管理内存，称为分页分段式内存管理。</li></ul></li><li><p><strong>分页分段式内存管理</strong>（Paging and Segmentation）：</p><ul><li>分页分段式内存管理结合了分页和分段的优点，将<strong>虚拟地址空间划分为多个段，每个段再分成多个页面</strong>，实现了灵活性和效率的平衡。</li><li>这种方式在现代操作系统中被广泛采用，例如，Intel x86 架构的操作系统（如 Windows 和 Linux）使用了分页分段式内存管理。</li></ul></li></ol><h3 id="7-printf-“-d”-amp-a-，输出的地址是物理地址还是虚拟地址？为什么？"><a href="#7-printf-“-d”-amp-a-，输出的地址是物理地址还是虚拟地址？为什么？" class="headerlink" title="7. printf(“%d”, &amp;a)，输出的地址是物理地址还是虚拟地址？为什么？"></a>7. printf(“%d”, &amp;a)，输出的地址是物理地址还是虚拟地址？为什么？</h3><p>在C语言中，<code>printf(&quot;%d&quot;, &amp;a)</code> 中的 <code>&amp;a</code> 表示取变量 <code>a</code> 的地址。然而，C语言本身并不关心地址是物理地址还是虚拟地址，它只是返回变量 <code>a</code> 在内存中的地址值。</p><p>具体来说，在大多数现代操作系统中，包括 Linux 和 Windows，在用户空间程序中，<code>&amp;a</code> 返回的是虚拟地址，而不是物理地址。这是因为操作系统为每个进程提供了一个独立的虚拟地址空间，每个进程的虚拟地址空间都从零开始，与物理内存地址是分离的。</p><p>当你在C语言中使用 <code>&amp;a</code> 获取变量 <code>a</code> 的地址时，实际上是获取了该变量在当前进程的虚拟地址空间中的地址。这个地址是相对于进程而言的，而不是物理内存的地址。操作系统会负责将这个虚拟地址映射到物理内存的相应位置。</p><p>你说得对，我明白你的疑问了。**<code>printf</code> 是C语言的标准库函数，它用于将格式化的数据输出到标准输出流（通常是终端）。而C语言的标准库函数 <code>printf</code> 并不是操作系统级别的函数，它实际上是在用户空间运行的，而不是在操作系统内核中运行。**</p><p>当你在C程序中调用 <code>printf</code> 函数时，这个函数是由C编译器编译生成的用户态代码。这个用户态的 <code>printf</code> 函数接收参数，执行输出操作，并将输出发送到标准输出流。这个过程并不涉及操作系统的内核代码。</p><p>因此，当你在C语言程序中使用 <code>printf(&quot;%d&quot;, &amp;a)</code> 来输出变量 <code>a</code> 的地址时，<code>printf</code> 函数实际上是直接输出了变量 <code>a</code> 在当前进程的虚拟地址空间中的地址，而不是物理地址。这个地址是在用户态计算得到的，与操作系统的内核代码无关。</p><p>因此，<code>printf(&quot;%d&quot;, &amp;a)</code> 输出的地址是<strong>相对于进程的虚拟地址</strong>，而不是物理地址。</p><h3 id="8-虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）"><a href="#8-虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）" class="headerlink" title="8. 虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）"></a>8. 虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）</h3><p>页表是一种数据结构，用于存储虚拟地址空间中每个页面（page）的映射信息，以便操作系统将虚拟地址映射到物理地址。</p><p>在常见的分页式内存管理中，页表的主要作用是实现虚拟内存到物理内存的地址映射。当程序访问虚拟地址时，操作系统会使用页表来确定对应的物理地址。</p><p>页表通常包含以下信息：</p><ol><li><p><strong>页号（Page Number）</strong>：用于表示虚拟地址中的页面号码。在页表中，每个页号都对应着一个页表项（Page Table Entry）。</p></li><li><p><strong>页框号（Frame Number）</strong>：用于表示物理地址中的页框号码。页表中的每个页表项都包含了对应的页框号码，用于将虚拟地址映射到物理地址。</p></li><li><p><strong>访问权限（Access Rights）</strong>：用于表示页面的访问权限，包括读、写、执行等权限。这些权限信息通常存储在页表项中，并且可以用于实现内存保护机制。</p></li><li><p><strong>其他控制位（Control Bits）</strong>：包括是否被访问过、是否被修改过等控制信息，用于实现页面置换算法等功能。</p></li><li><p><strong>其他辅助信息</strong>：可能包括页面的有效位、驻留位、脏位等，用于帮助操作系统实现内存管理和页面置换算法。</p></li></ol><p>页表的结构和内容可能因操作系统的不同而有所不同，但它的基本功能是将虚拟地址映射到物理地址，从而实现虚拟内存的管理。</p><h3 id="9-计算机网络："><a href="#9-计算机网络：" class="headerlink" title="9. 计算机网络："></a>9. 计算机网络：</h3><h4 id="浏览器输入网址的完整流程（重要）"><a href="#浏览器输入网址的完整流程（重要）" class="headerlink" title="浏览器输入网址的完整流程（重要）"></a>浏览器输入网址的完整流程（重要）</h4><p>（操作系统级别和网络级别的都可以讲）<br>别忘了dns解析（先看缓存再请求） socket连接 http请求 html渲染</p><h4 id="HTTP请求的类型有哪些，有什么作用？"><a href="#HTTP请求的类型有哪些，有什么作用？" class="headerlink" title="HTTP请求的类型有哪些，有什么作用？"></a>HTTP请求的类型有哪些，有什么作用？</h4><p>HTTP请求的类型主要包括以下几种：</p><ol><li><p><strong>GET</strong>：</p><ul><li>GET 请求用于从服务器获取数据，通常用于请求一个资源的内容。</li><li>GET 请求的参数通常包含在URL的查询字符串中，例如 <code>http://example.com/resource?id=123</code>。</li><li>GET 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>POST 请求用于向服务器提交数据，通常用于创建新资源或者向服务器提交表单数据。</li><li>POST 请求的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>POST 请求可以用于执行各种操作，例如创建、更新、删除等，具体取决于服务器的实现。</li></ul></li><li><p><strong>PUT</strong>：</p><ul><li>PUT 请求用于向服务器上传数据，通常用于更新已有资源。</li><li>PUT 请求的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>PUT 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>DELETE</strong>：</p><ul><li>DELETE 请求用于从服务器删除资源。</li><li>DELETE 请求通常不包含数据，而是用于删除服务器上指定的资源。</li><li>DELETE 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>PATCH</strong>：</p><ul><li>PATCH 请求用于对资源进行局部更新，即只更新资源的一部分内容。</li><li>PATCH 请求的数据通常包含在请求的主体（body）中，指定要更新的部分内容。</li><li>PATCH 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>HEAD</strong>：</p><ul><li>HEAD 请求用于获取资源的头部信息，即获取资源的元数据而不获取实际内容。</li><li>HEAD 请求与 GET 请求类似，但不会返回资源的主体内容，只返回头部信息。</li></ul></li><li><p><strong>OPTIONS</strong>：</p><ul><li>OPTIONS 请求用于获取服务器支持的HTTP方法列表，以及服务器支持的其他功能。</li><li>OPTIONS 请求通常用于跨域资源共享（CORS）等场景下，以确定是否允许跨域请求。</li></ul></li></ol><p>这些HTTP请求类型具有不同的功能和语义，使得客户端和服务器可以进行各种类型的交互，实现数据的获取、创建、更新和删除等操作。</p><h4 id="post和put和区别？"><a href="#post和put和区别？" class="headerlink" title="post和put和区别？"></a>post和put和区别？</h4><p>在HTTP协议中，POST和PUT都是用于向服务器提交数据的方法，但它们有一些重要的区别：</p><ol><li><p><strong>POST</strong>：</p><ul><li>POST 方法用于向服务器提交数据，通常用于创建新资源或者在服务器上执行某种操作。</li><li>POST 请求提交的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>POST 请求没有严格的语义，它可以用于多种用途，包括创建、更新、删除等操作。</li><li>POST 请求通常用于在服务器上创建新资源，因此，重复提交相同的POST请求可能会导致服务器创建多个相同的资源。</li></ul></li><li><p><strong>PUT</strong>：</p><ul><li>PUT 方法用于向服务器提交数据，通常用于更新现有资源。</li><li>PUT 请求提交的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>PUT 请求有严格的语义，它用于在服务器上更新指定的资源。PUT 请求应该是幂等的，即重复提交相同的PUT请求不应该产生不同的结果。</li><li>如果服务器上不存在指定的资源，PUT 请求通常会创建一个新的资源，但也可能返回错误，取决于服务器的实现和配置。</li></ul></li></ol><p>总之，POST 和 PUT 都是用于向服务器提交数据的方法，但它们在语义和用途上有所不同。POST 通常用于创建新资源或执行一些操作，而 PUT 通常用于更新现有资源。</p><h4 id="讲一下TCP报文有哪些关键字段"><a href="#讲一下TCP报文有哪些关键字段" class="headerlink" title="讲一下TCP报文有哪些关键字段"></a>讲一下TCP报文有哪些关键字段</h4><p>四元组 ack seq 控制位 滑动窗口 header_length crc content</p><h4 id="TCP如何做到可靠传输（重要）"><a href="#TCP如何做到可靠传输（重要）" class="headerlink" title="TCP如何做到可靠传输（重要）"></a>TCP如何做到可靠传输（重要）</h4><p>超时重传 crc校验 ackseq 握手连接 流量控制 拥塞控制</p><h3 id="10-100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp-100-x3D-dp-97-x3D-dp-94-…-x3D-dp-1-，所以一开始就拿一个"><a href="#10-100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp-100-x3D-dp-97-x3D-dp-94-…-x3D-dp-1-，所以一开始就拿一个" class="headerlink" title="10. 100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp[100]&#x3D;dp[97]&#x3D;dp[94]…&#x3D;dp[1]，所以一开始就拿一个"></a>10. 100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp[100]&#x3D;dp[97]&#x3D;dp[94]…&#x3D;dp[1]，所以一开始就拿一个</h3><h3 id="11-分糖果（leetcode135原题）"><a href="#11-分糖果（leetcode135原题）" class="headerlink" title="11. 分糖果（leetcode135原题）"></a>11. 分糖果（leetcode135原题）</h3><h3 id="12-如何学习新事物"><a href="#12-如何学习新事物" class="headerlink" title="12. 如何学习新事物"></a>12. 如何学习新事物</h3>]]></content>
    
    
    
    <tags>
      
      <tag>国际电商</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐一个抄mooc/智慧树答案的网站</title>
    <link href="/2024/05/10/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E6%8A%84mooc-%E6%99%BA%E6%85%A7%E6%A0%91%E7%AD%94%E6%A1%88%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <url>/2024/05/10/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E6%8A%84mooc-%E6%99%BA%E6%85%A7%E6%A0%91%E7%AD%94%E6%A1%88%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jhq8.cn/s/">https://www.jhq8.cn/s/</a><br>有时候网站会抽风找不到搜索框，这个时候只要修改网址栏就可以力</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jhq8.cn<span class="hljs-regexp">/s/</span>你要搜索的连续内容/<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼编码</title>
    <link href="/2024/05/09/%E7%AE%97%E6%B3%95%E6%81%B6%E8%A1%A5/"/>
    <url>/2024/05/09/%E7%AE%97%E6%B3%95%E6%81%B6%E8%A1%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" alt="huffman"><br>我的想法：用最小堆维护一个根节点，然后开辟额外的空间O(N)去维护最终的树<br>（带权最短路径</p><p>向左子树移动就是0，向右子树移动就是1，到叶子结点就是要访问的节点，每个节点都有自己的哈夫曼编码</p><p>xiaolincoding.com的计算机网络讲得真的很细（感觉是面试官会问到的级别</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搬运自用-MySQL面试题合集</title>
    <link href="/2024/05/08/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2024/05/08/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>题目合集：</p><ol><li>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15？</li><li>Mysql的技术特点是什么？</li><li>Heap表是什么？</li><li>Mysql服务器默认端口是什么？</li><li>与Oracle相比，Mysql有什么优势？</li><li>如何区分FLOAT和DOUBLE？</li><li>区分CHAR_LENGTH和LENGTH？</li><li>请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</li><li>在Mysql中ENUM的用法是什么？</li><li>如何定义REGEXP？</li><li>CHAR和VARCHAR的区别？</li><li>列的字符串类型可以是什么？</li><li>如何获取当前的Mysql版本？</li><li>Mysql中使用什么存储引擎？</li><li>Mysql驱动程序是什么？</li><li>TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？</li><li>主键和候选键有什么区别？</li><li>如何使用Unix shell登录Mysql？</li><li>myisamchk是用来做什么的？</li><li>MYSQL数据库服务器性能分析的方法命令有哪些?</li><li>如何控制HEAP表的最大尺寸？</li><li>MyISAM Static和MyISAM Dynamic有什么区别？</li><li>federated表是什么？</li><li>如果一个表有一列定义为TIMESTAMP，将发生什么？</li><li>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</li><li>怎样才能找出最后一次插入时分配了哪个自动增量？</li><li>你怎么看到为表格定义的所有索引？</li><li>LIKE声明中的％和_是什么意思？</li><li>如何在Unix和Mysql时间戳之间进行转换？</li><li>列对比运算符是什么？</li><li>我们如何得到受查询影响的行数？</li><li>Mysql查询是否区分大小写？</li><li>LIKE和REGEXP操作有什么区别？</li><li>BLOB和TEXT有什么区别？</li><li>mysql_fetch_array和mysql_fetch_object的区别是什么？</li><li>我们如何在mysql中运行批处理模式？</li><li>MyISAM表格将在哪里存储，并且还提供其存储格式？</li><li>Mysql中有哪些不同的表格？</li><li>ISAM是什么？</li><li>InnoDB是什么？</li><li>Mysql如何优化DISTINCT？</li><li>如何输入字符为十六进制数字？</li><li>如何显示前50行？</li><li>可以使用多少列创建索引？</li><li>NOW（）和CURRENT_DATE（）有什么区别？</li><li>什么样的对象可以使用CREATE语句创建？</li><li>Mysql表中允许有多少个TRIGGERS？</li><li>什么是非标准字符串类型？</li><li>什么是通用SQL函数？</li><li>解释访问控制列表</li><li>MYSQL支持事务吗？</li><li>mysql里记录货币用什么字段类型好</li><li>MYSQL数据表在什么情况下容易损坏？</li><li>mysql有关权限的表都有哪几个？</li><li>Mysql中有哪几种锁？</li></ol><h3 id="1-一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？"><a href="#1-一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？" class="headerlink" title="1. 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？"></a>1. 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</h3><p>1.如果表的类型是MyISAM，那么是18.因为MyISAM会把自己增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。<br>2.如果表的类型是InnoDB，那么是15.InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。</p><h3 id="2-Mysql的技术特点是什么？"><a href="#2-Mysql的技术特点是什么？" class="headerlink" title="2. Mysql的技术特点是什么？"></a>2. Mysql的技术特点是什么？</h3><p>Mysql数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程SQL服务器. 不同的后端. 广泛的应用程序编程接口和管理工具。</p><h3 id="3-Heap表是什么？"><a href="#3-Heap表是什么？" class="headerlink" title="3. Heap表是什么？"></a>3. Heap表是什么？</h3><p>HEAP表存在于内存中，用于临时高速存储。</p><p>BLOB或TEXT字段是不允许的</p><p>只能使用比较运算符&#x3D;，&lt;，&gt;，&#x3D;&gt;，&#x3D; &lt;</p><p>HEAP表不支持AUTO_INCREMENT</p><p>索引不可为NULL</p><h3 id="4-Mysql服务器默认端口是什么？"><a href="#4-Mysql服务器默认端口是什么？" class="headerlink" title="4. Mysql服务器默认端口是什么？"></a>4. Mysql服务器默认端口是什么？</h3><p>Mysql服务器的默认端口是3306。</p><h3 id="5-与Oracle相比，Mysql有什么优势？"><a href="#5-与Oracle相比，Mysql有什么优势？" class="headerlink" title="5. 与Oracle相比，Mysql有什么优势？"></a>5. 与Oracle相比，Mysql有什么优势？</h3><p>Mysql是开源软件，随时可用，无需付费。</p><p>Mysql是便携式的</p><p>带有命令提示符的GUI。</p><p>使用Mysql查询浏览器支持管理</p><h3 id="6-如何区分FLOAT和DOUBLE？"><a href="#6-如何区分FLOAT和DOUBLE？" class="headerlink" title="6. 如何区分FLOAT和DOUBLE？"></a>6. 如何区分FLOAT和DOUBLE？</h3><p>以下是FLOAT和DOUBLE的区别：</p><p>浮点数以8位精度存储在FLOAT中，并且有四个字节。</p><p>浮点数存储在DOUBLE中，精度为18位，有八个字节。</p><h3 id="7-区分CHAR-LENGTH和LENGTH？"><a href="#7-区分CHAR-LENGTH和LENGTH？" class="headerlink" title="7. 区分CHAR_LENGTH和LENGTH？"></a>7. 区分CHAR_LENGTH和LENGTH？</h3><p>CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。</p><h3 id="8-请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#8-请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="8. 请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>8. 请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>未解决</td><td>未解决</td><td>未解决</td></tr><tr><td>读提交</td><td>解决</td><td>未解决</td><td>未解决</td></tr><tr><td>可重复读</td><td>解决</td><td>解决</td><td>未解决</td></tr><tr><td>串行化</td><td>解决</td><td>解决</td><td>解决</td></tr></tbody></table><p>SQL标准定义的四个隔离级别为：</p><p>read uncommited ：读到未提交数据</p><p>read committed：脏读，不可重复读</p><p>repeatable read：可重读</p><p>serializable ：串行事物<br>详细解释如下：<br>Read Uncommitted（读取未提交内容）<br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br>Read Committed（读取提交内容）<br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br>Repeatable Read（可重读）<br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。<br>Serializable（可串行化）<br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。<br>对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在：</p><ol><li>脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。</li><li>非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。</li><li>幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。<br>不同的隔离级别有不同的现象，并有不同的锁定&#x2F;并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：</li></ol><h3 id="9-在Mysql中ENUM的用法是什么？"><a href="#9-在Mysql中ENUM的用法是什么？" class="headerlink" title="9. 在Mysql中ENUM的用法是什么？"></a>9. 在Mysql中ENUM的用法是什么？</h3><p>ENUM是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。</p><p>Create table size(name ENUM(‘Smail,’Medium’,’Large’));</p><h3 id="10-如何定义REGEXP？"><a href="#10-如何定义REGEXP？" class="headerlink" title="10. 如何定义REGEXP？"></a>10. 如何定义REGEXP？</h3><p>REGEXP是模式匹配，其中匹配模式在搜索值的任何位置。</p><p>REGEXP是一个用于在MySQL中执行正则表达式匹配的操作符。通过使用REGEXP操作符，可以在MySQL查询中使用正则表达式来进行模式匹配和过滤数据。</p><p>下面是REGEXP操作符的基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">expr REGEXP <span class="hljs-keyword">pattern</span><br></code></pre></td></tr></table></figure><ul><li><code>expr</code>：要匹配的表达式或字段。</li><li><code>pattern</code>：正则表达式模式。</li></ul><p>例如，要查找名字以字母”A”开头的所有用户，可以使用如下的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name REGEXP <span class="hljs-string">&#x27;^A&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个查询将返回所有名字以字母”A”开头的用户数据。</p><p>正则表达式提供了强大的模式匹配功能，可以用于各种情况下的数据过滤和匹配操作。MySQL中的REGEXP操作符使得我们可以在查询中利用这些功能来实现更加灵活和复杂的数据查询和处理。</p><h3 id="11-CHAR和VARCHAR的区别？"><a href="#11-CHAR和VARCHAR的区别？" class="headerlink" title="11. CHAR和VARCHAR的区别？"></a>11. CHAR和VARCHAR的区别？</h3><p>以下是CHAR和VARCHAR的区别：</p><p>CHAR和VARCHAR类型在存储和检索方面有所不同</p><p>CHAR列长度固定为创建表时声明的长度，长度值范围是1到255</p><p>当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</p><h3 id="12-列的字符串类型可以是什么？"><a href="#12-列的字符串类型可以是什么？" class="headerlink" title="12. 列的字符串类型可以是什么？"></a>12. 列的字符串类型可以是什么？</h3><p>字符串类型是：</p><p>SET</p><p>BLOB</p><p>ENUM</p><p>CHAR</p><p>TEXT</p><p>VARCHAR</p><h3 id="13-如何获取当前的Mysql版本？"><a href="#13-如何获取当前的Mysql版本？" class="headerlink" title="13. 如何获取当前的Mysql版本？"></a>13. 如何获取当前的Mysql版本？</h3><p>SELECT VERSION();用于获取当前Mysql的版本。</p><h3 id="14-Mysql中使用什么存储引擎？"><a href="#14-Mysql中使用什么存储引擎？" class="headerlink" title="14. Mysql中使用什么存储引擎？"></a>14. Mysql中使用什么存储引擎？</h3><p>存储引擎称为表类型，数据使用各种技术存储在文件中。<br>MySQL支持多种存储引擎，每种引擎都有其自身的特点和用途。在MySQL中，默认的存储引擎是InnoDB，但也支持其他存储引擎，例如MyISAM、MEMORY、CSV等。</p><p>常用的MySQL存储引擎包括：</p><ol><li><p><strong>InnoDB</strong>：支持事务处理和行级锁定，是MySQL默认的存储引擎，适用于大多数应用场景。</p></li><li><p><strong>MyISAM</strong>：不支持事务处理，但提供了高速的读取和全文索引功能，适用于读密集型应用。</p></li><li><p><strong>MEMORY</strong>：将数据存储在内存中，速度非常快，但数据不是持久的，适用于缓存和临时表等场景。</p></li><li><p><strong>CSV</strong>：将数据存储在CSV文件中，适用于数据交换和导入导出。</p></li><li><p><strong>ARCHIVE</strong>：用于存储大量归档数据，支持高压缩比和快速插入。</p></li><li><p><strong>NDB</strong>：用于MySQL Cluster，支持分布式存储和高可用性。</p></li></ol><p>不同的存储引擎具有不同的特点和适用场景，选择合适的存储引擎取决于应用的需求和性能要求。</p><p>技术涉及：</p><p>Storage mechanism</p><p>Locking levels</p><p>Indexing</p><p>Capabilities and functions.</p><h3 id="15-Mysql驱动程序是什么？"><a href="#15-Mysql驱动程序是什么？" class="headerlink" title="15. Mysql驱动程序是什么？"></a>15. Mysql驱动程序是什么？</h3><p>以下是Mysql中可用的驱动程序：</p><p>PHP驱动程序</p><p>JDBC驱动程序</p><p>ODBC驱动程序</p><p>CWRAPPER</p><p>PYTHON驱动程序</p><p>PERL驱动程序</p><p>RUBY驱动程序</p><p>CAP11PHP驱动程序</p><p>Ado.net5.mxj</p><h3 id="16-TIMESTAMP在UPDATE-CURRENT-TIMESTAMP数据类型上做什么？"><a href="#16-TIMESTAMP在UPDATE-CURRENT-TIMESTAMP数据类型上做什么？" class="headerlink" title="16. TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？"></a>16. TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？</h3><p>创建表时TIMESTAMP列用Zero更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP修饰符就将时间戳字段更新为当前时间。</p><h3 id="17-主键和候选键有什么区别？"><a href="#17-主键和候选键有什么区别？" class="headerlink" title="17. 主键和候选键有什么区别？"></a>17. 主键和候选键有什么区别？</h3><p>表格的每一行都由主键唯一标识,一个表只有一个主键。</p><p>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</p><h3 id="18-如何使用Unix-shell登录Mysql？"><a href="#18-如何使用Unix-shell登录Mysql？" class="headerlink" title="18. 如何使用Unix shell登录Mysql？"></a>18. 如何使用Unix shell登录Mysql？</h3><p>我们可以通过以下命令登录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"># [mysql dir]<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>mysql <span class="hljs-operator">-</span>h hostname <span class="hljs-operator">-</span>u <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><h3 id="19-myisamchk是用来做什么的？"><a href="#19-myisamchk是用来做什么的？" class="headerlink" title="19.  myisamchk是用来做什么的？"></a>19.  myisamchk是用来做什么的？</h3><p>它用来压缩MyISAM表，这减少了磁盘或内存使用。</p><h3 id="20-MYSQL数据库服务器性能分析的方法命令有哪些"><a href="#20-MYSQL数据库服务器性能分析的方法命令有哪些" class="headerlink" title="20. MYSQL数据库服务器性能分析的方法命令有哪些?"></a>20. MYSQL数据库服务器性能分析的方法命令有哪些?</h3><p>Show status</p><p>一些值得监控的变量值：</p><p>Bytes_received和Bytes_sent</p><p>和服务器之间来往的流量。</p><p>Com_*服务器正在执行的命令。</p><p>Created_*在查询执行期限间创建的临时表和文件。</p><p>Handler_*存储引擎操作。</p><p>Select_*不同类型的联接执行计划。</p><p>Sort_*几种排序信息。</p><p>Show session status like ‘Select’;</p><p>Show profiles</p><p>SET profiling&#x3D;1;</p><p>Show profiles \G</p><p>Show profile;</p><p>在MySQL中，你可以使用多种方法和命令来进行数据库服务器性能分析。以下是一些常用的方法和相关的命令：</p><ol><li><p><strong>SHOW STATUS</strong>：显示当前MySQL服务器的各种状态信息，包括连接数、查询数、缓存命中率等。可以通过查看这些状态信息来了解服务器的整体性能情况。</p></li><li><p><strong>SHOW PROCESSLIST</strong>：显示当前运行的所有MySQL进程，包括查询、连接等信息。通过查看当前进程列表，可以了解哪些查询正在执行，以及它们的状态和执行时间等信息。</p></li><li><p><strong>EXPLAIN</strong>：用于分析查询语句的执行计划。通过执行<code>EXPLAIN</code>命令，可以查看查询语句的执行计划，了解MySQL是如何执行查询的，以及是否使用了索引等信息。</p></li><li><p><strong>MySQL Performance Schema</strong>：MySQL Performance Schema是MySQL提供的一种性能监控和分析工具，可以用于收集和分析MySQL服务器的性能数据。通过分析Performance Schema中的各种性能指标和事件，可以更详细地了解MySQL服务器的性能状况。</p></li><li><p><strong>MySQL Slow Query Log</strong>：MySQL Slow Query Log是MySQL提供的一种记录慢查询的功能。通过启用Slow Query Log，并设置合适的阈值，可以记录下执行时间超过一定阈值的查询语句，从而帮助找出潜在的性能问题。</p></li><li><p><strong>MySQL Workbench Performance Dashboard</strong>：MySQL Workbench是MySQL官方提供的图形化管理工具，其中包含了Performance Dashboard功能，可以用于实时监控和分析MySQL服务器的性能数据，包括连接数、查询执行时间、缓存命中率等。</p></li><li><p><strong>Percona Toolkit</strong>：Percona Toolkit是一个由Percona提供的一组MySQL管理和监控工具，其中包含了一些用于性能分析的工具，例如pt-query-digest、pt-stalk等，可以用于分析慢查询、监控服务器性能等。</p></li></ol><p>这些方法和命令可以帮助你对MySQL数据库服务器的性能进行分析和监控，从而找出潜在的性能问题，并进行优化和调整。</p><h3 id="21-如何控制HEAP表的最大尺寸？"><a href="#21-如何控制HEAP表的最大尺寸？" class="headerlink" title="21. 如何控制HEAP表的最大尺寸？"></a>21. 如何控制HEAP表的最大尺寸？</h3><p>Heal表的大小可通过称为max_heap_table_size的Mysql配置变量来控制。</p><h3 id="22-MyISAM-Static和MyISAM-Dynamic有什么区别？"><a href="#22-MyISAM-Static和MyISAM-Dynamic有什么区别？" class="headerlink" title="22. MyISAM Static和MyISAM Dynamic有什么区别？"></a>22. MyISAM Static和MyISAM Dynamic有什么区别？</h3><p>在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。</p><p>MyISAM Static在受损情况下更容易恢复。</p><h3 id="23-federated表是什么？"><a href="#23-federated表是什么？" class="headerlink" title="23. federated表是什么？"></a>23. federated表是什么？</h3><p>federated表，允许访问位于其他服务器数据库上的表。</p><h3 id="24-如果一个表有一列定义为TIMESTAMP，将发生什么？"><a href="#24-如果一个表有一列定义为TIMESTAMP，将发生什么？" class="headerlink" title="24. 如果一个表有一列定义为TIMESTAMP，将发生什么？"></a>24. 如果一个表有一列定义为TIMESTAMP，将发生什么？</h3><p>每当行被更改时，时间戳字段将获取当前时间戳。</p><h3 id="25-列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#25-列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="25. 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>25. 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h3><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p><h3 id="26-怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#26-怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="26. 怎样才能找出最后一次插入时分配了哪个自动增量？"></a>26. 怎样才能找出最后一次插入时分配了哪个自动增量？</h3><p>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</p><h3 id="27-你怎么看到为表格定义的所有索引？"><a href="#27-你怎么看到为表格定义的所有索引？" class="headerlink" title="27. 你怎么看到为表格定义的所有索引？"></a>27. 你怎么看到为表格定义的所有索引？</h3><p>索引是通过以下方式为表格定义的：</p><p>SHOW INDEX FROM ;</p><h3 id="28-LIKE声明中的％和-是什么意思？"><a href="#28-LIKE声明中的％和-是什么意思？" class="headerlink" title="28.. LIKE声明中的％和_是什么意思？"></a>28.. LIKE声明中的％和_是什么意思？</h3><p>％对应于0个或更多字符，_ 只是LIKE语句中的一个字符。</p><h3 id="29-如何在Unix和Mysql时间戳之间进行转换？"><a href="#29-如何在Unix和Mysql时间戳之间进行转换？" class="headerlink" title="29. 如何在Unix和Mysql时间戳之间进行转换？"></a>29. 如何在Unix和Mysql时间戳之间进行转换？</h3><p>UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令</p><p>FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令</p><h3 id="30-列对比运算符是什么？"><a href="#30-列对比运算符是什么？" class="headerlink" title="30. 列对比运算符是什么？"></a>30. 列对比运算符是什么？</h3><p>在SELECT语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND，OR或LIKE运算符。</p><h3 id="31-我们如何得到受查询影响的行数？"><a href="#31-我们如何得到受查询影响的行数？" class="headerlink" title="31. 我们如何得到受查询影响的行数？"></a>31. 我们如何得到受查询影响的行数？</h3><p>行数可以通过以下代码获得：</p><p>SELECT COUNT(user_id)FROM users;</p><h3 id="32-Mysql查询是否区分大小写？"><a href="#32-Mysql查询是否区分大小写？" class="headerlink" title="32. Mysql查询是否区分大小写？"></a>32. Mysql查询是否区分大小写？</h3><p>不区分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> VERSION(), <span class="hljs-built_in">CURRENT_DATE</span>;<br><br><span class="hljs-keyword">SeLect</span> version(), <span class="hljs-built_in">current_date</span>;<br><br><span class="hljs-keyword">seleCt</span> vErSiOn(), <span class="hljs-built_in">current_DATE</span>;<br></code></pre></td></tr></table></figure><p>所有这些例子都是一样的，Mysql不区分大小写。</p><h3 id="33-LIKE和REGEXP操作有什么区别？"><a href="#33-LIKE和REGEXP操作有什么区别？" class="headerlink" title="33.. LIKE和REGEXP操作有什么区别？"></a>33.. LIKE和REGEXP操作有什么区别？</h3><p>LIKE和REGEXP运算符用于表示^和％。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> emp_name <span class="hljs-keyword">LIKE</span> &quot;%b&quot;;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> emp_name REGEXP &quot;^b&quot;;<br></code></pre></td></tr></table></figure><h3 id="34-BLOB和TEXT有什么区别？"><a href="#34-BLOB和TEXT有什么区别？" class="headerlink" title="34.. BLOB和TEXT有什么区别？"></a>34.. BLOB和TEXT有什么区别？</h3><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB -</p><p>TINYBLOB</p><p>BLOB</p><p>MEDIUMBLOB和</p><p>LONGBLOB</p><p>它们只能在所能容纳价值的最大长度上有所不同。</p><p>TEXT是一个不区分大小写的BLOB。四种TEXT类型</p><p>TINYTEXT</p><p>TEXT</p><p>MEDIUMTEXT和</p><p>LONGTEXT</p><p>它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。</p><p>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</p><h3 id="35-mysql-fetch-array和mysql-fetch-object的区别是什么？"><a href="#35-mysql-fetch-array和mysql-fetch-object的区别是什么？" class="headerlink" title="35. mysql_fetch_array和mysql_fetch_object的区别是什么？"></a>35. mysql_fetch_array和mysql_fetch_object的区别是什么？</h3><p>以下是mysql_fetch_array和mysql_fetch_object的区别：</p><ul><li><p>mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。</p></li><li><p>mysql_fetch_object - 从数据库返回结果行作为对象。</p></li></ul><h3 id="36-我们如何在mysql中运行批处理模式？"><a href="#36-我们如何在mysql中运行批处理模式？" class="headerlink" title="36. 我们如何在mysql中运行批处理模式？"></a>36. 我们如何在mysql中运行批处理模式？</h3><p>以下命令用于在批处理模式下运行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql;<br><br>mysql mysql.out<br></code></pre></td></tr></table></figure><h3 id="37-MyISAM表格将在哪里存储，并且还提供其存储格式？"><a href="#37-MyISAM表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="37. MyISAM表格将在哪里存储，并且还提供其存储格式？"></a>37. MyISAM表格将在哪里存储，并且还提供其存储格式？</h3><p>每个MyISAM表格以三种格式存储在磁盘上：</p><p>·“.frm”文件存储表定义</p><p>·数据文件具有“.MYD”（MYData）扩展名</p><p>索引文件具有“.MYI”（MYIndex）扩展名</p><h3 id="38-Mysql中有哪些不同的表格？"><a href="#38-Mysql中有哪些不同的表格？" class="headerlink" title="38. Mysql中有哪些不同的表格？"></a>38. Mysql中有哪些不同的表格？</h3><p>共有5种类型的表格：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coq">MyISAM<br><br><span class="hljs-keyword">Heap</span><br><br>Merge<br><br>INNODB<br><br>ISAM<br></code></pre></td></tr></table></figure><p>MyISAM是Mysql的默认存储引擎。</p><h3 id="39-ISAM是什么？"><a href="#39-ISAM是什么？" class="headerlink" title="39. ISAM是什么？"></a>39. ISAM是什么？</h3><p>ISAM简称为索引顺序访问方法。它是由IBM开发的，用于在磁带等辅助存储系统上存储和检索数据。</p><h3 id="40-InnoDB是什么？"><a href="#40-InnoDB是什么？" class="headerlink" title="40. InnoDB是什么？"></a>40. InnoDB是什么？</h3><p>lnnoDB是一个由Oracle公司开发的Innobase Oy事务安全存储引擎。</p><h3 id="41-Mysql如何优化DISTINCT？"><a href="#41-Mysql如何优化DISTINCT？" class="headerlink" title="41. Mysql如何优化DISTINCT？"></a>41. Mysql如何优化DISTINCT？</h3><p>DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> t1.a <span class="hljs-keyword">FROM</span> t1,t2 <span class="hljs-keyword">where</span> t1.a<span class="hljs-operator">=</span>t2.a;<br></code></pre></td></tr></table></figure><h3 id="42-如何输入字符为十六进制数字？"><a href="#42-如何输入字符为十六进制数字？" class="headerlink" title="42. 如何输入字符为十六进制数字？"></a>42. 如何输入字符为十六进制数字？</h3><p>如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。</p><p>如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。</p><h3 id="43-如何显示前50行？"><a href="#43-如何显示前50行？" class="headerlink" title="43. 如何显示前50行？"></a>43. 如何显示前50行？</h3><p>在Mysql中，使用以下代码查询显示前50行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span><br><br>LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><h3 id="44-可以使用多少列创建索引？"><a href="#44-可以使用多少列创建索引？" class="headerlink" title="44. 可以使用多少列创建索引？"></a>44. 可以使用多少列创建索引？</h3><p>任何标准表最多可以创建16个索引列。</p><h3 id="45-NOW（）和CURRENT-DATE（）有什么区别？"><a href="#45-NOW（）和CURRENT-DATE（）有什么区别？" class="headerlink" title="45. NOW（）和CURRENT_DATE（）有什么区别？"></a>45. NOW（）和CURRENT_DATE（）有什么区别？</h3><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。</p><p>CURRENT_DATE（）仅显示当前年份，月份和日期。</p><h3 id="46-什么样的对象可以使用CREATE语句创建？"><a href="#46-什么样的对象可以使用CREATE语句创建？" class="headerlink" title="46. 什么样的对象可以使用CREATE语句创建？"></a>46. 什么样的对象可以使用CREATE语句创建？</h3><p>以下对象是使用CREATE语句创建的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DATABASE</span><br><br>EVENT<br><br><span class="hljs-keyword">FUNCTION</span><br><br><span class="hljs-keyword">INDEX</span><br><br><span class="hljs-keyword">PROCEDURE</span><br><br><span class="hljs-keyword">TABLE</span><br><br><span class="hljs-keyword">TRIGGER</span><br><br><span class="hljs-keyword">USER</span><br><br><span class="hljs-keyword">VIEW</span><br></code></pre></td></tr></table></figure><h3 id="47-Mysql表中允许有多少个TRIGGERS？"><a href="#47-Mysql表中允许有多少个TRIGGERS？" class="headerlink" title="47. Mysql表中允许有多少个TRIGGERS？"></a>47. Mysql表中允许有多少个TRIGGERS？</h3><p>在Mysql表中允许有六个触发器，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">INSERT</span><br><br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span><br><br><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">UPDATE</span><br><br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">UPDATE</span><br><br><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">DELETE</span><br><br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">DELETE</span><br></code></pre></td></tr></table></figure><h3 id="48-什么是非标准字符串类型？"><a href="#48-什么是非标准字符串类型？" class="headerlink" title="48. 什么是非标准字符串类型？"></a>48. 什么是非标准字符串类型？</h3><p>以下是非标准字符串类型：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">TINYTEXT<br><br><span class="hljs-built_in">TEXT</span><br><br>MEDIUMTEXT<br><br>LONGTEXT<br></code></pre></td></tr></table></figure><h3 id="49-什么是通用SQL函数？"><a href="#49-什么是通用SQL函数？" class="headerlink" title="49. 什么是通用SQL函数？"></a>49. 什么是通用SQL函数？</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade">CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。<br><br>FORMAT(X, D)- 格式化数字X到D有效数字。<br><br>CURRDATE(), CURRTIME()- 返回当前日期或时间。<br><br><span class="hljs-built_in">NOW</span>（） - 将当前日期和时间作为一个值返回。<br><br><span class="hljs-built_in">MONTH</span>（），<span class="hljs-built_in">DAY</span>（），<span class="hljs-built_in">YEAR</span>（），<span class="hljs-built_in">WEEK</span>（），<span class="hljs-built_in">WEEKDAY</span>（） - 从日期值中提取给定数据。<br><br><span class="hljs-built_in">HOUR</span>（），<span class="hljs-built_in">MINUTE</span>（），<span class="hljs-built_in">SECOND</span>（） - 从时间值中提取给定数据。<br><br><span class="hljs-built_in">DATEDIFF</span>（A，B） - 确定两个日期之间的差异，通常用于计算年龄<br><br>SUBTIMES（A，B） - 确定两次之间的差异。<br><br>FROMDAYS（INT） - 将整数天数转换为日期值。<br></code></pre></td></tr></table></figure><h3 id="50-解释访问控制列表"><a href="#50-解释访问控制列表" class="headerlink" title="50. 解释访问控制列表"></a>50. 解释访问控制列表</h3><p>ACL（访问控制列表）是与对象关联的权限列表。这个列表是Mysql服务器安全模型的基础，它有助于排除用户无法连接的问题。</p><p>Mysql将ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql会按照预定的顺序检查ACL的认证信息和权限。</p><h3 id="51-MYSQL支持事务吗？"><a href="#51-MYSQL支持事务吗？" class="headerlink" title="51. MYSQL支持事务吗？"></a>51. MYSQL支持事务吗？</h3><p>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。</p><p>但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT&#x3D;0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。</p><p>示例如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">一<br><br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><br><span class="hljs-keyword">SELECT</span> @A:=SUM(salary) <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span>=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">UPDATE</span> table2 <span class="hljs-keyword">SET</span> summmary=@A <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span>=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="52-mysql里记录货币用什么字段类型好"><a href="#52-mysql里记录货币用什么字段类型好" class="headerlink" title="52.  mysql里记录货币用什么字段类型好"></a>52.  mysql里记录货币用什么字段类型好</h3><p>NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。</p><p>例如：</p><p>salary DECIMAL(9,2)</p><p>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。</p><p>因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI&#x2F;ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。</p><p>同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。Mysql当前不支持DECIMAL&#x2F;NUMERIC数据类型的这些变种形式的任一种。</p><p>这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。</p><p>DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</p><p>一个字符用于值的每一位. 小数点(如果scale&gt;0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。</p><p>DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。</p><p>当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。</p><p>当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，Mysql存储表示那个范围的相应的端点值。</p><p>我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。</p><h3 id="53-MYSQL数据表在什么情况下容易损坏？"><a href="#53-MYSQL数据表在什么情况下容易损坏？" class="headerlink" title="53. MYSQL数据表在什么情况下容易损坏？"></a>53. MYSQL数据表在什么情况下容易损坏？</h3><p>服务器突然断电导致数据文件损坏。</p><p>强制关机，没有先关闭 mysql 服务等。</p><h3 id="54-mysql有关权限的表都有哪几个？"><a href="#54-mysql有关权限的表都有哪几个？" class="headerlink" title="54. mysql有关权限的表都有哪几个？"></a>54. mysql有关权限的表都有哪几个？</h3><p>Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。</p><h3 id="55-Mysql中有哪几种锁？"><a href="#55-Mysql中有哪几种锁？" class="headerlink" title="55. Mysql中有哪几种锁？"></a>55. Mysql中有哪几种锁？</h3><p>MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁。</p><ul><li><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低</p></li><li><p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试合集搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搬运自用-大数据面试题合集</title>
    <link href="/2024/05/07/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2024/05/07/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>因为zjt老是把我叫走吃夜宵害我没空看面试所以存档一份。</p><h1 id="大数据面试题及答案"><a href="#大数据面试题及答案" class="headerlink" title="大数据面试题及答案"></a>大数据面试题及答案</h1><ul><li><p><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88">大数据面试题及答案</a></p><ul><li><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88-1">大数据面试题及答案</a><ul><li><a href="#1-kafka%E7%9A%84message%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF">1 kafka的message包括哪些信息</a></li><li><a href="#2-%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8Bkafka%E7%9A%84offset">2 怎么查看kafka的offset</a></li><li><a href="#3-hadoop%E7%9A%84shuffle%E8%BF%87%E7%A8%8B">3 hadoop的shuffle过程</a><ul><li><a href="#%E4%B8%80map%E7%AB%AF%E7%9A%84shuffle">一、Map端的shuffle</a></li><li><a href="#%E4%BA%8Creduce%E7%AB%AF%E7%9A%84shuffle">二、Reduce端的shuffle</a></li></ul></li><li><a href="#4-spark%E9%9B%86%E7%BE%A4%E8%BF%90%E7%AE%97%E7%9A%84%E6%A8%A1%E5%BC%8F">4 spark集群运算的模式</a></li><li><a href="#5-hdfs%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B">5 HDFS读写数据的过程</a></li><li><a href="#6-rdd%E4%B8%ADreducebykey%E4%B8%8Egroupbykey%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E5%A5%BD%E4%B8%BA%E4%BB%80%E4%B9%88">6 RDD中reduceBykey与groupByKey哪个性能好，为什么</a></li><li><a href="#7-spark20%E7%9A%84%E4%BA%86%E8%A7%A3">7 spark2.0的了解</a></li><li><a href="#8-rdd-%E6%80%8E%E4%B9%88%E5%88%86%E5%8C%BA%E5%AE%BD%E4%BE%9D%E8%B5%96%E5%92%8C%E7%AA%84%E4%BE%9D%E8%B5%96">8 rdd 怎么分区宽依赖和窄依赖</a></li><li><a href="#9-spark-streaming-%E8%AF%BB%E5%8F%96kafka%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">9 spark streaming 读取kafka数据的两种方式</a><ul><li><a href="#receiver-base">Receiver-base</a><ul><li><a href="#direct">Direct</a></li></ul></li></ul></li><li><a href="#10-kafka%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E7%A3%81%E7%9B%98">10 kafka的数据存在内存还是磁盘</a></li><li><a href="#11-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3kafka%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">11 怎么解决kafka的数据丢失</a></li><li><a href="#12-fsimage%E5%92%8Cedit%E7%9A%84%E5%8C%BA%E5%88%AB">12 fsimage和edit的区别？</a></li><li><a href="#13-%E5%88%97%E4%B8%BE%E5%87%A0%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">13 列举几个配置文件优化？</a></li><li><a href="#14-datanode-%E9%A6%96%E6%AC%A1%E5%8A%A0%E5%85%A5-cluster-%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E6%9E%9C-log-%E6%8A%A5%E5%91%8A%E4%B8%8D%E5%85%BC%E5%AE%B9%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E9%82%A3%E9%9C%80%E8%A6%81namenode%E6%89%A7%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%93%8D%E4%BD%9C%E8%BF%99%E6%A0%B7%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF">14 datanode 首次加入 cluster 的时候，如果 log 报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？</a></li><li><a href="#15-mapreduce-%E4%B8%AD%E6%8E%92%E5%BA%8F%E5%8F%91%E7%94%9F%E5%9C%A8%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%BF%99%E4%BA%9B%E6%8E%92%E5%BA%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BB%80%E4%B9%88">15 MapReduce 中排序发生在哪几个阶段？这些排序是否可以避免？为什么？</a></li><li><a href="#16-hadoop%E7%9A%84%E4%BC%98%E5%8C%96">16 hadoop的优化？</a></li><li><a href="#17-%E8%AE%BE%E8%AE%A1%E9%A2%98">17 设计题</a></li><li><a href="#18-%E6%9C%89-10-%E4%B8%AA%E6%96%87%E4%BB%B6%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6-1g%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E5%AD%98%E6%94%BE%E7%9A%84%E9%83%BD%E6%98%AF%E7%94%A8%E6%88%B7%E7%9A%84-query%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84query-%E9%83%BD%E5%8F%AF%E8%83%BD%E9%87%8D%E5%A4%8D%E8%A6%81%E6%B1%82%E4%BD%A0%E6%8C%89%E7%85%A7-query-%E7%9A%84%E9%A2%91%E5%BA%A6%E6%8E%92%E5%BA%8F%E8%BF%98%E6%98%AF%E5%85%B8%E5%9E%8B%E7%9A%84-top-k-%E7%AE%97%E6%B3%95">18 有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的query 都可能重复。要求你按照 query 的频度排序。还是典型的 TOP K 算法</a></li><li><a href="#19-%E5%9C%A825%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B4%E6%95%B0%E6%B3%A8%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E4%BB%A5%E5%AE%B9%E7%BA%B3%E8%BF%9925%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0">19 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</a></li><li><a href="#20-%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BB%9940%E4%BA%BF%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84-unsigned-int-%E7%9A%84%E6%95%B4%E6%95%B0%E6%B2%A1%E6%8E%92%E8%BF%87%E5%BA%8F%E7%9A%84%E7%84%B6%E5%90%8E%E5%86%8D%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E8%BF%99%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E5%9C%A8%E9%82%A3-40-%E4%BA%BF%E4%B8%AA%E6%95%B0%E5%BD%93%E4%B8%AD">20 腾讯面试题：给40亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</a></li><li><a href="#21-%E6%80%8E%E4%B9%88%E5%9C%A8%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%80%E4%B8%AA">21 怎么在海量数据中找出重复次数最多的一个？</a></li><li><a href="#22-%E4%B8%8A%E5%8D%83%E4%B8%87%E6%88%96%E4%B8%8A%E4%BA%BF%E6%95%B0%E6%8D%AE%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%9F%E8%AE%A1%E5%85%B6%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E9%92%B1-n-%E4%B8%AA%E6%95%B0%E6%8D%AE">22 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。</a></li><li><a href="#23-%E4%B8%80%E4%B8%AA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%A7%E7%BA%A6%E6%9C%89%E4%B8%80%E4%B8%87%E8%A1%8C%E6%AF%8F%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%AF%8D%E8%A6%81%E6%B1%82%E7%BB%9F%E8%AE%A1%E5%87%BA%E5%85%B6%E4%B8%AD%E6%9C%80%E9%A2%91%E7%B9%81%E5%87%BA%E7%8E%B0%E7%9A%84%E5%89%8D-10-%E4%B8%AA%E8%AF%8D%E7%BB%99%E5%87%BA%E6%80%9D%E6%83%B3%E7%BB%99%E5%87%BA%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">23 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，给出思想，给出时间复杂度分析。</a></li><li><a href="#24-100w-%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%84-100-%E4%B8%AA%E6%95%B0">24 100w 个数中找出最大的 100 个数。</a></li><li><a href="#25-%E6%9C%89%E4%B8%80%E5%8D%83%E4%B8%87%E6%9D%A1%E7%9F%AD%E4%BF%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E4%BB%A5%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%BD%A2%E5%BC%8F%E4%BF%9D%E5%AD%98%E4%B8%80%E8%A1%8C%E4%B8%80%E6%9D%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E8%AF%B7%E7%94%A8-5-%E5%88%86%E9%92%9F%E6%97%B6%E9%97%B4%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D-10-%E6%9D%A1">25 有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用 5 分钟时间，找出重复出现最多的前 10 条。</a></li></ul></li></ul><h2 id="大数据面试题及答案-1"><a href="#大数据面试题及答案-1" class="headerlink" title="大数据面试题及答案"></a>大数据面试题及答案</h2><h3 id="1-kafka的message包括哪些信息"><a href="#1-kafka的message包括哪些信息" class="headerlink" title="1 kafka的message包括哪些信息"></a>1 kafka的message包括哪些信息</h3><p> 一个Kafka的Message由一个固定长度的header和一个变长的消息体body组成<br> header部分由一个字节的magic(文件格式)和四个字节的CRC32(用于判断body消息体是否正常)构成。当magic的值为1的时候，会在magic和crc32之间多一个字节的数据：attributes(保存一些相关属性，比如是否压缩、压缩格式等等)；如果magic的值为0，那么不存在attributes属性<br> body是由N个字节构成的一个消息体，包含了具体的key&#x2F;value消息</p><h3 id="2-怎么查看kafka的offset"><a href="#2-怎么查看kafka的offset" class="headerlink" title="2 怎么查看kafka的offset"></a>2 怎么查看kafka的offset</h3><p> 0.9版本以上，可以用最新的Consumer client 客户端，有consumer.seekToEnd() &#x2F; consumer.position() 可以用于得到当前最新的offset：</p><h3 id="3-hadoop的shuffle过程"><a href="#3-hadoop的shuffle过程" class="headerlink" title="3 hadoop的shuffle过程"></a>3 hadoop的shuffle过程</h3><h4 id="一、Map端的shuffle"><a href="#一、Map端的shuffle" class="headerlink" title="一、Map端的shuffle"></a>一、Map端的shuffle</h4><p> 　　Map端会处理输入数据并产生中间结果，这个中间结果会写到本地磁盘，而不是HDFS。每个Map的输出会先写到内存缓冲区中，当写入的数据达到设定的阈值时，系统将会启动一个线程将缓冲区的数据写到磁盘，这个过程叫做spill。<br> 　　在spill写入之前，会先进行二次排序，首先根据数据所属的partition进行排序，然后每个partition中的数据再按key来排序。partition的目是将记录划分到不同的Reducer上去，以期望能够达到负载均衡，以后的Reducer就会根据partition来读取自己对应的数据。接着运行combiner(如果设置了的话)，combiner的本质也是一个Reducer，其目的是对将要写入到磁盘上的文件先进行一次处理，这样，写入到磁盘的数据量就会减少。最后将数据写到本地磁盘产生spill文件(spill文件保存在{mapred.local.dir}指定的目录中，Map任务结束后就会被删除)。</p><p> 　　最后，每个Map任务可能产生多个spill文件，在每个Map任务完成前，会通过多路归并算法将这些spill文件归并成一个文件。至此，Map的shuffle过程就结束了。</p><h4 id="二、Reduce端的shuffle"><a href="#二、Reduce端的shuffle" class="headerlink" title="二、Reduce端的shuffle"></a>二、Reduce端的shuffle</h4><p> 　　Reduce端的shuffle主要包括三个阶段，copy、sort(merge)和reduce。<br> 　　首先要将Map端产生的输出文件拷贝到Reduce端，但每个Reducer如何知道自己应该处理哪些数据呢？因为Map端进行partition的时候，实际上就相当于指定了每个Reducer要处理的数据(partition就对应了Reducer)，所以Reducer在拷贝数据的时候只需拷贝与自己对应的partition中的数据即可。每个Reducer会处理一个或者多个partition，但需要先将自己对应的partition中的数据从每个Map的输出结果中拷贝过来。<br> 　　接下来就是sort阶段，也成为merge阶段，因为这个阶段的主要工作是执行了归并排序。从Map端拷贝到Reduce端的数据都是有序的，所以很适合归并排序。最终在Reduce端生成一个较大的文件作为Reduce的输入。</p><p> 　　最后就是Reduce过程了，在这个过程中产生了最终的输出结果，并将其写到HDFS上。</p><h3 id="4-spark集群运算的模式"><a href="#4-spark集群运算的模式" class="headerlink" title="4 spark集群运算的模式"></a>4 spark集群运算的模式</h3><p> Spark 有很多种模式，最简单就是单机本地模式，还有单机伪分布式模式，复杂的则运行在集群中，目前能很好的运行在 Yarn和 Mesos 中，当然 Spark 还有自带的 Standalone 模式，对于大多数情况 Standalone 模式就足够了，如果企业已经有 Yarn 或者 Mesos 环境，也是很方便部署的。<br> standalone(集群模式)：典型的Mater&#x2F;slave模式，不过也能看出Master是有单点故障的；Spark支持ZooKeeper来实现 HA<br> on yarn(集群模式)： 运行在 yarn 资源管理器框架之上，由 yarn 负责资源管理，Spark 负责任务调度和计算<br> on mesos(集群模式)： 运行在 mesos 资源管理器框架之上，由 mesos 负责资源管理，Spark 负责任务调度和计算<br> on cloud(集群模式)：比如 AWS 的 EC2，使用这个模式能很方便的访问 Amazon的 S3;Spark 支持多种分布式存储系统：HDFS 和 S3</p><h3 id="5-HDFS读写数据的过程"><a href="#5-HDFS读写数据的过程" class="headerlink" title="5 HDFS读写数据的过程"></a>5 HDFS读写数据的过程</h3><p> <strong>读：</strong><br> 1、跟namenode通信查询元数据，找到文件块所在的datanode服务器<br> 2、挑选一台datanode（就近原则，然后随机）服务器，请求建立socket流<br> 3、datanode开始发送数据（从磁盘里面读取数据放入流，以packet为单位来做校验）<br> 4、客户端以packet为单位接收，现在本地缓存，然后写入目标文件<br> <img src="https://abumaster.oss-cn-beijing.aliyuncs.com/img/fix-dir/2021/08/29/17-19-32124c8fda5fcebef7af66ce6b384f8e-20210829171928-9cce98.png" alt="HDFS读流程"></p><p> <strong>写：</strong><br> 1、根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在<br> 2、namenode返回是否可以上传<br> 3、client请求第一个 block该传输到哪些datanode服务器上<br> 4、namenode返回3个datanode服务器ABC<br> 5、client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将真个pipeline建立完成，逐级返回客户端<br> 6、client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答<br> 7、当一个block传输完成之后，client再次请求namenode上传第二个block的服务器。<br> <img src="https://abumaster.oss-cn-beijing.aliyuncs.com/img/fix-dir/2021/08/29/17-29-03c90c9fb9679c5b96cde953eb36c97d-20210829172955-4f3dd5.png" alt="HDFS写流程"></p><h3 id="6-RDD中reduceBykey与groupByKey哪个性能好，为什么"><a href="#6-RDD中reduceBykey与groupByKey哪个性能好，为什么" class="headerlink" title="6 RDD中reduceBykey与groupByKey哪个性能好，为什么"></a>6 RDD中reduceBykey与groupByKey哪个性能好，为什么</h3><pre><code class="hljs"> reduceByKey：reduceByKey会在结果发送至reducer之前会对每个mapper在本地进行merge，有点类似于在MapReduce中的combiner。这样做的好处在于，在map端进行一次reduce之后，数据量会大幅度减小，从而减小传输，保证reduce端能够更快的进行结果计算。 groupByKey：groupByKey会对每一个RDD中的value值进行聚合形成一个序列(Iterator)，此操作发生在reduce端，所以势必会将所有的数据通过网络进行传输，造成不必要的浪费。同时如果数据量十分大，可能还会造成OutOfMemoryError。</code></pre><p>  通过以上对比可以发现在进行大量数据的reduce操作时候建议使用reduceByKey。不仅可以提高速度，还是可以防止使用groupByKey造成的内存溢出问题。</p><h3 id="7-spark2-0的了解"><a href="#7-spark2-0的了解" class="headerlink" title="7 spark2.0的了解"></a>7 spark2.0的了解</h3><pre><code class="hljs"> 更简单：ANSI SQL与更合理的API 速度更快：用Spark作为编译器 更智能：Structured Streaming</code></pre><h3 id="8-rdd-怎么分区宽依赖和窄依赖"><a href="#8-rdd-怎么分区宽依赖和窄依赖" class="headerlink" title="8 rdd 怎么分区宽依赖和窄依赖"></a>8 rdd 怎么分区宽依赖和窄依赖</h3><p> 宽依赖：父RDD的分区被子RDD的多个分区使用   例如 groupByKey、reduceByKey、sortByKey等操作会产生宽依赖，会产生shuffle<br> 窄依赖：父RDD的每个分区都只被子RDD的一个分区使用  例如map、filter、union等操作会产生窄依赖</p><h3 id="9-spark-streaming-读取kafka数据的两种方式"><a href="#9-spark-streaming-读取kafka数据的两种方式" class="headerlink" title="9 spark streaming 读取kafka数据的两种方式"></a>9 spark streaming 读取kafka数据的两种方式</h3><p> 这两种方式分别是：</p><h4 id="Receiver-base"><a href="#Receiver-base" class="headerlink" title="Receiver-base"></a>Receiver-base</h4><p> 使用Kafka的高层次Consumer API来实现。receiver从Kafka中获取的数据都存储在Spark Executor的内存中，然后Spark Streaming启动的job会去处理那些数据。然而，在默认的配置下，这种方式可能会因为底层的失败而丢失数据。如果要启用高可靠机制，让数据零丢失，就必须启用Spark Streaming的预写日志机制（Write Ahead Log，WAL）。该机制会同步地将接收到的Kafka数据写入分布式文件系统（比如HDFS）上的预写日志中。所以，即使底层节点出现了失败，也可以使用预写日志中的数据进行恢复。</p><h5 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h5><p> Spark1.3中引入Direct方式，用来替代掉使用Receiver接收数据，这种方式会周期性地查询Kafka，获得每个topic+partition的最新的offset，从而定义每个batch的offset的范围。当处理数据的job启动时，就会使用Kafka的简单consumer api来获取Kafka指定offset范围的数据。</p><h3 id="10-kafka的数据存在内存还是磁盘"><a href="#10-kafka的数据存在内存还是磁盘" class="headerlink" title="10 kafka的数据存在内存还是磁盘"></a>10 kafka的数据存在内存还是磁盘</h3><p> Kafka最核心的思想是使用磁盘，而不是使用内存，可能所有人都会认为，内存的速度一定比磁盘快，我也不例外。在看了Kafka的设计思想，查阅了相应资料再加上自己的测试后，发现磁盘的顺序读写速度和内存持平。<br> 而且Linux对于磁盘的读写优化也比较多，包括read-ahead和write-behind，磁盘缓存等。如果在内存做这些操作的时候，一个是JAVA对象的内存开销很大，另一个是随着堆内存数据的增多，JAVA的GC时间会变得很长，使用磁盘操作有以下几个好处：<br> 磁盘缓存由Linux系统维护，减少了程序员的不少工作。<br> 磁盘顺序读写速度超过内存随机读写。<br> JVM的GC效率低，内存占用大。使用磁盘可以避免这一问题。<br> 系统冷启动后，磁盘缓存依然可用。</p><h3 id="11-怎么解决kafka的数据丢失"><a href="#11-怎么解决kafka的数据丢失" class="headerlink" title="11 怎么解决kafka的数据丢失"></a>11 怎么解决kafka的数据丢失</h3><p> producer端：<br> 宏观上看保证数据的可靠安全性，肯定是依据分区数做好数据备份，设立副本数。<br> broker端：<br> topic设置多分区，分区自适应所在机器，为了让各分区均匀分布在所在的broker中，分区数要大于broker数。<br> 分区是kafka进行并行读写的单位，是提升kafka速度的关键。<br> Consumer端<br> consumer端丢失消息的情形比较简单：如果在消息处理完成前就提交了offset，那么就有可能造成数据的丢失。由于Kafka consumer默认是自动提交位移的，所以在后台提交位移前一定要保证消息被正常处理了，因此不建议采用很重的处理逻辑，如果处理耗时很长，则建议把逻辑放到另一个线程中去做。为了避免数据丢失，现给出两点建议：<br> enable.auto.commit&#x3D;false  关闭自动提交位移<br> 在消息被完整处理之后再手动提交位移</p><h3 id="12-fsimage和edit的区别？"><a href="#12-fsimage和edit的区别？" class="headerlink" title="12 fsimage和edit的区别？"></a>12 fsimage和edit的区别？</h3><p>   大家都知道namenode与secondary namenode 的关系，当他们要进行数据同步时叫做checkpoint时就用到了fsimage与edit，fsimage是保存最新的元数据的信息，当fsimage数据到一定的大小事会去生成一个新的文件来保存元数据的信息，这个新的文件就是edit，edit会回滚最新的数据。</p><h3 id="13-列举几个配置文件优化？"><a href="#13-列举几个配置文件优化？" class="headerlink" title="13 列举几个配置文件优化？"></a>13 列举几个配置文件优化？</h3><p>   1）Core-site.xml 文件的优化<br>     a、fs.trash.interval，默认值： 0；说明： 这个是开启hdfs文件删除自动转移到垃圾箱的选项，值为垃圾箱文件清除时间。一般开启这个会比较好，以防错误删除重要文件。单位是分钟。<br>     b、dfs.namenode.handler.count，默认值：10；说明：hadoop系统里启动的任务线程数，这里改为40，同样可以尝试该值大小对效率的影响变化进行最合适的值的设定。<br>     c、mapreduce.tasktracker.http.threads，默认值：40；说明：map和reduce是通过http进行数据传输的，这个是设置传输的并行线程数。</p><h3 id="14-datanode-首次加入-cluster-的时候，如果-log-报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？"><a href="#14-datanode-首次加入-cluster-的时候，如果-log-报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？" class="headerlink" title="14 datanode 首次加入 cluster 的时候，如果 log 报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？"></a>14 datanode 首次加入 cluster 的时候，如果 log 报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？</h3><p>   1）这样处理是不合理的，因为那么 namenode 格式化操作，是对文件系统进行格式化，namenode 格式化时清空 dfs&#x2F;name 下空两个目录下的所有文件，之后，会在目录 dfs.name.dir 下创建文件。<br>   2）文本不兼容，有可能时 namenode 与 datanode 的 数据里的 namespaceID、clusterID 不一致，找到两个 ID 位置，修改为一样即可解决。</p><h3 id="15-MapReduce-中排序发生在哪几个阶段？这些排序是否可以避免？为什么？"><a href="#15-MapReduce-中排序发生在哪几个阶段？这些排序是否可以避免？为什么？" class="headerlink" title="15 MapReduce 中排序发生在哪几个阶段？这些排序是否可以避免？为什么？"></a>15 MapReduce 中排序发生在哪几个阶段？这些排序是否可以避免？为什么？</h3><p>   1）一个 MapReduce 作业由 Map 阶段和 Reduce 阶段两部分组成，这两阶段会对数据排序，从这个意义上说，MapReduce 框架本质就是一个 Distributed Sort。<br>   2）在 Map 阶段，Map Task 会在本地磁盘输出一个按照 key 排序（采用的是快速排序）的文件（中间可能产生多个文件，但最终会合并成一个），在 Reduce 阶段，每个 Reduce Task 会对收到的数据排序，这样，数据便按照 Key 分成了若干组，之后以组为单位交给 reduce（）处理。<br>   3）很多人的误解在 Map 阶段，如果不使用 Combiner便不会排序，这是错误的，不管你用不用 Combiner，Map Task 均会对产生的数据排序（如果没有 Reduce Task，则不会排序，实际上 Map 阶段的排序就是为了减轻 Reduce端排序负载）。<br>   4）由于这些排序是 MapReduce 自动完成的，用户无法控制，因此，在hadoop 1.x 中无法避免，也不可以关闭，但 hadoop2.x 是可以关闭的。</p><h3 id="16-hadoop的优化？"><a href="#16-hadoop的优化？" class="headerlink" title="16 hadoop的优化？"></a>16 hadoop的优化？</h3><p>   1）优化的思路可以从配置文件和系统以及代码的设计思路来优化<br>   2）配置文件的优化：调节适当的参数，在调参数时要进行测试<br>   3）代码的优化：combiner的个数尽量与reduce的个数相同，数据的类型保持一致，可以减少拆包与封包的进度<br>   4）系统的优化：可以设置linux系统打开最大的文件数预计网络的带宽MTU的配置<br>   5）为 job 添加一个 Combiner，可以大大的减少shuffer阶段的maoTask拷贝过来给远程的   reduce task的数据量，一般而言combiner与reduce相同。<br>   6）在开发中尽量使用stringBuffer而不是string，string的模式是read-only的，如果对它进行修改，会产生临时的对象，二stringBuffer是可修改的，不会产生临时对象。<br>   7）修改一下配置：以下是修改 mapred-site.xml 文件<br>     a、修改最大槽位数：槽位数是在各个 tasktracker 上的 mapred-site.xml 上设置的，默认都是 2<br> <property><br> <name>mapred.tasktracker.map.tasks.maximum</name><br> <value>2</value><br> </property><br> <property><br> <name>mapred.tasktracker.reduce.tasks.maximum</name><br> <value>2</value><br> </property><br>     b、调整心跳间隔：集群规模小于 300 时，心跳间隔为 300 毫秒<br> mapreduce.jobtracker.heartbeat.interval.min 心跳时间<br> mapred.heartbeats.in.second 集群每增加多少节点，时间增加下面的值<br> mapreduce.jobtracker.heartbeat.scaling.factor 集群每增加上面的个数，心跳增多少<br>     c、启动带外心跳<br> mapreduce.tasktracker.outofband.heartbeat 默认是 false<br>     d、配置多块磁盘<br> mapreduce.local.dir<br>     e、配置 RPC hander 数目<br> mapred.job.tracker.handler.count 默认是 10，可以改成 50，根据机器的能力<br>     f、配置 HTTP 线程数目<br> tasktracker.http.threads 默认是 40，可以改成 100 根据机器的能力<br>     g、选择合适的压缩方式，以 snappy 为例：<br> <property><br> <name>mapred.compress.map.output</name><br> <value>true</value><br> </property><br> <property><br> <name>mapred.map.output.compression.codec</name><br> <value>org.apache.hadoop.io.compress.SnappyCodec</value><br> </property></p><h3 id="17-设计题"><a href="#17-设计题" class="headerlink" title="17 设计题"></a>17 设计题</h3><p>   1）采集nginx产生的日志，日志的格式为user  ip   time  url   htmlId  每天产生的文件的数据量上亿条，请设计方案把数据保存到HDFS上，并提供一下实时查询的功能（响应时间小于3s）<br> A、某个用户某天访问某个URL的次数<br> B、某个URL某天被访问的总次数<br> 实时思路是：使用Logstash + Kafka + Spark-streaming + Redis + 报表展示平台<br> 离线的思路是：Logstash + Kafka + Elasticsearch +  Spark-streaming + 关系型数据库<br> A、B、数据在进入到Spark-streaming 中进行过滤，把符合要求的数据保存到Redis中</p><h3 id="18-有-10-个文件，每个文件-1G，每个文件的每一行存放的都是用户的-query，每个文件的query-都可能重复。要求你按照-query-的频度排序。还是典型的-TOP-K-算法"><a href="#18-有-10-个文件，每个文件-1G，每个文件的每一行存放的都是用户的-query，每个文件的query-都可能重复。要求你按照-query-的频度排序。还是典型的-TOP-K-算法" class="headerlink" title="18 有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的query 都可能重复。要求你按照 query 的频度排序。还是典型的 TOP K 算法"></a>18 有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的query 都可能重复。要求你按照 query 的频度排序。还是典型的 TOP K 算法</h3><p>   解决方案如下：<br>     1）方案 1：<br>     顺序读取 10 个文件，按照 hash(query)%10 的结果将 query 写入到另外 10 个文件（记为）中。这样新生成的文件每个的大小大约也 1G（假设 hash 函数是随机的）。 找一台内存在 2G 左右的机器，依次对用 hash_map(query, query_count)来统计每个query 出现的次数。利用快速&#x2F;堆&#x2F;归并排序按照出现次数进行排序。将排序好的 query 和对应的 query_cout 输出到文件中。这样得到了 10 个排好序的文件（记为）。 对这 10 个文件进行归并排序（内排序与外排序相结合）。<br>     2）方案 2：<br>     一般 query 的总量是有限的，只是重复的次数比较多而已，可能对于所有的 query，一次性就可以加入到内存了。这样，我们就可以采用 trie 树&#x2F;hash_map等直接来统计每个 query出现的次数，然后按出现次数做快速&#x2F;堆&#x2F;归并排序就可以了。<br>     3）方案 3：<br>     与方案 1 类似，但在做完 hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如 MapReduce），最后再进行合并。</p><h3 id="19-在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。"><a href="#19-在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。" class="headerlink" title="19 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。"></a>19 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</h3><p>   1）方案 1：采用 2-Bitmap（每个数分配 2bit，00 表示不存在，01 表示出现一次，10 表示多次，11 无意义）进行，共需内存 2^32 * 2 bit&#x3D;1 GB 内存，还可以接受。然后扫描这 2.5亿个整数，查看 Bitmap 中相对应位，如果是 00 变 01，01 变 10，10 保持不变。所描完事后，查看 bitmap，把对应位是 01 的整数输出即可。<br>   2）方案 2：也可采用与第 1 题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p><h3 id="20-腾讯面试题：给40亿个不重复的-unsigned-int-的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那-40-亿个数当中？"><a href="#20-腾讯面试题：给40亿个不重复的-unsigned-int-的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那-40-亿个数当中？" class="headerlink" title="20 腾讯面试题：给40亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？"></a>20 腾讯面试题：给40亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</h3><p>   1）方案 1：oo，申请 512M 的内存，一个 bit 位代表一个 unsigned int 值。读入 40 亿个数，设置相应的 bit 位，读入要查询的数，查看相应 bit 位是否为 1，为 1 表示存在，为 0 表示不存在。<br>   2）方案 2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下： 又因为 2^32 为 40 亿多，所以给定一个数可能在，也可能不在其中； 这里我们把 40 亿个数中的每一个用 32 位的二进制来表示 ，假设这 40 亿个数开始放在一个文件中。 然后将这 40 亿个数分成两类:<br> 1.最高位为 0<br> 2.最高位为 1<br>     并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;&#x3D;20 亿，而另一个&gt;&#x3D;20 亿（这相当于折半了）； 与要查找的数的最高位比较并接着进入相应的文件再查找 再然后把这个文件为又分成两类:<br> 1.次最高位为 0<br> 2.次最高位为 1<br>     并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;&#x3D;10 亿，而另一个&gt;&#x3D;10 亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。<br> …..<br>     以此类推，就可以找到了,而且时间复杂度为 O(logn)，方案 2 完。<br>   3)附：这里，再简单介绍下，位图方法： 使用位图法判断整形数组是否存在重复 ,判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。<br>     位图法比较适合于这种情况，它的做法是按照集合中最大元素 max 创建一个长度为 max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上 1，如遇到 5 就给新数组的第六个元素置 1，这样下次再遇到 5 想置位时发现新数组的第六个元素已经是 1 了，这说明这次的数据肯定和以前的数据存在着重复。这 种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为 2N。如果已知数组的最大值即能事先给新数组定长的话效 率还能提高一倍。</p><h3 id="21-怎么在海量数据中找出重复次数最多的一个？"><a href="#21-怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="21 怎么在海量数据中找出重复次数最多的一个？"></a>21 怎么在海量数据中找出重复次数最多的一个？</h3><p>   1）方案 1：先做 hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><h3 id="22-上千万或上亿数据（有重复），统计其中出现次数最多的钱-N-个数据。"><a href="#22-上千万或上亿数据（有重复），统计其中出现次数最多的钱-N-个数据。" class="headerlink" title="22 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。"></a>22 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。</h3><p>   1）方案 1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用 hash_map&#x2F;搜索二叉树&#x2F;红黑树等来进行统计次数。然后就是取出前 N 个出现次数最多的数据了，可以用第 2 题提到的堆机制完成。</p><h3 id="23-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前-10-个词，给出思想，给出时间复杂度分析。"><a href="#23-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前-10-个词，给出思想，给出时间复杂度分析。" class="headerlink" title="23 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，给出思想，给出时间复杂度分析。"></a>23 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，给出思想，给出时间复杂度分析。</h3><p>   1）方案 1：这题是考虑时间效率。用 trie 树统计每个词出现的次数，时间复杂度是 O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前 10 个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是 O(n</em>lg10)。所以总的时间复杂度，是 O(n<em>le)与 O(n</em>lg10)中较大的哪一 个。</p><h3 id="24-100w-个数中找出最大的-100-个数。"><a href="#24-100w-个数中找出最大的-100-个数。" class="headerlink" title="24 100w 个数中找出最大的 100 个数。"></a>24 100w 个数中找出最大的 100 个数。</h3><p>   1）方案 1：在前面的题中，我们已经提到了，用一个含 100 个元素的最小堆完成。复杂度为O(100w<em>lg100)。<br>   2）方案 2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比 100 多的时候，采用传统排序算法排序，取前 100 个。复杂度为 O(100w</em>100)。<br>   3）方案 3：采用局部淘汰法。选取前 100 个元素，并排序，记为序列 L。然后一次扫描剩余的元素 x，与排好序的 100 个元素中最小的元素比，如果比这个最小的 要大，那么把这个最小的元素删除，并把 x 利用插入排序的思想，插入到序列 L 中。依次循环，直到扫描了所有的元素。复杂度为 O(100w*100)。</p><h3 id="25-有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用-5-分钟时间，找出重复出现最多的前-10-条。"><a href="#25-有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用-5-分钟时间，找出重复出现最多的前-10-条。" class="headerlink" title="25 有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用 5 分钟时间，找出重复出现最多的前 10 条。"></a>25 有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用 5 分钟时间，找出重复出现最多的前 10 条。</h3><p>   1）分析： 常规方法是先排序，在遍历一次，找出重复最多的前 10 条。但是排序的算法复杂度最低为nlgn。<br>   2）可以设计一个 hash_table, hash_map&lt;string, int&gt;，依次读取一千万条短信，加载到hash_table 表中，并且统计重复的次数，与此同时维护一张最多 10 条的短信表。 这样遍历一次就能找出最多的前 10 条，算法复杂度为 O(n)。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试合集搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>演练</title>
    <link href="/2024/05/07/%E6%BC%94%E7%BB%83/"/>
    <url>/2024/05/07/%E6%BC%94%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<p>吸取上次xhs笔试失败经验（题没刷完就去匆匆笔试</p><p>这次简历一投就去techguide里刷题了</p><p>but shoppee给数据的方式看着好怪，就算不一定真的给这么怪的输入样例hyx也不能掉以轻心！</p><p>它给的测试样例是这样的：[10,2]</p><p>我试问最后官网上难道也有那两个方括号吗，，如果我没准备过一眼看到会心态颤抖一下，，但是时间是金钱，于是hyx把这点也考虑到了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>    vector&lt;string&gt;strnum;<br>    <span class="hljs-comment">// int cur = 0;</span><br>    string temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>|| s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            <span class="hljs-comment">// 非数字字符，忽略</span><br>            strnum.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-comment">// cur = cur + 1;</span><br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp=temp+s[i];<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-type">int</span> size = strnum.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        cout&lt;&lt;strnum[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shoppee笔试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop+python实现博客中文词频统计</title>
    <link href="/2024/05/05/Hadoop-python%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"/>
    <url>/2024/05/05/Hadoop-python%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>一时兴起想做个博客关键词统计！（如果有空的话看看能不能打包成插件发布到hexo上面）<br><img src="/../img/hadoop%E6%88%90%E5%93%81/wordcloud.png" alt="词云图example"><br>看到的时候还有点纳闷怎么“父亲”和“母亲”两个这么书面的词出现频率那么高，后来仔细一看——鉴定为看弗兰肯斯坦看的（之前读评论文的时候写了一堆）。</p><p>po一个小小的攻略在这里！（项目地址：<a href="https://github.com/Liebe-grausam/hadoop_chinese_wordcount%EF%BC%89">https://github.com/Liebe-grausam/hadoop_chinese_wordcount）</a></p><p>前置准备：ubuntu20.04 + hadoop环境，以及python文件运行必要的包。</p><p>step 1：<br>在input文件夹中放入待处理的文件。<br><img src="/../img/hadoop%E6%88%90%E5%93%81/input%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E5%AE%B9.png" alt="input文件夹内容"></p><p>step 2：<br>在script文件夹下启动终端，运行代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop jar <span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-regexp">/share/</span>hadoop<span class="hljs-regexp">/tools/</span>lib<span class="hljs-regexp">/hadoop-streaming-version.jar -files mapper.py,reducer.py -mapper &quot;python3 mapper.py&quot; -reducer &quot;python3 reducer.py&quot; -input road_to_repo/i</span>nput<span class="hljs-regexp">/ -output road_to_repo/</span>output/<br></code></pre></td></tr></table></figure><p>其中“hadoop-streaming-version.jar”的“version”要改成你的hadoop的实际版本，“road_to_repo”要改成克隆下来的该项目文件夹所在路径。</p><p><strong>most important!：此命令为一次性操作，如果运行失败，必须把生成的output文件夹删掉之后再重新运行该命令。</strong></p><p>代码运行需要一定时间，如果单纯为学习目的可以使用small_input文件夹作为输入。</p><p>代码运行结果保存在output文件夹下的part-00000中。<br><img src="/../img/hadoop%E6%88%90%E5%93%81/part-00000.png" alt="part-00000内容"></p><p>step 3：<br>由于MapReduce的作用是统计词频，并不是用来生成词云图，因此还需要将刚才的运行结果拷贝到script文件夹中的output.txt。<br>在script文件夹下启动终端，运行代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> word_cloud.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>即可得到同一目录下保存的word_cloud.png。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reduce成功！</title>
    <link href="/2024/05/04/reduce%E6%88%90%E5%8A%9F%EF%BC%81/"/>
    <url>/2024/05/04/reduce%E6%88%90%E5%8A%9F%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>编写了reduce文件并运行成功了！来备个份</p><p>split_mapper.py的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> jieba<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-comment"># 在这里对数据进行处理，比如去除非中文字符，并分词</span><br>    content = re.sub(<span class="hljs-string">r&#x27;[^\u4e00-\u9fa5]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, data)  <span class="hljs-comment"># 去除非中文字符</span><br>    words = jieba.cut(content)  <span class="hljs-comment"># 分词</span><br>    <span class="hljs-keyword">return</span> words<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>        words = process_data(line.strip())<br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;word&#125;</span>\t1&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>split_reducer.py的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reducer</span>():<br>    current_word = <span class="hljs-literal">None</span><br>    current_count = <span class="hljs-number">0</span><br>    word_count_dict = defaultdict(<span class="hljs-built_in">int</span>)<br><br>    <span class="hljs-comment"># 读取来自Mapper的输入</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>        word, count = line.strip().split(<span class="hljs-string">&#x27;\t&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 转换计数为整数类型</span><br>        <span class="hljs-keyword">try</span>:<br>            count = <span class="hljs-built_in">int</span>(count)<br>        <span class="hljs-keyword">except</span> ValueError:<br>            <span class="hljs-comment"># 如果无法转换，就跳过这一行</span><br>            <span class="hljs-keyword">continue</span><br>        <br>        <span class="hljs-comment"># 合并相同的单词并计算总次数</span><br>        <span class="hljs-keyword">if</span> current_word == word:<br>            current_count += count<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 输出累积的单词计数</span><br>            <span class="hljs-keyword">if</span> current_word:<br>                word_count_dict[current_word] += current_count<br>            current_word = word<br>            current_count = count<br><br>    <span class="hljs-comment"># 处理最后一个单词</span><br>    <span class="hljs-keyword">if</span> current_word == word:<br>        word_count_dict[current_word] += current_count<br><br>    <span class="hljs-comment"># 输出最终结果</span><br>    <span class="hljs-keyword">for</span> word, count <span class="hljs-keyword">in</span> word_count_dict.items():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;word&#125;</span>\t<span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    reducer()<br></code></pre></td></tr></table></figure><p>终端运行代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop jar <span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-regexp">/share/</span>hadoop<span class="hljs-regexp">/tools/</span>lib<span class="hljs-regexp">/hadoop-streaming-3.4.0.jar -files split_mapper.py,split_reducer.py -mapper &quot;python3 split_mapper.py&quot; -reducer &quot;python3 split_reducer.py&quot; -input ~/</span>桌面<span class="hljs-regexp">/posts/</span>small_input<span class="hljs-regexp">/ -output ~/</span>桌面<span class="hljs-regexp">/posts/</span>f_output/<br></code></pre></td></tr></table></figure><p>注意：选项是files不是file（因为是多个文件），并且要用逗号分隔而不是空格</p><p><img src="/../img/hadoop/%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%BB%93%E6%9E%9C.png" alt="词频统计结果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中文词频统计第一部分</title>
    <link href="/2024/05/04/%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <url>/2024/05/04/%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>先总结一下今天干了什么（工作日报</p><p>使用jieba进行分词，将post里的input文件夹下的所有.md文件读进标准输入，删除日期、标签、标题等元数据，过滤非中文字符，输出以每个词为键、值为1的键值对，表示该词出现了一次。</p><p><img src="/../img/hadoop/split.txt.png" alt="原来的输出版本，一堆未经处理的以空格分割的分词"></p><p><img src="/../img/hadoop/%E6%9C%AA%E7%BB%8Freduce%E7%9A%84%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1.png" alt="未经reduce的词频统计"></p><p>下一步的操作是要编辑reduce文件，使得同一键的count合并</p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跑通第二个hadoop</title>
    <link href="/2024/05/04/%E8%B7%91%E9%80%9A%E7%AC%AC%E4%BA%8C%E4%B8%AAhadoop/"/>
    <url>/2024/05/04/%E8%B7%91%E9%80%9A%E7%AC%AC%E4%BA%8C%E4%B8%AAhadoop/</url>
    
    <content type="html"><![CDATA[<p>跑的第一个hadoop是hadoop自带的英文词频统计。</p><p>因为自己手头有一堆博客的md文件，于是想做一个中文的词频统计。</p><p>（扩完容之后开跑！</p><p>苯人环境：hadoop单机版 Ubuntu20.04</p><p>苯人文件夹结构：</p><ul><li>posts<ul><li>scripts<ul><li>mapper.py</li><li>reducer.py（仍在编写中</li></ul></li><li>small_input<ul><li>*.md</li></ul></li><li>a_output<ul><li>…</li></ul></li></ul></li></ul><p>终端代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop jar <span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-regexp">/share/</span>hadoop<span class="hljs-regexp">/tools/</span>lib<span class="hljs-regexp">/hadoop-streaming-3.4.0.jar -file mapper.py -mapper &quot;python3 mapper.py&quot; -input ~/</span>桌面<span class="hljs-regexp">/posts/</span>small_input<span class="hljs-regexp">/ -output ~/</span>桌面<span class="hljs-regexp">/posts/</span>a_output/<br></code></pre></td></tr></table></figure><p>可以每打一部分就用“\”作为分割符，就可以接着输没输完的命令</p><p>mapper.py代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> jieba<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_input</span>(<span class="hljs-params">file</span>):<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br>        <span class="hljs-keyword">yield</span> line<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">separator=<span class="hljs-string">&#x27;\t&#x27;</span></span>):<br>    <span class="hljs-comment"># 输入来自标准输入(stdin)</span><br>    data = read_input(sys.stdin)<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data:<br>        line = line.strip()<br>        <span class="hljs-comment"># 提取标题、日期和标签</span><br>        title = re.findall(<span class="hljs-string">r&#x27;title:\s*(.+)&#x27;</span>, line)<br>        date = re.findall(<span class="hljs-string">r&#x27;date:\s*(.+)&#x27;</span>, line)<br>        tags = re.findall(<span class="hljs-string">r&#x27;tags:\s*(.+)&#x27;</span>, line)<br>        <span class="hljs-keyword">if</span> title:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;title:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;title[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> date:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;date:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;date[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> tags:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;tags:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;tags[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 提取正文并分词</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line.startswith(<span class="hljs-string">&#x27;---&#x27;</span>) <span class="hljs-keyword">and</span> line.strip():<br>            <span class="hljs-comment"># 去除非中文字符</span><br>            content = re.sub(<span class="hljs-string">r&#x27;[^\u4e00-\u9fa5]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, line)<br>            words = jieba.cut(content)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;content:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;<span class="hljs-string">&#x27; &#x27;</span>.join(words)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>分词成功！</p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最复杂的系统往往只需要最简单的扩容方式</title>
    <link href="/2024/05/04/%E6%9C%80%E5%A4%8D%E6%9D%82%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BE%80%E5%BE%80%E5%8F%AA%E9%9C%80%E8%A6%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/05/04/%E6%9C%80%E5%A4%8D%E6%9D%82%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BE%80%E5%BE%80%E5%8F%AA%E9%9C%80%E8%A6%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>环境：Ubuntu 20.04</p><p>先在虚拟机设置中增加硬盘容量，不过此时还处于灰色未分配状态</p><p>扩容前安装gparted</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install gparted<br></code></pre></td></tr></table></figure><p>终端运行gparted，出现图形界面</p><p>&#x2F;dev&#x2F;sda1 为主分区<br>&#x2F;dev&#x2F;sda2 为扩展分区<br>&#x2F;dev&#x2F;sda5 为逻辑分区（我的sda5挂在sda2目录下</p><p>这个时候的正确操作（网上绝无仅有版！）：</p><p>step1<br>右键sda2所在分区，选择更改大小选项，将箭头拖到最右端</p><p>step2<br>右键sda5所在分区，选择更改大小选项，将箭头拖到最右端</p><p>两个都要改！！因为是挂载版，比较特殊</p><p>（在尝试这个方法前还尝试了fdisk，并且gparted大部分人分区和我不一样（他们好像没有扩展分区所以没办法复现，中间甚至碰到了很多稀奇古怪的错误，，，<strong>虚拟机快照</strong>你值得拥有</p>]]></content>
    
    
    
    <tags>
      
      <tag>vmware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置hadoop环境</title>
    <link href="/2024/05/04/%E9%85%8D%E7%BD%AEhadoop%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/05/04/%E9%85%8D%E7%BD%AEhadoop%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>大学生哪有不疯的，，，</p><p>今天回到寝室，查了一下日常实习的岗位，决定向大数据工程师发起进攻（数据挖掘是算法，算法达咩</p><p>流程：尝试在docker上装hadoop镜像未遂，尝试装裸机版，被百度网盘的垃圾网速和windows的傻逼环境整笑了（发现文件夹里有.sh文件所以最后还是决定用虚拟机，，，装了好几个小时终于！</p><p><img src="/../img/env/475981eb67fff95876bff514e239de3.png" alt="java与hadoop运行成功界面"></p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表！</title>
    <link href="/2024/05/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%81/"/>
    <url>/2024/05/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>初构造链表类<br>此题要点：迭代法，保存cur nxt pre，因为改指针后会丢失原来的信息，注意return的东西是pre<br>自己可以定义类定义测试数据的话其实自由度很大</p><p>加油加油</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    node* next;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> v)&#123;<br>        value=v;<br>        next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function">node* <span class="hljs-title">reverse_node</span><span class="hljs-params">(node*head)</span></span>&#123;<br>    node* cur = head;<br>    node* nxt = <span class="hljs-literal">nullptr</span>;<br>    node* pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>        nxt = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(node*head)</span></span>&#123;<br>    node*cur = head;<br>    <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;cur-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cur = cur-&gt;next;<br><br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>    node* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>);<br>    head-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">2</span>);<br>    head-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">3</span>);<br>    head-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">print_list</span>(head);<br>    <span class="hljs-built_in">print_list</span>(<span class="hljs-built_in">reverse_node</span>(head));<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>手搓代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于恐惧和爱的选择</title>
    <link href="/2024/04/26/%E5%85%B3%E4%BA%8E%E6%81%90%E6%83%A7%E5%92%8C%E7%88%B1%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <url>/2024/04/26/%E5%85%B3%E4%BA%8E%E6%81%90%E6%83%A7%E5%92%8C%E7%88%B1%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p>关于恐惧和爱的选择，我们最好选择爱吧，因为死亡就要降临。（感觉这句特别好！想要写到歌词里去</p>]]></content>
    
    
    
    <tags>
      
      <tag>bubble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>假期开始！</title>
    <link href="/2024/04/26/%E5%81%87%E6%9C%9F%E5%BC%80%E5%A7%8B%EF%BC%81/"/>
    <url>/2024/04/26/%E5%81%87%E6%9C%9F%E5%BC%80%E5%A7%8B%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>多吃主食就可以增肥！</p><p>找老师开了一下小灶，发现是练习方法的问题，现在可以踢5个了！老师还说如果我能踢到10个（对？没听清）就直接联系她，嘿嘿！（离三对合格只差一个！看来期末合格有望！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GOOD NEWS!</title>
    <link href="/2024/04/26/GOOD-NEWS/"/>
    <url>/2024/04/26/GOOD-NEWS/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/html_dialect.png" alt="html_dialect"><br>将combine.py和modulate.py合并为一个文件，命名为generate.py，看上去更加简洁。</p><p>vscode中可以直接运行generate.py，开启一个新的终端，在终端中按规定运行即可在文件夹内生成对应的读音。</p><p>原来的raw文件夹全都删除，只留下预处理后的文件，去掉了文件夹的output前缀，看上去更加精练！python api与html方面即将进入尾声！如果成功调用api，就开启下一步的方言数据库建设，敬请期待！</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尝试搭前端界面！</title>
    <link href="/2024/04/25/%E5%B0%9D%E8%AF%95%E6%90%AD%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2/"/>
    <url>/2024/04/25/%E5%B0%9D%E8%AF%95%E6%90%AD%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>借助chatgpt搭了一个较为丑陋的前端界面（虽然觉得它丑，然后就push chatgpt再写了一个稍微好看一点的界面）</p><p>装了一些用来写前端的扩展，在菜鸟教程的推荐下装了一些前端常用的插件，比如：fitten code，看着它在每次我输入日记的时候它会自动给我补全一些东西，但是它补全的完全不是我想说的哈哈哈哈啊哈哈，发现ai取代人类的思维还是为时尚早！</p><p>明天晚上7点有个xhs笔试，但是那个时候我在火车上了！（顺延掉吧哈哈哈哈哈哈 还是寄希望于投日常实习好了（简历太丑，现在也在抓紧学一些东西</p><p>前端地位低，，自己玩玩还行，去公司最好还是投后端岗位，毕竟前端的工作主要是写代码，后端的工作主要是写接口，数据库，服务器等等，前端的工作量相对后端来说要小很多，而且前端的技术栈相对后端来说更加简单，所以更适合个人学习。（后面的原因是fitten code补全的</p><p>以下是index.html的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Text Reader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;hr&gt;</span><br><span class="hljs-comment">    &lt;h1&gt;Text Reader&lt;/h1&gt;</span><br><span class="hljs-comment">    &lt;hr&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;textInput&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请键入吴语拼音&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;readButton&quot;</span>&gt;</span>Read<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;app.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是styles.css的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Arial&#x27;</span>, sans-serif;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f4f4f4</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>);<br>&#125;<br><br><span class="hljs-selector-id">#textInput</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>&#125;<br><br><span class="hljs-selector-id">#readButton</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#007BFF</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">border</span>: none;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">transition</span>: background-color <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><br><span class="hljs-selector-id">#readButton</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0334f6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（这fitten code还怪聪明的</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哇！我运行了第一个Flask程序</title>
    <link href="/2024/04/25/%E5%93%87%EF%BC%81%E6%88%91%E8%BF%90%E8%A1%8C%E4%BA%86%E7%AC%AC%E4%B8%80%E4%B8%AAFlask%E7%A8%8B%E5%BA%8F/"/>
    <url>/2024/04/25/%E5%93%87%EF%BC%81%E6%88%91%E8%BF%90%E8%A1%8C%E4%BA%86%E7%AC%AC%E4%B8%80%E4%B8%AAFlask%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>python的程序已经差不多搭建完成了！（今天录入了全部的音素 方言词典开发计划进入下一阶段，即在web网页中嵌入python代码</p><p>发现了flask这个宝藏应用程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Filename : example.py</span><br><span class="hljs-comment"># Copyright : 2020 By Nhooo</span><br><span class="hljs-comment"># Author by : www.cainiaojc.com</span><br><span class="hljs-comment"># Date : 2020-08-08</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World&#x27;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>只要把这个代码保存到hello.py中并在终端中运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python hello.py<br></code></pre></td></tr></table></figure><p>就可以在弹出的本地端口中发现网页上已经展示了一行“helloworld”~</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大连行程</title>
    <link href="/2024/04/25/%E5%A4%A7%E8%BF%9E%E8%A1%8C%E7%A8%8B/"/>
    <url>/2024/04/25/%E5%A4%A7%E8%BF%9E%E8%A1%8C%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>因为五一打算去日照看海，突然想起之前去了大连的一些行程没有记录，遂记</p><p>当时应该就是7.3-7.5，中间下雨的时候就宅在民宿里，幸运的是同时看到了晴天的海和阴天的海。拍了很多人生照片嘿嘿</p><p>凭着记忆写一波：</p><p>7.3<br>傍晚的时候坐高铁到的大连（甚至还有地铁<br>安顿并且追剧</p><p>7.4<br>下午（雨）：<br>有轨电车<br>罗斯福广场<br>KKV（逛过最大的KKV！强烈安利</p><p>傍晚（雨）：<br>星海公园</p><p>7.5<br>星海广场！！<br>住宿定在了汉庭优佳大连机场酒店（因为第二天要飞到宁波去了</p>]]></content>
    
    
    
    <tags>
      
      <tag>travel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现列表化输入</title>
    <link href="/2024/04/25/%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E5%8C%96%E8%BE%93%E5%85%A5/"/>
    <url>/2024/04/25/%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E5%8C%96%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>这次对modulate和combine进行了扩展，使得它们不仅可以处理单个音素，现在可以批量处理了，由于如果输入输出是相同路径很容易造成损坏，于是建了一个临时文件夹来存放中间值。</p><p>深深体会到了分部编程的好处（不会短时间内引入大量的bug，循序渐进</p><p>写完了米德尔马契的ddl！明天写探奥论文（以及要整理出去玩的东西啦！！顺便做攻略</p><p>干的事情一多甚至已经来不及写博客了，，直接po一个readme来汇报一下现在的进度<br><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/%E8%BE%93%E5%85%A5%E9%9F%B3%E7%B4%A0%E4%B8%8E%E5%8D%87%E9%99%8D%E5%8D%8A%E9%9F%B3%E6%95%B0%E5%85%83%E7%BB%84%E5%88%97%E8%A1%A8.png" alt="README更新"></p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现变调功能并封装预处理py</title>
    <link href="/2024/04/22/%E5%AE%9E%E7%8E%B0%E5%8F%98%E8%B0%83%E5%8A%9F%E8%83%BD%E5%B9%B6%E5%B0%81%E8%A3%85%E9%A2%84%E5%A4%84%E7%90%86py/"/>
    <url>/2024/04/22/%E5%AE%9E%E7%8E%B0%E5%8F%98%E8%B0%83%E5%8A%9F%E8%83%BD%E5%B9%B6%E5%B0%81%E8%A3%85%E9%A2%84%E5%A4%84%E7%90%86py/</url>
    
    <content type="html"><![CDATA[<p>北京下了很大很大的雨，感觉像回家了，自己是满是水的星球上的厄崔迪王子</p><p>今天写完了经济地理学的论文，刷完了党课在线学习视频，实现了变调功能，还封装了preprocessing.py（把预处理功能的py全部整合到同一个文件，封装函数接口</p><p>满是水的天气使我开心与振奋，，应该是太想家了（以及没淋到雨嘿嘿</p><p>冲了很久的热水澡，虽然联系了一个想做小程序的学姐并且杳无音讯，但是她应该会去淘宝上找代做吧！PaperPass居然可以降AIGC，，，真的太牛了，让AI改AI。</p><p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/%E6%9B%B4%E6%96%B0modulate.png" alt="更新modulate"></p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比较优势</title>
    <link href="/2024/04/22/%E6%AF%94%E8%BE%83%E4%BC%98%E5%8A%BF/"/>
    <url>/2024/04/22/%E6%AF%94%E8%BE%83%E4%BC%98%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>“东亚经济奇迹”一个很重要的特点，就是政府帮助本土企业进入复杂度很高的行业，充分利用其中的学习效应、规模效应和技术外溢效应，迅速提升本土制造业的技术能力和国际竞争力。假如韩国按照其1970年显示出的“比较优势”来规划产业，就应该听从世界银行的建议去发展纺织业。但韩国没有这么做，而是一头扎进了本国根本没有的产业。到了1990年，韩国最具“比较优势”的十大类出口商品，比如轮船和电子产品，1970年时根本就不存在。可见“比较优势”具有很大的不确定性，是可以靠人为创造的。其实“比较优势”并不神秘，就是机会成本低的意思。而对于没干过的事情，事前其实无从准确判断机会成本，没干过怎么知道呢？中国也是如此。政府和私人部门合力进入很多复杂的、传统上没有比较优势的行业，但经过多年发展，其产品如今在国际上已经有了比较优势。</p></blockquote><p>感觉这一段写的特别好！比较优势具有很大的不确定性，是可以靠人为创造的。事前无从准确判断机会成本，没干过怎么知道呢？</p><blockquote><p>从光伏产业的发展中，我们还可以看到“东亚产业政策模式”的另一个特点：强调出口。当国内市场有限时，海外市场可以促进竞争，迫使企业创新。补贴和优惠政策难免会产生一些低效率的企业，但这些企业在面对挑剔的海外客户时，是无法过关的。而出口量大的公司，往往是效率相对高的公司，它们市场份额的扩大，会吸纳更多的行业资源，压缩国内低效率同行的生存空间，淘汰一些落后产能。当然，像我国这样的大国，要应对的国际局势变幻比小国更加复杂，所以不断扩大和稳定国内市场，才是行业长期发展的基础。另一方面，若地方政府利用行政手段阻碍落后企业破产，就会阻碍优胜劣汰和效率提升，加剧产能过剩的负面影响。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平滑连接元音辅音</title>
    <link href="/2024/04/21/%E5%B9%B3%E6%BB%91%E8%BF%9E%E6%8E%A5%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3/"/>
    <url>/2024/04/21/%E5%B9%B3%E6%BB%91%E8%BF%9E%E6%8E%A5%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<p>配了一副新眼镜和一副新墨镜！（今天干的事情好多反而懒得写博客了哈哈哈</p><p>发现方言网站上有很多音频缺失了，于是还是打算自己录了（主要是为了保持音色和声调的一致，不然合成会很奇怪</p><p>今天最重大的成就是平滑连接了元音和辅音（t+ei&#x3D;tei）经过反复的调整迭代出了一个最优的合成方案（不知道是否适用于别的组合的情形呢</p><p>批处理真的很方便，，这几天主要在做预处理的事情，全都在为后面做铺垫（慢慢来吧！这几天也学到了很多东西！就像疯狂星期一说的那样 不要留下遗憾，不要一遍一遍地让人生重来 想着先干完这个就一定有时间去干别的东西类似的事情</p><p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/0421dialect.png" alt="今日进度"><br><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/readme%E6%9B%B4%E6%96%B0%E9%A2%84%E5%A4%84%E7%90%86.png" alt="README更新预处理部分"></p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重大突破-分离辅音</title>
    <link href="/2024/04/20/%E9%87%8D%E5%A4%A7%E7%AA%81%E7%A0%B4/"/>
    <url>/2024/04/20/%E9%87%8D%E5%A4%A7%E7%AA%81%E7%A0%B4/</url>
    
    <content type="html"><![CDATA[<p>发现配的环境还是不大行，，于是今天又倒腾了好久的环境</p><p>一直很好奇为什么终端每次打印环境变量的时候都会出现一些奇怪的字符 就算是人工键入也是非常奇怪的字符，今天破案了</p><p>下次输环境变量的时候不要再右键文件属性然后复制了，直接点<br><img src="/../img/env/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240420234648.png" alt="watch this"><br>就会出来一个直接可以复制的地址，这样就不会出现奇怪的字符了</p><p>再不行就重新下一个包（注意一下下载的是essential部分还是full部分 以免漏掉一些东西 不过我感觉根源还是上面的复制问题</p><p>又仔细研究了一下上次下的synthesis轮子，（如果方言能像拼音一样直接拼出来就好了，拆解成多个音频，每个音频播放固定的时长</p><p>居然被我找到了！吴语拼音！因为玉环话和温岭话比较相近所以打算采用温岭话拼音方案！<a href="https://wu-chinese.com/romanization/wenling.html">吴语协会温岭话拼音链接</a></p><p>从官网的辅音介绍下载了一个ogg（既然是方言爱好者官网的，肯定比我这个“门外汉”读的标准），但是问题在于这个音频是送气的（ta），所以就在想怎么把辅音和元音分开，问了chatgpt给的答案也不尽人意，最后hyx发挥了她的智慧——</p><p>主要思路就是利用pydub库（一个处理音频的库），将官网下载的音频找到非静音部分（这个灵感来源是华为录音的跳过静音功能），再截取前面的一小部分，就可以分离开了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydub <span class="hljs-keyword">import</span> AudioSegment<br><span class="hljs-keyword">from</span> pydub.silence <span class="hljs-keyword">import</span> detect_nonsilent<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 加载音频文件</span><br>audio_file = <span class="hljs-string">&quot;ta.ogg&quot;</span><br>audio = AudioSegment.from_ogg(audio_file)<br><br><span class="hljs-comment"># 使用detect_nonsilent找到非静音部分</span><br>nonsilent_intervals = detect_nonsilent(audio, silence_thresh=-<span class="hljs-number">40</span>, min_silence_len=<span class="hljs-number">50</span>)<br><br><span class="hljs-comment"># 获取第一个非静音部分的开始位置</span><br><span class="hljs-keyword">if</span> nonsilent_intervals:<br>    start_pos = nonsilent_intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 截取去掉静音部分后的前25毫秒音频</span><br>    chunk = audio[start_pos:start_pos + <span class="hljs-number">25</span>]  <br><br>    <span class="hljs-comment"># 创建一个新的音频文件夹来保存截取出的音频</span><br>    output_folder = <span class="hljs-string">&quot;output_audio&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_folder):<br>        os.mkdir(output_folder)<br><br>    <span class="hljs-comment"># 保存截取出的音频</span><br>    output_file = os.path.join(output_folder, <span class="hljs-string">&quot;first_25ms_after_silence.ogg&quot;</span>)<br>    chunk.export(output_file, <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;ogg&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成功截取去掉静音部分后的前25毫秒音频。&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未找到非静音部分。&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>听了一下效果感觉还可以！明天试试看把它和元音音频合起来</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>明明配了环境，却仍然不能运行？</title>
    <link href="/2024/04/19/%E4%BF%A1%E7%A7%91%E5%A3%AC%E6%9E%81%E5%85%B6%E8%A6%81%E5%BC%BA%E7%9A%84%E4%B8%80%E7%94%9F/"/>
    <url>/2024/04/19/%E4%BF%A1%E7%A7%91%E5%A3%AC%E6%9E%81%E5%85%B6%E8%A6%81%E5%BC%BA%E7%9A%84%E4%B8%80%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>省流：看看是不是磁盘权限问题！（F盘是用户盘不是系统盘，所以设置环境变量要设置在用户的环境变量，而不是系统的环境变量</p><p>一些检查方法：</p><p>在windows10的powershell终端运行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> $<span class="hljs-keyword">en</span><span class="hljs-variable">v:PATH</span><br></code></pre></td></tr></table></figure><p>发现所有F盘的环境变量设置都无效，，，但是平时配其他盘就没事（重启了好多次终于想到用打印环境变量这一方法</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> $<span class="hljs-keyword">en</span><span class="hljs-variable">v:MY_VARIABLE_FROM_F_DRIVE</span><br></code></pre></td></tr></table></figure><p>（运行这一命令，输出为空，证实了我的想法</p><p>解决方案是把系统环境变量挪到用户环境变量（D盘同理<br><img src="/../img/env/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240419144020.png" alt="用户环境变量与系统环境变量"><br>C盘没内存的人是这样的，，卑微</p><p>二更：还有一种解决方案！直接点上面的地址栏复制，不要去点到文件的属性里面去复制，容易复制下来一些无法识别的字符</p>]]></content>
    
    
    
    <tags>
      
      <tag>env</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方言词典开发计划！</title>
    <link href="/2024/04/19/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92%EF%BC%81/"/>
    <url>/2024/04/19/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2%E7%9A%84%E8%AE%BE%E6%83%B3.jpg" alt="一个界面的设想"><br>某种程度上也借鉴了德格方言词典app的设计（以简约为目标）。用户的登录&#x2F;注册与新增词条功能为次要功能，可以延缓开发。打算先从网页web版做起，再试试看能不能包装成apk。<br>起因是没钱买服务器，也不想在免费试用之后续费，于是决定先搞一个轻量级的应用。查了一个下午+一个晚上的资料，最终锁定采用flutter开发。<br><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/flutter%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F.png" alt="flutter部署成功"><br>想法是：如果用flutter开发了一个插件，就可以做到类似调用api的功能，即在静态网页上实现动态功能。</p><p>咨询了一下gpt，它也是这么认为的：</p><p>GPT：</p><p>是的，使用Flutter开发插件，你可以在静态网页上实现动态功能，类似于调用API的功能。Flutter插件可以与Web应用程序（例如JavaScript）进行交互，从而在静态网页中实现动态功能。</p><p>Flutter提供了<code>flutter_webview_plugin</code>这样的插件，它允许你在Flutter应用中嵌入Web视图。这样，你可以加载一个包含动态内容的网页，并与Flutter应用程序进行交互。</p><p>以下是使用<code>flutter_webview_plugin</code>插件嵌入Web视图的基本步骤：</p><ol><li>在<code>pubspec.yaml</code>文件中添加<code>flutter_webview_plugin</code>依赖：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br>  <span class="hljs-attr">flutter_webview_plugin:</span> <span class="hljs-string">^latest_version</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>运行<code>flutter pub get</code>安装依赖。</p></li><li><p>在Flutter应用中使用<code>WebviewScaffold</code>或<code>Webview</code>来嵌入Web视图：</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_webview_plugin/flutter_webview_plugin.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: WebviewScaffold(<br>        url: <span class="hljs-string">&quot;https://example.com&quot;</span>, <span class="hljs-comment">// 加载的网页URL</span><br>        appBar: AppBar(title: Text(<span class="hljs-string">&quot;Webview 示例&quot;</span>)),<br>        withZoom: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 允许缩放</span><br>        withLocalStorage: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 启用本地存储</span><br>        hidden: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 是否隐藏webview</span><br>        initialChild: Container( <span class="hljs-comment">// 加载过程中显示的控件</span><br>          color: Colors.white,<br>          child: Center(<br>            child: CircularProgressIndicator(),<br>          ),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用<code>WebviewScaffold</code>来加载一个网页，并显示一个AppBar。你可以根据需要自定义<code>WebviewScaffold</code>的属性，例如是否允许缩放、是否启用本地存储等。</p><p>通过这种方式，你可以在静态网页上实现动态功能，与Flutter应用程序进行交互，类似于调用API的功能。</p><p>终于看到了一点成功的可能性！睡觉！</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分税制改革具体举措</title>
    <link href="/2024/04/18/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9%E5%85%B7%E4%BD%93%E4%B8%BE%E6%8E%AA/"/>
    <url>/2024/04/18/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9%E5%85%B7%E4%BD%93%E4%B8%BE%E6%8E%AA/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%A4%96/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93.png" alt="本章小结"><br>经济发展就是盘活各种资源，提高资源使用效率（人力、土地等等）</p><h1 id="纵向失衡"><a href="#纵向失衡" class="headerlink" title="纵向失衡"></a>纵向失衡</h1><p>由于中央和省分成，省和市县分成，导致财权层层上收，事权层层下压（也就是俗话说的基层钱少事多），因此进行了支出分权，农村基本公共服务开支由中央和地方政府共同承担，乡财县管（规范乡镇行为，实现同县乡镇公共服务均等化），省直管县（让县财政和省财政直接发生关系，绕开市财政）。</p><h1 id="转移支付改革"><a href="#转移支付改革" class="headerlink" title="转移支付改革"></a>转移支付改革</h1><p>保证政府运作和公务员工资（可能会造成冗员问题，养了很多闲人），而且越穷的人拿到的转移支付越多，可能缺乏增收动力</p><h1 id="五个统筹"><a href="#五个统筹" class="headerlink" title="五个统筹"></a>五个统筹</h1><p>科学发展观的内容。人与自然和谐发展（自然保护区的就不准砍，，），统筹经济社会发展（主要还是社会稳定，所以民生问题也要关注</p>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>土地财政</title>
    <link href="/2024/04/18/%E5%9C%9F%E5%9C%B0%E8%B4%A2%E6%94%BF/"/>
    <url>/2024/04/18/%E5%9C%9F%E5%9C%B0%E8%B4%A2%E6%94%BF/</url>
    
    <content type="html"><![CDATA[<p>1998年之前，乡镇企业占用的都是农村集体土地。由于各大地方政府招商引资，城市土地一般以低价有偿转让，卖地收入不多。</p><h1 id="城市政府垄断土地建设"><a href="#城市政府垄断土地建设" class="headerlink" title="城市政府垄断土地建设"></a>城市政府垄断土地建设</h1><p>直到1998年颁布了一系列改革措施：职工停止分房（催生了商品房与房地产），颁布了《土地管理法》，即农村集体土地不能用于非农建设，这些土地必须通过征地成为国有土地才能发展工商业和建造住宅，因此，城市政府垄断了土地建设。</p><p>在2001年，制定了“招标拍卖”规则，土地财政膨胀。</p><p>土地财政的收入分为使用权转让收入和一系列税收收入（土地增值税、耕地占用税、契税）。在1999-2000的窗口期，招拍挂还未实施，土地转让不透明，一些开发商趁国企改革腾出的土地私下交易，以少量出让金就可开发房地产，这其中催生了许多腐败与混乱。</p><h1 id="工业化城市化两手抓"><a href="#工业化城市化两手抓" class="headerlink" title="工业化城市化两手抓"></a>工业化城市化两手抓</h1><p>改革后，地方政府一方面低价供应大量工业用地，一方面限制商住用地供给（获得垄断收益），随着工商业经济活动的繁荣，房价与地价不断哄抬。随着企业那边的改革交给政府的税越来越少，政府也从原来的狠抓工业化逐渐转变成工业化城市化两手抓。</p><h2 id="工业用地"><a href="#工业用地" class="headerlink" title="工业用地"></a>工业用地</h2><p>为什么地方政府不惜倒贴（提供各种补贴）也要供应工业用地呢？因为工业用地（制造业）可以带动转型升级，也可以提供增值税和其他税收，并且制造业上下游链条长，如果形成集群效应，还可以提升地方竞争优势，形成稳定税收来源。</p><p>而且工业用地对地域一般没有太大的限制，所以地方政府不大可能抬地价（人家厉害，哪都能生存，凭啥待这呢），要哄着企业</p><h2 id="商住用地"><a href="#商住用地" class="headerlink" title="商住用地"></a>商住用地</h2><p>商住用地一般仅服务本地居民，所以垄断性更高，更方便抬地价（软柿子</p>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>央地博弈与招商引资</title>
    <link href="/2024/04/17/%E5%A4%AE%E5%9C%B0%E5%8D%9A%E5%BC%88%E4%B8%8E%E6%8B%9B%E5%95%86%E5%BC%95%E8%B5%84/"/>
    <url>/2024/04/17/%E5%A4%AE%E5%9C%B0%E5%8D%9A%E5%BC%88%E4%B8%8E%E6%8B%9B%E5%95%86%E5%BC%95%E8%B5%84/</url>
    
    <content type="html"><![CDATA[<h1 id="央地博弈"><a href="#央地博弈" class="headerlink" title="央地博弈"></a>央地博弈</h1><p>分税制改革将税收分为三类，中央税、地方税和共享税。</p><p>增值税原本为地方税，现在变为共享税（中央75%，地方25%）。为防止地方收入急剧下跌，中央设立了“税收返还”机制：保证改革后地方增值税收入与改革前一样，新增部分才和中央分。广东谈判之后，在全国范围内用1993年做基年，引发第四季度的收税狂潮，由于地方突击征税，增值税占地方税收的比重在1993年出现了明显反常的尖峰。这让1994年的财政陷入了困境，中央承诺的税收返还因为数额剧增而无法到位，预算迟迟做不出来。当2001年推行所得税分成改革时，突击征税现象再次出现。</p><h1 id="招商引资"><a href="#招商引资" class="headerlink" title="招商引资"></a>招商引资</h1><p>地方发展经济的两条路线：税收（与中央分成）、预算外收入。</p><p>增加税收的途径：</p><ol><li>扩大税源（主要原因<br>改革前，企业按隶属关系上缴税收，改革后，企业按所在地上缴税收。这便吸引了地方政府招商引资。由于税收在生产环节征收（之前讲过增值税不管企业盈利亏本，只要生产了就要交税的），所以地方政府为了财政，重企业轻民生，重生产轻消费。（之前公考做到一道题就是盲目招商、招大商的问题，也导致了产能过剩与对环境的破坏）</li><li>加强征管（非主要原因</li></ol><p>增加预算外收入的途径：</p><ol><li>企业缴的各种杂项费用（行政收费、集资、赞助等），后来改革了就没有了</li><li><strong>土地财政（下一部分着重讲）</strong></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分税制改革背景</title>
    <link href="/2024/04/17/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9/"/>
    <url>/2024/04/17/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9/</url>
    
    <content type="html"><![CDATA[<p>由于原来的计划经济太僵化，所以进行了一系列改革转型。我国的基本国策决定了不能对所有权做出根本性变革，只能对经营权和使用权实行承包制来提高积极性。</p><p>中央根据地方实际来确定承包形式和分账比例，比较流行的是收入递增包干（以某一年为基准每年提高固定的百分比，超过的部分全部归地方，没超过的部分与中央五五分成）因此地方有动力扩大税收来源，大力发展经济。由于企业不管盈利与否，只要开工，都需要缴纳增值税，于是地方政府大力发展乡镇企业（这样就可以得到更多的税收）。</p><p>但是这样的财政包干造成了两个比重不断降低。</p><ol><li><p>中央财政预算收入占全国财政预算收入的比重不断降低。<br>这是因为地方的财政收入上涨的速度远远高于地方交给中央的那个税的增长率（就是自己发展的好留了很多）</p></li><li><p>全国财政预算总收入占GDP的比重越来越低。<br>这是因为地方财政担心报多了被中央压榨增多提高的百分比（怕变成老实人小丑），所以偷偷留几手（藏富于企业，企业偷税漏税），这样地方依然有预算外收入，但是上报的预算内收入就少了，要交的税就少了</p></li></ol><p>而如果中央没钱，就失去宏观调控的能力（手里没把米，叫鸡都不来），更没有财力去普及义务教育、赈灾……所以改革启动！</p>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事权划分三大原则</title>
    <link href="/2024/04/17/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/"/>
    <url>/2024/04/17/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/</url>
    
    <content type="html"><![CDATA[<p>《置身事内：中国政府与经济发展》：经济地理学的阅读书目，在此更新一些阅读笔记</p><h1 id="事权划分三大原则"><a href="#事权划分三大原则" class="headerlink" title="事权划分三大原则"></a>事权划分三大原则</h1><p>三大原则的共同主题是处理不同群体的利益差别与冲突。假如不同群体间完全没有差别和冲突，那事权如何划分就不重要，对结果影响不大。完全没有冲突当然不可能，但如果能让各个群体对利益和代价的看法趋同，也能消解很多矛盾，增强互信。所以国家对其公民都有基本的共同价值观教育，包括历史教育和国家观念教育。而对官员群体，我国自古以来就重视共同价值观的培养与教化，今天依然如此。</p><h2 id="1-公共服务的规模经济"><a href="#1-公共服务的规模经济" class="headerlink" title="1. 公共服务的规模经济"></a>1. 公共服务的规模经济</h2><p>一个城市总要划分成不同的区县，而行政边界的划分跟公共服务影响范围有关。</p><p>一方面，因为规模经济，覆盖的人越多越划算，政区越大越好；</p><p>另一方面，受制于人们获取这些服务的代价（距离、文化、意愿、基础设施），政区不能无限扩大。</p><blockquote><p>从公共服务覆盖范围角度看，不同人对公共服务的评价不同，享受该服务的代价不同，所以要划分不同的行政区域。</p></blockquote><h2 id="2-信息复杂性"><a href="#2-信息复杂性" class="headerlink" title="2. 信息复杂性"></a>2. 信息复杂性</h2><p>上级无法掌握和处理所有信息，虽然名义上有最终决定权，但是只有“形式权威”，下级具有信息优势，自主性很大，具有“实际权威”。上下级之间存在信息的获取与隐瞒问题。规则的模糊不清容易导致权力个人化，容易造成“一把手负责制”的专权与腐败现象。因此体制内的规章制度无法取代个人信任。</p><blockquote><p>从信息复杂性角度看，掌握不同信息的人，看法和判断不同，要把决策权交给占据信息优势的一方。</p></blockquote><h2 id="3-激励相容"><a href="#3-激励相容" class="headerlink" title="3. 激励相容"></a>3. 激励相容</h2><h3 id="垂直管理"><a href="#垂直管理" class="headerlink" title="垂直管理"></a>垂直管理</h3><p>适用于专业性强、标准化程度高的部门，工作主要由系统内的上级安排，任命、绩效与福利也主要由上级评价与决定。</p><h3 id="地方管理"><a href="#地方管理" class="headerlink" title="地方管理"></a>地方管理</h3><p>激励相容原则要求给地方放权：不仅要让地方负责，也要与地方分享发展成果；不仅要能激励地方努力做好，还要能约束地方不要搞砸，也不要努力过头。做任何事都有代价，最优的结果是让效果和代价匹配，而不是不计代价地达成目标。若不加约束，地方政府要实现短期经济高速增长目标并不难，可以尽情挥霍手中的资源，大肆借债、寅吃卯粮来推高增长数字，但这种结果显然不是最优的。</p><blockquote><p>从激励相容角度看，上下级的目标和能力不同，所以要设立有效的机制去激励下级完成上级的目标。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随记</title>
    <link href="/2024/04/17/%E9%9A%8F%E8%AE%B0/"/>
    <url>/2024/04/17/%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>因为之前的笔记本用完了，翻到了一个大一的时候用的笔记本。发现往里面记了很多有意思的东西，遂搬运。之前记录只是觉得有意思，或者有“价值”，当真正面临人生选择的时候，当认识了更多为了自己的梦想而去做一些看似愚蠢的事的人之后，不管是在名著中还是现实中。我很崇敬他们自洽而勇敢的生活方式，像放弃退休坚守招生岗位，为像我一样迷茫的孩子点了一盏灯，像sygg放弃了教育部秘书的光鲜职位而从上海回到小岛任教，像奶奶疫情后依然在经营着她的亏本小店，像米德尔马契里看似总是在做着错误的选择的多多。</p><p>我将我的前5&#x2F;8的大学用来迷茫，后3&#x2F;8的大学用来醒悟与召回。而今在寻找探奥论文素材的时候，偶然间又重新看到大一上册时的记录。那时候我没有被绩点和学业压力鞭挞，保持着最单纯的初心，选什么课都是为了好玩，也为了好玩去学习了一些很基础的一些东西（走了很多弯路，终于在大三下兜兜转转地绕回来）。</p><p>成功和功成名就没有什么关系，成功是一个人捍卫自己的完整性。他可以不为名利低下高傲的头，却会为一段自由俯身垂首。他开始变得勇敢，他不甘心再做一只囚鸟。人的每一种身份都是一种自我绑架，唯有失去是自由之途。我把自己丢了，也许他也只想飞翔一次。他应该羽翼丰满，为自己寻求一条明亮的活路。</p>]]></content>
    
    
    
    <tags>
      
      <tag>bubbles</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讯飞智文</title>
    <link href="/2024/04/17/%E8%AE%AF%E9%A3%9E%E6%99%BA%E6%96%87/"/>
    <url>/2024/04/17/%E8%AE%AF%E9%A3%9E%E6%99%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>低碳课要交一个作业，正好因为没有用过ai生成ppt，所以生成了一个看看效果</p><p><img src="/../img/%E8%AE%AF%E9%A3%9E%E6%99%BA%E6%96%87/ai%E7%94%9F%E6%88%90ppt.png" alt="AI生成ppt"><br>其实感觉乍一看还蛮好！不过有很多重复的内容和不合逻辑的内容，稍微调整一下顺序，删除几张重复的ppt，划分一下小节就好了。</p><p>快乐而又迅速地交作业（</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯？动归？</title>
    <link href="/2024/04/13/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2024/04/13/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<p>小红书笔试写到一道回溯题，，来不及写了，故在这里写完康康（正确率18%<br><img src="/../img/%E7%AC%94%E8%AF%95/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240413144759.png" alt="粉丝数问题"><br>祭出我写了一半的回溯代码，，（也有动归的残骸</p><p>漏看了一条很重要的信息：只有一个账号能推广多次<br>（带摄像头的线上笔试真的太磨人了，，，屏幕比较小没放大根本看不见</p><p>当时想加个最小值的返回判定但是来不及编译了，，加上去应该正确率不止这么点，挺可惜的，，不过就算写了也没来得及考虑推广多次的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// int dp[101][101];</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-comment">// 定义函数体</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ddd</span><span class="hljs-params">(<span class="hljs-type">int</span> bb,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>||bb&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x;i++)&#123;<br>        <span class="hljs-type">int</span> ii= a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x&gt;=ii)&#123;<br>            flag|=<span class="hljs-built_in">ddd</span>(bb<span class="hljs-number">-1</span>,x-ii);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 感觉还是动态规划</span><br>    <span class="hljs-comment">// 好像是回溯啊 那完蛋了</span><br><br>    <span class="hljs-comment">// 第一个参数是最少需要推广几次</span><br>    <span class="hljs-comment">// 第二个参数是现在的粉丝数量（这次推广之后</span><br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-comment">// for (int i=0;i&lt;n;i++)&#123;</span><br>    <span class="hljs-comment">//     int ii=a[i]/2;</span><br>    <span class="hljs-comment">//     dp[1][a[i]/2]=1;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ddd</span>(i,x))&#123;<br>            flag=<span class="hljs-literal">true</span>;<br>            cout&lt;&lt;i;<br>            <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag)&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// cout&lt;&lt;flag;</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>翻到了网上的解析，是用动归做的 因为我先做的下一题，，所以后来觉得这题不用动归做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>]; <span class="hljs-comment">// 本来我想设二维的，但是发现一维就够了</span><br><span class="hljs-comment">// dp[x]表示粉丝数恰好为x时至少需要推广的次数</span><br><span class="hljs-comment">// 初值全都赋成INF_MAX</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<span class="hljs-comment">// 输入的原账号的粉丝量</span><br><span class="hljs-type">int</span> t[<span class="hljs-number">100</span>];<span class="hljs-comment">// 每个账号推广后实际涨粉数（</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 这里就除以二 后面看着好看点</span><br>    &#125;<br>    <span class="hljs-comment">// 先考虑每个账号至多推广一次的情形</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>        dp[i]=<span class="hljs-number">99999</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        dp[t[i]]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// bool flag=0;</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span> (i-t[j]&gt;=<span class="hljs-number">0</span>)&#123;<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-t[j]]+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 控制一下下标范围，当时太急了也没来得及写</span><br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> tmp = dp[x];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x;j++)&#123;<br>            dp[j]=<span class="hljs-number">99999</span>;<br>        &#125;<br>        t[i]=a[i];<br>        <span class="hljs-comment">// dp[t[i]]=1;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            dp[t[j]]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 还有一个忽视了的点！题目问的是账号数不是推广的总次数</span><br>        <span class="hljs-comment">// 所以这里推广多次的账号dp值不需要设成2</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x;j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;n;m++)&#123;<br>                <span class="hljs-keyword">if</span> (j&gt;=t[m])&#123;<br>                    dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-t[m]]+<span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-comment">// 下标合法性</span><br>            &#125;<br>        &#125;<br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 回溯（bushi</span><br>        tmp = <span class="hljs-built_in">min</span>(tmp,dp[x]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[x]!=<span class="hljs-number">99999</span>)&#123;<br>        cout&lt;&lt;dp[x];<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout&lt;&lt;flag;</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>输出了一下还是错，，比对了一下标准答案发现是因为重新初始化，所以把之前迭代的数据丢失了，缺失了只推广一半粉丝数的数据，，所以蝴蝶效应影响到了其他的dp值（和循环内外顺序以及++&#x2F;–没有关系！</p><p>AC代码（应该AC了吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>]; <span class="hljs-comment">// 本来我想设二维的，但是发现一维就够了</span><br><span class="hljs-comment">// dp[x]表示粉丝数恰好为x时至少需要推广的次数</span><br><span class="hljs-comment">// 初值全都赋成INF_MAX</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<span class="hljs-comment">// 输入的原账号的粉丝量</span><br><span class="hljs-type">int</span> t[<span class="hljs-number">100</span>];<span class="hljs-comment">// 每个账号推广后实际涨粉数（</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 这里就除以二 后面看着好看点</span><br>    &#125;<br>    <span class="hljs-comment">// 先考虑每个账号至多推广一次的情形</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>        dp[i]=<span class="hljs-number">99999</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        dp[t[i]]=<span class="hljs-number">1</span>;<br>    &#125;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// bool flag=0;</span><br>    <br>    <span class="hljs-comment">// for (int j=0;j&lt;n;j++)&#123;</span><br>    <span class="hljs-comment">//     for (int i=t[j];i&lt;=x;i++)&#123;</span><br>    <span class="hljs-comment">//         dp[i]=min(dp[i],dp[i-t[j]]+1);</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span> (i&gt;=t[j])&#123;<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-t[j]]+<span class="hljs-number">1</span>);<br><br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-type">int</span> tmp = dp[x];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">// for (int j=1;j&lt;=x;j++)&#123;</span><br>        <span class="hljs-comment">//     dp[j]=99999;</span><br>        <span class="hljs-comment">// &#125;</span><br>        t[i]=a[i];<br>        <span class="hljs-comment">// dp[t[i]]=1;</span><br>        <span class="hljs-comment">// for (int j=0;j&lt;n;j++)&#123;</span><br>        <span class="hljs-comment">//     dp[t[j]]=1;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// dp[0]=0;</span><br>        <br>        <span class="hljs-comment">// 还有一个忽视了的点！题目问的是账号数不是推广的总次数</span><br>        <span class="hljs-comment">// 所以这里推广多次的账号dp值不需要设成2</span><br>        <br>        <br>        <span class="hljs-comment">// for (int m=0;m&lt;n;m++)&#123;</span><br>        <span class="hljs-comment">//     for (int j=t[m];j&lt;=x;j++)&#123;</span><br>        <span class="hljs-comment">//         dp[j]=min(dp[j],dp[j-t[m]]+1);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=x;j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;n;m++)&#123;<br>                <span class="hljs-keyword">if</span> (j&gt;=t[m])&#123;<br>                    dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-t[m]]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <br><br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 回溯（bushi</span><br>        tmp = <span class="hljs-built_in">min</span>(tmp,dp[x]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[x]!=<span class="hljs-number">99999</span>)&#123;<br>        cout&lt;&lt;dp[x];<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout&lt;&lt;flag;</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>再尝试下把回溯的方法补完，但是发现非常复杂，，gpt说这道题的最佳解法就是动态规划，回溯效率不高，，那就这样吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>xhs笔试复盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11的新特性</title>
    <link href="/2024/04/11/C-11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2024/04/11/C-11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="类型推导关键字"><a href="#类型推导关键字" class="headerlink" title="类型推导关键字"></a>类型推导关键字</h1><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>让编译器通过初始值进行类型推演（必须有初始值！<br>先对底层const和顶层const进行说明：</p><h3 id="底层const（常量指针）"><a href="#底层const（常量指针）" class="headerlink" title="底层const（常量指针）"></a>底层const（常量指针）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p<br><span class="hljs-type">int</span> <span class="hljs-type">const</span>* p;<br></code></pre></td></tr></table></figure><p>这两种命名方式是等价的，指的都是常量指针，const在类型名前后都可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> num_a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span>  *p_a = &amp;num_a; <span class="hljs-comment">// 底层const</span><br><span class="hljs-comment">//*p_a = 2;  // 错误，无法修改对象的值</span><br>p = &amp;b; <span class="hljs-comment">// 正确，允许修改指向</span><br>num_a = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p>指向“常量”的指针不代表它所指向的内容一定是常量，只是代表不能通过解引用符（操作符*）来改变它所指向的内容。上例中指针p_a指向的内容就不是常量，可以通过赋值语句：num_a&#x3D;2;  来改变它所指向的内容。</p><h3 id="顶层const（指针常量）"><a href="#顶层const（指针常量）" class="headerlink" title="顶层const（指针常量）"></a>顶层const（指针常量）</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手搓快排</title>
    <link href="/2024/04/10/%E6%89%8B%E6%90%93%E5%BF%AB%E6%8E%92/"/>
    <url>/2024/04/10/%E6%89%8B%E6%90%93%E5%BF%AB%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<p>大一的时候都是依赖vs studio那个非常大的软件来编译简单算法程序运行，，vscode对我的作用就是单纯地完成课堂搭建的服务器平台或者什么classmachine上的作业，环境也配得稀烂，甚至这个学期前都没跑通过python环境，，（甚至还以为是jupyter或者自己编程的问题，之前还把Python课退掉了</p><p>亏得这个学期选的一门创新创业课里配了个大模型环境，对自己的配环境技术有了稍稍地自信，由于之前为了腾内存以及认定自己要去体制内所以卸载了vs studio，导致基本没有现成可用的IDE，于是今天配了C++的运行环境。复制了launch.json, tasks.json, c_cpp_properties.json, 把vscode的环境变量（bin文件夹）也加进环境变量里去了。一个小时内终于能运行快排代码了（要不是面试要求手搓肯定hyx也不会想到倒腾这玩意，，</p><p>综合了两篇教程，设置了独立弹出的终端，，，非常有成就感，，（虽然zjt锐评这些事情他大一下就做过而我大三下居然才刚刚开始，，，但是对于一个对计算机没啥兴趣的人来说已经很厉害了orz</p><p>自己手搓了一份代码，不过数据具有偶然性，，发现有些数据跑不通（以下是错误代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; num;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>]=&#123;&#125;;<br>    <span class="hljs-type">int</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = num<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> tmp = a[base];<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// flag为0表示low为空指针，1表示high为空指针</span><br>    <span class="hljs-keyword">while</span>(high!=low)&#123;<br>        <span class="hljs-keyword">if</span> (flag==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// low为空指针，不操作low，只操作high</span><br>            <span class="hljs-keyword">if</span> (a[high]&gt;tmp)&#123;<br>                high--;<br>                <span class="hljs-comment">// high指向的数比基准值大，high左移一个单位</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                a[low]=a[high];<br>                <span class="hljs-comment">// high指向的数比基准值小，把a[high]赋值给a[low]</span><br>                flag=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 现在high为空</span><br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// high为空指针，不操作high，操作low</span><br>            <span class="hljs-keyword">if</span> (a[low]&lt;tmp)&#123;<br>                low++;<br>                <span class="hljs-comment">// low指向的数比基准值小，low右移一个单位</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                a[high]=a[low];<br>                <span class="hljs-comment">// low指向的数比基准值大，把a[low]赋值给a[high]</span><br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 现在low为空</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    a[high]=tmp;<br>    <span class="hljs-comment">// 当high指针和low指针重合时将基准值赋值给a[high]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>错误代码的总体思路：</p><p>基准值设在左边第一个。然后把a[0]取出来作为tmp基准值。设立两个指针low和high，初始low指向左边第一个，high指向右边第一个。初始low为空（因为low指向的值被取出来了），（我这里设了flag标定是对low操作还是对high操作，更简洁的方法是套两个while循环），主要作用就是一直找，找到第一个不应在这个位置的就和high&#x2F;low交换，待会码一个简洁版的。模拟了一下对21, 100, 3, 50, 100进行操作，发现只能实现3, 21, 100, 50, 100这样的功能，即只能保证基准值左边的比它小，基准值右边的比他大，但是这两个序列分别怎么排呢？不清楚，没排。（<strong>错因：没有递归</strong>）</p><p>正确代码：<br>（新增头文件algorithm，用来调用sort</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-comment">// 划分函数</span><br>    <span class="hljs-type">int</span> i = low;<br>    <span class="hljs-type">int</span> j = high;<br>    <br>    <span class="hljs-type">int</span> tmp = a[i];<br>    <span class="hljs-keyword">while</span>(j&gt;i)&#123;<br>        <span class="hljs-keyword">while</span>(a[j]&gt;tmp &amp;&amp;i&lt;j)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i&lt;j)&#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>            i++;<br>            <span class="hljs-comment">// 少了这一步！！！</span><br>        &#125;<br>        <span class="hljs-comment">// 一着急把if写在while里面了，，应该拿外面来</span><br>        <span class="hljs-keyword">while</span>(a[i]&lt;=tmp &amp;&amp; i&lt;j)&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 上面没加等于，所以这里加等于</span><br>        <span class="hljs-keyword">if</span> (i&lt;j)&#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>            j--;<br>            <span class="hljs-comment">// 少了这一步</span><br>        &#125;    <br>        <br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> i;<br><br>&#125;<br><span class="hljs-comment">// 快速排序函数分为两部分</span><br><span class="hljs-comment">// 一部分是划分函数（需返回枢值位置），一部分是函数主体</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">if</span>(low&lt;high)&#123;<br>        mid = <span class="hljs-built_in">part</span>(low,high);<br>        <span class="hljs-comment">// 一紧张忘给mid赋值了</span><br>        <span class="hljs-built_in">quicksort</span>(low,mid<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">quicksort</span>(mid+<span class="hljs-number">1</span>,high);<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; num;<br>    <br>    <span class="hljs-type">int</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = num<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">quicksort</span>(<span class="hljs-number">0</span>,num<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps：今天打开vscode差点以为又不能运行了，吓鼠，，，仔细一看是因为没有在文件夹下</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小米面试准备</title>
    <link href="/2024/04/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2024/04/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<p>感觉来不及准备了所以搞点高频考点突击一下。</p><h1 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h1><h2 id="my-answer："><a href="#my-answer：" class="headerlink" title="my answer："></a>my answer：</h2><p>线程和别的线程共享一个地址空间？）每个进程有自己独立的地址空间<br>（用标准的角度讲应该属于拥有资源的角度<br>（其他忘了</p><h2 id="standard："><a href="#standard：" class="headerlink" title="standard："></a>standard：</h2><ol><li>调度：进程是<strong>资源管理</strong>的基本单位，线程是<strong>程序执行</strong>的基本单位。</li><li>切换：线程上下文切换比进程上下文切换要快得多。</li><li>拥有资源： 进程是拥有资源的一个独立单位，线程<strong>不拥有系统资源，但是可以访问隶属于进程的资源</strong>。</li><li>系统开销： 创建或撤销进程时，系统都要为之<strong>分配或回收系统资源</strong>，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li></ol><h1 id="面向对象的三个特征"><a href="#面向对象的三个特征" class="headerlink" title="面向对象的三个特征"></a>面向对象的三个特征</h1><h2 id="my-answer：-1"><a href="#my-answer：-1" class="headerlink" title="my answer："></a>my answer：</h2><p>不会斯密达</p><h2 id="standard：-1"><a href="#standard：-1" class="headerlink" title="standard："></a>standard：</h2><p>面向对象编程的三大特征是封装、继承和多态。</p><ol><li><p>封装：封装是指将数据和操作数据的方法（即函数）捆绑在一起，形成一个<strong>类</strong>。通过封装，我们可以<strong>隐藏内部实现细节，只暴露必要的接口给外部使用</strong>。这样可以提高代码的可维护性和安全性，并且方便其他开发者使用该类。</p></li><li><p>继承：继承是指一个类可以<strong>派生出子类</strong>，子类会继承父类的属性和方法。通过继承，子类可以重用父类的代码，并且可以在不修改父类的情况下进行功能扩展。继承可以建立类之间的层次关系，使得代码更加灵活和可扩展。</p></li><li><p>多态：多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。 那么在继承中要构成多态还有两个条件：必须通过基类的指针或者引用调用虚函数；被调用的函数必须是<strong>虚函数</strong>，且派生类必须对基类的虚函数进行重写.</p></li></ol><h1 id="介绍一下项目（操统）"><a href="#介绍一下项目（操统）" class="headerlink" title="介绍一下项目（操统）"></a>介绍一下项目（操统）</h1><p>因为每次应该都会问到所以感觉需要重点打磨。</p><p>结合一篇博客来重点作答一下（参考：博客园 MIT 6.S081 xv6调试不完全指北）</p><h2 id="操统版"><a href="#操统版" class="headerlink" title="操统版"></a>操统版</h2><p>印象比较深刻的一个项目是MIT 6.S081对xv6的优化，其中有一个部分需要实现为每个新进程单独分配一个属于它的内核页。里面的细节非常多，debug起来也比较困难。比如说要在scheduler切换进程的时候, 刷新TLB和使用的虚拟-物理页表影射base，而且当控制权返回给调度器时，要切换为全局内核页表。这个点让我debug了很久。</p><h3 id="可能延伸的问题"><a href="#可能延伸的问题" class="headerlink" title="可能延伸的问题"></a>可能延伸的问题</h3><h4 id="咋debug的？"><a href="#咋debug的？" class="headerlink" title="咋debug的？"></a>咋debug的？</h4><p>通过网上查阅操作系统的官方文档、技术论坛和社区的讨论，还有就是通过printf大法或者gdb调试。MIT 6.S081 2019提供的xv6采用的指令集是riscv，因此我们虚拟机上针对x86指令集的gdb可能无法较好的调试。我们需要用交叉编译工具来编译xv6，并用交叉编译工具提供的gdb来调试。</p><h5 id="关于gdb的延伸"><a href="#关于gdb的延伸" class="headerlink" title="关于gdb的延伸"></a>关于gdb的延伸</h5><p>通过-g调试命令，gdb可以监控pc（程序计数器）、sp（堆栈指针）、各类寄存器的值，结合ELF中的符号表，就可以将这些信息“翻译”为我们想要看的变量。比如说如果输入命令 file user&#x2F;_sleep，其目的就是告诉gdb，加载_sleep的符号表，用它的符号表去解释你看到的东西。</p><h5 id="printf一般print啥的延伸"><a href="#printf一般print啥的延伸" class="headerlink" title="printf一般print啥的延伸"></a>printf一般print啥的延伸</h5><ol><li><p><strong>进程切换相关信息</strong>：打印当前正在运行的进程ID，以及即将切换到的进程ID。这可以帮助确认进程切换逻辑是否按预期执行。</p></li><li><p><strong>页表信息</strong>：打印页表的内容，包括虚拟地址到物理地址的映射情况，以及页表项的各种标志位（如是否有效、访问权限等）。这可以帮助确认进程切换时页表是否被正确更新。</p></li><li><p><strong>CPU寄存器状态</strong>：打印CPU寄存器的当前状态，包括程序计数器（PC）、栈指针（SP）等。这可以帮助确定进程切换后CPU状态的正确性。</p></li><li><p><strong>内核空间的映射情况</strong>：打印内核页表的内容，以及当前CPU的SATP寄存器的值（即当前使用的页表基地址）。这可以帮助确认内核空间的映射是否正确切换。</p></li><li><p><strong>TLB的状态</strong>：打印TLB的内容，可以帮助确认TLB是否被正确刷新，以及新的地址映射是否已经生效。</p></li><li><p><strong>锁的获取和释放信息</strong>：打印进程切换过程中获取和释放的锁，以及锁的持有情况。这可以帮助检查进程切换过程中的并发访问是否受到正确的同步保护。</p></li><li><p><strong>内存管理相关信息</strong>：打印内存分配和释放的信息，以及内存池或内存区域的状态。这可以帮助确认内存管理功能是否按预期工作。</p></li></ol><h6 id="怎么打印锁"><a href="#怎么打印锁" class="headerlink" title="怎么打印锁"></a>怎么打印锁</h6><p>在操作系统的源代码中，锁通常会定义为一个结构体，其中包含锁的状态和与锁相关的其他信息。锁的定义通常会包括锁的状态（如是否被持有）、持有锁的进程ID等信息。我们可以在锁的源代码中添加printf语句，以便打印锁的状态和其他信息。</p><p>下面是一个简单的示例，假设有一个名为<code>my_lock</code>的锁，它的内部结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> &#123;</span><br>    <span class="hljs-type">int</span> is_locked;<br>    <span class="hljs-type">int</span> holding_pid;<br>    <span class="hljs-comment">// 其他锁相关的信息</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">my_lock</span>;</span><br></code></pre></td></tr></table></figure><p>在需要打印锁信息的地方，可以添加类似以下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Lock status: %s\n&quot;</span>, my_lock.is_locked ? <span class="hljs-string">&quot;Locked&quot;</span> : <span class="hljs-string">&quot;Unlocked&quot;</span>);<br><span class="hljs-keyword">if</span> (my_lock.is_locked) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Holding process ID: %d\n&quot;</span>, my_lock.holding_pid);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关于交叉编译的延伸"><a href="#关于交叉编译的延伸" class="headerlink" title="关于交叉编译的延伸"></a>关于交叉编译的延伸</h4><p>交叉编译是指在一个主机上为另一个不同体系结构的目标平台（通常是嵌入式系统或者其他类型的系统）编译软件。在交叉编译过程中，编译器、链接器和其他开发工具被配置为生成目标平台上可执行的代码，而不是在主机上运行的代码。</p><h4 id="关于riscv的延伸"><a href="#关于riscv的延伸" class="headerlink" title="关于riscv的延伸"></a>关于riscv的延伸</h4><p>RISC-V采用精简的指令集设计，只包含少量基本指令，并且设计为模块化的架构。它允许处理器设计者根据特定的应用需求选择添加适当的扩展，以实现更高级别的性能和功能，设计用于各种用途的计算机处理器，包括嵌入式系统、个人计算机、服务器和超级计算机等。它的设计理念是基于精简、模块化和可扩展的原则，旨在提供高性能、低功耗和可靠性。</p><p>可扩展性：RISC-V架构具有多个标准扩展，包括基本指令集（RV32I&#x2F;RV64I）、乘法&#x2F;除法扩展（M）、原子操作扩展（A）、浮点数扩展（F&#x2F;D）、向量扩展（V）等。这些扩展允许处理器设计者根据需求选择添加额外的功能，例如浮点运算、向量计算等。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>歌词存档</title>
    <link href="/2024/04/10/%E6%AD%8C%E8%AF%8D%E5%AD%98%E6%A1%A3/"/>
    <url>/2024/04/10/%E6%AD%8C%E8%AF%8D%E5%AD%98%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>前半部分歌词orz！感觉这版写的比之前的流水账好（后半段写的尤其好</p><p>以及今天投了简历玩（书到用时方恨少啊，，怎么就把之前的课件和课程资料全删光了，，</p><p>想过平凡的每天&#x2F;也想勇敢向前<br>想要游荡在旷野&#x2F;却把亲人想念<br>愤世嫉俗的谎言&#x2F;被无力感裹挟<br>清澈带盐的海风&#x2F;结局却不能回头</p><p>抬头是狂风沙暴&#x2F;北京真是荒漠<br>低头是预制汤锅&#x2F;吃货开始emo<br>明明已二十出头&#x2F;却仍不想长大<br>每天将光阴虚过&#x2F;我到底犯错了吗</p><p>技术不停地迭代&#x2F;他们奋力在追赶<br>人们啊各自相残&#x2F;以同伴尸骸为餐<br>数据像量子海洋&#x2F;海浪上升不停歇<br>城市被齐齐切割&#x2F;我们不停地坠落</p><p>秋冬春夏的色彩&#x2F;沿四面八方飞散<br>操纵者躲在幕后&#x2F;管窥着斑斓巨兽<br>人们紧紧地拥抱&#x2F;三维向二维坍缩<br>那文明绘制的画&#x2F;如此短暂而哀伤</p>]]></content>
    
    
    
    <tags>
      
      <tag>写歌尝试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生出来了！</title>
    <link href="/2024/04/08/%E7%94%9F%E5%87%BA%E6%9D%A5%E4%BA%86%EF%BC%81/"/>
    <url>/2024/04/08/%E7%94%9F%E5%87%BA%E6%9D%A5%E4%BA%86%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>在没有教程的情况下，学会了采样乐器的方法，学会了调试混音参数，学会了设定采样区间，学会了渐入渐出，而且今天编的旋律比昨天的好听（昨天的不适合唱，跨度太大，今天的已经比较接近一些口水歌了</p><p>明天去新太阳录demo</p><p>特地在中午洗头并且编了头发，戴了蝴蝶结，穿了短裙和小白鞋，学了一些（很多）国际音标（很神奇！）明天继续戴蝴蝶结（今天戴了弹簧夹，明天戴抓夹嘿嘿</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>音韵学存档</title>
    <link href="/2024/04/06/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%AD%98%E6%A1%A3/"/>
    <url>/2024/04/06/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%AD%98%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%9F%BA%E6%9C%AC%E4%BA%94%E5%85%83%E9%9F%B3.png" alt="基本五元音"><br>i-最高最前  u-最高最后  a-最低 开口度最大</p><p>中间的过渡生成了e和o两种音</p><p>前展后圆规律：发音在前的一定是展的，发音在后的一定是圆的</p><p><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E8%88%8C%E9%9D%A2%E5%85%83%E9%9F%B3.png" alt="舌面元音"><br>最中间的是央元音（着、了、的）（发音最轻松的音 所以一般用作助词</p><p><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E8%88%8C%E5%B0%96%E5%85%83%E9%9F%B3.png" alt="舌尖元音"><br>把“姿”和“知”的辅音部分去掉就变成那个不认识的东西的读音</p><p>另外两个就是把“卒”和“猪”的辅音部分去掉<br><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%8D%8A%E5%85%83%E9%9F%B3.png" alt="半元音"></p><p>牙和阳因为要发音（直接用作辅音的那种），所以要浊化一点（就是发音的厉害一点，，细微的区分</p>]]></content>
    
    
    
    <tags>
      
      <tag>音韵学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】</title>
    <link href="/2024/04/05/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%83%B3%E8%A6%81%E5%81%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E9%85%B7%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <url>/2024/04/05/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%83%B3%E8%A6%81%E5%81%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E9%85%B7%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    
    <content type="html"><![CDATA[<p><strong>关于我？@金宇彬好帅</strong><br>三分钟热度吧（诶<br>一个比较喜欢折腾的人，或者说我目前的人生一直以折腾为乐趣！</p><p><strong>How to Contact Me？</strong><br>vx：keplers_needy_Girl<br>（本来想留qq的 突然想起qq是之前我搞的烛句专用号，，本着三次和二次隔绝的原则决定留微信小号！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>梦想清单</title>
    <link href="/2024/04/03/%E6%A2%A6%E6%83%B3%E6%B8%85%E5%8D%95/"/>
    <url>/2024/04/03/%E6%A2%A6%E6%83%B3%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>感觉自己很长一段时间都处在一种迷茫的状态，很想走出这种状态！从现在开始尝试吧</p><p>我感觉我是比较幸运的人，父母也非常开明。我一直都认为工作是非常耗尽心力的事情，而且我对一致性、不变性的追求已经到了一种病态的程度，也许这和安全感的稀缺有关系。在昨天深更半夜和zjt聊天以及今天早上践行一些提问的时候“被迫”和父母进行了交谈，我才第一次意识到人生可以是不那么stable的。毕竟人生只有一次！我也认为应该活得wild一点。</p><p>我一直认为我是一个很注重稳定性的人，但是我发现我日常的举动无不体现着“自由精神”，从小翘课，公然违抗老师命令，有自己的主见，有自己喜欢的乐器和乐队，讨厌规规矩矩，讨厌被束缚。只是对安全感的过分追求让我作茧自缚。我想我不应该被困住。我企图用一条确定的道路困住自己，这样就可以自己不用再思考。但是被困住的人生真的是我想要的吗？</p><p><strong>我想要做出怎样的事，让6岁的自己崇敬不已？</strong></p><p>一定不是随波逐流，那时候我总是察言观色，非常没有安全感，如果我接下来的生活依然能够保持孩童的好奇心，想要了解什么就尽力去了解，不要丧失对生活的活力，大脑依旧在转动，想尝试什么就尽量尝试（比如说旅游、组乐队、编曲、画画、学语言、看文学作品）。那我一定会非常崇敬。</p><p><strong>如果我是上帝，准备怎样拯救世界？</strong></p><p>我很崇敬多萝西娅这样的上帝式的角色，她希望让身边的人都幸福而不太看重自己的幸福。其实我也无法想象怎么拯救世界，，，我希望像wowaka一样，燃烧自己，呐喊出自己心中所想，让别人在他的音乐中受到拯救，自己也受到了拯救，这种互相救赎的感觉是极好的。</p><p><strong>如果没有经济限制，你想做什么？</strong></p><p>在市中心有一套独立的小别墅（其实已经有了但是不在市中心，，无所谓，在杭州实现经济自由之后可能真的会回去吧，会请很长很长的年假！）（当然如果工作是线上的话就更好了，在哪里都无所谓，想回去就回去（我dream一下！）</p><p>但是那个小别墅应该是我爸妈养老的地方所以我还是倾向于自己搞一个场地，然后我就练练电吉他，疯一疯（如果能遇到志同道合的乐队朋友的话</p><p><strong>你认为在怎样的事情中可以复现你曾经的精神体验？</strong></p><p>沉浸式、、形成心流的事情其实都可以，画手书的时候（全神贯注），在新太阳地下室躲在门后用民谣吉他大唱特唱摇滚乐的时候，看完电影之后写感想的时候，总之是输出性质的工作的时候都可以</p><p><strong>如果只有一年好活了，你会干什么？</strong></p><p>买一个电吉他（没错我甚至还没有电吉他），配备一些小音箱，找个老师先领我入门然后我大玩特玩</p><p>吃很多很多的三文鱼</p><p>很想把家乡话学会，，现在是只能讲日常用语的程度，，（其实现在就想看看有没有记载太平话的音韵学的书</p><p><strong>你的高我的事业是什么？</strong></p><p>先渡己，后渡人。</p><p><strong>你希望被后世怎样记得？</strong></p><p>她是一个天真的老顽童，有些不可思议，似乎她总是很幸运，只要是她想要得到的她就一定会达成。（她可能拥有很多追随者，也可能身后空无一人，但这对她都无所谓</p><p><strong>你的墓碑上只能写一个身份，你希望是什么？</strong></p><p>自由人！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树洞奇遇</title>
    <link href="/2024/04/02/%E6%A0%91%E6%B4%9E%E5%A5%87%E9%81%87/"/>
    <url>/2024/04/02/%E6%A0%91%E6%B4%9E%E5%A5%87%E9%81%87/</url>
    
    <content type="html"><![CDATA[<p>歌词接龙 要求：不是同一首歌，但是意思能连贯起来</p><p>洞友的力量真是太强大了！（我是D君</p><blockquote><p>第一句：我来到，你的城市<br>#27690146 12小时前 04-02 00:46<br>[Alice] 坐在小酒馆的门口<br>#27690153 12小时前 04-02 00:46<br>[Bob] 来一首我最爱的普通音乐<br>#27690160 12小时前 04-02 00:47<br>[Carol] 钟声响起归家的讯号<br>#27690172 12小时前 04-02 00:48<br>[Dave] 夜太乱以为心已与你交换<br>（E君格式不对 叉出去<br>#27690183 12小时前 04-02 00:48<br>[Francis] 杂讯太多信号弱 就连风吹都要干扰<br>#27690185 12小时前 04-02 00:48<br>[Grace] 光落在你脸上 可爱一如往常<br>#27690188 12小时前 04-02 00:49<br>[Hans] 神魂颠倒<br>#27690191 12小时前 04-02 00:49<br>[Isabella] 我颠颠又倒倒<br>#27690211 12小时前 04-02 00:50<br>[Jason] 听得见过山车有远渐驶近<br>#27690288 12小时前 04-02 00:55<br>[Carol] 透过手指尖看着天<br>#27690319 12小时前 04-02 00:57<br>[Francis] 天黑黑 会不会 让我忘了你是谁<br>[Kate] Re Francis: 谁能给我麻木的酒 醒着醉<br>[Louis] Re Kate: 以为你 有天会感动<br>#27690459 12小时前 04-02 01:09<br>[Margaret] 你却始终站在梦里难触碰<br>#27691472 5小时前 04-02 08:26<br>[Nathan] 如果再看你一眼 是否还会有感觉<br>[Olivia] Re Nathan: 想着或许，下个路口仍是同样的结局<br>#27691836 4小时前 04-02 09:38<br>[Paul] 每天都追赶太阳</p></blockquote><p>中午不知道吃啥就点了袁记云饺，结果去了发现外卖没了，桌子上还摆放着好多袁记云饺。猜测估计是别人拿错了。刚发一条树洞就发现下一条刚好是那个同学发的（一路小跑拿回来好可爱哈哈哈哈哈哈啊哈哈）算是奇遇了，非常好玩。遂拎着袁记云饺去了理教（因为路上突然收到了见面课通知，but没带包 直奔签到现场吃饭然后折返</p><p>星有野居然玩蛋仔啊啊啊！狮哥狮姐啥时成哇（</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>今日（昨日）成就！</title>
    <link href="/2024/04/02/%E4%BB%8A%E6%97%A5%EF%BC%88%E6%98%A8%E6%97%A5%EF%BC%89%E6%88%90%E5%B0%B1%EF%BC%81/"/>
    <url>/2024/04/02/%E4%BB%8A%E6%97%A5%EF%BC%88%E6%98%A8%E6%97%A5%EF%BC%89%E6%88%90%E5%B0%B1%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>继上节体育课偶然发现自己已经可以连续踢出两个毽子后这几天加紧练习！虽然大部分时候还是只能踢一个但是偶尔也可以踢出四个（单只脚），有很大的进步！</p><p>爪爪大作战mvp及获胜记录增加了很多！爪爪技术精进！判断推理刚好看到讲义的第99页（经zjt提醒才发现还有网课要听），经济地理学完全不想写读书笔记，，，（打算gpt）主要这个学期看的电子书实在太多了比较烦了</p><p>感觉自己大学后期的学习主要看兴趣和内驱力，，感兴趣的就多看一点，不感兴趣的就少看一点，甚至感兴趣的都懒得按格式写（认为格式的组织影响了我脑内观点的输出），虽然老师站在学术的角度还是很强调格式，，不过选英语课的人有几个最后真的去做研究呢（至少选英语课的都不是外院的人，我也是觉得读论文比较有意思，反正我读的评论文体也少，不需要花大量时间去组织资料，可能做学术的更需要条条框框吧</p><p>甚至因为自己厌恶条条框框对自己将来的职业规划产生了怀疑。不过晚上仔细想了一下，如果是自己不感兴趣的内容（应付摆烂式），顺便把格式做了对我来说也没有大碍，主要还是自己感兴趣的内容因为自己有很多自己的想法，所以就不想按照格式。不过以后的工作大概率是自己不感兴趣的。无论是大厂螺丝钉比较单一的职能，还是信息老师这种单一授课，或者其他泛体制内岗位。所以如果怀着摆烂心态的话，有没有条条框框都无所谓了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>渐入佳境！</title>
    <link href="/2024/03/31/%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%EF%BC%81/"/>
    <url>/2024/03/31/%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>要失去多邻国连击了啊啊啊啊啊！！（迅速补了 看到很多浊音发音</p><p>没听过的单词背起来真的太狼狈了，hitorie的歌词也有局限（归根结底还是听得太少，，，于是今天紧急搜了一首别的</p><p>正好是告五人（居然唱日语！</p><blockquote><p>見て、晴れの日<br>mi te  hare no hi<br>看啊、是晴天呢</p></blockquote><p>本单元背单词be like：有种听答案以及听方言的感觉哈哈哈哈啊哈哈（</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>坠落的审判</title>
    <link href="/2024/03/28/%E5%9D%A0%E8%90%BD%E7%9A%84%E5%AE%A1%E5%88%A4/"/>
    <url>/2024/03/28/%E5%9D%A0%E8%90%BD%E7%9A%84%E5%AE%A1%E5%88%A4/</url>
    
    <content type="html"><![CDATA[<p>晚上看了树洞上吵得很凶的坠落的审判，确实感叹语境不同每个人的观感都不太一样，像有些没体验过类似处境的人可能就不太理解电影的观点，而不同的人也可能会有不同的观点。但是如果强行忽视电影所传达出来的女性主义观点而去揪着讨论别的不重要的意向，我认为是一种很高傲的行为。</p><p>这部片给了我很大的惊喜，虽然话题与画风都非常沉重，但是相比之前看的另一部女性主义电影（芭比），当时是怀着很大的期望，但是比较失望地走出来，感觉没有拍到自己想要看到的点。但是这部片很精确地表达了我的想法。我眼中的女性主义，可能不局限于女性一个性别。感觉有点矛盾，但是我的想法是影片中的妻子角色其实是平常家庭中的丈夫，而丈夫角色却是平常的妻子。光头律师为影片中的丈夫辩护，而梵尚则为妻子辩护，光头看似咄咄逼人，其实体现了很多女孩子（或者较为弱势的群体）的困境，即不得不采取一种激进的手段，即证明他杀来达到判刑的目的，（类似于必须将房子屋顶打破，才能开一扇窗户），但是这样的证明是必定失败的。因为精神控制所带来的迫害无法被证明，它不是实质性的可以构成证据的损害，有很大的主观性。所以在开头我就知道妻子不可能被判刑，她一定会被无罪释放。</p><p>和npy一起看这个影片，并做了很多讨论。我们两个个体都有各自的特殊性。我从小在男生堆里长大，而他却截然相反。所以我们都具有对方性别的一些观念。他结合自己家庭的情况认为妻子（即日常的丈夫）理应做出更多，但我结合自己家庭的情况认为在大部分情况下只能采用无奈的措施，即牺牲其中一方，否则对于整体不利。总之感觉是一个取舍的问题。只有双方达成共识，要么都不牺牲，要么另一方必须看到对方做出的牺牲，ta不能粗暴地认为对方的事情全部是由于自由意志，（看似是自由意志，其实是在特定语境下做出的妥协与权衡），当一方的退让不被看见，那么就必然爆发极大的争端。</p><p>其中一个共识是那个边牧真的好可怜orz！And npy提出了一个疑问是为什么最后男孩会选择为妈妈辩护，我的理解是那是小孩的无奈之举吧，曾经小孩认为母亲是一个怪物，但是最后他们还是要生活在同一屋檐下，而母亲也确实是爱着这个小孩，所以小孩最终还是接受了她。就和很多家庭的结局一样，伤害者和被伤害者被血缘与爱的锁链禁锢，最终还是相互原谅，和平地生活在一起（）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>尝试独立做出数据库题目！</title>
    <link href="/2024/03/27/%E5%B0%9D%E8%AF%95%E7%8B%AC%E7%AB%8B%E5%81%9A%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%EF%BC%81/"/>
    <url>/2024/03/27/%E5%B0%9D%E8%AF%95%E7%8B%AC%E7%AB%8B%E5%81%9A%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>实在觉得老是抄不太好，所以决定认真学数据库！（一方面也是因为以后可能要当信息老师，一个信息老师如果连数据库都不会怎么教学生嘻嘻</p><blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>求没有供应零件号为P1和P2两种零件的供应商姓名。</p></blockquote><p>苯人直接自信上代码！</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME<br><span class="hljs-keyword">FROM</span> S <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span> S.SNO=SPJ.SNO<br><span class="hljs-keyword">WHERE</span> SPJ.PNO&lt;&gt;<span class="hljs-string">&#x27;P1&#x27;</span> <span class="hljs-keyword">AND</span> SPJ.PNO&lt;&gt;<span class="hljs-string">&#x27;P2&#x27;</span><br></code></pre></td></tr></table></figure><p>不出意外又是wrong answer，，，来看看到底哪里出了问题</p><p>首先左连接肯定是对的（万一有供货商一个货都没供过呢</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/c98e040f4e9128d2e3b7de08207b89c.jpg" alt="发现了问题所在"></p><p>它删除了供货商供货P1,P2的两行，然后把这个供应商供货其他货物的信息原封不动地保留了下来（我本来下意识以为它会自动删掉来着，但是本质上筛下来的是除了P1和P2以外的供货记录</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SNAME<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">WHERE</span> SNO <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> SNO<br><span class="hljs-keyword">FROM</span> SPJ<br><span class="hljs-keyword">WHERE</span> PNO=<span class="hljs-string">&#x27;P1&#x27;</span> <span class="hljs-keyword">OR</span> PNO=<span class="hljs-string">&#x27;P2&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>成功AC！</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金宇彬好笨</title>
    <link href="/2024/03/27/%E9%87%91%E5%AE%87%E5%BD%AC%E5%A5%BD%E7%AC%A8/"/>
    <url>/2024/03/27/%E9%87%91%E5%AE%87%E5%BD%AC%E5%A5%BD%E7%AC%A8/</url>
    
    <content type="html"><![CDATA[<p>这个系列用来专门更数据库<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240327124313.png" alt="列出所有供应商的信息"><br>总的说来就是列出所有供应商的信息，包括供应商姓名、所供应的零件名（没有供应零件的供应商也要列出，最后结果中不要出现重复元组）</p><p>想实现的效果like this<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/fd6783cf6517e9620578fc548e54fa6.jpg" alt="主要的痛点在于空行怎么实现"><br>在网上看到了一个用banbao搭博客的学长（姑且称他为banbao学长）的代码，但是运行之后是错误的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">select distinct S<span class="hljs-selector-class">.SNAME</span>, P<span class="hljs-selector-class">.PNAME</span><br>from S,SPJ,P<br>where S<span class="hljs-selector-class">.SNO</span> = SPJ<span class="hljs-selector-class">.SNO</span> and SPJ<span class="hljs-selector-class">.PNO</span> = P.PNO<br></code></pre></td></tr></table></figure><p>还没从关系模型里一堆奇怪的符号转过弯来的我表示震惊，大致研究了一下，distinct可以去掉重复行，from的作用是笛卡尔积（不是自然连接！！！！！）where这行起到了自然连接的作用</p><p>笛卡尔积就是无脑乘起来（相当于小学的乘法法则 总共有a×b×c种</p><p>但是对于苯人贫瘠的脑子还是无法想象，于是我想起以前高中某信息代课老师笨笨的做法，以上表为例全部列了出来</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%A4%A7%E5%8A%9B%E5%87%BA%E5%A5%87%E8%BF%B9.jpg" alt="大力出奇迹"></p><p>于是恍然大悟（模拟自然连接的筛选法则</p><p>所以学长的问题在于他没有实现空行，如何把空行揪出来呢</p><p>网上查询了一下（GPT），可以通过左外连接来实现这个需求。左外连接可以保证左边表（S 表）的所有记录都会被返回，即使它们在右边的表（这里是 SPJ 表）中没有匹配的记录。对于没有供应零件的供应商，其相关的零件名字段会返回为 NULL。</p><p>正确的代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME, P.PNAME<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span> S.SNO = SPJ.SNO<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> P <span class="hljs-keyword">ON</span> SPJ.PNO = P.PNO<br></code></pre></td></tr></table></figure><p>和学长代码的主要区别就是把（伪）自然连接换成了左外连接！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Tiring</title>
    <link href="/2024/03/25/Tiring/"/>
    <url>/2024/03/25/Tiring/</url>
    
    <content type="html"><![CDATA[<p>最近居然产生了一种疲惫感，，一段时间内应该不会再弹太多hitorie的歌了，一方面也是觉得很多曲子弹不出原有的风味。后期应该会梳理一份比较适合吉他弹唱的歌单，在毕业之前想在石舫弹琴唱歌（flag</p><p>报名了普通话考试，清明的时候去开放大学考。可能得稍微准备准备（沉淀.jpg</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>济南的春天</title>
    <link href="/2024/03/24/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/"/>
    <url>/2024/03/24/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>周末出逃济南行程记录~</p><p>周五zjt提前结束了小班课故提前出发！在北京南站吃了一顿汉堡王（黑松露和另一个什么味，因为黑松露更好吃所以只记住了黑松露），晚上七点到达“县城”济南站。</p><p>挑几张没有发票圈的放在博客里面hhh</p><p><img src="/../img/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/IMG_20240324_222649.jpg" alt="一出站就看到经一路的火车雕像"></p><p><img src="/../img/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/1711165164818_121418_edit_100645265969537.jpg" alt="美仑酒店的早餐，虽然离景点有二十分钟车程但是非常丰盛"></p><p>除了大明湖和几个专门给小孩子玩的水池以外其他的水真的很清澈！不愧是泉城，很喜欢这里的水。周六这天较为暖和，穿了在北京还没穿过的粉色v领薄毛衣，先趁早去了趵突泉，占领了与对岸相比人少了很多的高地。若不是知道是由于地下断层之类的原因，真的会认为底下有一个水泵在持续不断的运作。</p><p>池底和台阶都有细细密密的气泡偶尔升上来，如果在这边一直发呆，看着气泡上升也是一件美事。几乎每一个泉都清澈见底，红色的小鱼惬意地游动，还能看到池底的钱币，可惜由于反光而且缺乏专业的摄影设施所以拍不出此番美景。从南门出来打车去了大明湖公园，在门口领教了民间中华毽和太极拳，太极可能我们这边还有，但是毽子我们那边真的不咋踢。这与气候有很大的关系，毕竟我们那边多雨潮湿，毽子一旦遇雨则会变成落汤鸡。玉兰花开得极盛，园内的其他花也争奇斗艳。刚好遇上了樱花节，与园子里的各种花美美合影。</p><p>中午骑车去五龙潭附近吃饭，共享单车一直显示离停车点还有7m无法停车，悻悻地交了5块钱调度费。吃完之后便去景区里面游玩。一个巨大的收获是认识了两个水鸟的名字。北京各个湖中常见的“潜水鸭”原来是䴙䴘，那只一直伸头的蠢鸭子竟然是游泳的鸡（骨顶鸡）。</p><p>逛完五龙潭后回酒店休整，晚上来附近的一家鲁菜馆觅食之后又爬了回去（走不动是这样的）。葱烧鲤鱼非常好吃！剥好的虾姑也不错（有点咸，刚好下饭</p><p>DAY2济南大降温，刮了很大的风。去了环城公园（白石泉、黑虎泉、宽厚里、解放阁都在这一块），还买了一杯济南大碗茶。去宽厚里吃了中饭便打道回府，收拾东西之后开始了“流浪生活”，打卡了经三与纬三的爱心路口，买了一只zjt心心念念的德州扒鸡回到酒店大厅大快朵颐，准备回程。</p><p>可能是因为五哈录节目的原因，周日济南人尤其多，像春运一样，非常庆幸在周六那天起的特别早并且错峰看完了景点。火车票更是早早的就没有了（还好提前抢了）。为了赶周一的课周日晚上就回到了北京，迎接北京的雨水！（天气预报看早了，对两地的气温做了一些错误的估计</p><p><img src="/../img/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/IMG_20240324_202123.jpg" alt="Jungle Tiger限定皮肤"></p><p>由于对济南的道路命名方式非常好奇于是查了一下。第一种理论说济南受山河地形影响，东西狭长，南北窄小。古时织物“长者为经，短者为纬”，故将商埠区内东西方向的长道路命名为经，南北方向的短道路命名为纬。另一种理论则是古代建城讲究阴阳五行之说，“山南水北为阳，山北水南为阴”，而济南城位于山北水南皆为阴，从地理位置上阴气重，因此当时建城官员在命名时便将经纬逆转，抵消阴气，使得乾坤颠倒，由阴转阳。所以经一、纬三这种这么现代化的名字原来是古代起的！感到非常神奇。</p>]]></content>
    
    
    
    <tags>
      
      <tag>travel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大唱特唱想念！</title>
    <link href="/2024/03/21/%E5%A4%A7%E5%94%B1%E7%89%B9%E5%94%B1%E6%83%B3%E5%BF%B5%EF%BC%81/"/>
    <url>/2024/03/21/%E5%A4%A7%E5%94%B1%E7%89%B9%E5%94%B1%E6%83%B3%E5%BF%B5%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>唱歌的时候偶尔会唱到非常非常有感觉的歌！！就唱得非常率性特别开心！但是重唱一遍就唱不出那个感觉orz</p><p>对摇滚在音乐上的定义一般是三和弦的强调与重复，而且右手力量上来了之后可以非常迅速地扫弦（把木吉他弹成电吉他的感觉），but电吉他好贵and门槛好高，可能要等有一个自己的地下室之后再配备相关的装备。唱的时候就可以专注于情绪的表达而不是和弦的走向！喜欢这种率性的感觉。</p><p>之前是唱了nazenaze，这次唱了梁博的想念，差点忘了梁博也是摇滚歌手了ww。每次练完wowaka都会随机找一首很久没听的歌来当做换换口味。感觉快把自己唱哭了，果然看得懂歌词的歌更容易感情共鸣，but之后再唱一定又是不同的感觉了。很喜欢这种感觉。树洞上看到有人在听hitorie的歌，很感动，希望有越来越多的人听他的声音（感觉好像传教士，给自己赋予了亿点点宗教精神）</p><p>moikai！moikai！！最遗憾的就是这首歌一直唱不出自己想要的感觉（现场真的太炸了啊啊啊啊超喜欢现场），估计是调太低了，下次调高一点试试看，，，（阿里嘎多真的好可爱</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ollama</title>
    <link href="/2024/03/21/Ollama/"/>
    <url>/2024/03/21/Ollama/</url>
    
    <content type="html"><![CDATA[<p>昨天加入了环境变量，之前困扰的ollama报错问题也解决了。<br><img src="/../img/ollama/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.png" alt="运行环境"><br><img src="/../img/ollama/%E4%BB%A5%E6%B5%81%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B.png" alt="以流的形式运行实例"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ollama<br>stream = ollama.chat(<br>    model=<span class="hljs-string">&#x27;MyModel&#x27;</span>,<br>    messages=[&#123;<span class="hljs-string">&#x27;role&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>: <span class="hljs-string">&#x27;Why is the sky blue?&#x27;</span>&#125;],<br>    stream=<span class="hljs-literal">True</span>,<br>)<br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> stream:<br>  <span class="hljs-built_in">print</span>(chunk[<span class="hljs-string">&#x27;message&#x27;</span>][<span class="hljs-string">&#x27;content&#x27;</span>], end=<span class="hljs-string">&#x27;&#x27;</span>, flush=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ollama</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩了AI</title>
    <link href="/2024/03/20/%E7%8E%A9%E4%BA%86AI/"/>
    <url>/2024/03/20/%E7%8E%A9%E4%BA%86AI/</url>
    
    <content type="html"><![CDATA[<p>第一次跑一个ai的实例独立跑通了！之前没跑通是因为环境变量的问题，设置了环境变量就好了！（事实证明不能忽视控制台的警告哇</p><p>本地部署完成！（算是？</p><p>成就：获得免费API（记得运行的时候要全局翻墙</p><p><img src="/../img/%E7%8E%A9%E4%BA%86AI/API_keys.png" alt="API keys"><br><img src="/../img/%E7%8E%A9%E4%BA%86AI/%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B.png" alt="运行示例"><br>源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> groq <span class="hljs-keyword">import</span> Groq<br><br>client = Groq(api_key=<span class="hljs-string">&quot;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&quot;</span>)<br><br>chat_completion = client.chat.completions.create(<br>    messages=[<br>        &#123;<br>            <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,<br>            <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;why is the sea blue?&quot;</span>,<br>        &#125;<br>    ],<br>    model=<span class="hljs-string">&quot;gemma-7b-it&quot;</span>,<br>)<br><br><span class="hljs-built_in">print</span>(chat_completion.choices[<span class="hljs-number">0</span>].message.content)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>groq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nonsense!</title>
    <link href="/2024/03/20/Nonsense/"/>
    <url>/2024/03/20/Nonsense/</url>
    
    <content type="html"><![CDATA[<p>新太阳的免费乐谱架被搬走了（悲），接下来只能自己把乐谱架搬到新太阳练了。今天为了解放脖子除了学（W）here以外完全没有看谱子唱，（虽然感觉言之无物but唱得很自由很放松！）</p><p>rolling girl的现场特别特别伟大，，，moikai！！moikai！！</p><p>NONSENSE感觉比unknown mother goose还难唱，，bpm太高了orz</p><p>文字上的判断推理只差最后一p视频了，然后就是图推ww！希望立体图可以不要再无脑蒙选项</p><p>suno.ai做出来的榜单前几的音乐都挺好听耶，，，（第二的合成器波感觉很可），，还以为做出来的曲子都是些不三不四的曲子，有点超出想象了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>立方棱镜</title>
    <link href="/2024/03/19/%E7%AB%8B%E6%96%B9%E6%A3%B1%E9%95%9C/"/>
    <url>/2024/03/19/%E7%AB%8B%E6%96%B9%E6%A3%B1%E9%95%9C/</url>
    
    <content type="html"><![CDATA[<p>成功把姐妹带入hitorie坑！wowaka门！</p><p>看了立方棱镜的现场，特别特别伟大，，，和v曲完全不同的感觉，但是两版都很好听，，，</p><p>今天外面风大得要死，向北拜访小天鹅一家，差点错过了探奥签到（其实是路过二教楼下突然想起今天是周二，遂跑步前往理教，签完遂溜），路过东侧门草坪，这么大的风甚至也能找到摄影的同学。第一次在湖面上直观的感受到了风的形状，湖面上的波光特别美丽，因为风大所以湖边人少，找了很久终于找到了天鹅一家，我一直远远地观望，不想打扰到他们，后来来了几个同学怼脸看，于是天鹅一家便迁徙到我的位置，甚至还能看到他们上岸、下水、梳理羽毛。这风刮得我肺疼，不过能近距离观测小天鹅也值了！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>乡村路带我回家</title>
    <link href="/2024/03/18/%E4%B9%A1%E6%9D%91%E8%B7%AF%E5%B8%A6%E6%88%91%E5%9B%9E%E5%AE%B6/"/>
    <url>/2024/03/18/%E4%B9%A1%E6%9D%91%E8%B7%AF%E5%B8%A6%E6%88%91%E5%9B%9E%E5%AE%B6/</url>
    
    <content type="html"><![CDATA[<p>打开b站发现很喜欢的一个雨世界手书博主更新了，真的很喜欢胖猫线，非常温暖的归乡色调，，，hyx潸然泪下</p><p>刚好今天也和室友聊了雨世界的世界观，，看到这样一条评论非常喜欢</p><blockquote><p>对于蛞蝓猫而言，迭代器这样的造物宛若神明，而祂们或是祂们的创造者所追求的飞升，则更是无法企及的东西——但那与猫猫有又有什么关系呢？蛞蝓猫只是一个黏糊糊的小动物，想要的也只是能吃饱、能躲雨和能找到家人罢了。<br>我认为DLC的那些结局是对原版那种极度虚无的飞升结局的一种否定：或许最终一切都会归于虚无，但现在，你仍旧可以追求现世的幸福，与自己的家人和同伴在一起，共同度过一段美好的时光。胖猫打开了返乡的大门，黄白可以回到猫猫树，矛大师回到了红日身边，水猫选择在月姐这里留下——也许并不是所有猫猫都有好结局，但至少，我们并非只有遁入虚无这一件事可做。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>采风</title>
    <link href="/2024/03/18/%E9%87%87%E9%A3%8E/"/>
    <url>/2024/03/18/%E9%87%87%E9%A3%8E/</url>
    
    <content type="html"><![CDATA[<p>久违地去了北边，看了很多很多的新生的枝叶与花花。拍了很多很满意的构图，新生的枝叶与未落尽的枯叶，橙色的枫叶与粉白的山桃同框，未开的花苞，柔软的柳枝，蜘蛛网和树枝上留下的小鸟的绒毛也一并记录，发光的枝条与闪烁的花朵，蓝白相间的天空。</p><p>私以为春天的花朵与机械质地的摄像头同框有一种戴着镣铐跳舞的美。</p><p>在北边碰到一个奶奶，这个奶奶想去未名湖边（然鹅我自己也迷路），遂取消了寻找小天鹅计划，帮她拍了几张照并且带她去了未名湖。大概是想起了自己家里的长辈所以产生了老吾老以及人之老的念头。虽然后面就没怎么拍花了，但对我来说是很有意义感的一段小插曲。（甚至因为刚好在湖边目睹了鸭鸭交配的全过程）奶奶的孙子也在北大读书，但是因为课业忙所以让老人一个人在学校转悠x （哼！借口，如果我外婆过来北大我肯定翘课陪她玩</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>天微微仔光</title>
    <link href="/2024/03/17/%E5%A4%A9%E5%BE%AE%E5%BE%AE%E4%BB%94%E5%85%89/"/>
    <url>/2024/03/17/%E5%A4%A9%E5%BE%AE%E5%BE%AE%E4%BB%94%E5%85%89/</url>
    
    <content type="html"><![CDATA[<p>发现日摇（或日摇风格）乐队大多对音乐有一种虔诚。有一种献祭的味道。</p><p>起因是对象给我推了一首很对我胃口的歌，有一条弹幕“某某市某某县某某街道毫无压力”，虽然和我那个街道只差10分钟车程。由于up主自制的mv有一种浓浓的佛教味与雨世界味（虚空流体飞升）所以天然增强了亲切感，了解了一下这首歌的背景，是一段很悲伤的历史。</p><p>虽然主唱感觉音色和我很相似，但是听到后面觉得完全是摇滚风格，，真的很喜欢这个风格，知乎上搜了一下发现确实是非常喜欢的日摇风格（虽然我日摇风格也听得不多，只听过hitorie笑死</p><p>本来就听不懂的闽南语（好像日语）和日摇风格混合，感觉又有点二次元味，让人心里涌起了一种奇异之感。副歌的怒音很震撼，让我产生了一种想要像了解hitorie一样了解这个乐队的冲动。</p><p>总之大晚上听到这样的音乐很激动，，，不知道几点能睡着了，十一点半迅速码了一篇平复一下我激动的心情，，，（有人一直在连我的耳机 平时早就怒关电脑睡觉了，愣是支棱起来为了循环久一点硬是解决了耳机问题，，，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>突然回想！</title>
    <link href="/2024/03/17/%E7%AA%81%E7%84%B6%E5%9B%9E%E6%83%B3%EF%BC%81/"/>
    <url>/2024/03/17/%E7%AA%81%E7%84%B6%E5%9B%9E%E6%83%B3%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>食欲不振所以买了葡萄糖酸锌口服液，仔细一看自己平时吃的维生素，发现自己吃的维生素里面就有好多锌（是吃的那一支的几十倍了），极为震撼。</p><p>看到华农兄弟的“总集篇”，感觉好感慨，有一种蒙太奇的感觉（）一个小小的通知，荒废的养殖场，屏幕前乐观的脸，这么多亩的油菜，，，又看到对象转的一些童年动画片讽刺现在的一些现象，恰值3·15，这么多不达标的食材，，，要不是北京菜这么难吃而且都是预制菜，我也不会厌食了</p><p>自习的时候不知怎的就想起以前在年级大会上的“光荣事迹”，一查才发现原来是这个意思，瞬间脚趾抠地，，，不过这种事情大家估计都忘记了（万幸</p><p><img src="/../img/%E7%AA%81%E7%84%B6%E6%83%B3%E8%B5%B7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240317200634.png" alt="救大命"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>立竿见影</title>
    <link href="/2024/03/16/%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1/"/>
    <url>/2024/03/16/%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<p>吃了一颗鱼油立刻狂打哈欠，，，真的假的</p><p>中午逼着自己吃了三两米饭！一颗鱼油下肚之后回到寝室一分钟内已经打了十几个哈欠。吃了香蕉 吃了开心果（半包 做完了数据库作业！待会加餐（加餐失败</p><p>晚上去吃了老爸推荐的餐厅（虽然他说我菜点的不好，没鱼没虾的），有被环境吓到（毕竟是第一次和同龄人不在父母陪同下去吃这种餐厅），然后吃掉了一半多的羊肉（有史以来吃的最多的一次，zjt吃了一半，我没数自己吃了多少但是觉得自己吃的也很多），感觉自己看上去已经做好了长大的准备但是实际上心里还没做好长大的准备orz</p><p>花粉粉尘严重超标，感觉快过敏了，风巨大无比，感觉头发上也沾满了粉尘。看了一节判断推理，本来直接扔掉的题目现在强的要命，，（换个地方学数理逻辑</p><p><img src="/../img/%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240316220014.png" alt="聊天截图"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>增重计划！</title>
    <link href="/2024/03/15/%E5%A2%9E%E9%87%8D%E8%AE%A1%E5%88%92%EF%BC%81/"/>
    <url>/2024/03/15/%E5%A2%9E%E9%87%8D%E8%AE%A1%E5%88%92%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>继晚上在北京的街头痛哭流涕之后苯人的增重计划开始！</p><p>过瘦可能会导致贫血、尿、记忆衰退、胆结石之类的疾病，研究更指出男性有140% 、女性有100% 的机率会死得更早！（通过类似闭眼单脚站的恐吓术直接实现增加重视度！</p><p>重点提要：每天吃进去的热量要多于自己消耗的！</p><p>看到网上的食谱，说女生增重和男生增重基本没有区别，唯一的区别就是增加黄豆、木瓜、坚果、莴笋、猪脚等等的食物。首先排除猪脚（虽然gqq爱吃但是我是真的不会吃！！！），木瓜，，毫无疑问也是我平时基本不吃的东西，but坚果可以！正好桌上有坚果！吃掉！莴笋平时经常吃，黄豆经常会和肉放在一起，下次一定也要吃掉！（好像可以通过练臀和练胸来增重，先试着吃多一点吧</p><p>餐前不要喝水和饮料！！！避免让它们充满我的胃！多吃香蕉！！优先选择能量密度大的食物。</p><p><img src="/../img/%E5%A2%9E%E9%87%8D/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240315205112.png" alt="含有碳水化合物的食物"></p><p><img src="/../img/%E5%A2%9E%E9%87%8D/15g%E7%A2%B3%E6%B0%B4%E5%8C%96%E5%90%88%E7%89%A9.png" alt="15g碳水形象化"></p><p>吃碳水吃碳水吃碳水！！！吃高能量食物！</p><blockquote><p>坚果：杏仁、核桃、夏威夷豆、花生等。<br>水果干：葡萄干、梅干等。<br>高脂：全脂牛奶、优格、起司、奶油等。<br>油：初榨橄榄油、酪梨油、夏威夷坚果油等。<br>谷物：燕麦、米饭等。<br>肉类：鸡肉、牛肉、猪肉、羊肉等，选择较不油腻的区块。<br>薯类：马铃淑、山药、番薯等。<br>黑巧克力、花生酱、椰奶等食物。</p></blockquote><p>全脂牛奶是极好的（看来hyx要开始买麦片了。</p><p>增加有氧运动（等姨妈期过后吧，85km还没咋跑哇哇哇柳絮要来了ww</p><p>发现食谱里好多都是不爱吃的东西，，难怪增不了重，，zjt竟然在公司里一个月重了5斤！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些感慨</title>
    <link href="/2024/03/15/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%85%A8/"/>
    <url>/2024/03/15/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%85%A8/</url>
    
    <content type="html"><![CDATA[<p>看到一篇gzh讲了县城心理老师的处境，感觉很感慨。当年去tzyz讲学（忘了）的时候就觉得这些孩子的心理都比我们学校的健康太多，甚至还有一个专门的心理楼层，我都不知道我们学校的那个在哪，之前问了cxzx的npy，他说他们学校有定期的心理课，但是我们学校却一次都没有开过，班会课也都是打鸡血。我心理最崩溃的时候会偷偷跑到隔壁的空教室待在那边哭，一哭就是一节课，but不知道的老师还以为我是过去学习的，然后开始鼓励我们班的同学和我一样占领旁边的空教室，感觉心里也挺复杂的哈哈哈。</p><p>当时接触到一个tzyz的妹妹，她说家里人说她的问题就是太放松了，感觉考不上清北，只能考上浙大、人大或者复交，我心里就想考不上清北挺好的，干嘛人人都去冲清北呢，掉车尾多难受，，那个学校拥有整个tz最大的心理中心，是一所示范学校。而我们是完全效仿衡水。感觉到了高三每个人都很压抑，很心累，已经不愿回忆了，可能每个人都有每个人的烦恼。之前还看见北京的孩子很凡尔赛地说着“课外活动太多了负担不过来”，可能人家的烦恼是我们所理解不来的吧。</p><p>今天三个人围在一起踢毽子，由原来的没有办法发球到渐渐能接几个球了，感觉挺好hhh有进步就好，一方面生理期也是重要影响因素。课前闭眼单脚站差点变成全班站最久的，吓鼠我了。不过还是很欣喜。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些零碎</title>
    <link href="/2024/03/14/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E/"/>
    <url>/2024/03/14/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E/</url>
    
    <content type="html"><![CDATA[<p>昨天收拾了所有换季的衣服，把衣柜基本清理干净了！今天想点一杯姨妈热饮x 因为来姨妈的原因巨累无比，明天好想请假（</p><p>看老师跑了本地大模型跃跃欲试，觉得这个很简单自己又可以了，结果又遇到一些不知名报错（）不进厂是对的，环境都配不来（尖叫</p><p>进厂可以，但是要先找一个人帮我把所有环境配好（可能Mac真的会好配很多，，，吧，但据说现在Mac也很难配了），然后让我没有任何后顾之忧地开发（那还是当老师吧，不用导入这么多乱七八糟的东西只需要讲算法，but又想起今年奶奶让我修电视的经历（我：不会修哇） 有时候也不知道自己大学学了什么 感觉学了一堆高深莫测的理论 你有这么先进的机械进入中国！记住我给出的原理！</p><p>选了天空群岛做壁纸，本来想选有彩虹的那张但是清晰度太低了，于是选了在广播系统上的矛大师（你）用了可爱的rw鼠标指针（编辑文字的时候是垃圾佬钻管道，默认状态下是垃圾佬抖腿），本来还有一只蠕动的桌宠但是太烧cpu了</p><p>看了一点判断推理，觉得类比推理还是很玄学（鼙鼓一点都坐不住啊啊啊啊啊啊还是漫画好看</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些零碎的事情</title>
    <link href="/2024/03/13/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <url>/2024/03/13/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    
    <content type="html"><![CDATA[<p>昨天晚上回来的时候心情真的特别烦想要找个人说说话，但是一想到过去一些失败的社交经历就瞬间萎掉了。感觉自己没有办法找到“沉默不语或漫不经心地听”“喋喋不休”的过渡点，所以大部分时候的讲话都处在“无目的地应和”，这样既避免了沉默，也避免了喋喋不休。而与陌生人的交流却非常擅长。我会率先挑起话题并且确定这个话题双方都感兴趣（毕竟就是在那个场合才认识了陌生人），然后呢，就没有然后了。感觉人是孤独的吧。但是别人却能找到叽叽喳喳的同伴，我却没有这样的人。即便是之前的关系也鲜少维护。大部分时候觉得一个人挺好，但是没有考虑到在亲密关系的维护中也是同理。以前是想去社交的，后来发现一致的人太少，大部分人只是走在自己的道路上罢了，鲜少有人主动关心别人身上到底发生了什么。所以遇见这样的人我很感激，但这样的人也往往只是闪耀了一瞬便消失在自己的视野。</p><p>我的视野范围内还是没有这样的人。我大抵是和凉先辈一样的角色，或者弗兰肯斯坦，将自己囚禁在一个小小的地下室中。我很孤独，不过我也确实获得了快乐。想复制一个自己，但是复制出来又然后呢？她会替代我吗？单纯作为一个陪玩的工具还是不太好吧。这又牵扯到生命意义的问题了。不过我可以肯定地说，即便身边有人，我也仍然处于一个人的状态。这让我不禁思考，关系的意义到底又是什么呢？只是为了“无目的的应和”吗？写到这里情绪又上来了，情绪的源头到底又在哪里呢？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些神奇的想法</title>
    <link href="/2024/03/09/%E4%B8%80%E4%BA%9B%E7%A5%9E%E5%A5%87%E7%9A%84%E6%83%B3%E6%B3%95/"/>
    <url>/2024/03/09/%E4%B8%80%E4%BA%9B%E7%A5%9E%E5%A5%87%E7%9A%84%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本来只是想上小红书搜一些学习攻略结果不小心又点进视频里面了（捂脸），发现已经刷到很多宠物鹦鹉撕纸放在身后的行为，觉得很神奇，所以检索了一下，发现这是母鸟絮窝的方式，就是把草咬成一小截一小截，插在后面鼙鼓羽毛下，这样就可以带很多根，也叫别草。这是成鸟准备繁殖的信号。</p><p>之前吃饭的时候也想到为什么要吃盐的原因，有姐妹帮我查了是因为动物喜欢去盐碱地舔一舔盐巴，然后人们发现这种物质会让动物兴奋，于是就自己也尝了尝。感觉很多自然界的事情都特别有意思！</p><p>今天真的好渴，，，而且连考三门真的太反人性了！虽然大概率是陪考，不过科三的时候摸鱼画证件照画得差点在考场笑出来，，，下次不干了，，，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>明与暗</title>
    <link href="/2024/03/08/%E6%98%8E%E4%B8%8E%E6%9A%97/"/>
    <url>/2024/03/08/%E6%98%8E%E4%B8%8E%E6%9A%97/</url>
    
    <content type="html"><![CDATA[<p>我总是会为一些替代经历产生恐惧。因为害怕被伤害选择逃避，试图排除所有的危险，也许是对于幼儿时期的“全能自我”的迷恋，希望一辈子都像一个婴儿一样被所有人关心，即退行，而这也是我一直以来的防御机制。</p><p>转载了一点知乎的回答，觉得写的特别好，所以时时翻看勉励自己。</p><p>逃避伤害是对的，但是他的目的应该是为了尽可能选择值得的牺牲，而不是为了永远幸福地生活下去。如果“千万不要受伤害”在决策中变得越来越重要，只会让人生被浸透在“可能受伤害”的恐惧之中。越是恐惧，便越是敏感。最后除了自绝于人类，将没有任何手段能安抚极端敏感的恐惧。</p><p>要学会主动接受受伤的可能性，即聪明的受伤、有控制的、有意的受伤。在不断受伤之中形成耐受、脱去敏感，“伤害”的威力也就被剥夺了。</p><p>“于何时在何地为何人接受何种受伤的风险”应该是经过深思熟虑后进行的一种选择，而且这种选择应该贯穿整个人生。</p><p>与这种可能性主动的共舞，慢慢就会学会跳舞，于是别人不敢的，你敢；别人不肯的，你肯；别人不能的，你能。慢慢地就会体会到，唯有有效的牺牲是真正幸福的。因为人终将死去，你所舍不得牺牲的最终仍然会化为飞烟，你根本就不能选择“不失去”。</p><p>牺牲有技巧，有价值最大化的复杂策略。你不能选择拒绝牺牲，而只能选择学习牺牲的智慧和技术。如何将有限的人生转化为最大的人类福利、世界的福利，是一门需要毕生学习的课程。</p><p>你回避一种伤害，只该是因为不愿虚掷你的“受伤余额”，但绝不是为了守着这份余额到死的。不要再在一次次逃避中践踏光阴了！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HITORIE</title>
    <link href="/2024/03/06/HITORIE/"/>
    <url>/2024/03/06/HITORIE/</url>
    
    <content type="html"><![CDATA[<p>在地下室大唱特唱HITORIE。过路的人问我为什么喜欢日本的歌，我不假思索地回答，因为我喜欢HITORIE这个乐队，准确的说，我喜欢这个乐队的主唱。</p><p>wowaka的歌都很难翻唱。他的几首比较广为传诵的歌都是非常快的bpm，令人上气不接下气，但是在我非常低落的时期，他那种宣泄式的嘶吼的迷茫是我的精神支柱。从进入大学以来，几乎每个学期都在循环他的老歌。</p><p>发现冬野里有一句歌词是，“所有人都拥有的&#x2F;唯一的&#x2F;心脏&#x2F;即使被洋溢的色彩所浸染&#x2F;也依然跳不够&#x2F;不要离开我”，很感慨。</p><p>在五月天假唱风波时，我会想到wowaka的万人合唱unknown-mother goose现场。每一个人都向前挥动着手臂，就像巨浪。他不够高，甚至够不到立式话筒。但是他踮起脚抬起头，似乎是咬牙切齿地，但是饱含感情地喊出每一个词，弹奏着手中的电吉他。当我第一次听到现场最后那个爆发式的质问时，我的眼泪情不自禁地流了下来。有人假唱，有人燃尽生命怒吼。</p><p>从那首歌起，我对他的认知从一个净写些这么难翻唱的v家曲的p主，到发自内心认为他是一个可敬的歌者。我深深地崇拜着他的灵魂，尽管他也一样看似是现实逃避之人。从那一刻起我也开始去了解我几乎不怎么接触的日语歌领域，开始了解他担任主唱的乐队，开始费力地学着罗马音。</p><p>我带上耳机跟随着sleepwalk的节奏就像mv里漫步的舞者，这首歌是我循环次数最多的歌。我一边仰望着晴朗冬日里光秃秃的树枝枝干，一边一遍遍地听着冬野，每当听到那个钢琴变奏眼神都会突然变得柔和而悲伤。那时还在疫情学期，夜晚的未名湖非常寂静，我在未名湖的夜晚向着对面大喊“为何难解？为何难解！”。我一面郑重地弹奏，一面想象他站在台上的样子。我决定把记忆中的那个他重现出来，一直一直唱着他的歌。这是我的怀念，以最郑重的方式。</p><p>“在颤抖到无法动弹前，唱起来，唱起歌谣，只是唱着歌谣。”</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>上善若水</title>
    <link href="/2024/03/05/%E4%B8%8A%E5%96%84%E8%8B%A5%E6%B0%B4/"/>
    <url>/2024/03/05/%E4%B8%8A%E5%96%84%E8%8B%A5%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p>昨天发了一篇博客是想就inner peace这个话题发发牢骚的，后来想查一下inner peace的官方解释，发现是类似于一种自得其乐，不争的概念。啥是不争？于是进行了一些递归式检索，发现了它最早的出处。</p><p>“上善若水，水善利万物而不争。处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。”</p><p>要想理解不争，还得理解尤的意思。尤指过错吗？但是扶苏不争导致胡亥继任，秦朝灭亡，显然不争并不能避免错误。尤指别人的怨恨吗？道德品行再高的人也会被一些不理解的人责骂，这是人性所然。其实尤指的不是别人的怨恨，而是每个人自己的怨恨之心。所以老子这句话的意思是：如果你与世无争，就不会有怨恨之心。</p><p>诸烦恼中，瞋为最重。诸心病中，第一难治。一念嗔心起，百万障门开。杀瞋心安隐，杀瞋心不悔；瞋为毒之根，瞋灭一切善；杀瞋诸佛赞，杀瞋则无忧！那么如何才能杀掉心中的“嗔”呢？佛陀提供了一个绝招叫忍辱。而老子也提供一个必杀技叫不争。所谓“忍辱”，不正是“不争”吗？</p><p>只要有竞争，有博弈，就难免有得失，有成败。而水谦虚卑下，清湛悠然，择地而居。水助万物而自乐，滋润万物而不居功，柔弱处下，与世无争，这样才能免去患得患失的精神折磨，免去纷争、痛苦与烦恼。</p><p>但是我在检索的时候留意到上面广为传颂的版本反而是以讹传讹流传下来的版本，而真正的版本，很奇怪，表面上看起来是完全相反的观念。</p><p>“上善若水，水善利万物而有争。居众之所亚，故几于道。心善渊，居善地，予善天，正善信，事善能，动善时。不争容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。夫唯不争，故无尤。”</p><p>老子的原意，是争与不争的辩证。心善渊，居善地，予善天，正善信，事善能，动善时，是水的六个品性，也是不争的六个含义，而不是上一版本的人的品性。水像宇宙一样包容，像大地一样公平，像苍天一样无私，水真实可靠，有求必应，善于激发万物的潜能，也会在干旱缺水时雪中送炭。水滋润万物，满足需求，故而不争。但一切生命离不开水，万物无不归往，此为有争。水的这种“服务性”让我不禁想起了《沙丘》中的姐妹会。这个组织表面避其锋芒，负责激发各大家族基因组的潜能，甘于退居身后，因此在纷争之中保全自身，实则又把救世主牢牢控制。这种主旨也是“弱能胜强”在某种方面上的体现。</p><p>反者道之动，弱者道之用。前者指的是同一事物的循环往复，向着反面发展。后者则是不同个体之间的关系互动，强即是弱，弱即是强。我自己的心中也时时滋长许多恶念，正好我的主命格为水，故以此作为id来提醒自己。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我想要获得安宁的心境</title>
    <link href="/2024/03/04/%E6%88%91%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E5%AE%89%E5%AE%81%E7%9A%84%E5%BF%83%E5%A2%83/"/>
    <url>/2024/03/04/%E6%88%91%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E5%AE%89%E5%AE%81%E7%9A%84%E5%BF%83%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>我想要获得安宁的心境，而西方资本想获得货币的自我增值。我不会臣服于他们的工业化学制剂。是春天的错，我狂热地爱着春天。气温无预兆地变冷又变暖，就像我的心脏我的血液。冬天让我思维静止在室内，春天让我疯狂，都怪春天。</p><p>我厌倦了日复一日的发笑，我享受着遗弃的快乐。我会屈服于阳光，过度曝光却又寒冷刺骨。我怒目圆睁，步入轨道。</p><p>我手握着自行车把，一辆电动车撞向了我的腰间。我无所谓。我的手冻得麻木，失去知觉。</p><p>文史楼一股尿味，地学楼也是，一教也是，宿舍也是。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>可能只是碰巧吃到了辣椒籽</title>
    <link href="/2024/03/03/%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E7%A2%B0%E5%B7%A7%E5%90%83%E5%88%B0%E4%BA%86%E8%BE%A3%E6%A4%92%E7%B1%BD/"/>
    <url>/2024/03/03/%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E7%A2%B0%E5%B7%A7%E5%90%83%E5%88%B0%E4%BA%86%E8%BE%A3%E6%A4%92%E7%B1%BD/</url>
    
    <content type="html"><![CDATA[<p>吃到巨辣的东西时不要放弃一整盆菜，你可能只是碰巧吃到了辣椒籽。</p><p>如果一条鱼刺特别多也不代表这条鱼全是刺，你可能只是碰巧吃到了背部。</p><p>学会了All too well的前八分钟，手磨出泡了，明天休战一天。还以为毽子水平倒退了，原来是因为穿了白牛仔裤有了心里负担。晚上换了条裤子又练了一会，汗都出来了。</p><p>穿着风衣去五四跑了一会，谁能在外面阳光明媚的情况下憋在室内呢？开会的时候看完了沙丘前十五章，报告厅真的太挤了。两个小时内肝完了冯式结构读书报告，因为想练琴所以尤其高效。</p><p>变成凤凰蛋了，终于！这几天一直在跑训练图，辛苦了！感觉不开麦组队打训练图还是为时过早了些，线下再教训zjt。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FLIPPED DUNE</title>
    <link href="/2024/03/02/FLIPPED-DUNE/"/>
    <url>/2024/03/02/FLIPPED-DUNE/</url>
    
    <content type="html"><![CDATA[<p>二十四小时内看了两场电影，zjt说DUNE的海报字体设计很独特。这个学期要读的书有点多，但还是想找沙丘的原著看。FLIPPED个人认为有点强行HE。</p><p>“有没有一种可能，女主父亲允许男主在院子里挖洞是为了给女儿做恋爱脑切除手术，让女儿看清他有多坏。”</p><p>“标题都叫怦然心动了，你不HE让那些来看的小情侣怎么办？”</p><p>再次感觉每一个经历都是在为现在的我做铺垫，比如写博客在中间空一行就得益于之前想整自媒体但没整成的经验。</p><p>蹭进元培楼也愈发轻车熟路了，就是坐的有点后排被挡了字幕。</p><p>和zjt逛海淀公园，打牌。天气回暖，气温正好。他说我穿着羊羔绒的衣服更像一只小羊羔了。正好今天也cos了dongdong羊，薯片小羊训练图是大好图哇，虽然很艰难但是过关了，感觉有望成为硬核蛋。</p><p>尝试改手机端的icon但是没改成，无所谓，反正电脑端看得比较多。</p><p>今天练习了两百下毽子，从一开始的满场地跑，到大概有五十到一百下是可以踢一下接住的了，脚也暖和了。难怪说这是一个减轻玉玉的运动。</p><p>连续两天被错认为在准备十佳节目了哈哈，一个留学生姐姐走近并试图和我交流，差点没听懂口音不过她冲我比了个大拇指。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单脚站立的乌鸦</title>
    <link href="/2024/03/01/%E5%8D%95%E8%84%9A%E7%AB%99%E7%AB%8B%E7%9A%84%E4%B9%8C%E9%B8%A6/"/>
    <url>/2024/03/01/%E5%8D%95%E8%84%9A%E7%AB%99%E7%AB%8B%E7%9A%84%E4%B9%8C%E9%B8%A6/</url>
    
    <content type="html"><![CDATA[<p>研究表明，单脚闭眼站立不超过五秒的人十几年内会死。我哆哆嗦嗦地摇着花手，湖边北岸的鸭子双脚站立在将融未融的湖面上，而我维持着脚底的温度。</p><p>乌鸦侧着脑袋，看太阳表面的脉搏闪闪发光。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】古人计划</title>
    <link href="/2024/02/29/%E5%8F%A4%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    <url>/2024/02/29/%E5%8F%A4%E4%BA%BA%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>以前新生训练营的时候，很想与人交流，但碍于周围人都在看手机，只好作罢。手机，确实是一个隔断交流的东西，又加上开学后日益压抑、充满了距离感与落差感的氛围，我的内向指数也逐渐上涨。</p><p>智能手机第一次入侵了我的生活，之所以说是入侵，主要是因为以前我从来都是将它当做一个工具来使用，或搜题，或拍照，或聊天。</p><p>而现在我却被绑架了。当周围所有人都在看手机时，这是一个拒绝交流的信号，我也不得不低下头去，把眼睛拘束在屏幕之中。当时从不冲浪的我甚至不知道手机有什么好看的，也不知道该看什么。训练营在抬头与低头的循环中结束。</p><p>暑假的时候，妈妈把退役的智能手机给外婆用，尽管外婆不识字，但也觉得智能机好用，不会像老年机一样发出闹心的声音。但上初三的表妹占据了大部分手机的使用权，每天要刷至少两个小时的短视频。推开门，她坐在书桌前，悄悄把手机埋在参考书下，外放音量调到最小。她聊起现在班级里大家都在吐槽“应试教育”，不知怎的，这种专有名词从她口中讲出倒显得她像个早熟的小老头。同一部手机，所有年龄段的人收看着几乎一样的东西，所以大学生逐渐幼稚，小孩却早早体验大人的生活。</p><p>“你都看啥小说啊？”</p><p>“无限流！”她语气中不无骄傲。</p><p>“啥是无限流啊？”</p><p>“无限流就是……”她吧啦吧啦给我解释了半天，大致听了个明白。</p><p>可能前面的一代人看我们这代也饱含着同情与艳羡。但我认为短视频和电视剧、游戏有着本质的区别。短视频是一种漫长且没有尽头的刺激，刺激过后，只有精神涣散与空虚。于是尝试戒掉电子榨菜，并在这个四年一遇的日子重启了博客。</p><p>非常感谢grey’pe提供的建站帮助。</p><p>注：无限流，指系统强制给你下达任务，主角有无限生命，只有任务完成才能回到原来的世界。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
