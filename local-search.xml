<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>接雨水</title>
    <link href="/2024/05/27/%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2024/05/27/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p>字节臭名昭著接雨水</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 臭名昭著接雨水</span><br>    <span class="hljs-comment">// 用双指针做</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;height = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> size=height.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = size<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> leftMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> rightMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>        leftMax = <span class="hljs-built_in">max</span>(leftMax,height[left]);<br>        rightMax = <span class="hljs-built_in">max</span>(rightMax,height[right]);<br>        <span class="hljs-keyword">if</span> (rightMax&gt;leftMax)&#123;<br>            res+=leftMax-height[left];<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res+=rightMax-height[right];<br>            right--;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;res;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>括号生成</title>
    <link href="/2024/05/27/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2024/05/27/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>其实就是卡塔兰数，不过还是用dfs写了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;string&gt;res;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> remain, string &amp;tmp)</span></span>&#123;<br>    <span class="hljs-comment">// remain代表左括号比右括号多出的个数</span><br>    <span class="hljs-comment">// tmp要加引用符号</span><br>    <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">length</span>()==n*<span class="hljs-number">2</span>&amp;&amp;remain==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 注意一下有个条件是remain==0，过滤非法结果：即已经有2n个括号但是左括号比右括号多的情况</span><br>        res.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">length</span>()==n*<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 过滤非法结果</span><br>    <span class="hljs-keyword">if</span> (remain&lt;n)&#123;<br>        tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(n,remain+<span class="hljs-number">1</span>,tmp);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-comment">// 记得pop掉</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (remain&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 注意remain边界条件</span><br>        tmp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        <span class="hljs-built_in">dfs</span>(n,remain<span class="hljs-number">-1</span>,tmp);<br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printres</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> size = res.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (size==<span class="hljs-number">0</span>) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;no result&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;total nums:&quot;</span>&lt;&lt;size&lt;&lt;endl;<br>        <span class="hljs-comment">// 卡塔兰数</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        cout&lt;&lt;res[i]&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string tmp;<br>    <span class="hljs-type">int</span> n =<span class="hljs-number">6</span>;<br>    <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,tmp);<br>    <span class="hljs-built_in">printres</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>合并K个升序链表</title>
    <link href="/2024/05/27/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/05/27/%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> v,ListNode *n)&#123;<br>        value = v;<br>        next = n;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printlist</span><span class="hljs-params">(ListNode *head)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;head-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        head=head-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ListNode *head1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>);<br>    head1-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>);<br>    head1-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>);<br>    ListNode *head2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>);<br>    head2-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>);<br>    head2-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">printlist</span>(head1);<br>    <span class="hljs-built_in">printlist</span>(head2);<br>    <span class="hljs-keyword">auto</span> cmp = [](ListNode *a, ListNode *b)&#123;<span class="hljs-keyword">return</span> a-&gt;value&gt;b-&gt;value;&#125;;<br>    <span class="hljs-comment">// 请注意这里符号填的是大于（好反人类</span><br>    priority_queue&lt;ListNode *,vector&lt;ListNode *&gt;,<span class="hljs-keyword">decltype</span>(cmp)&gt;<span class="hljs-built_in">q</span>(cmp);<br>    <span class="hljs-comment">// 这两个语句背下来orz</span><br>    q.<span class="hljs-built_in">push</span>(head1);<br>    q.<span class="hljs-built_in">push</span>(head2);<br>    ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>,<span class="hljs-literal">nullptr</span>);<br>    ListNode *cur = dummy;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())&#123;<br>        ListNode *tmp = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cur-&gt;next = tmp;<br>        cur = tmp;<br>        <span class="hljs-keyword">if</span> (tmp-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-comment">// 这个非空条件很重要！</span><br>            q.<span class="hljs-built_in">push</span>(tmp-&gt;next);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-built_in">printlist</span>(dummy-&gt;next);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-13</title>
    <link href="/2024/05/26/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-13/"/>
    <url>/2024/05/26/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-13/</url>
    
    <content type="html"><![CDATA[<h3 id="进程有多少种状态，如何转换？"><a href="#进程有多少种状态，如何转换？" class="headerlink" title="进程有多少种状态，如何转换？"></a>进程有多少种状态，如何转换？</h3><p><strong>三种状态</strong>：<br>阻塞、就绪、运行。<br><strong>四种转换</strong>：<br>阻塞-&gt;就绪：当一个进程等待的事件发生或资源可用时，它会从阻塞状态转换回就绪状态，等待被调度执行。<br>运行-&gt;阻塞：当一个进程需要等待某个事件发生或等待某个资源时，它会从运行状态转换到阻塞状态。<br>运行-&gt;就绪：当一个运行中的进程的时间片用完或被操作系统抢占，它返回到就绪状态，等待下一次调度。<br>就绪-&gt;运行：调度器选择一个就绪进程并分配CPU给它，进程进入运行状态。</p><h3 id="哪些问题是HTTPS无法解决的？"><a href="#哪些问题是HTTPS无法解决的？" class="headerlink" title="哪些问题是HTTPS无法解决的？"></a>哪些问题是HTTPS无法解决的？</h3><ol><li>Http是基于<strong>TCP协议的，在网络层的传输耗时比较长</strong>，https没有解决这个问题；</li><li>http<strong>头是不能压缩</strong>的，每次要传递很大的数据包，<strong>每个连接也只能支持一个请求</strong>。</li><li>同时https应用了很多<strong>加密算法</strong>，这些算法的执行也是会<strong>影响速度</strong>的。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>速通KMP算法</title>
    <link href="/2024/05/24/%E9%80%9F%E9%80%9AKMP%E7%AE%97%E6%B3%95/"/>
    <url>/2024/05/24/%E9%80%9F%E9%80%9AKMP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E7%AE%97%E6%B3%95/kmp%E7%AE%97%E6%B3%95.png" alt="为什么要用KMP算法"><br><a href="https://zhuanlan.zhihu.com/p/83334559?utm_psn=1777131874840141824">知乎链接</a><br><img src="/../img/%E7%AE%97%E6%B3%95/581e5a8571eeb0cc180801a1d145db9.jpg" alt="笔记"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-type">int</span> dp[<span class="hljs-number">200</span>][<span class="hljs-number">256</span>];<br><span class="hljs-comment">// dp[x][y]=z表示状态x下遇到y字符（y是ascii码值）会转到z状态</span><br><span class="hljs-type">int</span> next[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_statement</span><span class="hljs-params">(string pat)</span></span>&#123;<br>    <span class="hljs-type">int</span> patlen = pat.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-comment">// int base = 0;</span><br>    <span class="hljs-type">int</span> X = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 影子状态</span><br>    dp[<span class="hljs-number">0</span>][pat[<span class="hljs-number">0</span>]]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;patlen;i++)&#123;<br>        <span class="hljs-comment">// 注意这里直接从状态1开始算，并且不包括最后一个状态</span><br>        <span class="hljs-comment">// 因为如果dp到最后一个状态说明就可以了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-number">256</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span> (j==pat[i])dp[i][j]=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> dp[i][j]=dp[X][j];<br>        &#125;<br>        X=dp[X][pat[i]];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(string pat, string txt)</span></span>&#123;<br>    <span class="hljs-type">int</span> patlen = pat.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> txtlen = txt.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span> ; <br>    <span class="hljs-comment">// 表示初始状态为0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;txtlen;i++)&#123;<br>        cur=dp[cur][txt[i]];<br>        <span class="hljs-keyword">if</span> (cur==patlen) <span class="hljs-keyword">return</span> i-patlen+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string pat=<span class="hljs-string">&quot;ababc&quot;</span>;<br>    string txt=<span class="hljs-string">&quot;bbcabbsaababcabbbac&quot;</span>;<br>    <span class="hljs-built_in">build_statement</span>(pat);<br>    cout&lt;&lt;<span class="hljs-built_in">search</span>(pat, txt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>看别人面经冲刺中</title>
    <link href="/2024/05/23/%E7%9C%8B%E5%88%AB%E4%BA%BA%E9%9D%A2%E7%BB%8F%E5%86%B2%E5%88%BA%E4%B8%AD/"/>
    <url>/2024/05/23/%E7%9C%8B%E5%88%AB%E4%BA%BA%E9%9D%A2%E7%BB%8F%E5%86%B2%E5%88%BA%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL的MVCC机制"><a href="#MySQL的MVCC机制" class="headerlink" title="MySQL的MVCC机制"></a>MySQL的MVCC机制</h2><p>MySQL 的 MVCC（多版本并发控制，Multi-Version Concurrency Control）机制是一种用于处理并发访问数据库的技术，主要应用于 InnoDB 存储引擎。它通过创建数据的多个版本来实现事务的隔离性和一致性，从而提高数据库的并发性能。MVCC 机制主要依赖于隐藏的列和快照来实现。这些隐藏列包括两个时间戳，分别是 <code>trx_id</code>（事务 ID）和 <code>roll_pointer</code>（回滚指针）。</p><h3 id="MVCC-的工作原理"><a href="#MVCC-的工作原理" class="headerlink" title="MVCC 的工作原理"></a>MVCC 的工作原理</h3><ol><li><p><strong>隐藏列</strong>:</p><ul><li><code>trx_id</code>: 每次事务对数据进行修改时，都会生成一个唯一的事务 ID，并将其赋值给修改后的数据行。</li><li><code>roll_pointer</code>: 指向该数据行在回滚段中的上一版本，用于实现数据的多版本控制和回滚操作。</li></ul></li><li><p><strong>快照读（Snapshot Read）</strong>:<br> 快照读是指读取数据库中的一致性快照，即读取数据行在某个时间点的版本。这种读取方式不会加锁，可以提高读取的并发性。具体来说，InnoDB 在读取数据时会根据当前事务的隔离级别和数据行的 <code>trx_id</code> 判断是否可以读取该版本的数据。</p></li><li><p><strong>当前读（Current Read）</strong>:<br> <strong>当前读是指读取最新版本的数据，并且会对读取的数据加锁</strong>，防止其他事务同时修改这些数据。例如，<code>SELECT ... FOR UPDATE</code> 和 <code>SELECT ... LOCK IN SHARE MODE</code> 都属于当前读。</p></li></ol><h3 id="事务隔离级别与-MVCC"><a href="#事务隔离级别与-MVCC" class="headerlink" title="事务隔离级别与 MVCC"></a>事务隔离级别与 MVCC</h3><p>MVCC 在不同的事务隔离级别下有不同的表现：</p><ol><li><p><strong>读未提交（Read Uncommitted）</strong>:<br> 事务可以读取其他未提交事务的数据修改。此隔离级别不使用 MVCC。</p></li><li><p><strong>读已提交（Read Committed）</strong>:<br> 事务只能读取已提交事务的数据修改。每次读取操作都会读取最新的已提交版本。</p></li><li><p><strong>可重复读（Repeatable Read）</strong>:<br> 在同一个事务中，多次读取同一数据行，返回的结果始终一致，即使其他事务已经提交了对该数据行的修改。InnoDB 通过创建事务开始时的快照来实现这一点。</p></li><li><p><strong>串行化（Serializable）</strong>:<br> 强制事务按顺序执行，类似于在每个读取的数据行上加锁，以实现最高级别的隔离性。</p></li></ol><h3 id="MVCC-的优势"><a href="#MVCC-的优势" class="headerlink" title="MVCC 的优势"></a>MVCC 的优势</h3><ol><li><p><strong>提高并发性能</strong>:<br> 通过快照读实现读写分离，读取操作无需加锁，从而大大提高了数据库的并发性能。</p></li><li><p><strong>避免幻读</strong>:<br> 在可重复读隔离级别下，MVCC 可以有效避免幻读问题，因为事务读取的是一致性快照，而不是实时数据。</p></li><li><p><strong>回滚方便</strong>:<br> 通过 <code>roll_pointer</code>，可以方便地回滚到数据行的前一个版本，支持事务的撤销操作。</p></li></ol><h3 id="MVCC-的实现细节"><a href="#MVCC-的实现细节" class="headerlink" title="MVCC 的实现细节"></a>MVCC 的实现细节</h3><p>在 InnoDB 中，每个数据行有两个隐藏的列：<code>DB_TRX_ID</code> 和 <code>DB_ROLL_PTR</code>。<code>DB_TRX_ID</code> 存储最近一次对该行进行修改的事务 ID，<code>DB_ROLL_PTR</code> 指向该行的上一版本。通过这些隐藏列，InnoDB 能够跟踪和管理多个版本的数据，从而实现 MVCC。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL 的 MVCC 机制通过维护数据行的多个版本以及利用事务的快照，能够在提高并发性能的同时保证数据的一致性和隔离性。这使得 MySQL 能够在高并发环境下，提供高效和可靠的数据访问服务。</p><h2 id="路由器和交换机区别"><a href="#路由器和交换机区别" class="headerlink" title="路由器和交换机区别"></a>路由器和交换机区别</h2><p>路由器（Router）和交换机（Switch）是网络中常见的两种设备，它们在网络中扮演着不同的角色，有着不同的工作原理和功能。以下是它们的主要区别：</p><ol><li><p><strong>工作层次</strong>：</p><ul><li><strong>路由器</strong>：工作在 OSI 模型的网络层（第三层），负责根据目标 IP 地址将数据包从一个网络路由到另一个网络。路由器能够理解 IP 地址和路由表，根据网络地址进行数据包转发。</li><li><strong>交换机</strong>：通常工作在 OSI 模型的数据链路层（第二层），负责在局域网内部进行数据包的转发和交换。交换机主要根据 MAC 地址学习和转发数据包，以实现局域网内部设备之间的通信。</li></ul></li><li><p><strong>转发方式</strong>：</p><ul><li><strong>路由器</strong>：根据目标 IP 地址来决定数据包的转发路径，需要进行 IP 地址的查找和路由表的查询，可以跨越不同网络进行数据包转发。</li><li><strong>交换机</strong>：根据数据包的目标 MAC 地址进行转发，通过学习和维护 MAC 地址表来实现数据包的快速转发，主要用于局域网内部的通信。</li></ul></li><li><p><strong>范围</strong>：</p><ul><li><strong>路由器</strong>：通常用于连接不同的网络，如连接局域网与广域网、不同的子网等，用于<strong>跨越不同网络的数据包转发</strong>。</li><li><strong>交换机</strong>：主要用于<strong>局域网内部</strong>，连接局域网中的多台计算机、打印机等设备，用于实现局域网内的数据包交换和通信。</li></ul></li><li><p><strong>决策方式</strong>：</p><ul><li><strong>路由器</strong>：基于 <strong>IP 地址</strong>进行决策，根据<strong>网络地址和路由表来选择最佳路径</strong>进行数据包转发。</li><li><strong>交换机</strong>：基于 <strong>MAC 地址</strong>进行决策，根据学习到的 MAC 地址和 MAC 地址表来实现数据包的转发。</li></ul></li><li><p><strong>处理能力</strong>：</p><ul><li><strong>路由器</strong>：通常拥有更复杂的处理能力，可以实现网络层的功能，如<strong>路由选择、分割广播域</strong>等，处理更多协议类型的数据包。</li><li><strong>交换机</strong>：主要用于数据链路层的转发，处理更多的是局域网内部的数据包转发，对于网络层及以上层次的协议不具备处理能力。</li></ul></li></ol><h2 id="什么是路由选择？"><a href="#什么是路由选择？" class="headerlink" title="什么是路由选择？"></a>什么是路由选择？</h2><p>路由选择（Routing）是指在计算机网络中，确定数据包从源节点传输到目标节点的最佳路径的过程。这个过程是由路由器或者路由器算法来完成的。路由选择是计算机网络中的关键部分，它影响了网络的性能、可用性和可靠性。</p><p>路由选择的过程通常包括以下几个步骤：</p><ol><li><p><strong>路由器学习网络拓扑</strong>：路由器需要学习整个网络的拓扑结构，包括了哪些节点（主机、路由器等）以及它们之间的连接方式。</p></li><li><p><strong>收集网络信息</strong>：路由器需要收集网络的相关信息，比如链路状态、带宽、延迟、拥塞情况等。</p></li><li><p><strong>构建路由表</strong>：根据收集到的信息，路由器构建路由表。路由表中记录了到达目的地的不同路径及其相关信息，比如下一跳路由器、跳数（跳数表示从源节点到目标节点经过的路由器数量）、路由的开销等。</p></li><li><p><strong>选择最佳路径</strong>：当一个数据包到达路由器时，路由器根据路由表选择最佳的路径将数据包转发给下一个节点。选择最佳路径的标准可以是多样化的，常见的标准包括最短路径、最快路径、最稳定路径等。</p></li><li><p><strong>数据包转发</strong>：根据选择的路径，路由器将数据包转发给下一个节点。这个过程通常涉及到修改数据包的目标地址和 TTL（生存时间）字段，并将数据包发送到下一跳路由器。</p></li><li><p><strong>更新路由表</strong>：定期或根据网络状态的变化，路由器需要更新自己的路由表，以反映网络拓扑的变化，确保选择的路径是最佳的。</p></li></ol><p>路由选择算法的设计和实现对于网络的性能和可靠性有着重要的影响。常见的路由选择算法包括静态路由、距离矢量路由（如 RIP）、链路状态路由（如 OSPF）、路径向量路由（如 BGP）等。这些算法在考虑到网络拓扑、链路状态、路由器开销等因素的基础上，通过不同的策略选择最佳路径。</p><h2 id="MTU的作用"><a href="#MTU的作用" class="headerlink" title="MTU的作用"></a>MTU的作用</h2><p>MTU（Maximum Transmission Unit）是指在计算机网络中，数据链路层可以传输的最大数据包大小。MTU的大小是由网络硬件或网络协议确定的，通常以字节为单位。</p><p>MTU的作用主要体现在以下几个方面：</p><ol><li><p><strong>最大利用带宽</strong>：传输的数据包越大，携带的有效数据就越多，从而可以更有效地利用网络带宽。减少数据包的数量可以降低网络的拥塞程度，提高网络的吞吐量。</p></li><li><p><strong>降低开销</strong>：每个数据包在传输过程中都会带有一定的开销，如头部信息、校验和等。通过增大MTU，可以减少传输的数据包数量，从而减少了网络传输的开销。</p></li><li><p><strong>减少碎片</strong>：当数据包的大小超过某些网络设备或网络链路的最大传输单元时，数据包就会被分割成更小的片段进行传输，这称为碎片化。增大MTU可以减少碎片的产生，提高网络的性能和效率。</p></li><li><p><strong>提高效率</strong>：MTU的调整可以根据网络的实际情况进行优化，从而提高网络的效率和性能。例如，在局域网中，可以设置较大的MTU来提高数据传输的效率；而在广域网中，由于网络环境的复杂性，可能需要设置较小的MTU来减少传输时的延迟和丢包率。</p></li></ol><p>总的来说，MTU的作用是优化网络传输的效率和性能，通过调整MTU的大小，可以最大程度地利用网络带宽，减少网络开销，降低碎片化，提高网络的吞吐量和响应速度。</p><h2 id="ISO五层模型？"><a href="#ISO五层模型？" class="headerlink" title="ISO五层模型？"></a>ISO五层模型？</h2><p>应用层 传输层 网络层 数据链路层 物理层</p><h2 id="MySQL存储高精度数据适用的数据类型"><a href="#MySQL存储高精度数据适用的数据类型" class="headerlink" title="MySQL存储高精度数据适用的数据类型"></a>MySQL存储高精度数据适用的数据类型</h2><p>在MySQL中存储高精度数据（例如货币金额、科学计数等）时，可以使用以下几种数据类型：</p><ol><li><p><strong>DECIMAL</strong>：DECIMAL 类型是一种精确的定点数数据类型，用于存储固定精度的数字。它可以存储非常大的数字，并且可以指定小数点后的位数。DECIMAL 类型通常用于存储货币金额等需要精确计算的数据。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">DECIMAL</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)</span></span><br></code></pre></td></tr></table></figure><p>这表示一个精度为 10，小数点后 2 位的固定精度的数字。</p></li><li><p><strong>NUMERIC</strong>：NUMERIC 类型与 DECIMAL 类型类似，也是一种精确的定点数数据类型。它用法与 DECIMAL 完全相同，但在某些MySQL版本中，DECIMAL 和 NUMERIC 可能是同义词。</p></li><li><p><strong>FLOAT</strong>：FLOAT 类型是一种近似数值数据类型，用于存储单精度浮点数。它可以存储较大范围的数字，但是精度相对较低。FLOAT 类型通常用于科学计算等场景，不适合精确计算。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">FLOAT</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)</span></span><br></code></pre></td></tr></table></figure><p>这表示一个单精度浮点数，总共 10 位数字，其中小数点后有 2 位。</p></li><li><p><strong>DOUBLE</strong>：DOUBLE 类型是一种近似数值数据类型，用于存储双精度浮点数。它的范围比 FLOAT 类型更大，精度也更高，但仍然是一种近似值。DOUBLE 类型通常用于存储科学计算等需要较高精度的数据。例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">DOUBLE</span><span class="hljs-params">(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>)</span></span><br></code></pre></td></tr></table></figure><p>这表示一个双精度浮点数，总共 15 位数字，其中小数点后有 5 位。</p></li></ol><p>总的来说，DECIMAL 和 NUMERIC 类型适用于需要精确计算的场景，而 FLOAT 和 DOUBLE 类型适用于科学计算等场景，其中 DOUBLE 类型的精度更高，但也会占用更多的存储空间。在选择数据类型时，需要根据具体的业务需求和数据特性来决定。</p><h2 id="MySQL索引组织方式"><a href="#MySQL索引组织方式" class="headerlink" title="MySQL索引组织方式"></a>MySQL索引组织方式</h2><p>在MySQL中，索引是用于加速数据检索的关键技术之一。MySQL支持多种索引组织方式，其中最常见的包括：</p><ol><li><p><strong>B树索引</strong>：</p><ul><li>B树索引是MySQL中最常用的索引类型，用于快速定位数据记录。B树索引按照一定的规则将数据分层存储在树结构中，使得在查找过程中可以通过多次二分查找来快速定位目标数据。</li><li>在MySQL中，InnoDB存储引擎默认使用B树索引。</li></ul></li><li><p><strong>B+树索引</strong>：</p><ul><li>B+树索引是B树索引的一种改进版本，它将数据记录只存储在叶子节点上，非叶子节点只存储索引信息，这样可以减少索引树的高度，提高了数据的检索效率。</li><li>在MySQL中，MyISAM存储引擎使用B+树索引。</li></ul></li><li><p><strong>哈希索引</strong>：</p><ul><li>哈希索引使用哈希算法将索引键映射到存储位置，然后直接在该位置查找目标数据记录，具有查找速度快的优点。但是哈希索引在范围查询和排序方面性能不如B树索引。</li><li>在MySQL中，Memory存储引擎支持哈希索引。</li></ul></li><li><p><strong>全文索引</strong>：</p><ul><li>全文索引用于对文本字段进行全文搜索，可以快速定位包含指定关键词的数据记录。全文索引不同于普通索引，它不是直接定位数据记录，而是通过分析文本内容建立反向索引来实现全文搜索。</li><li>在MySQL中，MyISAM和InnoDB存储引擎都支持全文索引，但实现方式和性能有所不同。</li></ul></li></ol><p>每种索引组织方式都有其优缺点，适用于不同的场景和需求。在选择索引组织方式时，需要根据具体的应用场景和查询需求来进行权衡和选择。</p><h2 id="MySQL事务的使用场景"><a href="#MySQL事务的使用场景" class="headerlink" title="MySQL事务的使用场景"></a>MySQL事务的使用场景</h2><p>事务是数据库管理系统中常用的概念，用于保证数据库操作的原子性、一致性、隔离性和持久性（ACID特性）。使用事务可以确保一系列数据库操作要么全部成功执行，要么全部失败回滚，从而保证数据的完整性和一致性。以下是一些常见的 MySQL 事务使用场景：</p><ol><li><p><strong>银行系统</strong>：在银行系统中，转账操作是一个典型的事务场景。一个完整的转账过程包括从一个账户扣款并向另一个账户存款，这两个操作必须同时成功或同时失败，以避免出现账户余额不一致的情况。</p></li><li><p><strong>电子商务系统</strong>：在电子商务系统中，订单处理是一个常见的事务场景。当用户下订单时，需要对订单进行创建、库存扣减、支付处理等一系列操作，这些操作必须保证原子性，以避免订单数据不一致或支付异常等问题。</p></li><li><p><strong>在线游戏系统</strong>：在在线游戏系统中，玩家之间的交易或资源交换是一个典型的事务场景。例如，玩家之间进行道具交易，需要同时扣除一个玩家的道具并增加另一个玩家的道具，这些操作必须原子执行，以避免资源丢失或重复扣减等问题。</p></li><li><p><strong>企业级应用</strong>：在企业级应用中，复杂的业务流程往往涉及多个数据库操作，例如订单处理、库存管理、客户资料更新等。这些操作需要在同一个事务中执行，以确保数据的一致性和完整性。</p></li></ol><p>总的来说，任何需要保证数据操作原子性、一致性和完整性的场景都适合使用事务。事务可以有效地处理复杂的业务逻辑，并确保数据的正确性和可靠性。</p><h2 id="查索引的过程"><a href="#查索引的过程" class="headerlink" title="查索引的过程"></a>查索引的过程</h2><ol><li>索引扫描：遍历索引树，找到满足查询条件的索引条目。</li><li>获取数据行：一旦索引扫描找到了满足查询条件的索引条目，MySQL 将会根据索引条目中的指针（或者叫做 RID，行标识符）来获取相应的数据行。</li><li>返回结果</li></ol><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><p>ACID（重点：你要知道事务特性是ACID</p><p>事务具有四个主要的特性，通常被称为 ACID 特性，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）：</p><ol><li><p><strong>原子性（Atomicity）</strong>：</p><ul><li>原子性指的是事务是一个不可分割的工作单元，要么全部执行成功，要么全部执行失败。即使在事务执行过程中发生了错误，也要保证事务中的所有操作都被回滚，数据库状态要回到事务开始之前的状态。</li></ul></li><li><p><strong>一致性（Consistency）</strong>：</p><ul><li>一致性指的是事务执行后，数据库从一个一致性状态转变到另一个一致性状态。事务中的操作应该满足数据库的约束和规则，确保数据的完整性和一致性。即使事务失败，也不会破坏数据库的一致性。</li></ul></li><li><p><strong>隔离性（Isolation）</strong>：</p><ul><li>隔离性指的是多个事务并发执行时，各个事务的操作彼此之间是相互隔离的，互不干扰。即使多个事务同时访问同一数据，也不会相互影响。隔离性可以防止并发执行事务时出现数据不一致的情况。</li></ul></li><li><p><strong>持久性（Durability）</strong>：</p><ul><li>持久性指的是事务一旦提交成功，其结果就应该永久保存在数据库中，并且不会丢失。即使系统发生故障，例如断电或者崩溃，数据库也应该能够恢复到事务提交后的状态，保证数据的持久性。</li></ul></li></ol><p>这些特性确保了事务的可靠性和数据的完整性，使得数据库操作可以更安全和可靠。在实际应用中，需要根据具体的业务需求和数据库系统的支持情况来选择合适的事务隔离级别和持久化机制，以确保数据的安全性和一致性。</p><h2 id="Linux中的ps和find命令"><a href="#Linux中的ps和find命令" class="headerlink" title="Linux中的ps和find命令"></a>Linux中的ps和find命令</h2><p><code>ps</code> 和 <code>find</code> 是 Linux 中两个常用的命令，用于查找和管理进程以及文件。</p><ol><li><p><strong>ps 命令</strong>：</p><ul><li><code>ps</code> 命令用于显示当前系统中正在运行的进程信息。可以显示系统中的所有进程或者指定用户的进程。</li><li>常用选项包括：<ul><li><code>-ef</code>：显示所有进程的完整信息。</li><li><code>-aux</code>：显示所有进程的详细信息，包括用户、CPU 使用情况等。</li><li><code>-u username</code>：显示指定用户的进程。</li><li><code>-p PID</code>：显示指定进程号（PID）的进程信息。</li></ul></li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef<br>ps -u username<br>ps -p 12345<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>find 命令</strong>：</p><ul><li><code>find</code> 命令用于在指定目录下查找文件或者目录，并可以根据各种条件来过滤搜索结果。</li><li>常用选项包括：<ul><li><code>-name filename</code>：按照文件名查找文件。</li><li><code>-type type</code>：按照文件类型（文件、目录、符号链接等）查找。</li><li><code>-user username</code>：按照文件所属用户查找。</li><li><code>-size size</code>：按照文件大小查找。</li><li><code>-exec command &#123;&#125; \;</code>：对搜索到的文件执行指定的命令。</li></ul></li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">find /path/to/directory -name <span class="hljs-string">&quot;*.txt&quot;</span><br>find /path/to/directory -<span class="hljs-built_in">type</span> f -user username<br>find /path/to/directory -size +1M<br>find /path/to/directory -name <span class="hljs-string">&quot;*.log&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">rm</span> &#123;&#125; \;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>这些命令在 Linux 系统中经常被用于管理和搜索文件以及查找进程信息，是系统管理和运维工作中的常用工具。</p><h2 id="select-poll-epoll的区别与联系？"><a href="#select-poll-epoll的区别与联系？" class="headerlink" title="select poll epoll的区别与联系？"></a>select poll epoll的区别与联系？</h2><p>select, poll和epoll都是I&#x2F;O多路复用技术，它们用于同时处理多个I&#x2F;O操作，特别是在高并发网络编程中。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select是最早的I&#x2F;O多路复用技术，它可以同时监视多个文件描述符（file descriptor, FD）的I&#x2F;O状态（如可读、可写、异常等）。select函数使用一个文件描述符集合（通常是一个位图）来表示要监视的文件描述符，当有I&#x2F;O事件发生时，select会返回对应的文件描述符集合。</p><p>select的主要限制如下：</p><p>文件描述符数量限制：select使用一个位图来表示文件描述符集合，这限制了它能够处理的文件描述符数量（通常是1024个）。<br>效率问题：当文件描述符数量较大时，select需要遍历整个文件描述符集合来查找就绪的文件描述符，这会导致较低的效率。<br>非实时性：每次调用select时，需要重新设置文件描述符集合，这会增加函数调用的开销。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll是为了克服select的限制而引入的一种I&#x2F;O多路复用技术。poll使用一个文件描述符数组（通常是一个结构体数组）来表示要监视的文件描述符。与select类似，poll可以监视多个文件描述符的I&#x2F;O状态。</p><p>poll的优点如下：</p><p>文件描述符数量不受限制：由于poll使用一个动态数组来表示文件描述符，因此它可以处理任意数量的文件描述符。<br>效率相对较高：poll在查找就绪的文件描述符时，只需要遍历实际使用的文件描述符数组，而不是整个文件描述符集合。<br>然而，poll仍然存在一些问题：</p><p>效率问题：尽管poll相对于select具有较高的效率，但当文件描述符数量很大时，它仍然需要遍历整个文件描述符数组。<br>非实时性：与select类似，每次调用poll时，需要重新设置文件描述符数组。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是Linux特有的一种高效I&#x2F;O多路复用技术，它克服了select和poll的主要限制。epoll使用一个事件驱动（event-driven）的方式来处理I&#x2F;O操作，它只会返回就绪的文件描述符，而不是遍历整个文件描述符集合。</p><p>epoll的主要优点如下：</p><p>高效：epoll使用事件驱动的方式来处理I&#x2F;O操作，因此它在处理大量文件描述符时具有很高的效率。当有I&#x2F;O事件发生时，epoll可以立即得到通知，而无需遍历整个文件描述符集合。这使得epoll在高并发场景中具有更好的性能。<br>可扩展性：与poll类似，epoll可以处理任意数量的文件描述符，因为它使用一个动态数据结构来表示文件描述符。<br>实时性：epoll使用一个内核事件表来记录要监视的文件描述符和事件，因此在每次调用epoll时无需重新设置文件描述符集合。这可以减少函数调用的开销，并提高实时性。<br>epoll具有诸多优点，但它目前仅在Linux平台上可用。对于其他平台，可能需要使用类似的I&#x2F;O多路复用技术，如BSD中的kqueue。</p><p>总结：select是最早的I&#x2F;O多路复用技术，但受到文件描述符数量和效率方面的限制。poll克服了文件描述符数量的限制，但仍然存在一定的效率问题。epoll是一种高效的I&#x2F;O多路复用技术，尤其适用于高并发场景，但它仅在Linux平台上可用。一般来说，epoll的效率是要比select和poll高的，但是对于活动连接较多的时候，由于回调函数触发的很频繁，其效率不一定比select和poll高。所以epoll在连接数量很多，但活动连接较小的情况性能体现的比较明显。</p><h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS(SSL+HTTP)数据传输过程是加密的，安全性较好。</p><p>使用 HTTPS 协议需要到 CA 申请证书。</p><p>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，而 HTTPS除了 TCP 的三个包，还要加上SSL握手的消耗。</p><p>用的端口也不一样，前者是 80，后者是 443。</p><p>HTTPS 其实就是建构在 SSL&#x2F;TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p><h2 id="GDB常见调试命令"><a href="#GDB常见调试命令" class="headerlink" title="GDB常见调试命令"></a>GDB常见调试命令</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>项目捶打</title>
    <link href="/2024/05/23/%E9%A1%B9%E7%9B%AE%E6%8D%B6%E6%89%93/"/>
    <url>/2024/05/23/%E9%A1%B9%E7%9B%AE%E6%8D%B6%E6%89%93/</url>
    
    <content type="html"><![CDATA[<p>复盘了一下字节的面经，感觉已经无懈可击（误</p><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>面试官您好，我是xxx，我来自北京大学信息科学技术学院计算机科学与技术方向，现在读大三，很荣幸可以参加贵公司的面试。我是一个做事踏实认真负责，善于沟通交流合作的人。我在大一的时候学习了数据结构与算法等专业基础课程，了解了大部分常用的数据结构以及应用场景。上个学期学了计算机网络和操作系统的基础知识，对计算机的基本组成以及运行有了更深的认识。这个学期学习了数据库概论这门课，学习了mysql关系型数据库的使用。我是一个自我要求严格的人，在小组合作中，我的代码风格比较良好，注重细节。真诚地期待可以成为贵公司的一员。</p><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>把计网的两个课设项目重新敲打一下（</p><p>我的第一个项目是基于tcp协议，实现了一个简单的 FTP Server 和 FTP Client CLI (CLI指命令行界面)。</p><p>支持的命令有：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">open</span> <span class="hljs-symbol">&lt;IP&gt;</span> <span class="hljs-symbol">&lt;port&gt;</span>: 建立一个到 <span class="hljs-symbol">&lt;IP&gt;</span>:<span class="hljs-symbol">&lt;port&gt;</span> 的连接<br><span class="hljs-keyword">ls</span>: 通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，获取server当前运行目录下的文件列表。<br><span class="hljs-built_in">get</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Server 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Client 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中。<br><span class="hljs-keyword">put</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Client 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Server 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中。<br><span class="hljs-built_in">sha256</span> <span class="hljs-symbol">&lt;filename&gt;</span>：通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，在 Server 运行目录中查询某个文件的 <span class="hljs-built_in">sha256</span> 值，若不存在则返回不存在。<br><span class="hljs-keyword">quit</span>: 如有连接则断开连接，回到 <span class="hljs-keyword">open</span> 前的状态；如果已经是 <span class="hljs-keyword">open</span> 前的状态，则关闭 Client。<br></code></pre></td></tr></table></figure><p>我的第二个项目是基于UDP构建一个简单可靠的传输协议RTP，并且我的sender端和receiver端支持两种传输数据的策略，分别是回退N和选择重传算法。</p><p>我在这两个端都分别维护了滑动窗口，其中，receiver端只接受编号在窗口内的数据报文。假设当前编号不大于y的数据报文都已被确认，且编号为y+1的数据报文未被确认，那么当前滑动窗口的编号范围是[y+1, y+window_size]。如果Receiver收到了窗口“左侧”（编号小的一侧）一个或多个报文，则此时可以更新滑动窗口的范围。</p><p>我还实现了超时重传的机制，如果滑动窗口在一定的时间（100ms）内没有更新，Sender需要重传没有被确认的数据报文。对于回退N算法，Sender每次重传当前窗口的所有报文。对于选择重传算法，Sender只重传窗口内没有被确认的报文。</p><p>除此之外，我还实现了错误处理功能，即便出现诸如网络错误、丢包、延迟、损坏、复制和重排序等事件，依然能提供有序、可靠的UDP数据报传递。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>中缀表达式求值</title>
    <link href="/2024/05/22/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2024/05/22/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>好像知道为什么当时面字节的时候没写出来了，，，因为不会中缀转后缀</p><p>中缀表达式转后缀表达式步骤：<br>只需要设立一个栈存符号<br>if 数字 直接输出<br>if 左括号 直接入栈<br>if 栈空 or 栈顶为左括号 or 当前优先级大于栈顶优先级<br>    入栈<br>else 依次弹出栈顶直到满足条件 然后入栈<br>if 右括号 依次弹出栈顶直到遇到左括号 把左括号也pop掉</p><p>后缀表达式求值步骤：<br>只需要一个数字栈<br>碰到数字 入栈<br>碰到符号，从数字栈弹出两个值计算，将得到的值压栈</p><p>贴个中缀转后缀的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">(<span class="hljs-type">char</span> sym)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (sym==<span class="hljs-string">&#x27;+&#x27;</span>||sym==<span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (sym==<span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-comment">// 请务必注意return 0这一点！！！</span><br>&#125;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s_mid;<br>    s_mid=<span class="hljs-string">&quot;1+(2+3)*2&quot;</span>;<br>    string s_back;<br>    stack&lt;<span class="hljs-type">char</span>&gt;symbol;<br>    <span class="hljs-type">int</span> len =s_mid.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <br>        <span class="hljs-comment">// if (symbol.empty()) symbol.push(s_mid[i]);</span><br>        <span class="hljs-comment">// 这是错的！！！要先判断它是不是数字！！！</span><br>        <span class="hljs-keyword">if</span> (s_mid[i]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s_mid[i]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)  s_back = s_back + s_mid[i];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (symbol.<span class="hljs-built_in">empty</span>()) symbol.<span class="hljs-built_in">push</span>(s_mid[i]);<br>        <span class="hljs-comment">// 数字直接输出</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s_mid[i]==<span class="hljs-string">&#x27;(&#x27;</span>) symbol.<span class="hljs-built_in">push</span>(s_mid[i]);<br>        <span class="hljs-comment">// 左括号直接入栈</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s_mid[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">while</span> (symbol.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;top:&quot;</span>&lt;&lt;symbol.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>                s_back = s_back + symbol.<span class="hljs-built_in">top</span>();<br>                cout&lt;&lt;s_back&lt;&lt;endl;<br>                symbol.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            symbol.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 最后将左括号也pop掉</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span> (!symbol.<span class="hljs-built_in">empty</span>()&amp;&amp;<span class="hljs-built_in">priority</span>(s_mid[i])&lt;=<span class="hljs-built_in">priority</span>(symbol.<span class="hljs-built_in">top</span>()))&#123;<br>                s_back = s_back+symbol.<span class="hljs-built_in">top</span>();<br>                symbol.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            symbol.<span class="hljs-built_in">push</span>(s_mid[i]);<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span> (!symbol.<span class="hljs-built_in">empty</span>())&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;symbol.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;<span class="hljs-string">&quot;stack is empty.&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <br>        cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;s_back&lt;&lt;endl;<br>        <br>    &#125;<br>    <span class="hljs-keyword">while</span> (!symbol.<span class="hljs-built_in">empty</span>())&#123;<br>        s_back = s_back + symbol.<span class="hljs-built_in">top</span>();<br>        symbol.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    cout&lt;&lt;s_back&lt;&lt;endl;<br>    <span class="hljs-comment">// 至此最难的部分：中缀转后缀完成</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-12</title>
    <link href="/2024/05/22/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-12/"/>
    <url>/2024/05/22/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-12/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍一下信号量"><a href="#介绍一下信号量" class="headerlink" title="介绍一下信号量"></a>介绍一下信号量</h2><p>信号量（Semaphore）是一种用于管理多线程或多进程<strong>并发访问共享资源</strong>的同步工具。它通过<strong>维护一个计数器来跟踪可用资源的数量</strong>，从而控制多个线程或进程对共享资源的访问。信号量在操作系统和并发编程中起着关键作用，广泛应用于<strong>避免竞争条件和确保资源的合理分配</strong>。</p><h3 id="信号量的类型"><a href="#信号量的类型" class="headerlink" title="信号量的类型"></a>信号量的类型</h3><ol><li><p><strong>二进制信号量（Binary Semaphore）</strong>：也称为<strong>互斥锁（Mutex）</strong>，其计数器只有两个值0和1。主要用于实现互斥访问，即保证同一时间只有一个线程可以访问共享资源。</p></li><li><p><strong>计数信号量（Counting Semaphore）</strong>：计数器可以大于1，<strong>允许多个线程同时访问有限数量的共享资源</strong>。例如，限制某个资源同时只能有N个线程访问。</p></li></ol><h3 id="信号量的基本操作"><a href="#信号量的基本操作" class="headerlink" title="信号量的基本操作"></a>信号量的基本操作</h3><p>信号量通常提供两个主要操作：</p><ul><li><strong>P（Proberen）操作</strong>：也叫wait、down或decrement操作，表示请求资源。如果信号量的计数器大于0，则减1；<strong>如果计数器为0，则线程会被阻塞，直到计数器大于0</strong>。</li><li><strong>V（Verhogen）操作</strong>：也叫signal、up或increment操作，表示释放资源。将信号量的计数器加1，<strong>如果有被阻塞的线程，则唤醒其中一个</strong>。</li></ul><h3 id="使用信号量的场景"><a href="#使用信号量的场景" class="headerlink" title="使用信号量的场景"></a>使用信号量的场景</h3><ol><li><strong>资源池管理</strong>：限制对有限资源（如数据库连接、线程池）的并发访问数量。</li><li><strong>生产者-消费者问题</strong>：确保生产者和消费者对共享缓冲区的正确访问，避免缓冲区溢出或空读。</li><li><strong>同步操作</strong>：保证多线程环境中操作的顺序性，防止数据不一致。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>根据之前的模拟面试记录复盘了一下</title>
    <link href="/2024/05/22/%E6%A0%B9%E6%8D%AE%E4%B9%8B%E5%89%8D%E7%9A%84%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E5%A4%8D%E7%9B%98%E4%BA%86%E4%B8%80%E4%B8%8B/"/>
    <url>/2024/05/22/%E6%A0%B9%E6%8D%AE%E4%B9%8B%E5%89%8D%E7%9A%84%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E5%A4%8D%E7%9B%98%E4%BA%86%E4%B8%80%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>肉眼可见地多掌握了好多</p><p>udp首部：源port（可选），目的port（必须），长度（最小为header长度8字节），校验和（总是忘<br>其中记得是port不是ip</p><p>http1.x和2.x区别：传输数据类型，服务器主动推送，多路复用（流ID），头部压缩</p><p>IO 模型：异步io 阻塞io 非阻塞io 信号<strong>驱动</strong>io 多路复用io</p><p>udp是什么：UDP 是一个简单的传输层协议，为网络层以上和应用层以下的程序<strong>提供了接口</strong>，他<strong>不保证传输的可靠性</strong>，网络交互和协议栈处理<strong>开销比较小</strong>，适用于对<strong>耗时要求较高但对报文可靠性要求不高</strong>的应用程序使用。 （传输层，接口，不可靠，尽力而为，开销小，高实时）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-11</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-11/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-11/</url>
    
    <content type="html"><![CDATA[<h3 id="谈谈InnoDB引擎中的锁"><a href="#谈谈InnoDB引擎中的锁" class="headerlink" title="谈谈InnoDB引擎中的锁"></a>谈谈InnoDB引擎中的锁</h3><p>在InnoDB存储引擎中，锁是实现并发控制和事务隔离的重要机制之一。InnoDB引擎提供了多种锁类型，包括共享锁、排他锁和意向锁等。</p><p>共享锁（Shared Lock）：允许多个事务同时读取同一行数据，但是不允许对该行数据进行修改。当一个事务持有共享锁时，其他事务可以获取共享锁，但是不能获取排他锁。多个事务可以同时持有共享锁，不会互相阻塞。</p><p>排他锁（Exclusive Lock）：只允许一个事务独占一行数据，其他事务不能获取共享锁或排他锁，直到该事务释放排他锁。当一个事务持有排他锁时，其他事务无法获取任何类型的锁，必须等待该事务释放锁。</p><p>意向锁（Intention Lock）：用于协调共享锁和排他锁之间的竞争。当一个事务获取共享锁或排他锁时，必须先获取对应的意向锁。意向锁是一种轻量级锁，不会阻塞其他事务的读取操作，只会阻塞其他事务的修改操作。</p><p>InnoDB引擎中还有其他类型的锁，例如行锁、表锁和间隙锁等，它们也都有各自的特点和应用场景。在实际开发中，需要根据具体的需求选择合适的锁类型，以保证并发控制和事务隔离的正确性和性能。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-10</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-10/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-10/</url>
    
    <content type="html"><![CDATA[<h2 id="static关键字的作用"><a href="#static关键字的作用" class="headerlink" title="static关键字的作用"></a>static关键字的作用</h2><p>在 C 和 C++ 中，<code>static</code> 关键字有多种用途，具体作用取决于它应用的上下文。主要有以下几种：</p><h3 id="1-在函数内部的作用"><a href="#1-在函数内部的作用" class="headerlink" title="1. 在函数内部的作用"></a>1. <strong>在函数内部的作用</strong></h3><p>当 <code>static</code> 用于函数内部的变量时，这个变量的生命周期将延续到程序结束，而不仅仅局限于函数调用期间。它在首次调用时被初始化，以后的每次调用都会使用上一次调用结束时的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br>    counter++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, counter);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    count(); <span class="hljs-comment">// 输出 1</span><br>    count(); <span class="hljs-comment">// 输出 2</span><br>    count(); <span class="hljs-comment">// 输出 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-在文件作用域的作用"><a href="#2-在文件作用域的作用" class="headerlink" title="2. 在文件作用域的作用"></a>2. <strong>在文件作用域的作用</strong></h3><p>当 <code>static</code> 用于文件作用域（即在函数外部定义的变量或函数）时，该变量或函数的作用域仅限于定义它的源文件。这可以防止其他文件访问该变量或函数，实现了内部链接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// file1.c</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    count++;<br>&#125;<br><br><span class="hljs-comment">// file2.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    increment();<br>    <span class="hljs-comment">// 无法直接访问 file1.c 中的 count 变量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>count</code> 变量和 <code>increment</code> 函数只能在 <code>file1.c</code> 中访问，而不能在其他文件中访问。</p><h3 id="3-在类中的作用（C-）"><a href="#3-在类中的作用（C-）" class="headerlink" title="3. 在类中的作用（C++）"></a>3. <strong>在类中的作用（C++）</strong></h3><p>在 C++ 中，<code>static</code> 关键字可以用于类成员，表示这些成员属于类本身，而不是某个具体对象。具体表现为以下几种情况：</p><h4 id="3-1-静态数据成员"><a href="#3-1-静态数据成员" class="headerlink" title="3.1. 静态数据成员"></a>3.1. <strong>静态数据成员</strong></h4><p>静态数据成员在所有对象之间共享，只占用一份存储空间。它们可以在类外部定义和初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-built_in">MyClass</span>() &#123;<br>        count++;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1;<br>    MyClass obj2;<br>    std::cout &lt;&lt; MyClass::count &lt;&lt; std::endl; <span class="hljs-comment">// 输出 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-静态成员函数"><a href="#3-2-静态成员函数" class="headerlink" title="3.2. 静态成员函数"></a>3.2. <strong>静态成员函数</strong></h4><p>静态成员函数只能访问静态数据成员和其他静态成员函数，不能访问非静态成员。它们可以通过类名直接调用，而不需要对象实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">displayCount</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; count &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass::count = <span class="hljs-number">5</span>;<br>    MyClass::<span class="hljs-built_in">displayCount</span>(); <span class="hljs-comment">// 输出 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>函数内部的静态变量</strong>：生命周期贯穿程序整个运行周期，但作用域仅限于函数内部。</li><li><strong>文件作用域的静态变量和函数</strong>：只在定义它们的文件内部可见，实现内部链接。</li><li><strong>类中的静态成员（C++）</strong>：属于类本身，而不是某个对象，可以在所有对象间共享，或直接通过类名访问。</li></ul><p>这些特性使 <code>static</code> 关键字在控制变量的作用域和生命周期、实现封装和数据共享方面非常有用。</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>一、堆栈空间分配区别：<br>    1、栈（操作系统）：由操作系统自动分配释放<br>，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；<br>    2、堆（操作系统）： 一般由程序员分配释放，<br>若程序员不释放，程序结束时可能由os回收，分配方式倒是类似于链表。<br>二、堆栈缓存方式区别：<br>    1、栈使用的是一级缓存，<br>他们通常都是被调用时处于存储空间中，调用完毕立即释放；<br>    2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。<br>    三、堆栈数据结构区别：<br>    堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>    栈（数据结构）：一种先进后出的数据结构。</p><h2 id="滑动窗口找最大值"><a href="#滑动窗口找最大值" class="headerlink" title="滑动窗口找最大值"></a>滑动窗口找最大值</h2><p>给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</p><p>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>窗口大于数组长度或窗口长度为0的时候，返回空。<br>gpt生成的：以后验证</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">windowValue</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> window)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    deque&lt;<span class="hljs-type">int</span>&gt; dq; <span class="hljs-comment">// 存储数组元素的索引</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-comment">// 移除不在当前窗口的元素</span><br>        <span class="hljs-keyword">if</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() == i - window) &#123;<br>            dq.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 移除所有小于当前元素的元素</span><br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; arr[dq.<span class="hljs-built_in">back</span>()] &lt;= arr[i]) &#123;<br>            dq.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 添加当前元素的索引到双端队列</span><br>        dq.<span class="hljs-built_in">push_back</span>(i);<br><br>        <span class="hljs-comment">// 当前窗口的最大值就是双端队列的头部</span><br>        <span class="hljs-keyword">if</span> (i &gt;= window - <span class="hljs-number">1</span>) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(arr[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> window = <span class="hljs-number">3</span>;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; result = <span class="hljs-built_in">windowValue</span>(arr, n, window);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : result) &#123;<br>        cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-9</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-9/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-9/</url>
    
    <content type="html"><![CDATA[<h3 id="IP协议的首部结构"><a href="#IP协议的首部结构" class="headerlink" title="IP协议的首部结构"></a>IP协议的首部结构</h3><p>（每次问每次不会）<br>首部协议一共是20个字节（固定）<br>第一个4字节： 版本号；<strong>首部长度</strong>； <strong>服务类型</strong>；<strong>总长度</strong>；<br>第二个4字节：<strong>标识（便于正确组装）；标志（表示是否分片 以及后面还有没有分片）；片偏移；</strong><br>第三个4字节：<strong>生存时间</strong>；<strong>协议（8表示TCP,17表示UDP）；校验和</strong>；<br>第四个4字节：源ip地址；<br>第五个4字节：目的ip地址；</p><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><p>先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。<br>短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。<br>时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br><strong>多级反馈队列调度算法</strong>：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。<br><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p><h3 id="合并两个有序数组到A"><a href="#合并两个有序数组到A" class="headerlink" title="合并两个有序数组到A"></a>合并两个有序数组到A</h3><p>给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组<br><img src="/../img/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%88%B0A.png" alt="合并两个有序数组到A"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">i从A的末尾，j从B末尾开始，两两比较，大的放在末端。</span><br><span class="hljs-comment">比如A[4,5,7] B[1,2,6],。</span><br><span class="hljs-comment">7比6大，A[5]处放置7，然后i前移。</span><br><span class="hljs-comment">再次比较5 和6,6放在A[4]处。</span><br><span class="hljs-comment">如此类推如果A穷尽，把B元素依次放进A的前几个位置，如果B穷尽，正好结束。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> B[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;B.length;k++)<br>                A[k]=B[k];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> i=m<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> s=m+n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;i&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(A[i]&gt;B[j])<br>                A[s--]=A[i--];<br>            <span class="hljs-keyword">else</span><br>                    A[s--]=B[j--];<br>        &#125;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-keyword">for</span>(;j&gt;=<span class="hljs-number">0</span>;j--)<br>                    A[j]=B[j];<br>        &#125; <br>        &#125;<br>       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-8</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-8/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-8/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议的缓存策略？"><a href="#HTTP协议的缓存策略？" class="headerlink" title="HTTP协议的缓存策略？"></a>HTTP协议的缓存策略？</h3><p>HTTP协议的缓存策略有两种，分别是强制缓存和协商缓存，强制缓存的优先级大于协商缓存。强制缓存是服务器告诉浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行协商缓存策略。协商缓存是让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified字段通过请求发送给服务器，由服务器校验。如果文件没有改变，那么直接返回304状态，继续使用浏览器缓存。</p><p>加分回答</p><p>HTTP协议的缓存策略是浏览器每次发起请求时，<strong>先在本地缓存中查找结果以及缓存标识</strong>，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使用本地缓存，否则，则向服务器发起请求并携带缓存标识。HTTP协议的缓存策略分两种：强制缓存和协商缓存，<strong>而强制缓存优先级大于协商缓存</strong>。</p><p>强制缓存：服务器告诉浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，<strong>不在时间内，执行比较缓存策略</strong>。<br>协商缓存：让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified<br>通过请求发送给服务器，由服务器校验。如果文件没有改变，那么直接返回304状态，继续使用浏览器缓存。<br><strong>HTTP缓存都是从第二次请求开始的</strong>：</p><p>第一次请求资源时，服务器返回资源，并在响应头首部中回传资源的缓存策略。<br>第二次请求时，浏览器判断这些请求参数，击中强缓存就直接返回状态码200，否则就把请求参数加到请求头首部中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。<br>延伸阅读<br>强制缓存：</p><p>强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory或者from disk。<br>控制强制缓存的字段有：Cache-Control（http1.1）和Expires（http1.0）。<br>Cache-control是一个相对时间，用以表达<strong>自上次请求正确的资源之后的多少秒的时间段内缓存有效</strong>。<br>Expires是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求。<br><strong>Cache-Control的优先级比Expires的优先级高</strong>。前者的出现是为了解决Expires在浏览器时间被手动更改导致缓存判断错误的问题。如果同时存在则使用Cache-control。<br>协商缓存：</p><p>协商缓存的状态码由服务器决策返回200或者304<br>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since或者 If-None-Match的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified或者ETag属性。<br>对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此在响应体体积上的节省是它的优化点。<br>协商缓存有2组字段(不是两个)，控制协商缓存的字段有：Last-Modified&#x2F;If-Modified-since（http1.0）和Etag&#x2F;If-None-match（http1.1）。<br>Last-Modified&#x2F;If-Modified-since表示的是服务器的资源最后一次修改的时间。Etag&#x2F;If-None-match表示的是服务器资源的唯一标识，只要资源变化，Etag就会重新生成。<br>Etag&#x2F;If-None-match的优先级比Last-Modified&#x2F;If-Modified-since高。</p><h3 id="C-11的新特性"><a href="#C-11的新特性" class="headerlink" title="C++11的新特性"></a>C++11的新特性</h3><p>auto类型推导（给变量做类型推导，需要初始值<br>decltype类型推导（类似与sizeof，不过decltype的推导过程是在编译期完成的，并且不会真正计算表达式的值<br>四种cast类型转换（static_cast, dynamic_cast, const_cast, reinterpret_cast）<br>智能指针<br>try_catch抛出异常<br>lambda表达式</p><h3 id="静态变量、全局变量、局部变量的特点"><a href="#静态变量、全局变量、局部变量的特点" class="headerlink" title="静态变量、全局变量、局部变量的特点"></a>静态变量、全局变量、局部变量的特点</h3><p>从所在位置、作用域、内存位置、生命周期来说一说静态变量、全局变量、局部变量的特点：</p><p>位置</p><p>局部变量：在函数中或者方法中，函数的参数，局部代码块中。</p><p>全局变量：在文件中，函数外。</p><p>静态变量：使用 static 修饰，可以是局部、全局或者修饰类成员。</p><p>作用域</p><p>局部变量：<strong>作用域</strong>为<strong>局部</strong>，也就是函数或方法中，出了作用域就不能访问，<strong>同一作用域不能有同名的变量</strong>，如果全局变量和局部变量同名，则访问时采用<strong>就近原则</strong>。</p><p>全局变量：作用域为<strong>全局</strong>，在<strong>本文件或者其它文件中都可以访问</strong>，在其它文件中访问可以通过 <strong>extern</strong> 进行声明，表示使用外部的全部变量。</p><p>静态变量：静态局部变量作用域为<strong>局部</strong>，静态全局变量作用域为所在文件中，<strong>其它文件中访问不了</strong>。</p><p>内存位置</p><p>局部变量：存储在<strong>栈内存</strong>中。</p><p>全局变量&#x2F;全局变量：存储在<strong>静态存储区</strong>中，如果未初始化或者初始化为0，在BSS段，初始化了在DATA段。</p><p>生命周期</p><p>局部变量：出了作用域销毁。</p><p>全局变量&#x2F;静态变量：程序结束销毁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-7</title>
    <link href="/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-7/"/>
    <url>/2024/05/21/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-7/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>面向对象是一种编程思想，把一切东西看成是一个个对象，比如人、耳机、鼠标、水杯等，他们各自都有属性，比如：耳机是白色的，鼠标是黑色的，水杯是圆柱形的等等，把这些对象拥有的属性变量和操作这些属性变量的函数打包成一个类来表示</p><p>面向过程和面向对象的区别</p><p>面向过程：根据业务逻辑从上到下写代码</p><p>面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程</p><h3 id="说说你对MySQL引擎的理解"><a href="#说说你对MySQL引擎的理解" class="headerlink" title="说说你对MySQL引擎的理解"></a>说说你对MySQL引擎的理解</h3><p>mysql 有两种数据库引擎</p><p>一种是 MyISAM,一种是 InnoDB</p><p>MyISAM 发音为 “my-z[ei]m”;</p><p>InnoDB 发音为 “in-no-db”</p><p><img src="/../img/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/MySQL%E5%BC%95%E6%93%8E.png" alt="mysql引擎"></p><h3 id="Linux中fork-函数的作用"><a href="#Linux中fork-函数的作用" class="headerlink" title="Linux中fork()函数的作用"></a>Linux中fork()函数的作用</h3><p>fork函数是在已经存在的进程中创建一个子进程，其中这个已经存在的这个进程被称为父进程</p><h3 id="数字字符串转IP地址"><a href="#数字字符串转IP地址" class="headerlink" title="数字字符串转IP地址"></a>数字字符串转IP地址</h3><p>当时没写完 因为对string库函数用的不熟练<br>substr和atoi<br>注意不能出现连续的0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param s string字符串</span><br><span class="hljs-comment">     * @return string字符串vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;string&gt;result;<br>        <span class="hljs-type">int</span> len =s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len1 = <span class="hljs-number">1</span>; len1 &lt;= <span class="hljs-number">3</span>; len1++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len2 = <span class="hljs-number">1</span>; len2 &lt;= <span class="hljs-number">3</span>; len2++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len3 = <span class="hljs-number">1</span>; len3 &lt;= <span class="hljs-number">3</span>; len3++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len4 = <span class="hljs-number">1</span>; len4 &lt;= <span class="hljs-number">3</span>; len4++)<br>                        <span class="hljs-keyword">if</span> (len1 + len2 + len3 + len4 == len) &#123;<br>                            string temp;<br>                            <span class="hljs-comment">// for (int i=0;i&lt;len1;i++)&#123;</span><br>                            <span class="hljs-comment">//     temp = temp+s[i];</span><br>                            <span class="hljs-comment">// &#125;</span><br>                            string tmp1 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, len1);<br>                            <span class="hljs-keyword">if</span> (len1!=<span class="hljs-number">1</span>&amp;&amp;tmp1[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-type">int</span> t1 = <span class="hljs-built_in">stoi</span>(tmp1);<br>                            string tmp2 = s.<span class="hljs-built_in">substr</span>(len1, len2);<br>                            <span class="hljs-keyword">if</span> (len2!=<span class="hljs-number">1</span>&amp;&amp;tmp2[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-type">int</span> t2 = <span class="hljs-built_in">stoi</span>(tmp2);<br>                            string tmp3 = s.<span class="hljs-built_in">substr</span>(len1 + len2, len3);<br>                            <span class="hljs-keyword">if</span> (len3!=<span class="hljs-number">1</span>&amp;&amp;tmp3[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-type">int</span> t3 = <span class="hljs-built_in">stoi</span>(tmp3);<br>                            string tmp4 = s.<span class="hljs-built_in">substr</span>(len1 + len2 + len3, len4);<br>                            <span class="hljs-keyword">if</span> (len4!=<span class="hljs-number">1</span>&amp;&amp;tmp4[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-type">int</span> t4 = <span class="hljs-built_in">stoi</span>(tmp4);<br>                            <span class="hljs-keyword">if</span> (t1 &gt; <span class="hljs-number">255</span> || t2 &gt; <span class="hljs-number">255</span> || t3 &gt; <span class="hljs-number">255</span> || t4 &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">continue</span>;<br><br>                            temp = tmp1 + <span class="hljs-string">&#x27;.&#x27;</span> + tmp2 + <span class="hljs-string">&#x27;.&#x27;</span> + tmp3 + <span class="hljs-string">&#x27;.&#x27;</span> + tmp4;<br>                            result.<span class="hljs-built_in">push_back</span>(temp);<br><br><br>                        &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虾皮笔试-我被恶心的输入机制害惨啦</title>
    <link href="/2024/05/21/%E8%99%BE%E7%9A%AE%E7%AC%94%E8%AF%95-%E6%88%91%E8%A2%AB%E6%81%B6%E5%BF%83%E7%9A%84%E8%BE%93%E5%85%A5%E6%9C%BA%E5%88%B6%E5%AE%B3%E6%83%A8%E5%95%A6/"/>
    <url>/2024/05/21/%E8%99%BE%E7%9A%AE%E7%AC%94%E8%AF%95-%E6%88%91%E8%A2%AB%E6%81%B6%E5%BF%83%E7%9A%84%E8%BE%93%E5%85%A5%E6%9C%BA%E5%88%B6%E5%AE%B3%E6%83%A8%E5%95%A6/</url>
    
    <content type="html"><![CDATA[<p>战绩：一道90% 一道AK 一道0%<br>谁家好人直接用字符串读入一个二维数组，，，要死了<br>案例输入：<br>[[0]]<br>[[1,2,3],[4,5,6],[7,8,9]]<br>[[1,2,3,4]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-6</title>
    <link href="/2024/05/20/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-6/"/>
    <url>/2024/05/20/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-6/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是野指针？如何避免？"><a href="#什么是野指针？如何避免？" class="headerlink" title="什么是野指针？如何避免？"></a>什么是野指针？如何避免？</h3><p>野指针是指指向无效内存地址的指针。这种指针通常是未初始化的、已经被释放的或者指向无效内存的指针。在访问野指针所指向的内存时，会导致未定义的行为，可能导致程序崩溃、数据损坏或安全漏洞。</p><p>野指针通常是由于以下原因导致的：</p><ol><li>未初始化：指针变量被声明但未被赋值，指向一个随机的内存地址。</li><li>已释放：指针指向的内存已经被释放，但指针本身并没有置为 <code>nullptr</code> 或 <code>NULL</code>。</li><li>悬空：指针指向的内存已经不再有效，可能是因为它指向的对象已经被销毁或超出了作用域。</li></ol><p>为了避免野指针导致的问题，程序员应该养成良好的指针管理习惯，包括在声明指针时初始化为 <code>nullptr</code> 或 <code>NULL</code>、及时释放动态分配的内存、避免悬空指针等。</p><h3 id="C-的内存管理"><a href="#C-的内存管理" class="headerlink" title="C++的内存管理"></a>C++的内存管理</h3><p>C&#x2F;C++的内存分配主要包括以下几个部分：栈（Stack）、堆（Heap）和静态存储区（Static Storage Area）。这些部分的功能和特点如下：</p><ol><li>栈（Stack）： 栈是一种用于存储局部变量和函数调用信息的内存区域。它是一种后进先出（LIFO）的数据结构，每当一个函数被调用时，都会在栈上创建一个栈帧（Stack Frame）。栈帧中包含了局部变量、函数参数以及其他与函数调用相关的信息。函数调用结束后，分配的内存会自动释放。栈的内存分配和释放速度非常快，但由于栈的大小有限，不能用于存储大量或运行时确定大小的数据。</li><li>堆（Heap）： 堆是一种用于动态分配内存的内存区域。在C++中，可以使用new和delete操作符（或new[]和delete[]操作符）在堆上分配和释放内存。堆内存的分配和释放需要在运行时进行，速度相对较慢，且需要程序员手动管理内存的生命周期。不正确地管理堆内存可能导致内存泄漏或悬挂指针等问题。由于堆的大小远大于栈，可以用于存储大量或运行时确定大小的数据。</li><li>静态存储区（Static Storage Area）： 静态存储区是一种用于存储全局变量、静态变量和常量的内存区域。静态存储区的内存分配在编译时就确定，程序的整个生命周期内都存在，直到程序结束。静态存储区的内存分配速度快，但分配的内存大小在编译时就确定，不能在运行时改变。</li></ol><h3 id="TCP怎么保证有效传输"><a href="#TCP怎么保证有效传输" class="headerlink" title="TCP怎么保证有效传输"></a>TCP怎么保证有效传输</h3><p>首先通过三次握手建立连接<br>建立连接的时候交换序列号<br>发送方每次发送包的时候会带上序列号<br>接收方收到包后检验数据是否正确，确认后发送确认的序列号给发送方<br>发送方没有收到确认的序列号的包，就会重写发送</p><p>1、确认和重传<br>2、数据校验<br>3、流量控制<br>4、拥赛控制</p><h3 id="IP协议首部结构"><a href="#IP协议首部结构" class="headerlink" title="IP协议首部结构"></a>IP协议首部结构</h3><p>IP（Internet Protocol）协议首部是互联网协议栈中的核心部分之一，它负责在网络中传输数据包。以下是IPv4协议首部的结构：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section"> 0      4      8     16     19     31</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">| Version  |  IHL | Type of Service |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|         Total Length               |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|       Identification              |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|Flags| Fragment Offset             |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|  Time to Live | Protocol         |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|         Header Checksum           |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|       Source Address              |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|    Destination Address            |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|   Options and Padding             |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>Version (4 bits)</strong>: 指定IP协议的版本。IPv4协议的版本为4。</p></li><li><p><strong>IHL (Internet Header Length) (4 bits)</strong>: 表示IP首部的长度，以32位字为单位。因为IP首部的长度可变，所以该字段用来指示首部的长度。</p></li><li><p><strong>Type of Service (8 bits)</strong>: 服务类型字段用来指定数据包的服务质量，如优先级、延迟、吞吐量等。</p></li><li><p><strong>Total Length (16 bits)</strong>: 指定整个IP数据报的长度，包括IP首部和数据部分，以字节为单位。</p></li><li><p><strong>Identification (16 bits)</strong>: 用于标识IP数据报的唯一标识符。</p></li><li><p><strong>Flags (3 bits)</strong>: 标识数据报是否被分片，分片相关的标志位。</p></li><li><p><strong>Fragment Offset (13 bits)</strong>: 指定分片相对于原始数据报的偏移量，以8字节为单位。</p></li><li><p><strong>Time to Live (TTL) (8 bits)</strong>: 表示数据报在网络中的生存时间（跳数），每经过一个路由器，该字段的值减1，当该字段的值为0时，数据报会被丢弃。</p></li><li><p><strong>Protocol (8 bits)</strong>: 表示IP数据报携带的上层协议类型，如TCP、UDP等。</p></li><li><p><strong>Header Checksum (16 bits)</strong>: 校验和字段用来检查IP首部在传输过程中是否发生了错误。</p></li><li><p><strong>Source Address (32 bits)</strong>: 源IP地址，指定数据报的发送者。</p></li><li><p><strong>Destination Address (32 bits)</strong>: 目标IP地址，指定数据报的接收者。</p></li><li><p><strong>Options and Padding</strong>: 可选字段，用于指定一些附加的选项信息，如记录路由、时间戳等。如果选项字段不存在，首部会通过填充字段使其对齐到32位字边界。</p></li></ul><p>这是IPv4协议首部的基本结构，IPv6协议首部有所不同。</p><p>IPv6和IPv4首部在结构上有一些不同之处，主要体现在IPv6相对于IPv4的改进和扩展。以下是IPv6协议首部的结构：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section"> 0      4      8     16     19     31</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">| Version  | Traffic Class | Flow Label |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|         Payload Length             |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br><span class="hljs-section">|  Next Header  |   Hop Limit       |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br>|                                   |<br><span class="hljs-code">+           Source Address          +</span><br>|                                   |<br><span class="hljs-code">+------+</span>--    --<span class="hljs-code">+------+</span>------<span class="hljs-code">+------+</span><br>|                                   |<br><span class="hljs-code">+        Destination Address        +</span><br><span class="hljs-section">|                                   |</span><br><span class="hljs-section">+------+------+------+------+------+</span><br></code></pre></td></tr></table></figure><p>与IPv4首部相比，IPv6首部的主要变化如下：</p><ul><li><p><strong>Version (4 bits)</strong>: 同样指定IP协议的版本，IPv6协议的版本为6。</p></li><li><p><strong>Traffic Class (8 bits)</strong>: 类似于IPv4中的服务类型字段，但Traffic Class字段更加灵活，可以支持更多的服务质量标记。</p></li><li><p><strong>Flow Label (20 bits)</strong>: IPv6引入的新特性，用于标识数据流。流标签用于标识需要特殊处理的数据流，如实时流媒体等。</p></li><li><p><strong>Payload Length (16 bits)</strong>: 指定数据报的有效载荷长度，包括扩展首部和数据部分，以字节为单位。</p></li><li><p><strong>Next Header (8 bits)</strong>: 类似于IPv4中的Protocol字段，但Next Header字段更加通用，可以指示下一个扩展首部或上层协议。</p></li><li><p><strong>Hop Limit (8 bits)</strong>: 类似于IPv4中的Time to Live字段，但Hop Limit字段更名为跳限，表示数据报在网络中最多可以经过的路由器数量。</p></li><li><p><strong>Source Address (128 bits)</strong>: IPv6地址长度为128位，比IPv4的32位地址更长。</p></li><li><p><strong>Destination Address (128 bits)</strong>: 目标IPv6地址，同样长度为128位。</p></li></ul><p>IPv6的首部相比IPv4首部更加简洁和灵活，增加了一些新的字段以支持新的功能和特性。IPv6的地址长度增加为128位，提供了更大的地址空间，以应对互联网中设备数量的增长。同时，IPv6还引入了流标签等新特性，以提升数据传输的效率和安全性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-5</title>
    <link href="/2024/05/20/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-5/"/>
    <url>/2024/05/20/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-5/</url>
    
    <content type="html"><![CDATA[<h3 id="说一说你对SQL注入的理解"><a href="#说一说你对SQL注入的理解" class="headerlink" title="说一说你对SQL注入的理解"></a>说一说你对SQL注入的理解</h3><p>SQL注入是一种常见的网络安全攻击，通过利用应用程序对用户输入数据的处理不当，从而使攻击者可以执行未经授权的SQL查询。攻击者通过向应用程序发送恶意的SQL查询语句，然后利用应用程序对这些查询的处理方式，来实现对数据库的非法操作。</p><p>SQL注入攻击通常发生在存在动态SQL查询的应用程序中，例如Web应用程序。攻击者可以利用输入表单、URL参数或其他用户输入渠道注入恶意的SQL代码。一旦成功注入，攻击者可以执行各种恶意操作，包括但不限于：</p><ol><li>数据库信息泄露：通过SQL注入，攻击者可以获取数据库中的敏感信息，如用户凭据、个人数据等。</li><li>数据库修改：攻击者可以修改数据库中的数据，例如删除数据、插入虚假数据等。</li><li>拒绝服务攻击（Denial of Service，DoS）：通过执行耗费大量资源的查询，攻击者可以使数据库服务器过载，从而拒绝正常用户的服务。</li></ol><p>为了防止SQL注入攻击，开发人员应该使用参数化查询或预编译语句等安全的数据库访问方式，并严格验证和过滤所有用户输入数据。此外，还可以使用安全编码实践、漏洞扫描和Web应用程序防火墙等技术来增强应用程序的安全性。</p><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>浅拷贝<strong>只复制指向某个对象的指针，而不复制对象本身</strong>，新旧对象还是<strong>共享同一块内存</strong>。但深拷贝会<strong>另外创造一个一模一样的</strong>对象，新对象跟原对象<strong>不共享内存</strong>，修改新对象<strong>不会改到</strong>原对象。</p><h3 id="C-中的内存对齐"><a href="#C-中的内存对齐" class="headerlink" title="C++中的内存对齐"></a>C++中的内存对齐</h3><p>内存对齐是计算机系统中的一种优化技术，它指的是将数据存储在内存中的地址开始位置按照特定的规则对齐到某个边界上的过程。在大多数计算机体系结构中，内存对齐是默认的行为，即数据类型在内存中的存储位置通常是按照其大小和特定的对齐规则来确定的。</p><p><strong>内存对齐的原因</strong>：</p><ol><li><strong>提高访问效率</strong>：当数据按照规定的对齐方式存储在内存中时，CPU可以更快地访问内存，因为对齐的数据<strong>可以直接通过单个内存访问周期进行读取</strong>，而不需要多次读取。</li><li><strong>硬件要求</strong>：某些硬件体系结构要求数据按照特定的边界对齐，否则可能会导致硬件故障或性能下降。</li></ol><p><strong>内存对齐的规则</strong>：</p><ol><li><strong>字节对齐</strong>：基本数据类型的存储起始地址必须是其<strong>长度的整数倍</strong>。例如，一个4字节的整数应该从内存地址的4的倍数位置开始存储，一个8字节的双精度浮点数应该从内存地址的8的倍数位置开始存储。</li><li><strong>结构体对齐</strong>：结构体中的每个成员变量都要遵循字节对齐规则。结构体的起始地址必须是结构体中最大成员变量的大小的整数倍，并且结构体中的每个成员变量都要按照其大小进行对齐。</li><li><strong>数组对齐</strong>：数组的每个元素都要按照其数据类型的大小进行对齐。</li></ol><p>总之，内存对齐是一种提高计算机系统性能和兼容性的重要优化技术，它通过合理地安排数据在内存中的存储位置，减少了内存访问的时间和开销，提高了系统的整体性能。</p><h3 id="TCP协议的特点？"><a href="#TCP协议的特点？" class="headerlink" title="TCP协议的特点？"></a>TCP协议的特点？</h3><p>1.TCP是面向连接的<strong>传输层</strong>的协议<br>也就是说，应用程序在使用TCP协议之前，必须<strong>先建立</strong>TCP连接。数据传输完毕以后，必须<strong>释放</strong>已经建立的TCP的连接<br>2.每一条TCP连接必须是<strong>一对一</strong>的<br>3.TCP提供<strong>可靠交付</strong>的服务。通过TCP连接传输的数据，不丢失、不重复、无差错，并且按需到达。<br>4.TCP提供<strong>全双工</strong>通信。TCP允许通信双方的应用程序<strong>在任何时候都能发送数据</strong>。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，TCP在合适的时候把数据发送出去。在接收时，TCP把收到的数据存入缓存，上层的应用程序在合适的时候读取缓存中的数据。<br>5.面向<strong>字节流</strong>。TCP中“流(Stream)”指的是<strong>流入到进程或从进程流出的字节序列</strong>。<br>面向字节流的含义是：虽然应用程序和TCP的交互式一次一个数据块(大小不等)，但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流</p><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><p>一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M &gt;&#x3D;0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）（如n&#x3D;6，m&#x3D;2，从123456变成561234）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 旋转数组</span><br><span class="hljs-comment">     * @param n int整型 数组长度</span><br><span class="hljs-comment">     * @param m int整型 右移距离</span><br><span class="hljs-comment">     * @param a int整型vector 给定数组</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span> || (m %= n) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">begin</span>() + n - m);<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>() + n - m, a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>模拟面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-4</title>
    <link href="/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-4/"/>
    <url>/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-4/</url>
    
    <content type="html"><![CDATA[<h2 id="常见的HTTP协议请求头有哪些？"><a href="#常见的HTTP协议请求头有哪些？" class="headerlink" title="常见的HTTP协议请求头有哪些？"></a>常见的HTTP协议请求头有哪些？</h2><p>（答三个差不多得了<br>host（目标主机和端口号）、指定可以处理、可以接受的balabala、cookie、if modified since…<br>HTTP协议请求头（HTTP request headers）是客户端发送给服务器的附加信息，用于描述请求的细节。以下是一些常见的HTTP请求头及其作用：</p><h3 id="通用头字段（General-Header-Fields）"><a href="#通用头字段（General-Header-Fields）" class="headerlink" title="通用头字段（General Header Fields）"></a>通用头字段（General Header Fields）</h3><ul><li><strong>Host</strong>：指定请求的目标主机和端口号。例如：<code>Host: www.example.com</code></li><li><strong>User-Agent</strong>：包含发出请求的客户端应用程序的信息。例如：<code>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)</code></li><li><strong>Accept</strong>：指定客户端可处理的内容类型。例如：<code>Accept: text/html,application/xhtml+xml</code></li><li><strong>Accept-Language</strong>：指定客户端可接受的语言。例如：<code>Accept-Language: en-US,en;q=0.5</code></li><li><strong>Accept-Encoding</strong>：指定客户端可接受的内容编码（压缩方式）。例如：<code>Accept-Encoding: gzip, deflate, br</code></li><li><strong>Connection</strong>：控制连接的行为。常见值有<code>keep-alive</code>和<code>close</code>。例如：<code>Connection: keep-alive</code></li><li><strong>Referer</strong>：包含发出请求的页面的地址，用于告诉服务器该请求来自哪个页面。例如：<code>Referer: https://www.google.com/</code></li><li><strong>Cache-Control</strong>：用于指定请求和响应的缓存机制。例如：<code>Cache-Control: no-cache</code></li></ul><h3 id="请求方法特定头字段（Request-Method-Specific-Header-Fields）"><a href="#请求方法特定头字段（Request-Method-Specific-Header-Fields）" class="headerlink" title="请求方法特定头字段（Request Method Specific Header Fields）"></a>请求方法特定头字段（Request Method Specific Header Fields）</h3><ul><li><strong>Content-Type</strong>：指示请求体的媒体类型。例如：<code>Content-Type: application/json</code></li><li><strong>Content-Length</strong>：指示请求体的长度（以字节为单位）。例如：<code>Content-Length: 348</code></li><li><strong>Authorization</strong>：包含认证信息，用于验证客户端的身份。例如：<code>Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</code></li><li><strong>Cookie</strong>：包含存储在客户端的Cookie信息。用于在客户端和服务器之间传递状态信息。例如：<code>Cookie: sessionId=abc123</code></li><li><strong>If-Modified-Since</strong>：允许服务器返回自指定日期以来未修改的资源。例如：<code>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</code></li><li><strong>If-None-Match</strong>：允许服务器返回资源的ETag（实体标签），如果资源未修改，服务器会返回304（Not Modified）状态码。例如：<code>If-None-Match: &quot;xyzzy&quot;</code></li></ul><h3 id="特定场景的头字段"><a href="#特定场景的头字段" class="headerlink" title="特定场景的头字段"></a>特定场景的头字段</h3><ul><li><strong>Range</strong>：请求资源的部分内容。例如：<code>Range: bytes=500-999</code></li><li><strong>Expect</strong>：指示客户端期望服务器的行为，例如100-continue。例如：<code>Expect: 100-continue</code></li><li><strong>Upgrade</strong>：用于请求服务器升级到另一个协议。例如：<code>Upgrade: websocket</code></li><li>**TE (Transfer-Encoding)**：指定传输编码。例如：<code>TE: trailers, deflate</code></li></ul><h3 id="示例HTTP请求"><a href="#示例HTTP请求" class="headerlink" title="示例HTTP请求"></a>示例HTTP请求</h3><p>以下是一个带有多个请求头的HTTP GET请求示例：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64)<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US,en;q=0.5<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>https://www.google.com/<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>sessionId=abc123<br></code></pre></td></tr></table></figure><h2 id="常见的HTTP协议响应头有哪些？"><a href="#常见的HTTP协议响应头有哪些？" class="headerlink" title="常见的HTTP协议响应头有哪些？"></a>常见的HTTP协议响应头有哪些？</h2><ol><li><code>Content-Type</code>：指定响应的媒体类型（例如：text&#x2F;html、application&#x2F;json）。</li><li><code>Content-Length</code>：指定响应正文的长度（以字节为单位）。</li><li><code>Server</code>：指定服务器软件的名称和版本。</li><li><code>Date</code>：指定响应生成的日期和时间。</li><li><code>Last-Modified</code>：指定资源的最后修改日期和时间。</li><li><code>ETag</code>：指定资源的实体标识符，用于缓存验证。</li><li><code>Expires</code>：指定响应的过期日期和时间。</li><li><code>Cache-Control</code>：指定缓存机制的控制指令。</li><li><code>Location</code>：指定重定向的目标 URL。</li><li><code>Set-Cookie</code>：在客户端保存一个或多个 cookie。</li><li><code>Access-Control-Allow-Origin</code>：指定允许访问资源的域名。</li><li><code>Content-Encoding</code>：指定响应正文的编码方式（例如：gzip、deflate）。</li><li><code>Content-Disposition</code>：指定响应正文的处理方式（例如：inline、attachment）。</li></ol><h2 id="软链接和硬链接的区别"><a href="#软链接和硬链接的区别" class="headerlink" title="软链接和硬链接的区别"></a>软链接和硬链接的区别</h2><p><img src="/../img/%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95/%E7%A1%AC%E9%93%BE%E6%8E%A5%E8%BD%AF%E8%BF%9E%E6%8E%A5.png" alt="硬链接软连接"></p><h2 id="STL中常见容器的实现原理"><a href="#STL中常见容器的实现原理" class="headerlink" title="STL中常见容器的实现原理"></a>STL中常见容器的实现原理</h2><p>C++标准模板库（STL）提供了一系列强大的容器，用于存储和管理数据。这些容器各有不同的实现方式，适用于不同的应用场景。以下是STL中常见容器的实现原理：</p><h3 id="1-std-vector"><a href="#1-std-vector" class="headerlink" title="1. std::vector"></a>1. <code>std::vector</code></h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>动态数组</strong>：<code>std::vector</code> 底层使用<strong>动态数组</strong>实现，支持随机访问。</li><li><strong>内存管理</strong>：<ul><li><strong>容量和大小</strong>：<code>std::vector</code> 有两个重要属性：容量（capacity）和大小（size）。容量是分配的存储空间，大小是当前元素个数。</li><li><strong>动态扩展</strong>：当元素超过容量时，<code>std::vector</code> 会分配更大的内存块（通常是当前容量的两倍），并将现有元素复制到新内存中。</li></ul></li><li><strong>优势</strong>：<ul><li>支持快速的随机访问（O(1)）。</li><li>动态扩展，避免手动管理内存。</li></ul></li></ul><h3 id="2-std-list"><a href="#2-std-list" class="headerlink" title="2. std::list"></a>2. <code>std::list</code></h3><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>双向链表</strong>：<code>std::list</code> 底层实现为<strong>双向链表</strong>，每个节点包含指向前后节点的指针。</li><li><strong>内存管理</strong>：每个元素都分配独立的内存，因此插入和删除操作不会导致整体移动。</li><li><strong>优势</strong>：<ul><li>常数时间的插入和删除操作（在任意位置）。</li><li>遍历性能较好，但随机访问性能较差（O(n)）。</li></ul></li></ul><h3 id="3-std-deque"><a href="#3-std-deque" class="headerlink" title="3. std::deque"></a>3. <code>std::deque</code></h3><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>分段连续存储</strong>：<code>std::deque</code> 使用一系列固定大小的数组块（或称为“缓冲区”）来存储元素，每个数组块称为一个“缓冲区”。</li><li><strong>双端队列</strong>：支持在头尾两端高效插入和删除。</li><li><strong>内存管理</strong>：<strong>分段连续存储方式</strong>使其既可以高效进行头尾插入，又可以支持快速的随机访问。</li><li><strong>优势</strong>：<ul><li>双端高效操作。</li><li>适用于需要频繁头尾操作的场景。</li></ul></li></ul><h3 id="4-std-stack-和-std-queue"><a href="#4-std-stack-和-std-queue" class="headerlink" title="4. std::stack 和 std::queue"></a>4. <code>std::stack</code> 和 <code>std::queue</code></h3><h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>适配器容器</strong>：<code>std::stack</code> 和 <code>std::queue</code> 是基于其他容器（如 <code>std::deque</code> 或 <code>std::list</code>）的适配器。</li><li><strong>LIFO 和 FIFO</strong>：<ul><li><code>std::stack</code>：后进先出（LIFO），通常基于 <code>std::vector</code> 或 <code>std::deque</code>。</li><li><code>std::queue</code>：先进先出（FIFO），通常基于 <code>std::deque</code>。</li></ul></li><li><strong>优势</strong>：<ul><li>简化特定操作（如堆栈和队列操作）。</li></ul></li></ul><h3 id="5-std-set-和-std-map"><a href="#5-std-set-和-std-map" class="headerlink" title="5. std::set 和 std::map"></a>5. <code>std::set</code> 和 <code>std::map</code></h3><h4 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>平衡二叉树</strong>：通常实现为<strong>红黑树</strong>，每次插入、删除和查找操作都是 O(log n) 时间复杂度。</li><li><strong>键值存储</strong>：<ul><li><code>std::set</code>：只存储键，键唯一且有序。</li><li><code>std::map</code>：存储键值对，键唯一且有序。</li></ul></li><li><strong>内存管理</strong>：每个节点独立分配内存，节点间通过指针连接。</li><li><strong>优势</strong>：<ul><li>有序存储，快速查找、插入和删除。</li></ul></li></ul><h3 id="6-std-unordered-set-和-std-unordered-map"><a href="#6-std-unordered-set-和-std-unordered-map" class="headerlink" title="6. std::unordered_set 和 std::unordered_map"></a>6. <code>std::unordered_set</code> 和 <code>std::unordered_map</code></h3><h4 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>哈希表</strong>：底层使用<strong>哈希表</strong>实现，支持平均 O(1) 时间复杂度的查找、插入和删除。</li><li><strong>哈希函数和冲突解决</strong>：通过哈希函数计算键的位置，使用链地址法（链表）或开放地址法解决哈希冲突。</li><li><strong>键值存储</strong>：<ul><li><code>std::unordered_set</code>：只存储键，无序且键唯一。</li><li><code>std::unordered_map</code>：存储键值对，无序且键唯一。</li></ul></li><li><strong>内存管理</strong>：哈希表中的每个桶可能包含链表（链地址法）。</li><li><strong>优势</strong>：<ul><li>高效的查找、插入和删除，无需保持顺序。</li></ul></li></ul><h3 id="7-std-array"><a href="#7-std-array" class="headerlink" title="7. std::array"></a>7. <code>std::array</code></h3><h4 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><strong>静态数组</strong>：<code>std::array</code> 是固定大小的数组，大小在编译时确定。</li><li><strong>内存管理</strong>：在栈上分配内存，支持随机访问。</li><li><strong>优势</strong>：<ul><li>简单高效，大小固定无需动态分配。</li><li>全部功能和普通C数组一致，但提供了STL容器接口。</li></ul></li></ul><p>这些容器的设计各有特点，适用于不同的使用场景。选择合适的容器可以大大提高程序的性能和可维护性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>重排链表</title>
    <link href="/2024/05/19/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/05/19/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>很经典的一道题目<br>注意分解为一个一个函数，并且通过输出来debug（当然正式写的时候可能没时间debug了，所以还是要常写常新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> v,ListNode* n)&#123;<br>        value = v;<br>        next = n;<br>    &#125;<br>&#125;;<br><span class="hljs-function">ListNode* <span class="hljs-title">find_mid</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>    <span class="hljs-comment">// 这个的版本是：如果有两个都是中间，返回前面那个</span><br>    <span class="hljs-comment">// 如果要返回后面那个，得fast!=nullptr&amp;&amp;fast-&gt;next!=nullptr</span><br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span> (fast-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">reverse_list</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        ListNode* cur = head;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* nxt = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>            nxt = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_list</span><span class="hljs-params">(ListNode* head1,ListNode* head2)</span></span>&#123;<br>        ListNode* cur1 = head1;<br>        ListNode* cur2 = head2;<br>        ListNode* nxt1 = <span class="hljs-literal">nullptr</span>;<br>        ListNode* nxt2 = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur1!=<span class="hljs-literal">nullptr</span>&amp;&amp;cur2!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <br>            nxt1 = cur1-&gt;next;<br>            nxt2 = cur2-&gt;next;<br>            cur1-&gt;next = cur2;<br>            cur1 = nxt1;<br>            cur2-&gt;next = nxt1;<br>            cur2 = nxt2;<br>            <br>        &#125;<br>        <br><br>    &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>    <span class="hljs-keyword">while</span> (head!=<span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;head-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        head=head-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">3</span>,<span class="hljs-literal">nullptr</span>);<br>    head-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">4</span>,<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-comment">// head-&gt;next-&gt;next-&gt;next-&gt;next = new ListNode(5,nullptr);</span><br>    ListNode* mid = <span class="hljs-built_in">find_mid</span>(head);<br>    ListNode*new_head = <span class="hljs-built_in">reverse_list</span>(mid-&gt;next);<br>    mid-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-comment">// 这一步很重要！！！！</span><br><br>    <span class="hljs-comment">// cout&lt;&lt;&quot;mid=&quot;&lt;&lt;mid-&gt;value&lt;&lt;endl;</span><br>    <br>    <span class="hljs-built_in">merge_list</span>(head,new_head);<br>    <span class="hljs-built_in">print_list</span>(head);<br>    <span class="hljs-comment">// print_list(new_head);</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-3</title>
    <link href="/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-3/"/>
    <url>/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-3/</url>
    
    <content type="html"><![CDATA[<h3 id="UDP（用户数据报协议）是什么？"><a href="#UDP（用户数据报协议）是什么？" class="headerlink" title="UDP（用户数据报协议）是什么？"></a>UDP（用户数据报协议）是什么？</h3><p>UDP是<strong>传输层协议</strong>，是面向用户数据报协议，不保证可靠交付，<strong>没用TCP的拥塞控制和三次握手的机制保证可靠传输（虽然我的项目里写了但是那个是可靠udp！udp本身没有拥塞控制），UDP尽最大努力交付</strong>。最少只有8个字节。UDP支持单播、组播、广播，UDP相对TCP更简单，传输的速率更快，所以通常可以<strong>用在实时性比较强的需求上</strong>，比如视频会议等。</p><h3 id="如何实现可靠udp"><a href="#如何实现可靠udp" class="headerlink" title="如何实现可靠udp"></a>如何实现可靠udp</h3><p>（这不就是我的项目吗！！！！）<br>实现可靠UDP（User Datagram Protocol）的方法通常涉及在应用层增加逻辑来处理数据包的丢失、重传、排序和确认。以下是一些实现可靠UDP的关键步骤：</p><ol><li><p><strong>数据包编号（Sequence Numbering）</strong>：</p><ul><li>在发送每个数据包时分配一个<strong>唯一的序列号</strong>。接收方可以使用这个序列号来检测丢失的数据包并按正确的顺序重组数据。</li></ul></li><li><p><strong>确认机制（Acknowledgment Mechanism）</strong>：</p><ul><li>接收方在收到数据包后<strong>发送确认包（ACK）</strong>回发送方，告知其数据包已成功接收。如果发送方在一定时间内未收到ACK，则认为该数据包丢失，需要重传。</li></ul></li><li><p><strong>重传机制（Retransmission Mechanism）</strong>：</p><ul><li>发送方在一定时间内未收到ACK时，<strong>重传</strong>未被确认的数据包。这个时间可以是固定的，也可以根据网络状况进行调整。</li></ul></li><li><p><strong>超时和重试次数（Timeout and Retry Count）</strong>：</p><ul><li>设置<strong>超时重传的时间间隔和重试的次数。如果超过重试次数仍未收到ACK，可以认为连接断开。</strong></li></ul></li><li><p><strong>滑动窗口（Sliding Window）</strong>：</p><ul><li>为了提高传输效率，可以实现<strong>滑动窗口协议，允许发送方在等待ACK的同时继续发送一定数量的数据包。</strong></li></ul></li><li><p><strong>流量控制和拥塞控制（Flow Control and Congestion Control）</strong>：</p><ul><li>实现流量控制机制以避免发送方过快发送数据导致接收方缓冲区溢出。拥塞控制机制可以帮助在网络拥堵时调整发送速率。</li></ul></li></ol><h3 id="HTTPS（安全超文本传输协议）是什么"><a href="#HTTPS（安全超文本传输协议）是什么" class="headerlink" title="HTTPS（安全超文本传输协议）是什么"></a>HTTPS（安全超文本传输协议）是什么</h3><p>标准回答</p><p>HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的HTTP通道，在HTTP的基础上通过<strong>身份认证和传输加密</strong>阶段保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入TLS（Transport Layer Security 安全传输层协议）&#x2F;SSL（Secure Sockets Layer 安全套接层协议），HTTPS 的安全基础是 TLS&#x2F;SSL，因此加密就需要TLS&#x2F; SSL。HTTPS的特点是：<strong>内容加密、身份验证、数据完整性</strong>。</p><p>加分回答</p><p>HTTPS（Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的HTTP通道，在HTTP的基础上通过身份认证和传输加密阶段保证了传输过程的安全性。HTTPS 在HTTP 的基础下加入TLS（Transport Layer Security 安全传输层协议）&#x2F;SSL（Secure Sockets Layer 安全套接层协议），HTTPS 的安全基础是 TLS&#x2F;SSL，因此加密就需要TLS&#x2F; SSL。</p><p>SSL的全称为Secure Sockets Layer，安全套接层协议。是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL。</p><p>TLS的全称是Transport Layer Security，安全传输层协议。是SSL3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。</p><p>在HTTPS数据传输的过程中，需要用TLS&#x2F;SSL对数据进行加密，然后通过HTTP对加密后的密文进行传输，可以看出HTTPS的通信是由HTTP和TLS&#x2F;SSL配合完成的。</p><p>HTTPS的特点：</p><p>内容加密：<strong>混合加密方式，对称加密和非对称加密</strong>。<br>验证身份：通过<strong>证书认证</strong>客户端访问的是正确的服务器。<br>数据完整性：<strong>防止传输的数据被中间人篡改</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-2</title>
    <link href="/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-2/"/>
    <url>/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-2/</url>
    
    <content type="html"><![CDATA[<h3 id="C-中的四种类型转换"><a href="#C-中的四种类型转换" class="headerlink" title="C++ 中的四种类型转换"></a>C++ 中的四种类型转换</h3><p><a href="https://zhuanlan.zhihu.com/p/258975506">知乎链接</a><br>1、static_cast</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">static_cast</span>&lt;<span class="hljs-keyword">type</span>&gt;(expression)<br></code></pre></td></tr></table></figure><p>该运算符把 expression 转换为 type 类型，主要用于基本数据类型之间的转换，如把 uint 转换为 int，把 int 转换为 double 等。<br>需要注意的是：static_cast 会进行一些类型检查，但是没有运行时检查来保证转换的安全性，需要程序员来判断转换是否安全。</p><p>2、dynamic_cast</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">dynamic_cast</span>&lt;<span class="hljs-keyword">type</span>&gt;(expression)<br></code></pre></td></tr></table></figure><p>dynamic_cast 主要用于类层次间的上行转换或下行转换。在进行上行转换（派生类-&gt;基类）时，dynamic_cast 和 static_cast 的效果是一样的，但在下行转换（基类-&gt;派生类）时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。</p><p>3、const_cast</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">const_cast</span>&lt;<span class="hljs-keyword">type</span>&gt;(expression)<br></code></pre></td></tr></table></figure><p>用于去除 const 属性，去掉类型的 const 或者 volatile 属性，将 const 类型的指针变为非 const 类型的指针。</p><p>4、reinterpret_cast<br>reinterpret_cast <strong>不进行任何类型安全检查</strong>，直接将位模式解释为目标类型。这意味着它可以将任何指针类型转换为其他任何指针类型，而不考虑它们之间是否有合理的转换关系。</p><h3 id="HTTP-1-X-和-HTTP-2-X-的区别"><a href="#HTTP-1-X-和-HTTP-2-X-的区别" class="headerlink" title="HTTP 1.X 和 HTTP 2.X 的区别"></a>HTTP 1.X 和 HTTP 2.X 的区别</h3><p>（1）.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。</p><p><strong>二进制传送的单位是帧和流</strong>。帧组成了流，同时流还有<strong>流ID</strong>标示</p><p>（2）.HTTP2<strong>支持多路复用</strong></p><p>因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求</p><p>（3）.HTTP2<strong>头部压缩</strong></p><p>HTTP2通过gzip和compress<strong>压缩头部</strong>然后再发送，<strong>同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID查询表头的值</strong></p><p>（4）.HTTP2<strong>支持服务器推送</strong></p><p>HTTP2支持在未经客户端许可的情况下，主动向客户端推送内容</p><h3 id="介绍一下几种IO模型"><a href="#介绍一下几种IO模型" class="headerlink" title="介绍一下几种IO模型"></a>介绍一下几种IO模型</h3><p>阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO</p><h3 id="如何判断大端和小端"><a href="#如何判断大端和小端" class="headerlink" title="如何判断大端和小端"></a>如何判断大端和小端</h3><p><a href="https://blog.csdn.net/weixin_38184628/article/details/136305592">csdn链接</a><br>Big-Endian（大端字节序） 和Little-Endian。<br>a) Little-Endian 高位字节在前，低位字节在后。<br>b) Big-Endian 低位字节在前，高位字节在后。<br>c) 网络字节序：TCP&#x2F;IP各层协议将字节序定义为Big-Endian，因此TCP&#x2F;IP协议中使用的字节序通常称之为网络字节序。</p><p>假设有一个 int 类型的数据，值为 0x12345678，保存在地址 0x400 ~ 0x403 这 4 个字节的位置。</p><p>大端：</p><p>在大端 cpu 上，存储情况如下图所示，高位存储在低地址。0x12 是高位，存储在地址 0x400 上；0x78 是低位，存储才 0x403 上。</p><p>小端：</p><p>小端与大端相反，高位存储在高地址。0x12 是高位，存储在 0x403；0x78 是低位，存储在 0x400。</p>]]></content>
    
    
    
    <tags>
      
      <tag>模拟面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客模拟面试-1</title>
    <link href="/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-1/"/>
    <url>/2024/05/19/%E7%89%9B%E5%AE%A2%E6%A8%A1%E6%8B%9F%E9%9D%A2%E8%AF%95-1/</url>
    
    <content type="html"><![CDATA[<h3 id="C和C-中struct的区别"><a href="#C和C-中struct的区别" class="headerlink" title="C和C++中struct的区别"></a>C和C++中struct的区别</h3><p>1.C的结构体不允许有成员函数，<strong>C++允许，并且还可以是虚函数</strong>。</p><p>2.<strong>C的结构体没有权限这个说法，默认public</strong>；C++的结构体就<strong>和类一样，有权限，默认是public</strong>。</p><p>3.C的结构体可以继承,C++的结构体可以和其他结构体或类继承</p><p>4.<strong>C++的结构体可以初始化</strong>，而C不可以</p><p>5.C要加上<strong>struct关键字或者使用typedef取别名来使用</strong>，而C++直接使用结构体名字。</p><h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><p>1.struct一般用于描述数据的集合，class是<strong>对一个对象数据的封装</strong></p><p>2.struct<strong>默认权限</strong>是public，class默认权限是private</p><p>3.<strong>继承方式，struct默认公有继承，而class默认是私有继承</strong></p><p>4.class关键字可以用来<strong>定义模板</strong>，struct不可以。</p><h3 id="简述一下linux中的零拷贝"><a href="#简述一下linux中的零拷贝" class="headerlink" title="简述一下linux中的零拷贝"></a>简述一下linux中的零拷贝</h3><p><a href="https://blog.csdn.net/YL3126/article/details/117468640">csdn链接</a><br>传统 IO 执行的话需要 <strong>4 次上下文切换（用户态 -&gt; 内核态 -&gt; 用户态 -&gt; 内核态 -&gt; 用户态）和 4 次拷贝（磁盘文件 DMA 拷贝到内核缓冲区，内核缓冲区 CPU 拷贝到用户缓冲区，用户缓冲区 CPU 拷贝到 Socket 缓冲区，Socket 缓冲区 DMA 拷贝到协议引擎）</strong>。</p><p>mmap 将磁盘文件映射到内存，支持读和写，对内存的操作会反映在磁盘文件上，适合小数据量读写，需要 4 次上下文切换（用户态 -&gt; 内核态 -&gt; 用户态 -&gt; 内核态 -&gt; 用户态）和<strong>3 次拷贝</strong>（磁盘文件DMA拷贝到内核缓冲区，内核缓冲区 CPU 拷贝到 Socket 缓冲区，Socket 缓冲区 DMA 拷贝到协议引擎）<strong>（少了内核缓冲区拷贝到用户缓冲区，直接拷贝到socket缓冲区</strong>。</p><p>sendfile 是将读到内核空间的数据，转到 socket buffer，进行网络发送，适合大文件传输，只需要 2 次上下文切换（用户态 -&gt; 内核态 -&gt; 用户态）和 2 次拷贝（磁盘文件 DMA 拷贝到内核缓冲区，内核缓冲区 DMA 拷贝到协议引擎）（kafka就用了sendfile）。</p><p>什么是零拷贝</p><p>零拷贝（Zero-Copy）就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术，是指<strong>将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手</strong>。</p><p>零拷贝的好处</p><p>内核与内核：避免操作系统<strong>内核缓冲区之间</strong>进行数据拷贝操作<br>内核与用户：避免<strong>操作系统内核和用户应用程序地址空间</strong>这两者之间进行数据拷贝操作<br>硬件与OS：用户应用程序可以<strong>避开操作系统直接访问硬件存储</strong><br><strong>避免不必要的系统调用和上下文切换</strong><br>数据传输尽量让 DMA 来做，需要拷贝的数据可以先被缓存起来，对数据进行处理尽量让硬件来做<br>Linux中零拷贝实现</p><p>Linux 中零拷贝技术实现方式通常有 2 种：</p><p><strong>mmap() + write()</strong><br><strong>sendfile()</strong><br>零拷贝的实现原理</p><h4 id="mmap-write-："><a href="#mmap-write-：" class="headerlink" title="mmap() + write()："></a>mmap() + write()：</h4><p><strong>mmap 相比于传统的 IO 来说，其实就是少了 1 次 CPU 拷贝而已</strong></p><p>mmap() 系统调用函数会<strong>直接把内核缓冲区里的数据映射到用户空间</strong>，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。具体过程：</p><p>应用进程调用了 mmap() 后，<strong>DMA</strong> 会把磁盘的数据拷贝到内核的缓冲区里，接着应用进程跟操作系统内核共享这个缓冲区<br>应用进程再调用 write()，操作系统<strong>直接将内核缓冲区的数据拷贝到 socket 缓冲区中</strong>，这一切都发生在内核态，由 <strong>CPU</strong> 来搬运数据<br>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 <strong>DMA</strong> 搬运的</p><p>传统 IO 里面从内核缓冲区到用户缓冲区有一次 CPU 拷贝，从用户缓冲区到 Socket 缓冲区又有一次 CPU 拷贝。mmap 则一步到位，<strong>直接基于 CPU 将内核缓冲区的数据拷贝到了 Socket 缓冲区</strong>。</p><p>之所以能够减少一次拷贝，就是因为 mmap 直接将磁盘文件数据映射到内核缓冲区，这个映射的过程是基于 DMA 拷贝的，同时用户缓冲区是跟内核缓冲区共享一块映射数据的，建立共享映射之后，就不需要从内核缓冲区拷贝到用户缓冲区了。</p><p>虽然减少了一次拷贝，但是上下文切换的次数还是没变。</p><p>sendfile()：</p><p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用 sendfile()。具体过程：<br>可以看到在图中，已经没有了用户缓冲区，因为用户缓冲区是在用户空间的，所以没有了用户缓冲区也就意味着不需要上下文切换了，就省略了这一步的从内核态切换为用户态。</p><p>同时也不需要基于 CPU 将内核缓冲区的数据拷贝到 Socket 缓冲区了，只需要从内核缓冲区拷贝一些 offset 和 length 到 Socket 缓冲区。</p><p>接着从内核态切换到用户态，从内核缓冲区直接把数据拷贝到网络协议引擎里去；同时从 Socket 缓冲区里拷贝一些 offset 和 length 到网络协议引擎里去，但是这个 offset 和 length 的量很少，几乎可以忽略。</p><p>sendFile 整个过程只有两次上下文切换和两次 DMA 拷贝，很重要的一点是这里完全不需要 CPU 来进行拷贝了，所以才叫做零拷贝，这里的拷贝指的就是操作系统的层面。</p><h3 id="MySQL的ACID特性分别是怎么实现的？"><a href="#MySQL的ACID特性分别是怎么实现的？" class="headerlink" title="MySQL的ACID特性分别是怎么实现的？"></a>MySQL的ACID特性分别是怎么实现的？</h3><p>标准回答</p><p>以InnoDB引擎为例，事务的四个特性主要由<strong>锁和日志</strong>来实现，锁用来保证事务的隔离性，undo log用来保证事务的一致性（一致性是指<strong>数据满足所有数据库的条件，比如字段约束，外键约束，触发器</strong>等。 数据库事务需要满足一致性，就是值一个事务从一致性开始，必须一致性结束），redo log用来保证事务的持久性（数据持久性是指在计算机系统中，<strong>将数据保存在磁盘等非易失性存储介质中，以确保在系统崩溃或断电等异常情况下，数据不会丢失或损坏，</strong>能够在系统恢复后仍然可以正常使用）。</p><p>加分回答</p><p>InnoDB引擎通过Record Lock、Gap Lock、Next-Key Lock三种算法，实现了<strong>四种隔离级别</strong>：READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ（默认）、SERIALIZABLE，并且在REPEATABLE READ级别就解决了脏读、不可重复读、幻读等问题。</p><p>redo log用来实现事务的持久性，即事务ACID中的D。其由两部分组成：一是内存中的重做日志缓冲（redo log buffer），其是易失的；二是重做日志文件（redo log file），其是持久的。InnoDB是事务的存储引擎，其通过Force Log at Commit机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到redo log文件进行持久化，待事务的COMMIT操作完成才算完成。</p><p>事务有时还需要进行回滚操作，这时就需要undo。因此在对数据库进行修改时，InnoDB存储引擎不但会产生redo，还会产生一定量的undo。这样如果用户执行的事务或语句由于某种原因失败了，又或者用户请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。</p><h3 id="UDP协议的首部结构"><a href="#UDP协议的首部结构" class="headerlink" title="UDP协议的首部结构"></a>UDP协议的首部结构</h3><p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节<br>1.源端口号： 可有可无，需要对方回信时选用，不需要时全部置0。<br>2.目的端口号：必须有，在终点交付报文的时候需要用到。<br>3.长度：UDP的数据报的长度（包括首部和数据）其最小值为8字节（只有首部）。<br>4.校验和：检测UDP数据报在传输中是否有错，有错则丢弃。</p>]]></content>
    
    
    
    <tags>
      
      <tag>模拟面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转变</title>
    <link href="/2024/05/18/%E8%BD%AC%E5%8F%98/"/>
    <url>/2024/05/18/%E8%BD%AC%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<p>这个博客的初衷是撒糖哈哈，不过最近变成技术博客了orz</p><p>Q: 和天天在一起带来最大的改变是什么？</p><p>大概是我切身地体会到：</p><p>我不需要再像以前那样通过自我贬低的愤怒来获得前进的动力</p><p>原来生命的动力来源也可以是积极的，原来我可以笑着向前走</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>放个shoppee笔试合集吧方便复习</title>
    <link href="/2024/05/18/%E6%94%BE%E4%B8%AAshoppee%E7%AC%94%E8%AF%95%E5%90%88%E9%9B%86%E5%90%A7%E6%96%B9%E4%BE%BF%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/05/18/%E6%94%BE%E4%B8%AAshoppee%E7%AC%94%E8%AF%95%E5%90%88%E9%9B%86%E5%90%A7%E6%96%B9%E4%BE%BF%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>每次笔试前（这次有笔试吗？zjt说没有）编译器就必定会出幺蛾子，幸好他推荐给我一个网站：<a href="https://vscch.guyutongxue.site/">https://vscch.guyutongxue.site/</a><br>（感谢谷雨同学！！！救大命了）<br>下载一个这个编译器就可以运行</p><p>请注意！！！一定要按F6，不要去戳那个右上角的运行按钮！！！（终于能跑通了呜呜呜，而且不用加system(“pause”)，太牛了，，，</p><p>5.18二更：真的有笔试啊，，幸好事先调好了</p><h3 id="一、最大整数"><a href="#一、最大整数" class="headerlink" title="一、最大整数"></a>一、最大整数</h3><p>给定一个int数组nums，排列每个数的顺序（每个数不可拆分，比如12不能拆成1和2），使之组成一个最大的整数。<br>注意：输出结果可能非常大，所以返回一个字符串而不是整数。<br>输入样例：[10,2]<br>输出样例：“210”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string a,string b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b &gt; b+a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>    vector&lt;string&gt;strnum;<br>    <span class="hljs-comment">// int cur = 0;</span><br>    string temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>|| s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            <span class="hljs-comment">// 非数字字符，忽略</span><br>            strnum.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-comment">// cur = cur + 1;</span><br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp=temp+s[i];<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-type">int</span> size = strnum.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// for (int i=0;i&lt;size;i++)&#123;</span><br>    <span class="hljs-comment">//     cout&lt;&lt;strnum[i]&lt;&lt;endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-built_in">sort</span>(strnum.<span class="hljs-built_in">begin</span>(),strnum.<span class="hljs-built_in">end</span>(),cmp);<br>    string result;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        result = result + strnum[i];<br><br>    &#125;<br>    cout&lt;&lt;result;<br>    <span class="hljs-comment">// system(&quot;pause&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、LOL买英雄"><a href="#二、LOL买英雄" class="headerlink" title="二、LOL买英雄"></a>二、LOL买英雄</h3><p>用金币购买英雄联盟英雄的最大个数，要求给出具体方案。<br>输入描述：给出每个英雄联盟的价格和持有的金币数。<br>输入样例：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[2,1,3,4,5]</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[2,1,3,4]</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">bool</span> flag[<span class="hljs-number">10000</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hero</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> price;<br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-built_in">hero</span>(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> i)&#123;<br>        price = p;<br>        index = i;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(hero a,hero b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.price!=b.price) <span class="hljs-keyword">return</span> a.price&lt;b.price;<br>    <span class="hljs-keyword">return</span> a.index&lt;b.index;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    <span class="hljs-type">int</span> coin;<br>    cin&gt;&gt;s&gt;&gt;coin;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>    <br>    vector&lt;hero&gt;heroes;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]&gt;<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            temp = temp*<span class="hljs-number">10</span>+s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            heroes.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">hero</span>(temp,index));<br>            temp = <span class="hljs-number">0</span>;<br>            index = index+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    vector&lt;hero&gt;<span class="hljs-built_in">ori_heroes</span>(heroes);<br>    <span class="hljs-built_in">sort</span>(heroes.<span class="hljs-built_in">begin</span>(),heroes.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cur_i = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (cur+heroes[cur_i].price&lt;=coin)&#123;<br>        cur = cur +heroes[cur_i].price;<br>        flag[heroes[cur_i].index]=<span class="hljs-number">1</span>;<br>        cur_i=cur_i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// [0,cur_i-1]都是买过了的</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;[&quot;</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;index;i++)&#123;<br>        <span class="hljs-keyword">if</span> (flag[i]&amp;&amp;count&lt;cur_i<span class="hljs-number">-1</span>)&#123;<br>            cout&lt;&lt;ori_heroes[i].price&lt;&lt;<span class="hljs-string">&#x27;,&#x27;</span>;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag[i]&amp;&amp;count==cur_i<span class="hljs-number">-1</span>)&#123;<br>            cout&lt;&lt;ori_heroes[i].price&lt;&lt;<span class="hljs-string">&#x27;]&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、反转语句"><a href="#三、反转语句" class="headerlink" title="三、反转语句"></a>三、反转语句</h3><p>将指定字符串中每个单词的字符顺序反转，需要保留空格和单词的初始顺序不变。<br>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。<br>输入样例：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;hello world, my friends&quot;</span><br></code></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;olleh ,dlrow ym sdneirf&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    string result;<br>    <span class="hljs-built_in">getline</span>(cin,s);<br>    <span class="hljs-comment">// 注意读入一整行的写法</span><br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    string temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len<span class="hljs-number">-1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            result = result + temp + s[i];<br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp = s[i]+temp;<br>        &#125;<br>    &#125;<br>    result = <span class="hljs-string">&#x27;&quot;&#x27;</span>+result + temp + <span class="hljs-string">&#x27;&quot;&#x27;</span>;<br>    cout&lt;&lt;result;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、0到n中包含2的数字个数"><a href="#四、0到n中包含2的数字个数" class="headerlink" title="四、0到n中包含2的数字个数"></a>四、0到n中包含2的数字个数</h3><p>给定一个正整数n，其取值范围为(0,999999],计算出[0,n]之间包含2的数字出现的次数。<br>样例输入：20<br>样例输出：3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_2_num</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span> (n%<span class="hljs-number">10</span>==<span class="hljs-number">2</span>)&#123;<br>            count++;<br>        &#125;<br>        n=n/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        sum += <span class="hljs-built_in">count_2_num</span>(i);<br>    &#125;<br>    cout&lt;&lt;sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>优化了一下，感觉重复计算太多了，采用数组进行记忆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> count[<span class="hljs-number">1000000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">count_2_num</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (n%<span class="hljs-number">10</span>==<span class="hljs-number">2</span>)&#123;<br>        count[n]=count[n/<span class="hljs-number">10</span>]+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        count[n]=count[n/<span class="hljs-number">10</span>];<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">count_2_num</span>(i);<br>        sum += count[i];<br>    &#125;<br>    cout&lt;&lt;sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>函数依赖最小覆盖</title>
    <link href="/2024/05/15/%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86/"/>
    <url>/2024/05/15/%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/icurious/article/details/51240114">csdn链接</a><br><strong>计算最小函数依赖集步骤：</strong><br>① 用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；<br>② 去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，看X+是否包含Y，若是，则去掉X→Y；否则不能去掉，依次做下去。直到找不到冗余的函数依赖；<br>③去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。例如XY→A，若要判Y为多余的，则以X→A代替XY→A是否等价？若A∈(X)+，则Y是多余属性，可以去掉。<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96.jpg" alt="最小覆盖"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3NF分解</title>
    <link href="/2024/05/15/3NF%E5%88%86%E8%A7%A3/"/>
    <url>/2024/05/15/3NF%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/538080461">知乎链接</a><br><strong>3NF分解步骤</strong>：</p><ol><li>先求出正则覆盖Fc</li><li>对于Fc里面的所有函数依赖a-&gt;b,均转化为Ri&#x3D;ab</li><li>对于所有的模式Ri<br> ①如果包含候选码，进行4.<br> ②如果都不包含候选码， 将任意一个候选码添加到模式Ri里面</li><li>如果一个模式被另一个模式包含，则去掉此被包含的模式。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BCNF分解</title>
    <link href="/2024/05/15/%E7%BB%99%E5%87%BA%E4%BF%9D%E6%8C%81%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E5%88%86%E8%A7%A3/"/>
    <url>/2024/05/15/%E7%BB%99%E5%87%BA%E4%BF%9D%E6%8C%81%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>输入：关系R0和其上的函数依赖集S0<br>输出：由R0分解出的关系集合，其中每个关系均属于BCNF<br>方法：下列步骤可以被递归地用于任意关系R和FD集合S。初始时，R&#x3D;R0，S&#x3D;S0。</p><p>检验R是否属于BCNF。如果是，不需要做任何事，返回{R}作为结果。<br>如果存在BCNF违例，假设为X→Y。计算X+。选择R1&#x3D;X+作为一个关系模式，并使另一个关系模式R2包含属性X以及那些不在X+中的属性。<br>（对于R2，它将包含所有不在X+中的属性，因此X → Y 的函数依赖不会存在于R2中，因为X已经被分解到了R1中。所以，R2一定是满足BCNF的。）<br>计算R1和R2的FD集，分别记为S1和S2。<br>递归地分解R1和R2。返回这些分解得到的结果集合。</p><h3 id="通俗的描述"><a href="#通俗的描述" class="headerlink" title="通俗的描述"></a>通俗的描述</h3><p>当一个关系模式违反BCNF时，意味着存在非平凡的函数依赖，其左侧不是任何候选键的超键。</p><p>具体来说，一个关系模式违反BCNF的条件是：</p><p>存在一个非平凡的函数依赖X → Y。<br>X 不是任何候选键的超键。<br>如果存在这样的函数依赖，那么该关系模式就违反了BCNF。</p><h3 id="什么是超键"><a href="#什么是超键" class="headerlink" title="什么是超键"></a>什么是超键</h3><p>候选键的超键是以候选键为子集的超键。</p><p>一个候选键是能够唯一标识关系中的每个元组的最小属性集合。而一个超键是能够唯一标识关系中的每个元组的任意属性集合。</p><p>因此，候选键的超键必然包含了候选键本身，以及候选键的任何真子集。因为候选键本身已经能够唯一标识关系中的每个元组，所以任何包含候选键的超键也能够唯一标识关系中的每个元组。</p><p>举个例子，如果 {A, B} 是一个候选键，那么 {A, B} 和 {A, B, C} 都是候选键的超键，因为它们包含了候选键 {A, B}。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://blog.csdn.net/weixin_42319408/article/details/92066595">例题链接跳转</a><br>如：R(A,B,C,D,E) FD{AB→C,DE→C,B→D}<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/BCNF%E5%88%86%E8%A7%A3%E4%BE%8B%E9%A2%98.jpg" alt="BCNF分解例题"><br>R(ABCDE), F &#x3D; { AB → C, B → D, CD →  E , CE → B , AC → B }<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BD%9C%E4%B8%9A%E4%BE%8B%E9%A2%98.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二战xhs笔试</title>
    <link href="/2024/05/14/%E4%BA%8C%E6%88%98xhs%E7%AC%94%E8%AF%95/"/>
    <url>/2024/05/14/%E4%BA%8C%E6%88%98xhs%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>后续：三道编程题，第一道是签到题（和上次考的第一道一模一样，就是给一堆浏览记录，然后去重，根据第一次浏览的顺序打印，100%AK</p><p>第二道是新书推广计划（漏看的条件和上次考的时候一模一样，，也是最后15分钟突然发现，<br>【最好笑的是除了第一个样例以外其他的都过了，幸好克服了心态问题，试着提交了，91%，下次记得多留存档】<br>【甚至下面写的代码样例也是审题审错了的版本</p><p>第三道是遗失的记忆（回溯，没复习到，考前仓促看了一点思路，现写的，正确率15%以下</p><h3 id="1-博主送礼物"><a href="#1-博主送礼物" class="headerlink" title="1. 博主送礼物"></a>1. 博主送礼物</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E5%8D%9A%E4%B8%BB%E9%80%81%E7%A4%BC%E7%89%A9.png" alt="博主送礼物"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 定义一个类，比结构体好用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fan</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-comment">// sum=like+star*2</span><br>    <span class="hljs-type">int</span> like;<br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-comment">// 定义一个fan的构造函数</span><br>    <span class="hljs-built_in">fan</span>(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> i)&#123;<br>        sum = s;<br>        like = l;<br>        index = i;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(fan a, fan b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (a.sum != b.sum)&#123;<br>        <span class="hljs-keyword">return</span> a.sum&gt;b.sum;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a.like != b.like)&#123;<br>        <span class="hljs-keyword">return</span> a.like&gt;b.like;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.index&lt;b.index;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    <span class="hljs-type">int</span> like,star,sum;<br>    <span class="hljs-comment">// n=4;</span><br>    <span class="hljs-comment">// k=2;</span><br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-comment">// vector&lt;fan&gt;fans(n);</span><br>    <span class="hljs-comment">// 采用这一条会报错是因为没有对于空值的构造函数，所以慢慢push_back就好</span><br>    vector&lt;fan&gt;fans;<br>    vector&lt;<span class="hljs-type">int</span>&gt;num;<br><br>    <span class="hljs-comment">// fans[1]=fan(1+2*2,1,1);</span><br>    <span class="hljs-comment">// fans[2]=fan(2+1*2,2,2);</span><br>    <span class="hljs-comment">// fans[3]=fan(3,3,3);</span><br>    <span class="hljs-comment">// fans[4]=fan(1+2*3,1,4);</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;like&gt;&gt;star;<br>        sum = like+star*<span class="hljs-number">2</span>;<br>        fans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">fan</span>(sum,like,i+<span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(fans.<span class="hljs-built_in">begin</span>(),fans.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-comment">// 记得sort的时候要写begin end</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-comment">// 最后编号也要按升序输出，所以要再处理一下</span><br>        <span class="hljs-comment">// cout&lt;&lt;fans[i].index&lt;&lt;endl;</span><br>        num.<span class="hljs-built_in">push_back</span>(fans[i].index);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(),num.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        cout&lt;&lt;num[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-H小姐的新书推广计划"><a href="#2-H小姐的新书推广计划" class="headerlink" title="2. H小姐的新书推广计划"></a>2. H小姐的新书推广计划</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E6%96%B0%E4%B9%A6%E6%8E%A8%E5%B9%BF%E8%AE%A1%E5%88%92.png" alt="新书推广计划"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">a</span>(n);<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">t</span>(n);<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(x+<span class="hljs-number">1</span>,INT_MAX);<br>    <span class="hljs-comment">// vector数组在定义的时候就可以初始化</span><br>    <br>    <span class="hljs-comment">// 调试数据</span><br>    <span class="hljs-comment">// n=5;</span><br>    <span class="hljs-comment">// x=8;</span><br>    <span class="hljs-comment">// vector&lt;int&gt;a=&#123;1,2,3,4,10&#125;;</span><br>    <span class="hljs-comment">// vector&lt;int&gt;t=&#123;0,1,1,2,5&#125;;</span><br>    <br>    <br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 达到0粉丝数成本为0</span><br>    <span class="hljs-comment">// 不需要赋值dp[a[i]],dp[t[i]]，让他们全都回归初心就行 </span><br>    <span class="hljs-comment">// 我们不需要给a[i]、t[i]排序，只需要减一下就行，而且只减一遍！！！</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">// 逆序遍历即可，记得加前置条件，否则会计算溢出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y=x;y&gt;=t[i];y--)&#123;<br>            <span class="hljs-keyword">if</span> (dp[y - t[i]] != INT_MAX) dp[y]=<span class="hljs-built_in">min</span>(dp[y],dp[y-t[i]]+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y=x;y&gt;=a[i];y--)&#123;<br>            <span class="hljs-comment">// 记得循环遍历的边界条件要等于a[i]，，太好笑了</span><br>             <span class="hljs-keyword">if</span> (dp[y - a[i]] != INT_MAX) dp[y]=<span class="hljs-built_in">min</span>(dp[y],dp[y-a[i]]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>    &#125;<br>    cout&lt;&lt;dp[x]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-H小姐的旅行笔记"><a href="#3-H小姐的旅行笔记" class="headerlink" title="3. H小姐的旅行笔记"></a>3. H小姐的旅行笔记</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E6%97%85%E8%A1%8C%E7%AC%94%E8%AE%B0%E7%B2%BE%E9%80%89.png" alt="旅行笔记精选"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-comment">// 记得priorityqueue头文件</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">article</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 记得写public</span><br>    <span class="hljs-type">int</span> like;<br>    <span class="hljs-type">int</span> comment;<br>    <span class="hljs-built_in">article</span>(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> c)&#123;<br>        like=l;<br>        comment=c;<br>    &#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(article a,article b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.comment&gt;b.comment;<br>    <span class="hljs-comment">// 记得降序</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">likes</span>(n);<br>    <span class="hljs-type">int</span> comment;<br>    vector&lt;article&gt;articles;<br>    <span class="hljs-comment">// 记得不要直接声明大小，没有空值的构造函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;likes[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;comment;<br>        articles.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">article</span>(likes[i],comment));<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(articles.<span class="hljs-built_in">begin</span>(),articles.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-comment">// 记得格式</span><br>    priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt;pq;<br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> best = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>()&lt;k)&#123;<br>            pq.<span class="hljs-built_in">push</span>(articles[i].like);<br>            total+=articles[i].like;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">top</span>()&lt;articles[i].like)&#123;<br>            total+=articles[i].like-pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            pq.<span class="hljs-built_in">push</span>(articles[i].like);<br>            best = <span class="hljs-built_in">max</span>(best,total*articles[i].comment);<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;best&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-点赞数之和最小"><a href="#4-点赞数之和最小" class="headerlink" title="4. 点赞数之和最小"></a>4. 点赞数之和最小</h3><p><img src="/../img/%E7%AC%94%E8%AF%95/%E7%82%B9%E8%B5%9E%E6%95%B0%E4%B9%8B%E5%92%8C.png" alt="点赞数之和"><br>来不及写了，看一下二分思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> total_likes = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> max_likes = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">likes</span><span class="hljs-params">(n)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; likes[i];<br>        total_likes += likes[i];<br>        max_likes = <span class="hljs-built_in">max</span>(max_likes, likes[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> like : likes) &#123;<br>            <span class="hljs-keyword">if</span> (like != max_likes)<br>                cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; like &lt;&lt; endl;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (likes[i] == max_likes)<br>                <span class="hljs-comment">// 有一篇和他一样也行，也算最大</span><br>                cout &lt;&lt; total_likes &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> L = max_likes;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> R = <span class="hljs-number">1e12</span>;<br>                <span class="hljs-comment">// mid值是该博客最后要达到的点赞值</span><br>                <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = (L + R) / <span class="hljs-number">2</span>;<br>                    <span class="hljs-comment">// 这个条件是说 博客还需要点赞的次数是点赞其他博客总次数+1</span><br>                    <span class="hljs-comment">// 而点赞其他博客的总次数肯定小于等于（记得这里有等于）把每篇都点到mid（最大值）的次数</span><br>                    <span class="hljs-keyword">if</span> (mid - likes[i] &lt;= mid * (n - <span class="hljs-number">1</span>) - (total_likes - likes[i]) + <span class="hljs-number">1</span>)<br>                        R = mid;<br>                    <span class="hljs-keyword">else</span><br>                        L = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>                cout &lt;&lt; total_likes + (L - likes[i]) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span> &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>xhs笔试复盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苯人第一次面试-字节复盘</title>
    <link href="/2024/05/13/%E8%8B%AF%E4%BA%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E5%A4%8D%E7%9B%98/"/>
    <url>/2024/05/13/%E8%8B%AF%E4%BA%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p>结果出了！10：20醒，10：08收到了感谢信，流程推进的很快，总比吊着好！</p><p>字节面试凉（凉？凉！）经一面，不知道到底是凉了还是过了呢？先做个总结吧，实在不行去美团接开水（当当）！当做锻炼机会也不是不可</p><p>面试评价：体验很好，题目挺简单的，面试官人很好一直在捞</p><p><strong>个人总结：</strong><br>基础知识有点不扎实，有点不自信（）毕竟是第一次面试也是情有可原，下次要自信！</p><p><strong>zjt评价：</strong><br>术语太少了感觉像唠嗑，，下次要多记术语，多输出，不要尬笑 底气不足</p><p><strong>面试官评价：</strong><br>在分析问题上面挺好的，但是有几个点我觉得还是需要后面去重点的去回忆一下（回忆？补强！）。</p><ol><li>就是针对于基础知识的一些掌握，因为学校里面有一些基础课程其实是很有意义很有价值的。很多原理性的东西几乎都是源于这个基础知识的演变跟演化，所以把基础的知识了解一下。（您说的对我之前太混了啊啊啊</li><li>可以额外的去了解一下，因为我们是后端开发的一个工作，可以了解一下后端开发的一些工程上的知识，比如说我刚刚给你提到的是<strong>软件工程</strong>相关的一些知识，可以系统的去了解一下，你们有这个课程我知道，所以也可以就直接去看一下他的一些教材或者教案相关的东西了解一下。</li><li>代码这一块，我看你写代码还算比较流利，然后思考问题的话也还算ok，但是有一个点就是你再去编码的时候，<strong>要注意对一些关键环节上面的一些信息的输出，就是通过日志或者通过一些关键环节去整理出来就行了，</strong>主要是这三块（这一点帮助了我xhs的第二次笔试，虽然不知道过了没</li><li>不用太紧张（面试经验不足导致的，多锤几次就好了</li></ol><h1 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h1><p>（唠嗑）</p><h1 id="2-项目经历"><a href="#2-项目经历" class="headerlink" title="2.项目经历"></a>2.项目经历</h1><p>（讲了myftp的项目，面试官尽力在救【试图往udp上引，奈何苯人没有面试经验，救不回来】）<br>（myftp的项目也说得太简单了，要说的详细一点）<br>（下次顺带着把udp的项目也讲了！！！）<br>（malloc说成memset了，我的锅）</p><h1 id="3-项目拓展"><a href="#3-项目拓展" class="headerlink" title="3.项目拓展"></a>3.项目拓展</h1><p>（以后反正也会问到，觉得这一部分特别重要</p><h2 id="Q1-具体是怎么去做的文件的切分？"><a href="#Q1-具体是怎么去做的文件的切分？" class="headerlink" title="Q1:具体是怎么去做的文件的切分？"></a>Q1:具体是怎么去做的文件的切分？</h2><p>凉经案例：只说了把大文件分割成固定大小的块进行传输，而且把字节说成了比特。</p><p><strong>问了gpt：</strong><br>我采用的策略是将一个大文件分割成固定大小的块进行传输，比如1024字节。</p><p>还可以根据网络带宽和延迟动态调整文件块的大小。在这种策略中，服务器端根据当前网络条件动态地调整文件块的大小，以提高传输效率。例如，如果网络带宽较大，可以增大文件块的大小以减少传输次数；如果网络延迟较高，可以减小文件块的大小以降低传输延迟。</p><p>除了以上两种策略，还可以根据具体应用场景和需求设计其他的文件切分策略，例如按照文件类型、内容等进行切分。</p><h2 id="Q2-这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战"><a href="#Q2-这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战" class="headerlink" title="Q2:这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战"></a>Q2:这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战</h2><p>凉经案例：只说了连接管理和文件切分</p><p><strong>问了gpt：</strong></p><ol><li>连接管理：需要处理客户端和服务器端的连接管理，包括建立连接、维护连接状态、处理连接断开等情况。</li><li>文件切分和传输：需要实现文件切分和传输功能，包括将大文件切分成多个小块、传输文件块、重组文件块等操作。</li><li><strong>并发处理</strong>：需要处理多个客户端同时连接的情况，保证并发访问的正确性和性能。</li><li><strong>错误处理和恢复</strong>：需要处理各种错误情况，包括网络异常、文件传输中断、客户端或服务器崩溃等，保证系统的稳定性和可靠性。</li><li><strong>安全性</strong>：需要考虑数据传输的安全性，包括加密传输、身份认证、访问控制等机制。</li></ol><h1 id="4-八股"><a href="#4-八股" class="headerlink" title="4.八股"></a>4.八股</h1><p>面试官可能比较无语（嘿嘿）所以问了一些八股，但是答得也不咋地</p><h2 id="TCP和udp的区别？"><a href="#TCP和udp的区别？" class="headerlink" title="TCP和udp的区别？"></a>TCP和udp的区别？</h2><p>把没有提到的标粗了（我草怎么这么多标粗，感情一共六条就讲了两条</p><ul><li>tcp是面向连接的可靠传输服务；udp不需要建立连接，尽力而为，不保证可靠传输。</li><li><strong>tcp是点对点连接，udp则是支持一对多、多对一、多对多</strong></li><li><strong>udp对系统资源要求较少，而且首部较短节省开销；tcp比较庞大，开销比较大</strong></li><li>tcp是流式传输，没有边界，但是顺序可靠；udp是一个包一个包传输，可能有丢包和乱序</li><li><strong>tcp在传输层进行分片，udp在ip层进行分片</strong></li><li><strong>tcp用于FTP、HTTP等；udp用于dns、smtp、音视频等多媒体</strong><br>（顺带一提 面试官想从这里引到udp来着，太紧张硬生生被我憋回去了，卒</li></ul><h2 id="文件存储的具体的格式？"><a href="#文件存储的具体的格式？" class="headerlink" title="文件存储的具体的格式？"></a>文件存储的具体的格式？</h2><p>（完全不知道是什么东西orz）</p><p>文件通常以二进制形式存储在文件系统中。具体来说，文件的存储格式通常分为两部分，由文件内容和元数据组成：</p><ol><li><p><strong>文件内容</strong>：文件内容以二进制形式存储在文件系统中。对于文本文件，内容可以直接以字符流的形式存储；对于二进制文件，内容则是原始的二进制数据。</p></li><li><p><strong>文件元数据</strong>：文件元数据包括文件的名称、大小、权限、创建时间、修改时间等信息。这些元数据通常会以特定的格式存储在文件系统中，以便文件系统能够快速地识别和管理文件。</p></li></ol><h2 id="问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的"><a href="#问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的" class="headerlink" title="问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的"></a>问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的</h2><h2 id="进程跟线程的区别？"><a href="#进程跟线程的区别？" class="headerlink" title="进程跟线程的区别？"></a>进程跟线程的区别？</h2><p>凉经案例：只讲了第一点资源分配</p><p><strong>问了gpt：</strong><br>进程（Process）和线程（Thread）是操作系统中两个重要的概念，它们之间有以下几点区别：</p><p>第一点，他们在xxxx方面存在区别，进程……，线程……</p><ol><li><p>资源分配：</p><ul><li>进程是<strong>程序的执行实例</strong>，是<strong>系统中的一个独立单位</strong>，拥有独立的<strong>内存空间、文件描述符、堆栈</strong>等资源。</li><li>线程是<strong>进程的执行单元</strong>，是 <strong>CPU 调度的基本单位</strong>，同一进程内的线程共享进程的内存空间和其他资源。</li></ul></li><li><p><strong>调度和切换</strong>：</p><ul><li>进程之间的切换开销比较大，因为需要<strong>保存和恢复整个进程的上下文信息</strong>。</li><li>线程之间的切换开销相对较小，因为<strong>线程共享进程的地址空间</strong>，只需要保存和恢复线程的上下文信息。</li></ul></li><li><p><strong>通信机制</strong>：</p><ul><li>进程之间通信需要使用<strong>IPC（Inter-Process Communication）机制</strong>，例如管道、消息队列、信号量等。</li><li>线程之间通信可以直接<strong>共享进程的地址空间，通过共享变量进行通信</strong>。</li></ul></li><li><p><strong>创建和销毁</strong>：</p><ul><li>进程的创建和销毁开销比较大，因为需要<strong>分配和释放独立的内存空间</strong>。</li><li>线程的创建和销毁开销相对较小，因为线程共享进程的资源，只需要分配和释放<strong>线程的控制块</strong>。</li></ul></li><li><p><strong>并发性</strong>：</p><ul><li>进程之间的并发性较低，因为进程间<strong>切换开销大</strong>。</li><li>线程之间的<strong>并发性较高</strong>，因为线程间切换开销小，<strong>可以更快地响应用户的请求</strong>。</li></ul></li></ol><h2 id="进程间通信方式（IPC）"><a href="#进程间通信方式（IPC）" class="headerlink" title="进程间通信方式（IPC）"></a>进程间通信方式（IPC）</h2><p>凉经：只答了管道、pv信号量（答的时候忘记是信号量了，只记得pv操作）、把共享内存说成了共享变量（共享变量是线程的orz</p><p>进程间通信（IPC）的不同方式各有其优缺点，适用于不同的应用场景。下面是常见的几种IPC方式及其优缺点：</p><h3 id="1-管道（Pipes）"><a href="#1-管道（Pipes）" class="headerlink" title="1. 管道（Pipes）"></a>1. 管道（Pipes）</h3><p>管道又分为匿名管道和命名管道。其中，匿名管道只能用于父子进程等具有亲缘关系的进程，命名管道则存在于文件系统中，可以用于任何进程之间的通信，具有比较好的持久性。管道的优点是创建和使用非常简单，并且数据在管道中的顺序由操作系统来保证，不需要显式同步。但是他也有一些缺点，第一点，管道是<strong>半双工</strong>的，需要两个管道才能实现双向通信。第二点，<strong>读取时如果没有数据会阻塞进程</strong>。</p><h3 id="2-消息队列（Message-Queues）"><a href="#2-消息队列（Message-Queues）" class="headerlink" title="2. 消息队列（Message Queues）"></a>2. 消息队列（Message Queues）</h3><p><strong>优点</strong>：</p><ul><li>支持无亲缘关系的进程通信。</li><li>灵活的消息格式：<strong>可以发送和接收不同类型和优先级的消息</strong>。</li><li>非阻塞操作：可以设置为<strong>非阻塞模式</strong>，避免进程挂起。</li></ul><p><strong>缺点</strong>：</p><ul><li>复杂性：使用和管理相对复杂，需要显式创建和销毁。</li><li>消息大小限制：消息队列<strong>有最大消息大小限制，可能不适合传输大数据</strong>。</li></ul><h3 id="3-共享内存（Shared-Memory）"><a href="#3-共享内存（Shared-Memory）" class="headerlink" title="3. 共享内存（Shared Memory）"></a>3. 共享内存（Shared Memory）</h3><p><strong>优点</strong>：</p><ul><li>高效：直接在内存中进行数据读写，<strong>速度快</strong>，<strong>适合大数据量通信</strong>。</li><li>灵活：可以在共享内存区域内自由读写数据。</li></ul><p><strong>缺点</strong>：</p><ul><li>同步问题：需要<strong>显式同步机制（如信号量）</strong>来保证数据一致性。</li><li>安全性：需要确保访问权限和数据完整性，<strong>避免数据竞争和破坏</strong>。</li></ul><h3 id="4-信号量（Semaphores）"><a href="#4-信号量（Semaphores）" class="headerlink" title="4. 信号量（Semaphores）"></a>4. 信号量（Semaphores）</h3><p>与“信号”要做区别！！！<br><strong>优点</strong>：</p><ul><li>用于进程同步：非常适合解决进程间的<strong>同步和资源竞争</strong>问题。</li><li>灵活：可以用于多种同步场景，支持复杂的同步操作。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>不直接传递数据</strong>：只用于同步，不用于数据传输。</li><li>复杂性：使用和管理相对复杂，需理解信号量机制。</li></ul><h3 id="5-套接字（Sockets）"><a href="#5-套接字（Sockets）" class="headerlink" title="5. 套接字（Sockets）"></a>5. 套接字（Sockets）</h3><p><strong>优点</strong>：</p><ul><li>通用性强：不仅用于<strong>本地进程间通信</strong>，还可以用于<strong>网络通信</strong>。</li><li>灵活：<strong>支持多种通信协议（TCP&#x2F;UDP）</strong>，适合多种通信需求。</li></ul><p><strong>缺点</strong>：</p><ul><li>复杂性：<strong>使用和管理较复杂，需要处理连接、数据流控制等</strong>。</li><li>性能：比共享内存等方式稍<strong>慢</strong>，尤其是在本地通信时。</li></ul><h3 id="6-信号（Signals）"><a href="#6-信号（Signals）" class="headerlink" title="6. 信号（Signals）"></a>6. 信号（Signals）</h3><p><strong>优点</strong>：</p><ul><li>简单：发送和处理信号非常简单，<strong>适合简单的通知和事件处理</strong>。</li><li>异步：信号处理可以<strong>异步进行</strong>，响应事件及时。</li></ul><p><strong>缺点</strong>：</p><ul><li>功能有限：信号<strong>只能传递简单的信息，无法传递复杂数据</strong>。</li><li><strong>易忽略</strong>：进程可能忽略或阻塞信号，需要小心处理。</li></ul><h3 id="7-内存映射文件（Memory-Mapped-Files）"><a href="#7-内存映射文件（Memory-Mapped-Files）" class="headerlink" title="7. 内存映射文件（Memory-Mapped Files）"></a>7. 内存映射文件（Memory-Mapped Files）</h3><p><strong>优点</strong>：</p><ul><li><strong>高效</strong>：通过文件映射到内存，实现快速的数据共享。</li><li><strong>持久性</strong>：数据存储在文件中，具有持久性。</li></ul><p><strong>缺点</strong>：</p><ul><li>同步问题：需要<strong>显式同步机制</strong>来保证数据一致性。</li><li><strong>平台依赖</strong>：不同操作系统对内存映射文件的支持和实现有所不同。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>管道</strong>适合<strong>简单的父子进程</strong>间通信，匿名管道用于亲缘关系进程，命名管道用于无亲缘关系进程。</li><li><strong>消息队列</strong>适合需要<strong>灵活消息传递</strong>的场景，但有<strong>消息大小</strong>限制。</li><li><strong>共享内存</strong>适合<strong>大数据量、高效通信</strong>，但需要<strong>显式同步机制</strong>。</li><li><strong>信号量</strong>用于进程<strong>同步</strong>，解决资源竞争问题，但<strong>不用于数据传输</strong>。</li><li><strong>套接字</strong>通用性强，适合本地和网络通信，但使用复杂。</li><li><strong>信号</strong>适合<strong>简单的通知和事件处理</strong>，但无法传递复杂数据。</li><li><strong>内存映射文件</strong>高效且具有持久性，但需要同步机制，且<strong>平台依赖性较强</strong>。</li></ul><p>选择哪种进程间通信方式取决于具体的应用需求、数据量、性能要求和实现复杂性。</p><p>进程间通信（Inter-Process Communication, IPC）是指在操作系统中，不同进程之间进行数据交换和同步的一系列机制。常见的进程间通信方式包括：</p><h3 id="1-管道（Pipes）具体代码"><a href="#1-管道（Pipes）具体代码" class="headerlink" title="1. 管道（Pipes）具体代码"></a>1. 管道（Pipes）具体代码</h3><p>管道是一种半双工的通信方式，分为匿名管道和命名管道。</p><ul><li><p><strong>匿名管道</strong>：只能用于具有亲缘关系的进程间通信（如父子进程）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">pipe</span>(pipefd);<br><span class="hljs-comment">// pipefd[0] 用于读，pipefd[1] 用于写</span><br></code></pre></td></tr></table></figure></li><li><p><strong>命名管道（FIFO）</strong>：可以用于无亲缘关系的进程间通信。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-built_in">mkfifo</span>(<span class="hljs-string">&quot;/tmp/myfifo&quot;</span>, <span class="hljs-number">0666</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-消息队列（Message-Queues）具体代码"><a href="#2-消息队列（Message-Queues）具体代码" class="headerlink" title="2. 消息队列（Message Queues）具体代码"></a>2. 消息队列（Message Queues）具体代码</h3><p>消息队列允许进程以消息的形式进行通信，可以实现多个进程之间的消息传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg_buffer</span> &#123;<br>    <span class="hljs-type">long</span> msg_type;<br>    <span class="hljs-type">char</span> msg_text[<span class="hljs-number">100</span>];<br>&#125;;<br><br><span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;progfile&quot;</span>, <span class="hljs-number">65</span>);<br><span class="hljs-type">int</span> msgid = <span class="hljs-built_in">msgget</span>(key, <span class="hljs-number">0666</span> | IPC_CREAT);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg_buffer</span> message;<br>message.msg_type = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">strcpy</span>(message.msg_text, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-built_in">msgsnd</span>(msgid, &amp;message, <span class="hljs-built_in">sizeof</span>(message), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="3-共享内存（Shared-Memory）具体代码"><a href="#3-共享内存（Shared-Memory）具体代码" class="headerlink" title="3. 共享内存（Shared Memory）具体代码"></a>3. 共享内存（Shared Memory）具体代码</h3><p>共享内存是最快的一种进程间通信方式，允许多个进程直接访问同一块内存区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><br><span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;shmfile&quot;</span>, <span class="hljs-number">65</span>);<br><span class="hljs-type">int</span> shmid = <span class="hljs-built_in">shmget</span>(key, <span class="hljs-number">1024</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br><span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">shmat</span>(shmid, (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-built_in">shmdt</span>(str);<br></code></pre></td></tr></table></figure><h3 id="4-信号量（Semaphores）具体代码"><a href="#4-信号量（Semaphores）具体代码" class="headerlink" title="4. 信号量（Semaphores）具体代码"></a>4. 信号量（Semaphores）具体代码</h3><p>信号量是一种用于进程同步的机制，用于解决进程间的资源竞争问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><br><span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;semfile&quot;</span>, <span class="hljs-number">65</span>);<br><span class="hljs-type">int</span> semid = <span class="hljs-built_in">semget</span>(key, <span class="hljs-number">1</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> sb = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// P操作</span><br><span class="hljs-built_in">semop</span>(semid, &amp;sb, <span class="hljs-number">1</span>);<br>sb.sem_op = <span class="hljs-number">1</span>; <span class="hljs-comment">// V操作</span><br><span class="hljs-built_in">semop</span>(semid, &amp;sb, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="5-套接字（Sockets）具体代码"><a href="#5-套接字（Sockets）具体代码" class="headerlink" title="5. 套接字（Sockets）具体代码"></a>5. 套接字（Sockets）具体代码</h3><p>套接字不仅可以用于网络通信，也可以用于本地进程间通信（Unix域套接字）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/un.h&gt;</span></span><br><br><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_un</span> addr;<br>addr.sun_family = AF_UNIX;<br><span class="hljs-built_in">strcpy</span>(addr.sun_path, <span class="hljs-string">&quot;/tmp/mysocket&quot;</span>);<br><span class="hljs-built_in">bind</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br><span class="hljs-built_in">listen</span>(sockfd, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><h3 id="6-信号（Signals）具体代码"><a href="#6-信号（Signals）具体代码" class="headerlink" title="6. 信号（Signals）具体代码"></a>6. 信号（Signals）具体代码</h3><p>信号是一种用于通知进程某个事件发生的机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d\n&quot;</span>, sig);<br>&#125;<br><br><span class="hljs-built_in">signal</span>(SIGINT, signal_handler);<br><span class="hljs-built_in">raise</span>(SIGINT);<br></code></pre></td></tr></table></figure><h3 id="7-内存映射文件（Memory-Mapped-Files）具体代码"><a href="#7-内存映射文件（Memory-Mapped-Files）具体代码" class="headerlink" title="7. 内存映射文件（Memory-Mapped Files）具体代码"></a>7. 内存映射文件（Memory-Mapped Files）具体代码</h3><p>内存映射文件允许进程通过映射文件到内存地址空间来共享文件的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, O_RDWR);<br><span class="hljs-type">char</span> *data = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">strcpy</span>(data, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-built_in">munmap</span>(data, <span class="hljs-number">4096</span>);<br><span class="hljs-built_in">close</span>(fd);<br></code></pre></td></tr></table></figure><p>每种进程间通信方式都有其优缺点，选择哪种方式取决于具体的应用需求。例如，共享内存虽然速度最快，但需要注意同步和并发控制；而套接字虽然速度较慢，但具有更高的灵活性和适用范围。</p><h2 id="什么是页面置换？"><a href="#什么是页面置换？" class="headerlink" title="什么是页面置换？"></a>什么是页面置换？</h2><p>凉经案例：<br>把那些不太常用的页给替换成另一个页（<strong>你空间够的话换个p啊，所以本质还是空间不够</strong></p><p><strong>问了gpt：</strong></p><p>页面置换（Page Replacement）是指操作系统在虚拟内存管理中，<strong>当内存中的页面不足以容纳所有正在运行的进程所需的页面时，需要将一些页面从内存中换出到磁盘上，以便为新的页面腾出空间</strong>。这个过程就是页面置换。</p><p>在虚拟内存管理中，每个进程通常拥有自己的<strong>虚拟地址空间</strong>，而实际的<strong>物理内存空间有限</strong>（面试官特地强调了这一点）。当进程需要访问的页面不在内存中时，操作系统会发生<strong>缺页中断（Page Fault），此时就需要进行页面置换</strong>。操作系统会根据一定的<strong>置换算法</strong>选择要置换出去的页面，以便将新的页面加载到内存中。</p><p>常见的页面置换算法包括（加粗的是没答的，不过这个无关紧要，他后来问了LRU：</p><ol><li><p><strong>最佳（Optimal）置换算法</strong>：选择在未来最长时间内不再访问的页面进行置换。这是一种理想情况下的算法，但由于无法预知未来的页面访问情况，因此很难实现。</p></li><li><p>先进先出（FIFO）置换算法：选择最早进入内存的页面进行置换。这是一种简单而直观的置换算法，但可能会导致“Belady异常”，即增加页面数目时，缺页次数反而增多。</p></li><li><p>最近最少使用（LRU）置换算法：选择最近最少被使用的页面进行置换。这是一种较为实用的置换算法，但需要维护页面访问的顺序，实现相对复杂。</p></li><li><p>时钟（Clock）置换算法：结合 FIFO 算法和 LRU 算法，使用一个时钟指针来模拟页面的访问情况。当时钟指针指向一个页面时，如果该页面未被访问，则选择该页面进行置换；否则，将该页面的访问位清零，继续检查下一个页面。</p></li><li><p><strong>最不经常使用（LFU）置换算法</strong>：选择最近使用频率最低的页面进行置换。这是一种根据页面使用频率来进行置换的算法，适用于某些特定场景。</p></li></ol><p>页面置换算法的选择取决于系统的需求和性能要求，不同的置换算法有不同的优缺点，需要根据具体情况进行权衡和选择。</p><h2 id="FIFO的缺点"><a href="#FIFO的缺点" class="headerlink" title="FIFO的缺点"></a>FIFO的缺点</h2><p>凉经案例：<br>用很通俗的语言只讲了一点（页面串扰</p><p><strong>问了gpt：</strong></p><ol><li><p><strong>Belady异常</strong>：FIFO 算法可能会出现 Belady 异常，即增加页面数目时，缺页次数反而增多。这是因为 FIFO 算法只考虑了页面进入内存的顺序，而没有考虑页面的使用频率。当内存中的页面数目增多时，先进入内存的页面可能会被频繁置换出去，导致缺页次数增加。</p></li><li><p><strong>局部性原理不符</strong>：FIFO 算法不符合局部性原理，即程序访问内存时存在时间和空间局部性的倾向。由于 FIFO 算法只考虑了页面进入内存的顺序，而没有考虑页面的使用情况，因此可能会导致页面置换不够有效，无法利用程序的局部性原理。</p></li><li><p><strong>未利用页面的使用情况</strong>：FIFO 算法没有考虑页面的使用情况，即便某些页面可能长时间未被访问，也会被保留在内存中。这样会导致内存资源没有得到充分利用，降低了内存的利用率。</p></li><li><p><strong>容易受到页面串扰影响</strong>：FIFO 算法容易受到页面串扰的影响，即当一些页面由于访问频繁而常驻内存时，可能会导致其他页面被频繁置换出去，影响系统的整体性能。</p></li></ol><p>综上所述，FIFO 算法虽然简单直观，但在实际应用中可能会存在一些缺点，特别是在面对局部性原理、程序访问模式的变化时，可能会导致性能下降或者系统资源的浪费。因此，在选择页面置换算法时，需要根据具体情况权衡各种因素，选择适合系统需求的算法。</p><h2 id="如何实现一个基于lru算法的页面置换算法？"><a href="#如何实现一个基于lru算法的页面置换算法？" class="headerlink" title="如何实现一个基于lru算法的页面置换算法？"></a>如何实现一个基于lru算法的页面置换算法？</h2><p>实现一个基于LRU（Least Recently Used）算法的页面置换算法可以通过维护一个缓存结构来跟踪最近使用的页面。当缓存满了，需要替换一个页面时，选择最久未使用的页面进行替换。常见的实现思路包括使用双向链表和哈希表的组合，以达到高效的插入、删除和访问操作。</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol><li><p><strong>数据结构选择</strong>：</p><ul><li><strong>双向链表</strong>：用于维护页面的访问顺序，最近使用的页面在链表头部，最久未使用的页面在链表尾部。</li><li><strong>哈希表</strong>：用于实现页面在双向链表中的快速定位，从而在O(1)时间内进行查找、插入和删除操作。</li></ul></li><li><p><strong>基本操作</strong>：</p><ul><li><strong>访问页面</strong>：<ul><li>如果页面在缓存中（命中），则将该页面移到链表头部。</li><li>如果页面不在缓存中（未命中），则将页面添加到链表头部。如果缓存已满，需要移除链表尾部的页面。</li></ul></li><li><strong>插入页面</strong>：<ul><li>将新页面插入到链表头部，同时在哈希表中添加对应的键值对。</li></ul></li><li><strong>删除页面</strong>：<ul><li>从链表尾部删除页面，并在哈希表中移除对应的键值对。</li></ul></li></ul></li></ol><h2 id="HTTP常用方法"><a href="#HTTP常用方法" class="headerlink" title="HTTP常用方法"></a>HTTP常用方法</h2><p>HTTP（超文本传输协议）定义了一组请求方法来指示特定的操作以执行资源。这些方法在HTTP&#x2F;1.1规范中有详细的定义。以下是常用的HTTP方法：</p><ol><li><p><strong>GET</strong>：</p><ul><li><strong>用途</strong>：从服务器获取资源。</li><li><strong>幂等性</strong>：幂等（多次请求的结果相同）。</li><li><strong>副作用</strong>：无副作用（安全）。</li><li><strong>示例</strong>：获取网页内容或API数据。</li><li><strong>请求示例</strong>：<code>GET /index.html HTTP/1.1</code></li></ul></li><li><p><strong>POST</strong>：</p><ul><li><strong>用途</strong>：向服务器提交数据，通常用于表单提交或文件上传。</li><li><strong>幂等性</strong>：非幂等（多次请求可能产生不同结果）。</li><li><strong>副作用</strong>：有副作用（不安全）。</li><li><strong>示例</strong>：提交表单数据或创建新资源。</li><li><strong>请求示例</strong>：<code>POST /submit-form HTTP/1.1</code></li></ul></li><li><p><strong>PUT</strong>：</p><ul><li><strong>用途</strong>：向服务器上传资源或更新资源。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：有副作用。</li><li><strong>示例</strong>：上传文件或更新数据库中的记录。</li><li><strong>请求示例</strong>：<code>PUT /user/123 HTTP/1.1</code></li></ul></li><li><p><strong>DELETE</strong>：</p><ul><li><strong>用途</strong>：从服务器删除资源。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：有副作用。</li><li><strong>示例</strong>：删除数据库中的记录或文件。</li><li><strong>请求示例</strong>：<code>DELETE /user/123 HTTP/1.1</code></li></ul></li><li><p><strong>HEAD</strong>：</p><ul><li><strong>用途</strong>：与GET相同，但只返回响应的头部，不返回主体内容。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：无副作用。</li><li><strong>示例</strong>：检查资源是否存在或获取资源的元数据。</li><li><strong>请求示例</strong>：<code>HEAD /index.html HTTP/1.1</code></li></ul></li><li><p><strong>OPTIONS</strong>：</p><ul><li><strong>用途</strong>：获取服务器支持的通信选项和请求方法。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：无副作用。</li><li><strong>示例</strong>：查看服务器允许的HTTP方法。</li><li><strong>请求示例</strong>：<code>OPTIONS /index.html HTTP/1.1</code></li></ul></li><li><p><strong>PATCH</strong>：</p><ul><li><strong>用途</strong>：对资源进行部分修改。</li><li><strong>幂等性</strong>：非幂等。</li><li><strong>副作用</strong>：有副作用。</li><li><strong>示例</strong>：更新资源的部分属性。</li><li><strong>请求示例</strong>：<code>PATCH /user/123 HTTP/1.1</code></li></ul></li><li><p><strong>TRACE</strong>：</p><ul><li><strong>用途</strong>：回显服务器收到的请求，用于诊断。</li><li><strong>幂等性</strong>：幂等。</li><li><strong>副作用</strong>：无副作用。</li><li><strong>示例</strong>：用于调试请求路径。</li><li><strong>请求示例</strong>：<code>TRACE /index.html HTTP/1.1</code></li></ul></li></ol><h3 id="不常用的方法"><a href="#不常用的方法" class="headerlink" title="不常用的方法"></a>不常用的方法</h3><ol><li><strong>CONNECT</strong>：<ul><li><strong>用途</strong>：用于将请求连接转换为透明的TCP&#x2F;IP隧道，通常用于HTTPS。</li><li><strong>幂等性</strong>：非幂等。</li><li><strong>副作用</strong>：有副作用。</li><li><strong>示例</strong>：代理服务器设置隧道以进行SSL（HTTPS）连接。</li><li><strong>请求示例</strong>：<code>CONNECT www.example.com:443 HTTP/1.1</code></li></ul></li></ol><h3 id="幂等性和安全性"><a href="#幂等性和安全性" class="headerlink" title="幂等性和安全性"></a>幂等性和安全性</h3><ul><li><strong>幂等性</strong>：指多次执行相同的操作，结果应保持不变（GET、PUT、DELETE、HEAD、OPTIONS）。</li><li><strong>安全性</strong>：指操作不会更改服务器状态（GET、HEAD、OPTIONS、TRACE）。</li></ul><p>了解这些HTTP方法及其特性有助于更好地设计和实现基于HTTP的客户端和服务器应用程序。</p><h2 id="MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？"><a href="#MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？" class="headerlink" title="MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？"></a>MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？</h2><h3 id="1-存储引擎选择"><a href="#1-存储引擎选择" class="headerlink" title="1. 存储引擎选择"></a>1. 存储引擎选择</h3><p>MySQL提供了多种存储引擎，其中InnoDB是最常用的高并发支持引擎。InnoDB支持行级锁定和外键约束，具有较好的并发处理能力和崩溃恢复功能。</p><ul><li><strong>InnoDB:</strong> 适用于大多数高并发场景，支持事务、行级锁、外键等特性。</li><li><strong>MyISAM:</strong> 虽然查询性能较高，但不支持事务和行级锁，通常不推荐用于高并发写操作的场景。（读法：My Eye sam）</li></ul><h3 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2. 索引优化"></a>2. 索引优化</h3><p>合理使用索引可以显著提高查询速度。常见的索引类型有：</p><ul><li><strong>B树索引:</strong> 适用于大多数查询。</li><li><strong>全文索引:</strong> 适用于文本搜索。</li><li><strong>哈希索引:</strong> 适用于精确匹配查询。</li></ul><h3 id="3-查询优化"><a href="#3-查询优化" class="headerlink" title="3. 查询优化"></a>3. 查询优化</h3><p>优化SQL查询是提高并发性能的关键。包括：</p><ul><li>避免使用SELECT *，尽量只查询必要的字段。</li><li>使用EXPLAIN分析查询计划，优化慢查询。</li><li>使用合适的WHERE条件，减少扫描行数。</li></ul><h3 id="4-数据库设计"><a href="#4-数据库设计" class="headerlink" title="4. 数据库设计"></a>4. 数据库设计</h3><p>良好的数据库设计对高并发支持至关重要。</p><ul><li><strong>规范化:</strong> 减少数据冗余，避免更新异常。</li><li><strong>反规范化:</strong> 在读操作频繁的场景下适当反规范化，减少联表查询。</li></ul><h3 id="5-连接池和缓存"><a href="#5-连接池和缓存" class="headerlink" title="5. 连接池和缓存"></a>5. 连接池和缓存</h3><ul><li><strong>连接池:</strong> 复用数据库连接，减少连接建立的开销。</li><li><strong>缓存:</strong> 使用Redis或Memcached缓存热点数据，减轻数据库压力。</li></ul><h3 id="6-配置优化"><a href="#6-配置优化" class="headerlink" title="6. 配置优化"></a>6. 配置优化</h3><p>MySQL配置参数的优化可以显著提高性能。</p><ul><li><strong>innodb_buffer_pool_size:</strong> 设置为物理内存的60-80%，以增加缓存命中率。</li><li><strong>query_cache_size:</strong> 控制查询缓存大小（需要权衡开销和收益）。</li><li><strong>max_connections:</strong> 设置合适的最大连接数，避免过多连接导致资源耗尽。</li></ul><h3 id="7-水平扩展"><a href="#7-水平扩展" class="headerlink" title="7. 水平扩展"></a>7. 水平扩展</h3><p>当单一MySQL实例无法满足高并发需求时，可以考虑通过水平扩展来分担负载。</p><ul><li><strong>主从复制:</strong> 配置多个从库，分担读取压力。</li><li><strong>分片:</strong> 将数据拆分到多个数据库实例上。</li></ul><h2 id="什么是脏读？什么是幻读？"><a href="#什么是脏读？什么是幻读？" class="headerlink" title="什么是脏读？什么是幻读？"></a>什么是脏读？什么是幻读？</h2><p>在数据库系统中，脏读和幻读是两种不同的并发事务问题，通常会在不同的隔离级别下发生。</p><h3 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h3><p>脏读是指一个事务能够读到另一个事务尚未提交的修改。这种情况可能会导致数据不一致，因为读到的数据可能会在后续被回滚。脏读发生在最低的隔离级别，即<strong>读未提交（Read Uncommitted）</strong>。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol><li>事务A开始，并更新了一条记录的值，但尚未提交。</li><li>事务B读取了这条记录，得到事务A更新后的值。</li><li>如果事务A回滚，那么事务B读取的数据就是无效的。</li></ol><h3 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h3><p>幻读是指在一个事务中，两次读取同一个条件的数据集时，由于另一个事务插入了新的数据，导致两次读取的数据集不一致。这通常发生在隔离级别较低的情况下，例如<strong>可重复读（Repeatable Read）</strong>和<strong>读已提交（Read Committed）</strong>。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol><li>事务A开始，并读取满足某个条件的一组数据。</li><li>事务B插入了一条满足相同条件的新记录，<strong>并提交</strong>。</li><li>事务A再次读取相同条件的数据集时，会发现多了一条记录。</li></ol><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>为了避免这些并发问题，SQL标准定义了四种隔离级别，每种隔离级别能避免不同类型的并发问题：</p><ol><li><strong>读未提交（Read Uncommitted）</strong>：<ul><li>可能出现脏读、不可重复读和幻读。</li></ul></li><li><strong>读已提交（Read Committed）</strong>：<ul><li>避免脏读，但可能出现不可重复读和幻读。</li></ul></li><li><strong>可重复读（Repeatable Read）</strong>：<ul><li>避免脏读和不可重复读，但可能出现幻读。</li></ul></li><li><strong>可串行化（Serializable）</strong>：<ul><li>避免脏读、不可重复读和幻读，是最严格的隔离级别。</li></ul></li></ol><p>通过选择适当的隔离级别，可以在性能和数据一致性之间取得平衡。通常情况下，<strong>读已提交</strong>和<strong>可重复读</strong>是实际应用中最常用的隔离级别。</p><h2 id="数据库范式？"><a href="#数据库范式？" class="headerlink" title="数据库范式？"></a>数据库范式？</h2><p>数据库范式（Normalization）是用于数据库设计的一组规则和标准，旨在减少数据冗余和提高数据完整性。以下是常见的几种范式：</p><h3 id="1-第一范式（1NF）"><a href="#1-第一范式（1NF）" class="headerlink" title="1. 第一范式（1NF）"></a>1. 第一范式（1NF）</h3><p>第一范式的目标是确保每个列的值都是原子的，即不可再分。要达到1NF，数据库表中的每个字段都应该包含单一的值，不允许有重复的组或多值字段。</p><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>每个列都应包含原子值。</li><li>每个列都只包含一种类型的数据。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>如果有一个表如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">学生    课程<br>张三    数学, 英语<br>李四    物理<br></code></pre></td></tr></table></figure><p>为满足1NF，应改成：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">学生    课程<br>张三    数学<br>张三    英语<br>李四    物理<br></code></pre></td></tr></table></figure><h3 id="2-第二范式（2NF）"><a href="#2-第二范式（2NF）" class="headerlink" title="2. 第二范式（2NF）"></a>2. 第二范式（2NF）</h3><p>第二范式在满足1NF的基础上，还要求消除部分依赖，即表中的非主键字段必须完全依赖于主键，而不是主键的一部分。通常在有复合主键的表中会考虑2NF。</p><h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足1NF。</li><li>所有非主键字段都必须<strong>完全依赖</strong>于主键，而<strong>不能依赖于主键的一部分</strong>。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>考虑一个有复合主键的表：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">学生ID    课程ID    成绩    课程名称<br>1        <span class="hljs-number"> 101 </span>     <span class="hljs-number"> 90 </span>     数学<br>1        <span class="hljs-number"> 102 </span>     <span class="hljs-number"> 85 </span>     英语<br>2        <span class="hljs-number"> 101 </span>     <span class="hljs-number"> 88 </span>     数学<br></code></pre></td></tr></table></figure><p>在这个表中，课程名称只依赖于课程ID而不是整个主键，因此应分解成两个表：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">学生ID    课程ID    成绩<br>1        <span class="hljs-number"> 101 </span>      90<br>1        <span class="hljs-number"> 102 </span>      85<br>2        <span class="hljs-number"> 101 </span>      88<br><br>课程ID    课程名称<br>101       数学<br>102       英语<br></code></pre></td></tr></table></figure><h3 id="3-第三范式（3NF）"><a href="#3-第三范式（3NF）" class="headerlink" title="3. 第三范式（3NF）"></a>3. 第三范式（3NF）</h3><p>第三范式在满足2NF的基础上，要求消除传递依赖，即非主键字段之间不能有依赖关系。</p><h4 id="规则-2"><a href="#规则-2" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足2NF。</li><li>所有<strong>非主键字段都必须直接依赖于主键，而不能通过其他非主键字段间接依赖</strong>。</li></ul><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>考虑以下表：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">学生ID    学生姓名    学院ID    学院名称<br>1         张三       <span class="hljs-number"> 10 </span>       计算机学院<br>2         李四       <span class="hljs-number"> 20 </span>       数学学院<br></code></pre></td></tr></table></figure><p>在这个表中，学院名称依赖于学院ID，而学院ID依赖于学生ID，因此应分解成两个表：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">学生ID    学生姓名    学院ID<br>1         张三        10<br>2         李四        20<br><br>学院ID    学院名称<br>10        计算机学院<br>20        数学学院<br></code></pre></td></tr></table></figure><h3 id="4-BC范式（BCNF）"><a href="#4-BC范式（BCNF）" class="headerlink" title="4. BC范式（BCNF）"></a>4. BC范式（BCNF）</h3><p>Boyce-Codd范式是3NF的一个更严格版本，它要求每个非平凡函数依赖的左侧都必须是<strong>超键</strong>（即唯一标识表中记录的属性集）。</p><h4 id="规则-3"><a href="#规则-3" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足3NF。</li><li>对于每一个非平凡函数依赖X → Y，X必须是超键。</li></ul><h3 id="5-第四范式（4NF）"><a href="#5-第四范式（4NF）" class="headerlink" title="5. 第四范式（4NF）"></a>5. 第四范式（4NF）</h3><p>第四范式要求<strong>消除多值依赖</strong>，即一个表中不能存在多对多关系的属性组。</p><h4 id="规则-4"><a href="#规则-4" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足BCNF。</li><li>没有非平凡的多值依赖。</li></ul><h3 id="6-第五范式（5NF）"><a href="#6-第五范式（5NF）" class="headerlink" title="6. 第五范式（5NF）"></a>6. 第五范式（5NF）</h3><p>第五范式要求消除连接依赖，即表应该能够自然分解，而不导致信息丢失。</p><h4 id="规则-5"><a href="#规则-5" class="headerlink" title="规则"></a>规则</h4><ul><li>表必须满足4NF。</li><li>每个非平凡的连接依赖必须由候选键隐含。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过这些范式，数据库设计者可以在减少数据冗余、消除异常和提高数据完整性之间找到平衡。在实际应用中，通常会<strong>根据需求选择适当的范式</strong>，而不一定严格地应用所有的范式。</p><h2 id="真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？"><a href="#真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？" class="headerlink" title="真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？"></a>真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？</h2><p>在实际项目中，特别是ERP系统或其他大型数据库应用中，严格遵循数据库范式的设计原则是非常重要的，能够帮助减少数据冗余、避免数据异常并保持数据一致性。然而，实际情况往往比理论复杂，在某些情况下，违反范式的设计可能是更好的选择。以下是一些违反范式的常见场景和理由：</p><h3 id="1-性能优化"><a href="#1-性能优化" class="headerlink" title="1. 性能优化"></a>1. 性能优化</h3><p>在高并发、大量数据读写的场景中，性能往往是优先考虑的因素。以下是一些常见的违反范式的情况：</p><h4 id="读优化"><a href="#读优化" class="headerlink" title="读优化"></a>读优化</h4><ul><li><strong>反规范化（Denormalization）</strong>：为了减少联表查询的次数，可以将相关数据冗余存储在一个表中。例如，在一个订单系统中，客户信息可以直接存储在订单表中，而不是每次查询订单都去联接客户表。</li></ul><h4 id="写优化"><a href="#写优化" class="headerlink" title="写优化"></a>写优化</h4><ul><li><strong>预计算和缓存（Precomputed Values and Caching）</strong>：为了加速查询，可以存储预先计算好的结果，如总金额、统计数据等，尽管这些数据可以通过计算得到，但这样可以减少实时计算的负担。</li></ul><h3 id="2-简化查询"><a href="#2-简化查询" class="headerlink" title="2. 简化查询"></a>2. 简化查询</h3><p>在某些业务场景中，简单、快速的查询比严格的范式化设计更重要。例如：</p><ul><li><strong>报表和分析系统</strong>：为了便于生成报表和进行数据分析，可能需要违反范式，将数据冗余地存储在一个表中，简化复杂的查询逻辑。</li></ul><h3 id="3-数据一致性和完整性"><a href="#3-数据一致性和完整性" class="headerlink" title="3. 数据一致性和完整性"></a>3. 数据一致性和完整性</h3><p>在有些情况下，为了保持数据的一致性和完整性，违反范式是必要的。例如：</p><ul><li><strong>历史数据存储</strong>：在审计和追踪历史数据的场景中，可能需要在一个表中存储数据快照，这样尽管增加了冗余，但可以确保数据的不可变性和一致性。</li></ul><h3 id="4-实际开发和维护"><a href="#4-实际开发和维护" class="headerlink" title="4. 实际开发和维护"></a>4. 实际开发和维护</h3><p>在实际开发过程中，开发和维护的复杂性也是一个重要的考虑因素：</p><ul><li><strong>开发便利性</strong>：有时候，简单、直观的表结构可以减少开发和维护的复杂性，即使这意味着违反某些范式。例如，团队可能决定在一个表中存储更多信息，以避免频繁的联表操作。</li></ul><h3 id="具体场景示例"><a href="#具体场景示例" class="headerlink" title="具体场景示例"></a>具体场景示例</h3><h4 id="示例1：订单系统"><a href="#示例1：订单系统" class="headerlink" title="示例1：订单系统"></a>示例1：订单系统</h4><p>在一个订单系统中，订单表通常会涉及多个关联表，如客户表、产品表、地址表等。严格的范式化设计可能如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">订单表(Order)<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>客户ID<br><span class="hljs-bullet">- </span>总金额<br><span class="hljs-bullet">- </span>创建日期<br><br>客户表(Customer)<br><span class="hljs-bullet">- </span>客户ID<br><span class="hljs-bullet">- </span>客户姓名<br><span class="hljs-bullet">- </span>联系方式<br><br>订单项表(OrderItem)<br><span class="hljs-bullet">- </span>订单项ID<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>产品ID<br><span class="hljs-bullet">- </span>数量<br><span class="hljs-bullet">- </span>单价<br></code></pre></td></tr></table></figure><p>然而，为了提高查询性能，尤其是查询订单时避免多次联表，可以采取反规范化设计：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">订单表(Order)<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>客户ID<br><span class="hljs-bullet">- </span>客户姓名<br><span class="hljs-bullet">- </span>联系方式<br><span class="hljs-bullet">- </span>总金额<br><span class="hljs-bullet">- </span>创建日期<br><br>订单项表(OrderItem)<br><span class="hljs-bullet">- </span>订单项ID<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>产品ID<br><span class="hljs-bullet">- </span>产品名称<br><span class="hljs-bullet">- </span>数量<br><span class="hljs-bullet">- </span>单价<br></code></pre></td></tr></table></figure><p>这种设计牺牲了一些规范性，但在性能和查询简便性方面有很大提升。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>虽然范式化设计是数据库设计的指导原则，但在实际项目中，特别是在性能、查询简便性、开发和维护复杂性方面，违反范式是常见的。设计数据库时，应在范式化和实际需求之间找到平衡，具体问题具体分析，根据实际情况采取适当的设计策略。</p><h2 id="什么叫回表？"><a href="#什么叫回表？" class="headerlink" title="什么叫回表？"></a>什么叫回表？</h2><p>在数据库系统中，<strong>回表（Index Lookup Back to Table）</strong> 是指数据库在使用索引查询数据时，由于<strong>索引不包含所需的所有列，必须回到数据表中去获取完整的记录</strong>。这种情况常见于关系型数据库如MySQL。</p><h3 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h3><p>当执行查询时，如果使用的索引中不包含查询所需的所有字段，数据库首先通过索引定位到符合条件的记录，然后<strong>再通过索引中的指针访问实际的数据表以获取缺失的字段</strong>。这种从索引跳回数据表获取完整数据的操作称为回表。</p><h3 id="回表的示例"><a href="#回表的示例" class="headerlink" title="回表的示例"></a>回表的示例</h3><p>假设有一张用户表 <code>users</code>，包含如下字段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">users</span> (<span class="hljs-built_in">id</span>, name, email, age)<br></code></pre></td></tr></table></figure><p>并且在 <code>email</code> 字段上建立了索引：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_email <span class="hljs-keyword">ON</span> users(email);<br></code></pre></td></tr></table></figure><p>现在执行一个查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, email <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;example@example.com&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="索引覆盖和回表"><a href="#索引覆盖和回表" class="headerlink" title="索引覆盖和回表"></a>索引覆盖和回表</h3><p>在这个查询中，数据库可以通过 <code>idx_email</code> 索引快速定位到符合条件的记录，但是：</p><ul><li>如果索引中只包含 <code>email</code> 字段，那么数据库需要通过回表操作，从实际的数据表中获取 <code>name</code> 字段的值。</li><li>如果索引包含 <code>email</code> 和 <code>name</code> 字段（称为<strong>覆盖索引</strong>），则不需要回表，因为索引已经包含了查询所需的所有字段。</li></ul><h3 id="避免回表的方法"><a href="#避免回表的方法" class="headerlink" title="避免回表的方法"></a>避免回表的方法</h3><ol><li><p><strong>使用覆盖索引（Covering Index）</strong>：</p><ul><li><strong>创建包含查询中所有字段的索引</strong>。例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_email_name <span class="hljs-keyword">ON</span> users(email, name);<br></code></pre></td></tr></table></figure>这样，在上面的查询中，数据库不需要回表即可获取所有数据。</li></ul></li><li><p><strong>减少查询字段</strong>：</p><ul><li>只查询索引中已有的字段，避免回表。</li></ul></li></ol><h3 id="回表的影响"><a href="#回表的影响" class="headerlink" title="回表的影响"></a>回表的影响</h3><ul><li><strong>性能开销</strong>：回表操作会<strong>增加I&#x2F;O开销</strong>，因为需要额外访问数据表，尤其是在查询结果集较大时。</li><li><strong>查询效率</strong>：对频繁执行的查询，回表可能显著<strong>影响性能</strong>，因此需要根据查询模式和频率优化索引设计。</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>回表是数据库优化中的一个重要概念，通过合理设计索引（如使用覆盖索引），可以减少回表操作，从而提高查询性能。在数据库设计和查询优化中，应仔细分析查询需求和数据访问模式，权衡索引的维护开销与查询性能之间的关系。</p><h2 id="索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？"><a href="#索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？" class="headerlink" title="索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？"></a>索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？</h2><p>索引是数据库管理系统中的一种数据结构，可以提高数据检索速度。索引的核心作用是减少数据库在查找数据时需要扫描的数据量，从而提高查询效率。在没有索引的情况下，数据库系统执行查询操作时可能需要执行全表扫描，即逐行检查表中的每一行数据，直到找到符合查询条件的数据。这种方法在数据量小的时候还可以接受，但随着数据量的增加，查询效率会显著下降。</p><h3 id="索引的主要类型："><a href="#索引的主要类型：" class="headerlink" title="索引的主要类型："></a>索引的主要类型：</h3><ol><li><p><strong>B树索引</strong>：最常见的索引类型，尤其适用于等值查询和范围查询。B树索引通过维护一个多层级的树形结构来存储数据，每个节点都是有序的，这样可以非常快速地通过分裂和合并来维持树的平衡。</p></li><li><p><strong>哈希索引</strong>：适用于快速查找操作，特别是等值查询。它通过哈希表实现，其中键通过哈希函数直接映射到表中一个位置。</p></li><li><p><strong>全文索引</strong>：专门为处理文本数据设计，可以快速从大量文本中找到关键词。例如，搜索引擎常用的倒排索引就是一种全文索引。</p></li><li><p><strong>空间索引</strong>：如R树，用于空间数据查询，如地图位置的检索。</p></li></ol><h3 id="索引提高查询效率的原理："><a href="#索引提高查询效率的原理：" class="headerlink" title="索引提高查询效率的原理："></a>索引提高查询效率的原理：</h3><ol><li><p><strong>减少查找范围</strong>：例如，B树索引通过树形结构，使得每次查询都能在树的每个级别上排除大量不符合条件的数据，迅速缩小查找范围。</p></li><li><p><strong>避免全表扫描</strong>：索引可以直接指向表中的具体行，无需逐行扫描整个表来查找数据。</p></li><li><p><strong>排序和快速访问</strong>：索引通常以某种顺序存储数据，使得范围查询更为高效。同时，索引结构通常设计为易于在内存中快速访问的形式。</p></li></ol><h3 id="使用索引的代价："><a href="#使用索引的代价：" class="headerlink" title="使用索引的代价："></a>使用索引的代价：</h3><p>尽管索引可以显著提高查询速度，但也有其代价和限制：</p><ul><li><strong>空间消耗</strong>：索引本身需要占用存储空间。</li><li><strong>维护成本</strong>：每次数据更新（插入、删除、修改）时，相关的索引也需要更新，这会增加操作的开销。</li><li><strong>设计和管理复杂性</strong>：合理设计和维护索引需要精确考虑数据使用模式，不当的索引可能导致性能下降而非提升。</li></ul><p>总之，索引是优化数据库查询性能的重要工具，但需要根据实际的数据量和查询需求来合理设计和使用。</p><h2 id="为什么实际用B-树用的更多？"><a href="#为什么实际用B-树用的更多？" class="headerlink" title="为什么实际用B+树用的更多？"></a>为什么实际用B+树用的更多？</h2><p>在数据库索引的实现中，实际上 B+树 更常被用作索引结构而不是 B树。虽然两者都是平衡树结构，用于提高数据的检索效率，但 B+树 相对于 B树 有几个特点使其更适合用于数据库索引：</p><h3 id="1-所有键值对都在叶节点："><a href="#1-所有键值对都在叶节点：" class="headerlink" title="1. 所有键值对都在叶节点："></a>1. <strong>所有键值对都在叶节点</strong>：</h3><p>B+树的所有键值对都存储在叶节点，而非叶节点仅存储键值的副本以用于导航。这种结构使得叶节点形成了一个有序链表，适合进行范围查询。范围查询是数据库常见的操作，比如查询所有在某个日期范围内的记录。在 B树 中，数据分散在整个树中，不容易直接支持高效的范围查询。</p><h3 id="2-非叶节点仅用于索引："><a href="#2-非叶节点仅用于索引：" class="headerlink" title="2. 非叶节点仅用于索引："></a>2. <strong>非叶节点仅用于索引</strong>：</h3><p>在 B+树 中，非叶节点的作用仅是索引，不存储实际数据。这意味着非叶节点更小，树可以更高效地加载更多的索引键到内存中，从而降低树的高度，提高查询速度。</p><h3 id="3-叶节点的链表结构："><a href="#3-叶节点的链表结构：" class="headerlink" title="3. 叶节点的链表结构："></a>3. <strong>叶节点的链表结构</strong>：</h3><p>B+树的叶节点之间是相连的，这样可以快速进行顺序访问。对于数据库系统中常见的顺序扫描操作，这种结构显著提高了效率。</p><h3 id="4-更少的指针跳转："><a href="#4-更少的指针跳转：" class="headerlink" title="4. 更少的指针跳转："></a>4. <strong>更少的指针跳转</strong>：</h3><p>由于非叶节点不含实际数据，对数据的访问总是会到达叶节点，这种一致的访问模式意味着缓存更为有效，减少了指针跳转和磁盘I&#x2F;O操作。</p><h3 id="5-磁盘I-x2F-O优化："><a href="#5-磁盘I-x2F-O优化：" class="headerlink" title="5. 磁盘I&#x2F;O优化："></a>5. <strong>磁盘I&#x2F;O优化</strong>：</h3><p>数据库系统通常与磁盘操作密切相关，而 B+树 结构可以减少磁盘读写次数。B+树的设计使得它可以很好地适应磁盘的页结构，每个节点大小通常与磁盘页大小相匹配，这减少了节点分裂时的磁盘I&#x2F;O需求。</p><p>因此，虽然“B树索引”这个术语在通话中可能被泛泛地使用，实际上在现代数据库系统中，B+树索引因其对于磁盘存储和数据检索操作优化更胜一筹，从而被广泛采用。</p><h2 id="什么是哈希冲突？如何解决？"><a href="#什么是哈希冲突？如何解决？" class="headerlink" title="什么是哈希冲突？如何解决？"></a>什么是哈希冲突？如何解决？</h2><p>哈希冲突是在使用哈希表或哈希映射时发生的一种情况，其中两个或更多的输入值（键）被哈希函数映射到同一个哈希值（即同一个桶或位置）上。哈希表是一种数据结构，它提供了非常快速的数据查找速度。哈希函数的作用是将输入值（通常是一个字符串或其他数据）转换成一个整数，这个整数然后用来计算在哈希表中的存储位置。</p><h3 id="哈希冲突的产生原因"><a href="#哈希冲突的产生原因" class="headerlink" title="哈希冲突的产生原因"></a>哈希冲突的产生原因</h3><p>哈希冲突的产生通常是由于以下几个原因：</p><ol><li><strong>哈希函数设计</strong>：如果哈希函数<strong>没有很好地分散</strong>各种不同的输入值到不同的哈希码，就更容易发生冲突。</li><li><strong>哈希表的大小</strong>：哈希表的<strong>大小是有限</strong>的，而且可能小于可能的输入值的数量，所以即使是理想的哈希函数也无法避免冲突。</li><li><strong>输入数据的分布</strong>：如果输入<strong>数据本身</strong>具有一定的模式或规律，可能导致哈希函数产生<strong>非均匀的哈希值分布</strong>。</li></ol><h3 id="解决哈希冲突的常见方法"><a href="#解决哈希冲突的常见方法" class="headerlink" title="解决哈希冲突的常见方法"></a>解决哈希冲突的常见方法</h3><p>解决哈希冲突主要有几种常用的策略：</p><ol><li><strong>开放寻址法</strong>：当发生冲突时，尝试在哈希表中找到另一个空闲的桶来存储当前的元素。这种方法可能会采用线性探测、二次探测或双重散列等策略。</li><li><strong>链表法</strong>（拉链法）：每个哈希表的桶或位置实际上存储的是一个链表的头节点。所有映射到该位置的元素都会被加入到这个链表中。因此，查找、插入和删除操作需要遍历链表。</li><li><strong>再哈希法</strong>：设计多个哈希函数，当第一个哈希函数导致冲突时，尝试第二个哈希函数，以此类推。</li></ol><h3 id="哈希冲突的影响"><a href="#哈希冲突的影响" class="headerlink" title="哈希冲突的影响"></a>哈希冲突的影响</h3><p>虽然哈希表在最佳情况下可以提供接近 O(1) 的平均时间复杂度，但是哈希冲突会增加这些操作的时间复杂度。尤其是当使用链表法处理冲突时，如果冲突非常频繁，链表可能变得非常长，这会导致接近于线性搜索的性能，即平均时间复杂度接近 O(n)。</p><p>因此，选择合适的哈希函数和冲突解决机制对于哈希表的性能至关重要。理想的哈希函数应该易于计算，且能将输入均匀分布到所有的哈希值上，最小化冲突的可能性。</p><h2 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h2><p>线性探测是解决哈希表冲突的一种开放寻址策略。它的基本思想很简单：当插入一个元素时，如果计算出的哈希表位置已经被占用（即发生冲突），则探测下一个位置，直到找到一个空的位置来放置这个新元素。这个“下一个位置”是指当前位置的直接后续位置。</p><h3 id="线性探测的工作原理"><a href="#线性探测的工作原理" class="headerlink" title="线性探测的工作原理"></a>线性探测的工作原理</h3><ol><li><p><strong>插入操作</strong>：</p><ul><li>使用哈希函数计算数据项的哈希值，得到其应当存储的位置。</li><li>如果该位置已被占用，则检查下一个连续的位置（即当前位置加1，考虑数组边界可能需要取模操作）。</li><li>重复这个过程直到找到一个空闲位置。</li></ul></li><li><p><strong>查找操作</strong>：</p><ul><li>使用同样的哈希函数计算数据项的哈希值，得到其应当存储的初始位置。</li><li>如果该位置上的元素不匹配，则继续检查下一个位置，直到找到匹配的元素或遇到一个空位置（空位置意味着元素不存在）。</li></ul></li><li><p><strong>删除操作</strong>：</p><ul><li>直接从哈希表中删除元素可能会中断探测序列，使得之后的元素无法被正确找到。因此，一种常见的做法是使用一个特殊标记来表示“已删除”的状态，而不是真的从哈希表中去除元素。</li><li>查找和插入操作需要对这种“已删除”标记进行处理，确保它们的正确运行。</li></ul></li></ol><h3 id="线性探测的优点与缺点"><a href="#线性探测的优点与缺点" class="headerlink" title="线性探测的优点与缺点"></a>线性探测的优点与缺点</h3><p><strong>优点</strong>：</p><ul><li>实现简单。</li><li>不需要额外的数据结构（如链表）来存储冲突的元素，节省空间。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>聚集问题</strong>：线性探测的一个主要缺点是它倾向于在哈希表中形成聚集区域，即连续占用的序列，这会影响性能。当哈希表填充率高时，聚集现象尤其严重。</li><li><strong>性能下降</strong>：随着填充率的增加，插入和搜索的平均时间成本增加，因为需要探测更多的位置才能找到空闲位置或目标元素。</li></ul><h3 id="应用建议"><a href="#应用建议" class="headerlink" title="应用建议"></a>应用建议</h3><p>线性探测比较适合于元素数量相对固定，且哈希表负载因子较低的应用场景。在设计哈希表时，应该合理设置哈希表的大小和负载因子，以及及时调整哈希表大小（通过再哈希等手段）来优化性能。对于高冲突环境，可能需要考虑其他冲突解决策略，如二次探测或双重哈希，来减少聚集问题的影响。</p><h2 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h2><p>二次探测是开放寻址法处理哈希表中冲突的一种方法，它是线性探测的一个变体。线性探测在发现冲突时会简单地检查下一个连续的槽位。与之不同，二次探测则会在原始位置的基础上增加一个增长的平方项来找到新的槽位，这可以在一定程度上减少聚集问题。</p><h3 id="二次探测的工作原理"><a href="#二次探测的工作原理" class="headerlink" title="二次探测的工作原理"></a>二次探测的工作原理</h3><p>二次探测的基本思想是在原始哈希位置基础上探测新位置时，步长是探测次数的平方。具体过程如下：</p><ol><li><p><strong>插入操作</strong>：</p><ul><li>使用哈希函数计算数据项的原始哈希值 <code>h(x)</code>。</li><li>如果该位置已经被占用，则探测新位置 <code>h(x) + 1^2, h(x) + 2^2, h(x) + 3^2, ...</code> 直到找到一个空闲位置。</li><li>步长（即平方项）会随着每次冲突递增，因此探测的位置迅速分散，有助于减少聚集。</li></ul></li><li><p><strong>查找操作</strong>：</p><ul><li>查找开始于数据项的原始哈希值 <code>h(x)</code>。</li><li>如果该位置的元素不匹配，则按 <code>1^2, 2^2, 3^2, ...</code> 的步长继续查找，直到找到目标元素或遇到一个空槽位（空槽位意味着元素不存在）。</li></ul></li><li><p><strong>删除操作</strong>：</p><ul><li>和线性探测一样，删除操作通常不会直接从表中移除元素，而是将其标记为“已删除”，以保持探测连续性，避免断开查找链。</li></ul></li></ol><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>减少聚集</strong>：二次探测相比线性探测，能更好地减少主聚集（primary clustering）现象，因为它探测的位置不再是连续的，而是跳跃式增加。</li><li><strong>实现简单</strong>：二次探测相对于其他一些复杂的冲突解决策略（如双重哈希）来说，实现起来依然简单。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>次级聚集</strong>：虽然解决了主聚集问题，二次探测依然存在次级聚集（secondary clustering）。不同的键可能以相同的序列探测空槽位，特别是当表中有多个数据项冲突时。</li><li><strong>表的利用率</strong>：当哈希表填充度较高时，二次探测可能找不到空槽位，即使表中实际上还有空闲位置。</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>二次探测提供了一种相对于线性探测更高效的冲突解决方法，尤其在减少聚集方面表现更好。然而，随着表的填充度增加，其性能可能受到影响，因此需要合理设定哈希表的大小和负载因子，或者考虑通过再哈希等方式调整哈希表大小。在选择哈希冲突解决策略时，需要根据具体应用的需求和特点来决定使用哪种方法。</p><h2 id="双重哈希"><a href="#双重哈希" class="headerlink" title="双重哈希"></a>双重哈希</h2><p>双重哈希是处理哈希表中冲突的另一种开放寻址技术。它使用两个独立的哈希函数来计算数据项的存储位置，当第一个哈希函数计算的位置已经被占用时，它将使用第二个哈希函数来帮助找到一个空闲位置。这种方法旨在减少聚集问题，提高哈希表的性能。</p><h3 id="双重哈希的工作原理"><a href="#双重哈希的工作原理" class="headerlink" title="双重哈希的工作原理"></a>双重哈希的工作原理</h3><p>双重哈希的基本过程包括：</p><ol><li><p><strong>初始化</strong>：</p><ul><li>定义两个哈希函数：<code>h1(x)</code> 和 <code>h2(x)</code>。这两个函数对于表中的每个元素都应该返回一个哈希值。</li></ul></li><li><p><strong>插入操作</strong>：</p><ul><li>使用第一个哈希函数 <code>h1(x)</code> 计算元素 x 的初始位置。</li><li>如果该位置已被占用，则计算一个新位置：<code>(h1(x) + i * h2(x)) % table_size</code>，其中 i 是探测的次数，从 1 开始。</li><li>继续探测，增加 i 的值，直到找到一个空闲位置。</li></ul></li><li><p><strong>查找操作</strong>：</p><ul><li>查找开始于使用 <code>h1(x)</code> 计算的位置。</li><li>如果该位置上的元素不是目标元素，则使用 <code>(h1(x) + i * h2(x)) % table_size</code> 进行下一次探测，直到找到元素或遇到空位置。</li></ul></li><li><p><strong>删除操作</strong>：</p><ul><li>类似于其他开放寻址技术，删除操作通常不是直接从表中移除元素，而是将其标记为已删除，这样不会破坏查找过程中的探测链。</li></ul></li></ol><h3 id="设计哈希函数"><a href="#设计哈希函数" class="headerlink" title="设计哈希函数"></a>设计哈希函数</h3><p>为了使双重哈希有效，第二个哈希函数 <code>h2(x)</code> 的设计至关重要。理想的 <code>h2(x)</code> 应满足以下条件：</p><ul><li><code>h2(x)</code> 应始终返回一个非零的正整数，因为如果 <code>h2(x)</code> 返回零，探测序列将不会改变，无法找到新的空位。</li><li><code>h2(x)</code> 应尽量保证返回的值能均匀分布在哈希表的整个空间中。</li></ul><h3 id="优点与缺点-1"><a href="#优点与缺点-1" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>减少聚集</strong>：与线性探测和二次探测相比，双重哈希能更有效地减少聚集问题，因为它通过两个独立的函数来探测空闲位置。</li><li><strong>灵活性和可靠性</strong>：通过适当选择两个哈希函数，双重哈希方法可以适应各种数据分布，提高哈希表的整体性能。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>计算复杂性</strong>：使用两个哈希函数可能会增加计算的复杂性，尤其是在插入和查找操作中。</li><li><strong>设计挑战</strong>：设计两个好的哈希函数需要一定的技术知识和经验，以确保它们独立并均匀地分散冲突。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>双重哈希是一个强大的技术，适用于那些对查找性能要求较高的应用场景。正确实施时，它可以提供较高的效率和良好的加载因子性能，但需要确保哈希函数的选择和实现得当。</p><h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><p>链表法，也称为拉链法，是解决哈希表冲突的一种常用方法。与开放寻址法不同，其中尝试找到空闲位置来存储每个冲突的元素，链表法在哈希表的每个槽位（或桶）中存储一个指向链表的指针。当多个元素的哈希值指向同一个槽位时，这些元素会被组织在同一链表中。</p><h3 id="链表法的工作原理"><a href="#链表法的工作原理" class="headerlink" title="链表法的工作原理"></a>链表法的工作原理</h3><p>链表法的基本步骤包括：</p><ol><li><p><strong>初始化</strong>：</p><ul><li>哈希表由一系列槽位组成，每个槽位初始时可能是空的或指向一个链表的头节点。</li></ul></li><li><p><strong>插入操作</strong>：</p><ul><li>对元素 x 应用哈希函数 <code>h(x)</code>，计算出该元素应存储在哈希表的哪个槽位。</li><li>如果该槽位为空，则在该位置创建一个新的链表，并将 x 作为链表的第一个元素。</li><li>如果该槽位已经链接到一个链表，则将 x 添加到链表的末尾（或头部，具体实现可能有所不同）。</li></ul></li><li><p><strong>查找操作</strong>：</p><ul><li>使用相同的哈希函数 <code>h(x)</code> 定位元素 x 应在的槽位。</li><li>遍历该槽位的链表，逐个检查链表中的元素，直到找到 x 或链表结束。</li></ul></li><li><p><strong>删除操作</strong>：</p><ul><li>定位元素 x 应在的槽位。</li><li>遍历该槽位的链表，找到 x 并从链表中移除。</li></ul></li></ol><h3 id="优点与缺点-2"><a href="#优点与缺点-2" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点</strong>：</p><ul><li><strong>处理冲突灵活</strong>：链表法可以容纳数量不定的冲突元素，只要链表可以继续扩展。</li><li><strong>性能稳定</strong>：只要哈希函数选得好，保证分布均匀，每个槽位的链表长度通常不会很长，从而保持操作的效率。</li><li><strong>动态扩展</strong>：相比于开放寻址法，链表法可以更容易地处理大量数据，因为链表本身没有固定的大小限制。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>空间利用率低</strong>：每个元素需要额外的空间来存储指针，尤其是在存储小型数据项时，这种额外成本较为显著。</li><li><strong>缓存不友好</strong>：链表节点可能在内存中不连续存储，从而导致较差的缓存性能，影响整体速度。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>链表法非常适合于那些冲突可能较多的环境，例如，在一个大型哈希表中存储大量数据时。此外，由于其处理冲突的灵活性，它在实际应用中非常受欢迎，例如在编程语言中的散列表实现或在数据库的索引中。</p><h2 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h2><p>设计模式是在软件设计中经常出现的问题的解决方案的模板。它们提供了一种通用的方法来解决常见的设计问题，并鼓励面向对象编程中的可重用性、可维护性和灵活性。以下是一些常见的设计模式：</p><ol><li><p><strong>单例模式（Singleton Pattern）</strong>：</p><ul><li>保证一个类只有一个实例，并提供全局访问点。</li></ul></li><li><p><strong>工厂模式（Factory Pattern）</strong>：</p><ul><li>定义一个用于创建对象的接口，但是由子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</li></ul></li><li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：</p><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li></ul></li><li><p><strong>建造者模式（Builder Pattern）</strong>：</p><ul><li>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li></ul></li><li><p><strong>原型模式（Prototype Pattern）</strong>：</p><ul><li>通过复制现有对象来创建新对象，而不是使用构造函数。</li></ul></li><li><p><strong>适配器模式（Adapter Pattern）</strong>：</p><ul><li>将一个类的接口转换成客户端所期待的另一个接口。适配器让原本接口不兼容的类可以合作无间。</li></ul></li><li><p><strong>装饰器模式（Decorator Pattern）</strong>：</p><ul><li>动态地将责任附加到对象上。装饰器提供了一种灵活地扩展功能的方式。</li></ul></li><li><p><strong>代理模式（Proxy Pattern）</strong>：</p><ul><li>为其他对象提供一种代理以控制对这个对象的访问。</li></ul></li><li><p><strong>观察者模式（Observer Pattern）</strong>：</p><ul><li>定义对象之间的一对多依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。</li></ul></li><li><p><strong>策略模式（Strategy Pattern）</strong>：</p><ul><li>定义一系列算法，将每个算法封装起来，并使它们可以互相替换。</li></ul></li><li><p><strong>模板方法模式（Template Method Pattern）</strong>：</p><ul><li>定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法的某些步骤。</li></ul></li><li><p><strong>状态模式（State Pattern）</strong>：</p><ul><li>允许对象在内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</li></ul></li><li><p><strong>读者-写者模式（Reader-Writer Pattern）</strong>：</p><ul><li>解决多个读操作和写操作同时对共享资源进行访问的问题。它允许多个读操作同时进行，但写操作必须互斥执行。</li></ul></li><li><p><strong>订阅者模式（Subscriber Pattern）</strong>：</p><ul><li>也称为发布-订阅模式，定义了一种一对多的关系，当一个对象的状态发生变化时，所有依赖于它的对象都会收到通知并自动更新。</li></ul></li><li><p><strong>工厂模式（Factory Pattern）</strong>：</p><ul><li>提供一个创建对象的接口，但是允许子类决定实例化哪个类。它将对象的实例化过程延迟到子类中进行，从而提高了代码的灵活性和可维护性。</li></ul></li><li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：</p><ul><li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。它可以看作是多个工厂方法的集合，用于创建一组相关的对象。</li></ul></li><li><p><strong>建造者模式（Builder Pattern）</strong>：</p><ul><li>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。它通过一个指导者来组装具体的构建者，从而实现了构建过程的灵活性。</li></ul></li><li><p><strong>原型模式（Prototype Pattern）</strong>：</p><ul><li>通过复制现有对象来创建新对象，而不是使用构造函数。它通常适用于创建成本较高的对象，或者当创建过程涉及复杂的初始化逻辑时。</li></ul></li></ol><p>这些设计模式都是为了解决软件开发中常见的设计问题而提出的，并且在实际项目中都有着广泛的应用。通过理解和运用这些设计模式，开发人员可以更加高效地设计、编写和维护高质量的软件系统。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hyx的面试之路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>停水时间到</title>
    <link href="/2024/05/12/%E5%81%9C%E6%B0%B4%E6%97%B6%E9%97%B4%E5%88%B0/"/>
    <url>/2024/05/12/%E5%81%9C%E6%B0%B4%E6%97%B6%E9%97%B4%E5%88%B0/</url>
    
    <content type="html"><![CDATA[<p>一天中最喜欢的就是洗澡的时间<br>和等待洗澡的时间<br>我躲在帘子后面轻声哼唱<br>（空荡的易碎品）<br>脑袋空空循环播放着旋律<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>要多少才叫足够<br>怎样才能真正满意<br>我追逐着一些很重要的东西<br>也有一些没有那么重要的东西<br>“菜就多练”  他们是这么讲的<br>明明那些都属于我<br>我讨厌夺走 夺走<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>我追逐着他们的背影<br>他们告诉我该这样做该那样做<br>什么时候才可以不用撒谎呢<br>什么时候才可以分享快乐呢<br>什么时候才能不孤独呢<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>嘟噜噜噜冲刷 冲刷 冲刷<br>什么时候才可以不用追赶呢<br>什么时候才可以停下来呢<br>无比渴望存在证明<br>我的耳朵停止了吼叫<br>也许这样已经足够了吧<br>（呀 停水时间到）</p>]]></content>
    
    
    
    <tags>
      
      <tag>写点歌词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载知乎-kafka面试题</title>
    <link href="/2024/05/10/%E8%BD%AC%E8%BD%BD%E7%9F%A5%E4%B9%8E-kafka%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/05/10/%E8%BD%AC%E8%BD%BD%E7%9F%A5%E4%B9%8E-kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-为什么要使用-kafka，为什么要使用消息队列？"><a href="#1-为什么要使用-kafka，为什么要使用消息队列？" class="headerlink" title="1. 为什么要使用 kafka，为什么要使用消息队列？"></a>1. 为什么要使用 kafka，为什么要使用消息队列？</h3><p>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。<br>解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。<br>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。<br>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。<br>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h3 id="2-Kafka的常用组件有哪些？"><a href="#2-Kafka的常用组件有哪些？" class="headerlink" title="2. Kafka的常用组件有哪些？"></a>2. Kafka的常用组件有哪些？</h3><p>producer：消息的生产者, 自己决定哪个 partions 中生产消息, 两种机制:hash 与 轮询。<br>consumer：通过 zookeeper 进行维护消费者偏移量, consumer有自己的消费组,不同组之间维护同一个 topic 数据,互不影响.相同组的不同 consumer消费同一个 topic,这个 topic相同的数据只被消费一次。<br>broker：broker 组成 kafka 集群的节点,之间没有主从关系, 依赖 zookeeper进行协调, broker 负责消息的读写与存储, 一个 broker可以管理读个 partionstopic：一类消息的总称&#x2F;消息队里, topic是由 partions组成, 一个 topic 由多台 server 里的 partions 组成。zookeeper 协调 kafka broker,存储元数据, consumer的 offset+ broker 信息 +topic信息+ partions信息partions 组成 topic 的单元, 每个 topic有副本(创建 topic 指定), 每个 partions 只能有有个 broker管理</p><h3 id="3-数据传输的事物定义有哪三种"><a href="#3-数据传输的事物定义有哪三种" class="headerlink" title="3. 数据传输的事物定义有哪三种?"></a>3. 数据传输的事物定义有哪三种?</h3><p>数据传输的事务定义通常有以下三种级别：</p><p>最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输。<br>最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输。<br>精确的一次(Exactly once): 不会漏传输也不会重复传输,每个消息都传输被一次而 且仅仅被传输一次，这是大家所期望的。</p><h3 id="4-ZooKeeper在Kafka中的作用是什么？"><a href="#4-ZooKeeper在Kafka中的作用是什么？" class="headerlink" title="4. ZooKeeper在Kafka中的作用是什么？"></a>4. ZooKeeper在Kafka中的作用是什么？</h3><p>Apache Kafka是一个使用Zookeeper构建的分布式系统。虽然，Zookeeper的主要作用是在集群中的不同节点之间建立协调。但是，如果任何节点失败，我们还使用Zookeeper从先前提交的偏移量中恢复，因为它做周期性提交偏移量工作。</p><h3 id="5-没有ZooKeeper可以使用Kafka吗？"><a href="#5-没有ZooKeeper可以使用Kafka吗？" class="headerlink" title="5. 没有ZooKeeper可以使用Kafka吗？"></a>5. 没有ZooKeeper可以使用Kafka吗？</h3><p>zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖。但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等。</p><h3 id="6-Kafka-判断一个节点是否还活着有那两个条件"><a href="#6-Kafka-判断一个节点是否还活着有那两个条件" class="headerlink" title="6. Kafka 判断一个节点是否还活着有那两个条件?"></a>6. Kafka 判断一个节点是否还活着有那两个条件?</h3><p>节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接。<br>如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太久。</p><h3 id="7-解释偏移的作用。"><a href="#7-解释偏移的作用。" class="headerlink" title="7. 解释偏移的作用。"></a>7. 解释偏移的作用。</h3><p>给分区中的消息提供了一个顺序ID号，我们称之为偏移量。因此，为了唯一地识别分区中的每条消息，我们使用这些偏移量。</p><h3 id="8-producer-是否直接将数据发送到-broker-的-leader-主节点"><a href="#8-producer-是否直接将数据发送到-broker-的-leader-主节点" class="headerlink" title="8. producer 是否直接将数据发送到 broker 的 leader(主节点)?"></a>8. producer 是否直接将数据发送到 broker 的 leader(主节点)?</h3><p>producer 直接将数据发送到 broker 的 leader(主节点)，不需要在多个节点进行分发，为了 帮助 producer 做到这点，所有的 Kafka 节点都可以及时的告知:哪些节点是活动的，目标topic 目标分区的 leader 在哪。这样 producer 就可以直接将消息发送到目的地了。</p><h3 id="9-Kafa-consumer-是否可以消费指定分区消息"><a href="#9-Kafa-consumer-是否可以消费指定分区消息" class="headerlink" title="9. Kafa consumer 是否可以消费指定分区消息?"></a>9. Kafa consumer 是否可以消费指定分区消息?</h3><p>Kafa consumer 消费消息时，向 broker 发出”fetch”请求去消费特定分区的消息，consumer指定消息在日志中的偏移量(offset)，就可以消费从这个位置开始的消息，customer 拥有 了 offset 的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的。</p><h3 id="10-Kafka-存储在硬盘上的消息格式是什么"><a href="#10-Kafka-存储在硬盘上的消息格式是什么" class="headerlink" title="10. Kafka 存储在硬盘上的消息格式是什么?"></a>10. Kafka 存储在硬盘上的消息格式是什么?</h3><p>消息由一个固定长度的头部和可变长度的字节数组组成。头部包含了一个版本号和 CRC32校验码。</p><p>消息长度: 4 bytes (value: 1+4+n)<br>版本号: 1 byte<br>CRC 校验码: 4 bytes<br>具体的消息: n bytes<br>11. kafka follower如何与leader同步数据？<br>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。<br>12. Kafka 高效文件存储设计特点:</p><p>Kafka 把 topic 中一个 parition 大文件分成多个小文件段，通过多个小文件段，就容易定 期清除或删除已经消费完文件，减少磁盘占用。<br>通过索引信息可以快速定位 message 和确定 response 的最大大小。<br>通过 index 元数据全部映射到 memory，可以避免 segment file 的 IO 磁盘操作。<br>通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小。<br>13. Kafka 与传统消息系统之间有三个关键区别</p><p>Kafka 持久化日志，这些日志可以被重复读取和无限期保留<br>Kafka 是一个分布式系统:它以集群的方式运行，可以灵活伸缩，在内部通过复制数据 提升容错能力和高可用性<br>Kafka 支持实时的流式处理<br>14. Kafka为什么那么快？</p><p>Cache Filesystem Cache PageCache缓存<br>顺序写 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。<br>Zero-copy 零拷技术减少拷贝次数<br>Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。<br>Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符。<br>15. 什么情况下一个 broker 会从 isr中踢出去？<br>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其重ISR中移除 。<br>16. kafka producer如何优化打入速度？</p><p>增加线程<br>提高 batch.size<br>增加更多 producer 实例<br>增加 partition 数<br>设置 acks&#x3D;-1 时，如果延迟增大：可以增大 num.replica.fetchers（follower 同步数据的线程数）来调解；<br>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。</p><ol start="17"><li>kafka producer 打数据，ack 为 0， 1， -1 的时候代表啥（ack机制）， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了？</li></ol><p>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。<br>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的。<br>-1 producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。<br>18. Kafka中的消息是否会丢失和重复消费？<br>要确定Kafka的消息是否丢失或重复，从两个方面分析入手：消息发送和消息消费。</p><ol><li>消息发送<br>Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。Kafka通过配置request.required.acks属性来确认消息的生产：</li></ol><p>0—表示不进行消息接收是否成功的确认；<br>1—表示当Leader接收成功时确认；<br>-1—表示Leader和Follower都接收成功时确认；<br>综上所述，有6种消息生产的情况，下面分情况来分析消息丢失的场景：<br>（1）acks&#x3D;0，不和Kafka集群进行消息接收确认，则当网络异常. 缓冲区满了等情况时，消息可能丢失；<br>（2）acks&#x3D;1. 同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失；<br>2. 消息消费<br>Kafka消息消费有两个consumer接口，Low-level API和High-level API：</p><p>Low-level API：消费者自己维护offset等值，可以实现对Kafka的完全控制；<br>High-level API：封装了对parition和offset的管理，使用简单；<br>如果使用高级接口High-level API，可能存在一个问题就是当消息消费者从集群中把消息取出来. 并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就“诡异”的消失了；<br>解决办法：</p><p>针对消息丢失：同步模式下，确认机制设置为-1，即让消息写入Leader和Follower之后再确认消息发送成功；异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时让生产者一直处于阻塞状态；<br>针对消息重复：将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可。<br>消息重复消费及解决参考：<a href="https://www.javazhiyin.com/22910.html">https://www.javazhiyin.com/22910.html</a></p><ol start="19"><li>为什么Kafka不支持读写分离？<br>在 Kafka 中，生产者写入消息. 消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。<br>Kafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:</li></ol><p>数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。<br>延时问题。类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经 历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。<br>20. Kafka中是怎么体现消息顺序性的？<br>kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。<br>整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.<br>21. 消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?<br>offset+1<br>22. kafka如何实现延迟队列？<br>Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty. Akka. Quartz. Zookeeper等组件中都存在时间轮的踪影。<br>底层使用数组实现，数组中的每个元素可以存放一个TimerTaskList对象。TimerTaskList是一个环形双向链表，在其中的链表项TimerTaskEntry中封装了真正的定时任务TimerTask.<br>Kafka中到底是怎么推进时间的呢？Kafka中的定时器借助了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList都会加入到DelayQueue中。<br>Kafka中的TimingWheel专门用来执行插入和删除TimerTaskEntry的操作，而DelayQueue专门负责时间推进的任务。再试想一下，DelayQueue中的第一个超时任务列表的expiration为200ms，第二个超时任务为840ms，这里获取DelayQueue的队头只需要O(1)的时间复杂度。<br>如果采用每秒定时推进，那么获取到第一个超时的任务列表时执行的200次推进中有199次属于“空推进”，而获取到第二个超时任务时有需要执行639次“空推进”，这样会无故空耗机器的性能资源，这里采用DelayQueue来辅助以少量空间换时间，从而做到了“精准推进”。Kafka中的定时器真可谓是“知人善用”，用TimingWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，相辅相成。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>myftp项目介绍</title>
    <link href="/2024/05/10/myftp%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/05/10/myftp%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>计算机网络的课程项目：基于tcp协议，实现了一个简单的 FTP Server 和 FTP Client CLI (CLI指命令行界面)。</p><p>支持的命令有：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">open</span> <span class="hljs-symbol">&lt;IP&gt;</span> <span class="hljs-symbol">&lt;port&gt;</span>: 建立一个到 <span class="hljs-symbol">&lt;IP&gt;</span>:<span class="hljs-symbol">&lt;port&gt;</span> 的连接<br><span class="hljs-keyword">ls</span>: 通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，获取server当前运行目录下的文件列表。<br><span class="hljs-built_in">get</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Server 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Client 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中。<br><span class="hljs-keyword">put</span> <span class="hljs-symbol">&lt;filename&gt;</span>: 将 Client 运行目录中的 <span class="hljs-symbol">&lt;filename&gt;</span> 文件存放到 Server 运行目录的 <span class="hljs-symbol">&lt;filename&gt;</span> 中。<br><span class="hljs-built_in">sha256</span> <span class="hljs-symbol">&lt;filename&gt;</span>：通过C语言中的popen函数来调用<span class="hljs-keyword">shell</span>输出的结果，在 Server 运行目录中查询某个文件的 <span class="hljs-built_in">sha256</span> 值，若不存在则返回不存在。<br><span class="hljs-keyword">quit</span>: 如有连接则断开连接，回到 <span class="hljs-keyword">open</span> 前的状态；如果已经是 <span class="hljs-keyword">open</span> 前的状态，则关闭 Client。<br></code></pre></td></tr></table></figure><p>（如果问到popen函数和system函数的区别，就说system函数的返回值五花八门，而popen返回值只有非空和空值，更好处理；而且调用system函数会阻塞进程，调用popen函数不会阻塞进程，也就是说用户可以继续运行主进程）</p><p>我觉得我的项目主要的亮点在于实现大文件的传输。其中有一个测试点是要实现1MB的文件的上传与下载。我一开始想通过开一个数组来实现，但是发现这样行不通，最后经过修改之后决定通过malloc分配出一段空间，然后将文件分片后传输，最后在另一端重新组合起来。</p><p>在这段代码中，文件的传输是按照一块一块来发送的，但是只有第一块设置了头部信息。头部信息包含了整个文件的长度，所以只需要在第一块传输时发送文件的长度信息即可，后续的块不需要再发送头部信息。</p><p>在GET_REQUEST中，第一块数据发送前，服务器端会发送一个含有文件长度信息的头部信息给客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 设置文件传输的头部信息</span><br>set_header(&amp;header, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, HEADER_LENGTH + statbuf.st_size);<br>send(client, &amp;header, HEADER_LENGTH, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>接着，服务器端开始逐块发送文件内容，后续的块不需要再发送头部信息，只需要发送文件内容即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 打开文件并逐块发送文件内容</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> temp[<span class="hljs-number">1024</span>];<br>FILE *fp = fopen(filename,<span class="hljs-string">&quot;rb&quot;</span>);<br><span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    length = fread(temp,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>),<span class="hljs-number">1024</span>,fp);<br>    <span class="hljs-keyword">if</span>(length == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    send(client,temp,length,<span class="hljs-number">0</span>);<br>&#125;<br>fclose(fp);<br></code></pre></td></tr></table></figure><p>因此，只有第一块设置了头部信息，后续的块不需要再设置头部信息。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字节面试准备</title>
    <link href="/2024/05/10/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2024/05/10/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<p>看了同岗位别人的一些面经x</p><p>字节国际电商后端一面<br>写在前面：八股很少，更多的是考察我们对八股文理解能力</p><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1. 自我介绍"></a>1. 自我介绍</h3><h3 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. 数据库</h3><p>（1）给你一个表，(id, userid, amount, month, day)，筛选出所有的日期在3.1-3.10且累计金额大于等于100w的数据<br>（2）select * from table where b&#x3D;xx 和 select id from table where b&#x3D;xx的区别是什么</p><h3 id="3-C-访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？"><a href="#3-C-访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？" class="headerlink" title="3. C++访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？"></a>3. C++访问空指针操作系统会把进程coredump掉，能解释原理吗？怎么终止掉该进程的？操作系统怎么知道这段地址不合理？</h3><p>当你尝试在C++中访问空指针时，实际上你在尝试访问一个未分配给你的内存地址。操作系统为每个进程分配一定范围的虚拟内存空间，并且对这些内存地址进行了合理的管理。然而，当你尝试使用空指针时，你实际上是在尝试访问地址0附近的内存，这是一个特殊的情况，通常是由操作系统所保留的，以防止应用程序错误地引用未分配的内存。</p><p>当你尝试访问空指针时，操作系统会检测到这个非法的内存访问，因为它监视着进程的内存访问情况。操作系统会触发一个信号，通常是称为”<strong>Segmentation Fault</strong>“（段错误）或”Access Violation”（访问违规），表示程序试图访问未分配的内存。</p><p>这时，操作系统会终止该进程，并生成一个核心转储文件（core dump），其中包含了导致程序崩溃的内存和程序状态信息。核心转储文件对于调试应用程序非常有用，因为它可以帮助开发人员追踪程序崩溃的原因。</p><p>终止进程的方法通常是通过发送一个<strong>信号</strong>来实现。在发生段错误时，操作系统会向进程发送一个信号，通常是<strong>SIGSEGV</strong>。操作系统会在接收到这个信号后，终止该进程的执行。</p><p>操作系统知道这段地址不合理是因为在内存管理中，<strong>每个页面都有自己的状态，操作系统会跟踪哪些页面是已分配的，哪些是空闲的，以及哪些是保留的。</strong>当程序访问一个未分配的或者无效的地址时，操作系统会检测到这个异常情况，并采取适当的措施，例如终止进程。</p><h3 id="4-C-内存分区是怎样的"><a href="#4-C-内存分区是怎样的" class="headerlink" title="4. C++内存分区是怎样的"></a>4. C++内存分区是怎样的</h3><p>在C++中，内存通常被划分为以下几个主要区域：</p><ol><li><p><strong>栈（Stack）</strong>：</p><ul><li>栈是用于存储函数调用的局部变量和函数参数的内存区域。</li><li>当一个函数被调用时，其局部变量和参数会被存储在栈上，并在函数返回时被自动释放。</li><li>栈是一种后进先出（LIFO）的数据结构，它的大小是固定的。</li></ul></li><li><p><strong>堆（Heap）</strong>：</p><ul><li>堆是动态分配内存的区域，用于存储程序运行时动态分配的对象。</li><li>堆的大小没有固定限制，它的大小取决于程序运行时的需求和系统资源。</li><li>堆上分配的内存需要手动释放，否则会导致内存泄漏。</li></ul></li><li><p><strong>全局&#x2F;静态存储区（Global&#x2F;Static Storage Area）</strong>：</p><ul><li>全局存储区用于存储全局变量和静态变量。</li><li>全局变量在程序的整个生命周期内都存在，静态变量在声明时初始化，在程序的整个生命周期内存在。</li><li>全局&#x2F;静态存储区在程序启动时被分配，在程序结束时被释放。</li></ul></li><li><p><strong>常量存储区（Constant Storage Area）</strong>：</p><ul><li>常量存储区用于存储常量值，例如字符串常量。</li><li>这部分内存通常是只读的，不能被修改。</li></ul></li><li><p><strong>代码区（Code Area）</strong>：</p><ul><li>代码区存储程序的可执行代码。</li><li>这部分内存通常是只读的，存储程序的指令。</li></ul></li></ol><p>这些内存区域在程序运行时起着不同的作用，并且由编译器和操作系统进行管理。程序员需要了解这些内存区域的特点和使用方式，以便正确地分配和管理内存，避免内存泄漏和其他内存相关的问题。</p><h3 id="5-linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用"><a href="#5-linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用" class="headerlink" title="5. linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用"></a>5. linux终端输入一个命令，讲一下操作系统怎么处理的，涉及到哪些系统调用</h3><p>当你在Linux终端输入一个命令时，操作系统会执行以下步骤来处理：</p><ol><li><p><strong>解析命令</strong>：</p><ul><li>操作系统首先会解析你输入的命令，确定你想要执行的程序或者脚本的路径。</li><li>如果输入的命令是一个内置命令（例如<code>cd</code>、<code>echo</code>等），则不需要进一步解析，而是直接调用相应的内置功能。</li></ul></li><li><p><strong>查找可执行文件</strong>：</p><ul><li>操作系统会搜索环境变量 <code>$PATH</code> 中列出的目录，以查找你输入的命令对应的可执行文件。</li><li>如果找到了对应的可执行文件，操作系统会准备执行它。</li></ul></li><li><p><strong>创建进程</strong>：</p><ul><li>操作系统会创建一个新的进程来执行你输入的命令。这个新进程是通过 <code>fork()</code> 系统调用创建的，然后调用 <code>exec()</code> 系统调用来加载并执行命令对应的可执行文件。</li></ul></li><li><p><strong>加载程序</strong>：</p><ul><li>在创建的新进程中，操作系统会加载你输入的命令对应的可执行文件到进程的内存空间中。</li></ul></li><li><p><strong>执行程序</strong>：</p><ul><li>一旦程序被加载到内存中，操作系统会开始执行它。程序的执行可能涉及到多个系统调用，具体取决于程序的功能和实现。</li></ul></li><li><p><strong>等待程序执行完成</strong>：</p><ul><li>操作系统会等待程序执行完成。如果程序是一个交互式程序，操作系统会将终端的输入输出连接到程序的标准输入输出上，以便你与程序进行交互。</li><li>如果程序执行完成并退出，操作系统会关闭该进程，并返回控制权给终端。</li></ul></li></ol><p>在这个过程中，涉及到的系统调用可能包括：</p><ul><li><code>fork()</code>：用于创建新的进程。</li><li><code>exec()</code>：用于加载并执行新的程序。</li><li><code>wait()</code> 或 <code>waitpid()</code>：用于等待子进程的退出。</li><li><code>open()</code>、<code>close()</code>、<code>read()</code> 和 <code>write()</code>：用于打开文件、关闭文件以及读写文件描述符，这些系统调用用于标准输入、输出和错误的重定向。</li><li>其他可能涉及到的系统调用，具体取决于命令执行过程中涉及的具体操作和功能。</li></ul><h3 id="6-讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？"><a href="#6-讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？" class="headerlink" title="6. 讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？"></a>6. 讲一下操作系统内存管理的方式？内存管理的目的？（忘记了，到这里已经满头大汗了）？讲一下主流OS的内存管理方式？</h3><p>内存管理是操作系统的重要功能之一，它负责管理计算机系统的物理内存，以便有效地分配和利用内存资源。内存管理的主要目的包括：</p><ol><li><strong>内存分配与回收</strong>：分配内存给进程使用，并在进程终止时回收已使用的内存，以便其他进程使用。</li><li><strong>内存保护</strong>：确保进程只能访问自己分配的内存空间，防止程序越界访问和恶意代码攻击。</li><li><strong>内存共享</strong>：允许多个进程共享内存区域，以提高系统性能和节省内存空间。</li><li><strong>内存虚拟化</strong>：提供每个进程独立的虚拟地址空间，使每个进程都认为自己在使用整个计算机的内存。</li></ol><p>不同的操作系统采用不同的内存管理方式，以下是主流操作系统的内存管理方式：</p><ol><li><p><strong>单一连续内存管理</strong>（Single Contiguous Memory Management）：</p><ul><li>在早期的操作系统中，使用了单一连续内存管理方式。在这种方式下，整个物理内存被视为一个连续的字节序列，进程被分配到内存的连续区域中。</li><li><strong>MS-DOS 是一个使用单一连续内存管理方式的操作系统的例子</strong>。</li></ul></li><li><p><strong>分页式内存管理</strong>（Paging）：</p><ul><li>在分页式内存管理中，物理内存被分割成固定大小的页面（page），通常为4KB或者更大。</li><li>进程的虚拟地址空间也被分成相同大小的页面。操作系统负责将虚拟页面映射到物理页面，从而实现了内存虚拟化。</li><li>当进程访问一个尚未加载到内存的虚拟页面时，操作系统会触发页面错误（page fault），将对应的页面从磁盘加载到内存中。</li><li>UNIX、Linux 和 Windows 等操作系统采用了分页式内存管理。</li></ul></li><li><p><strong>段式内存管理</strong>（Segmentation）：</p><ul><li>在段式内存管理中，虚拟地址空间被分成不同大小的段（segment），<strong>每个段代表一个逻辑单位，如代码段、数据段等</strong>。</li><li>物理内存也被分成相应的段，每个段可以有不同的大小和属性。</li><li>段式内存管理可以更灵活地管理内存，但也更复杂。现代操作系统往往结合分页和分段的方式来管理内存，称为分页分段式内存管理。</li></ul></li><li><p><strong>分页分段式内存管理</strong>（Paging and Segmentation）：</p><ul><li>分页分段式内存管理结合了分页和分段的优点，将<strong>虚拟地址空间划分为多个段，每个段再分成多个页面</strong>，实现了灵活性和效率的平衡。</li><li>这种方式在现代操作系统中被广泛采用，例如，Intel x86 架构的操作系统（如 Windows 和 Linux）使用了分页分段式内存管理。</li></ul></li></ol><h3 id="7-printf-“-d”-amp-a-，输出的地址是物理地址还是虚拟地址？为什么？"><a href="#7-printf-“-d”-amp-a-，输出的地址是物理地址还是虚拟地址？为什么？" class="headerlink" title="7. printf(“%d”, &amp;a)，输出的地址是物理地址还是虚拟地址？为什么？"></a>7. printf(“%d”, &amp;a)，输出的地址是物理地址还是虚拟地址？为什么？</h3><p>在C语言中，<code>printf(&quot;%d&quot;, &amp;a)</code> 中的 <code>&amp;a</code> 表示取变量 <code>a</code> 的地址。然而，C语言本身并不关心地址是物理地址还是虚拟地址，它只是返回变量 <code>a</code> 在内存中的地址值。</p><p>具体来说，在大多数现代操作系统中，包括 Linux 和 Windows，在用户空间程序中，<code>&amp;a</code> 返回的是虚拟地址，而不是物理地址。这是因为操作系统为每个进程提供了一个独立的虚拟地址空间，每个进程的虚拟地址空间都从零开始，与物理内存地址是分离的。</p><p>当你在C语言中使用 <code>&amp;a</code> 获取变量 <code>a</code> 的地址时，实际上是获取了该变量在当前进程的虚拟地址空间中的地址。这个地址是相对于进程而言的，而不是物理内存的地址。操作系统会负责将这个虚拟地址映射到物理内存的相应位置。</p><p>你说得对，我明白你的疑问了。**<code>printf</code> 是C语言的标准库函数，它用于将格式化的数据输出到标准输出流（通常是终端）。而C语言的标准库函数 <code>printf</code> 并不是操作系统级别的函数，它实际上是在用户空间运行的，而不是在操作系统内核中运行。**</p><p>当你在C程序中调用 <code>printf</code> 函数时，这个函数是由C编译器编译生成的用户态代码。这个用户态的 <code>printf</code> 函数接收参数，执行输出操作，并将输出发送到标准输出流。这个过程并不涉及操作系统的内核代码。</p><p>因此，当你在C语言程序中使用 <code>printf(&quot;%d&quot;, &amp;a)</code> 来输出变量 <code>a</code> 的地址时，<code>printf</code> 函数实际上是直接输出了变量 <code>a</code> 在当前进程的虚拟地址空间中的地址，而不是物理地址。这个地址是在用户态计算得到的，与操作系统的内核代码无关。</p><p>因此，<code>printf(&quot;%d&quot;, &amp;a)</code> 输出的地址是<strong>相对于进程的虚拟地址</strong>，而不是物理地址。</p><h3 id="8-虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）"><a href="#8-虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）" class="headerlink" title="8. 虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）"></a>8. 虚拟地址怎么映射到物理地址？页表里面存了什么？4G的内存，一个物理块是4KB，需要多大的页表来存？（显然是1mb，除一下）既然每个进程都要存1MB的页表，如何解决这个问题？（我答得两级页表，面试官说这样要的空间更大了。应该是只把一级页表调入内存，二级页表留在外存）</h3><p>页表是一种数据结构，用于存储虚拟地址空间中每个页面（page）的映射信息，以便操作系统将虚拟地址映射到物理地址。</p><p>在常见的分页式内存管理中，页表的主要作用是实现虚拟内存到物理内存的地址映射。当程序访问虚拟地址时，操作系统会使用页表来确定对应的物理地址。</p><p>页表通常包含以下信息：</p><ol><li><p><strong>页号（Page Number）</strong>：用于表示虚拟地址中的页面号码。在页表中，每个页号都对应着一个页表项（Page Table Entry）。</p></li><li><p><strong>页框号（Frame Number）</strong>：用于表示物理地址中的页框号码。页表中的每个页表项都包含了对应的页框号码，用于将虚拟地址映射到物理地址。</p></li><li><p><strong>访问权限（Access Rights）</strong>：用于表示页面的访问权限，包括读、写、执行等权限。这些权限信息通常存储在页表项中，并且可以用于实现内存保护机制。</p></li><li><p><strong>其他控制位（Control Bits）</strong>：包括是否被访问过、是否被修改过等控制信息，用于实现页面置换算法等功能。</p></li><li><p><strong>其他辅助信息</strong>：可能包括页面的有效位、驻留位、脏位等，用于帮助操作系统实现内存管理和页面置换算法。</p></li></ol><p>页表的结构和内容可能因操作系统的不同而有所不同，但它的基本功能是将虚拟地址映射到物理地址，从而实现虚拟内存的管理。</p><h3 id="9-计算机网络："><a href="#9-计算机网络：" class="headerlink" title="9. 计算机网络："></a>9. 计算机网络：</h3><h4 id="浏览器输入网址的完整流程（重要）"><a href="#浏览器输入网址的完整流程（重要）" class="headerlink" title="浏览器输入网址的完整流程（重要）"></a>浏览器输入网址的完整流程（重要）</h4><p>（操作系统级别和网络级别的都可以讲）<br>别忘了dns解析（先看缓存再请求） socket连接 http请求 html渲染</p><h4 id="HTTP请求的类型有哪些，有什么作用？"><a href="#HTTP请求的类型有哪些，有什么作用？" class="headerlink" title="HTTP请求的类型有哪些，有什么作用？"></a>HTTP请求的类型有哪些，有什么作用？</h4><p>HTTP请求的类型主要包括以下几种：</p><ol><li><p><strong>GET</strong>：</p><ul><li>GET 请求用于从服务器获取数据，通常用于请求一个资源的内容。</li><li>GET 请求的参数通常包含在URL的查询字符串中，例如 <code>http://example.com/resource?id=123</code>。</li><li>GET 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>POST</strong>：</p><ul><li>POST 请求用于向服务器提交数据，通常用于创建新资源或者向服务器提交表单数据。</li><li>POST 请求的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>POST 请求可以用于执行各种操作，例如创建、更新、删除等，具体取决于服务器的实现。</li></ul></li><li><p><strong>PUT</strong>：</p><ul><li>PUT 请求用于向服务器上传数据，通常用于更新已有资源。</li><li>PUT 请求的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>PUT 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>DELETE</strong>：</p><ul><li>DELETE 请求用于从服务器删除资源。</li><li>DELETE 请求通常不包含数据，而是用于删除服务器上指定的资源。</li><li>DELETE 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>PATCH</strong>：</p><ul><li>PATCH 请求用于对资源进行局部更新，即只更新资源的一部分内容。</li><li>PATCH 请求的数据通常包含在请求的主体（body）中，指定要更新的部分内容。</li><li>PATCH 请求是幂等的，即对于相同的请求，多次执行不会产生不同的结果。</li></ul></li><li><p><strong>HEAD</strong>：</p><ul><li>HEAD 请求用于获取资源的头部信息，即获取资源的元数据而不获取实际内容。</li><li>HEAD 请求与 GET 请求类似，但不会返回资源的主体内容，只返回头部信息。</li></ul></li><li><p><strong>OPTIONS</strong>：</p><ul><li>OPTIONS 请求用于获取服务器支持的HTTP方法列表，以及服务器支持的其他功能。</li><li>OPTIONS 请求通常用于跨域资源共享（CORS）等场景下，以确定是否允许跨域请求。</li></ul></li></ol><p>这些HTTP请求类型具有不同的功能和语义，使得客户端和服务器可以进行各种类型的交互，实现数据的获取、创建、更新和删除等操作。</p><h4 id="post和put和区别？"><a href="#post和put和区别？" class="headerlink" title="post和put和区别？"></a>post和put和区别？</h4><p>在HTTP协议中，POST和PUT都是用于向服务器提交数据的方法，但它们有一些重要的区别：</p><ol><li><p><strong>POST</strong>：</p><ul><li>POST 方法用于向服务器提交数据，通常用于创建新资源或者在服务器上执行某种操作。</li><li>POST 请求提交的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>POST 请求没有严格的语义，它可以用于多种用途，包括创建、更新、删除等操作。</li><li>POST 请求通常用于在服务器上创建新资源，因此，重复提交相同的POST请求可能会导致服务器创建多个相同的资源。</li></ul></li><li><p><strong>PUT</strong>：</p><ul><li>PUT 方法用于向服务器提交数据，通常用于更新现有资源。</li><li>PUT 请求提交的数据通常包含在请求的主体（body）中，而不是在URL中。</li><li>PUT 请求有严格的语义，它用于在服务器上更新指定的资源。PUT 请求应该是幂等的，即重复提交相同的PUT请求不应该产生不同的结果。</li><li>如果服务器上不存在指定的资源，PUT 请求通常会创建一个新的资源，但也可能返回错误，取决于服务器的实现和配置。</li></ul></li></ol><p>总之，POST 和 PUT 都是用于向服务器提交数据的方法，但它们在语义和用途上有所不同。POST 通常用于创建新资源或执行一些操作，而 PUT 通常用于更新现有资源。</p><h4 id="讲一下TCP报文有哪些关键字段"><a href="#讲一下TCP报文有哪些关键字段" class="headerlink" title="讲一下TCP报文有哪些关键字段"></a>讲一下TCP报文有哪些关键字段</h4><p>四元组 ack seq 控制位 滑动窗口 header_length crc content</p><h4 id="TCP如何做到可靠传输（重要）"><a href="#TCP如何做到可靠传输（重要）" class="headerlink" title="TCP如何做到可靠传输（重要）"></a>TCP如何做到可靠传输（重要）</h4><p>超时重传 crc校验 ackseq 握手连接 流量控制 拥塞控制</p><h3 id="10-100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp-100-x3D-dp-97-x3D-dp-94-…-x3D-dp-1-，所以一开始就拿一个"><a href="#10-100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp-100-x3D-dp-97-x3D-dp-94-…-x3D-dp-1-，所以一开始就拿一个" class="headerlink" title="10. 100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp[100]&#x3D;dp[97]&#x3D;dp[94]…&#x3D;dp[1]，所以一开始就拿一个"></a>10. 100个苹果，A和B轮流拿，一次只能拿一个或两个，A先拿。A应该怎么拿才能保证拿到最后一个苹果？dp[100]&#x3D;dp[97]&#x3D;dp[94]…&#x3D;dp[1]，所以一开始就拿一个</h3><h3 id="11-分糖果（leetcode135原题）"><a href="#11-分糖果（leetcode135原题）" class="headerlink" title="11. 分糖果（leetcode135原题）"></a>11. 分糖果（leetcode135原题）</h3><h3 id="12-如何学习新事物"><a href="#12-如何学习新事物" class="headerlink" title="12. 如何学习新事物"></a>12. 如何学习新事物</h3>]]></content>
    
    
    
    <tags>
      
      <tag>国际电商</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>推荐一个抄mooc/智慧树答案的网站</title>
    <link href="/2024/05/10/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E6%8A%84mooc-%E6%99%BA%E6%85%A7%E6%A0%91%E7%AD%94%E6%A1%88%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <url>/2024/05/10/%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E6%8A%84mooc-%E6%99%BA%E6%85%A7%E6%A0%91%E7%AD%94%E6%A1%88%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jhq8.cn/s/">https://www.jhq8.cn/s/</a><br>有时候网站会抽风找不到搜索框，这个时候只要修改网址栏就可以力</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.jhq8.cn<span class="hljs-regexp">/s/</span>你要搜索的连续内容/<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试搬运-SQL面试五十题</title>
    <link href="/2024/05/10/%E9%9D%A2%E8%AF%95%E6%90%AC%E8%BF%90-SQL%E9%9D%A2%E8%AF%95%E4%BA%94%E5%8D%81%E9%A2%98/"/>
    <url>/2024/05/10/%E9%9D%A2%E8%AF%95%E6%90%AC%E8%BF%90-SQL%E9%9D%A2%E8%AF%95%E4%BA%94%E5%8D%81%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>字号太小了就搬过来了。<br>原地址：<a href="https://blog.csdn.net/qiqi123i/article/details/108455130">https://blog.csdn.net/qiqi123i/article/details/108455130</a></p><ol><li>查询课程编号为“01”的课程比“02”的课程成绩高的所有学生的学号（难）</li><li>查询平均成绩大于60分的学生的学号和平均成绩</li><li>查询所有学生的学号、姓名、选课数、总成绩</li><li>查询姓“猴”的老师的个数</li><li>查询没学过“张三”老师课的学生的学号、姓名</li><li>查询学过“张三”老师所教的所有课的同学的学号、姓名</li><li>查询学过编号为“01”的课程并且也学过编号为“02”的课程的学生的学号、姓名</li><li>查询课程编号为“02”的总成绩</li><li>查询所有课程成绩小于60分的学生的学号、姓名</li><li>查询没有学全所有课的学生的学号、姓名</li><li>查询至少有一门课与学号为“01”的学生所学课程相同的学生的学号和姓名 （难）</li><li>查询和“01”号同学所学课程完全相同的其他同学的学号（难）</li><li>查询没学过”张三”老师讲授的任一门课程的学生姓名 和47题一样</li><li>查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</li><li>检索”01”课程分数小于60，按分数降序排列的学生信息</li><li>按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩(难)</li><li>查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率</li><li>按各科成绩进行排序，并显示排名(难)</li><li>查询学生的总成绩并进行排名</li><li>查询不同老师所教不同课程平均分从高到低显示</li><li>查询所有课程的成绩第2名到第3名的学生信息及该课程成绩（重要 25类似）</li><li>使用分段[100-85],[85-70],[70-60],[&lt;60]来统计各科成绩，分别统计各分数段人数：课程ID和课程名称</li><li>查询学生平均成绩及其名次</li><li>查询各科成绩前三名的记录（不考虑成绩并列情况）</li><li>查询每门课程被选修的学生数</li><li>查询出只有两门课程的全部学生的学号和姓名</li><li>查询男生、女生人数</li><li>查询名字中含有”风”字的学生信息</li><li>查询1990年出生的学生名单</li><li>查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩</li><li>查询每门课程的平均成绩，结果按平均成绩升序排序，平均成绩相同时，按课程号降序排列</li><li>查询课程名称为”数学”，且分数低于60的学生姓名和分数</li><li>查询所有学生的课程及分数情况</li><li>查询任何一门课程成绩在70分以上的姓名、课程名称和分数</li><li>查询不及格的课程并按课程号从大到小排列</li><li>查询课程编号为03且课程成绩在80分以上的学生的学号和姓名</li><li>求每门课程的学生人数</li><li>查询选修“张三”老师所授课程的学生中成绩最高的学生姓名及其成绩</li><li>查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 （难）</li><li>查询每门功成绩最好的前两名</li><li>统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</li><li>检索至少选修两门课程的学生学号</li><li>查询选修了全部课程的学生信息</li><li>查询各学生的年龄</li><li>查询没学过“张三”老师讲授的任一门课程的学生姓名</li><li>查询两门以上不及格课程的同学的学号及其平均成绩</li><li>查询本月过生日的学生</li><li>查询下一个月过生日的学生</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼编码</title>
    <link href="/2024/05/09/%E7%AE%97%E6%B3%95%E6%81%B6%E8%A1%A5/"/>
    <url>/2024/05/09/%E7%AE%97%E6%B3%95%E6%81%B6%E8%A1%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" alt="huffman"><br>我的想法：用最小堆维护一个根节点，然后开辟额外的空间O(N)去维护最终的树<br>（带权最短路径</p><p>向左子树移动就是0，向右子树移动就是1，到叶子结点就是要访问的节点，每个节点都有自己的哈夫曼编码</p><p>xiaolincoding.com的计算机网络讲得真的很细（感觉是面试官会问到的级别</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL测验</title>
    <link href="/2024/05/08/SQL%E6%B5%8B%E9%AA%8C/"/>
    <url>/2024/05/08/SQL%E6%B5%8B%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>不想成为那个八股背的非常流利但是sql一道都不会写的人于是开始恶补啊啊啊啊啊</p><p>一个选择题测验网站：<a href="https://www.w3school.com.cn/quiz/quiz.asp?quiz=sql">https://www.w3school.com.cn/quiz/quiz.asp?quiz=sql</a></p><p>注：“您的回答”下没有“正确答案”的就是答对了</p><p>1.SQL 指的是？<br>您的回答：Structured Query Language</p><p>2.哪个 SQL 语句用于从数据库中提取数据？<br>您的回答：SELECT</p><p>3.哪条 SQL 语句用于更新数据库中的数据？<br>您的回答：UPDATE</p><p>4.哪条 SQL 语句用于删除数据库中的数据？<br>您的回答：DELETE</p><p>5.哪条 SQL 语句用于在数据库中插入新的数据？<br>您的回答：INSERT INTO</p><p>6.通过 SQL，您如何从 “Persons” 表中选取 “FirstName” 列？<br>您的回答：SELECT FirstName FROM Persons</p><p>7.通过 SQL，您如何从 “Persons” 表中选取所有的列？<br>您的回答：SELECT * FROM Persons</p><p>8.通过 SQL，您如何从 “Persons” 表中选取 “FirstName” 列的值等于”Peter” 的所有记录？<br>您的回答：SELECT * FROM Persons WHERE FirstName&#x3D;’Peter’</p><p>9.通过 SQL，您如何从 “Persons” 表中选取 “FirstName” 列的值以 “a” <strong>开头</strong>的所有记录？<br>您的回答：SELECT * FROM Persons WHERE FirstName LIKE ‘%a’<br><strong>正确答案：SELECT * FROM Persons WHERE FirstName LIKE ‘a%’</strong></p><p>10.请判断下列说法是否正确：当所列出的某个条件为 true 时，OR 运算符会显示记录。当列出的所有条件为 true 时，AND 运算符会显示记录。<br>您的回答：正确</p><p>11.通过 SQL，您如何在表 Persons 中选择 FirstName 等于 Thomas 而 LastName 等于 Carter 的所有记录？<br>您的回答：SELECT * FROM Persons WHERE FirstName&#x3D;’Thomas’ AND LastName&#x3D;’Carter’</p><p>12.通过 SQL，您如何按字母顺序选取 Persons 表中 LastName 介于 Adams 和 Carter 的所有记录？<br>您的回答：SELECT * FROM Persons WHERE LastName&gt;’Adams’ AND LastName&lt;’Carter’<br><strong>正确答案：SELECT * FROM Persons WHERE LastName BETWEEN ‘Adams’ AND ‘Carter’</strong></p><p>13.哪条 SQL 语句可返回唯一不同的值？<br>您的回答：SELECT DISTINCT</p><p>14.哪个 SQL 关键词用于对<strong>结果集</strong>进行排序？<br>您的回答：SORT BY<br><strong>正确答案：ORDER BY</strong></p><p>15.通过 SQL，您如何根据 “FirstName” 列降序地从 “Persons” 表返回所有记录？<br>您的回答：SELECT * FROM Persons ORDER BY FirstName DESC</p><p>16.通过 SQL，您如何向 “Persons” 表插入新的记录？<br>您的回答：INSERT INTO Persons VALUES (‘Jimmy’, ‘Jackson’)</p><p>17.通过 SQL，您如何向 “Persons” 表中的 “LastName” 列插入 “Wilson” ？<br>您的回答：INSERT INTO Persons (LastName) VALUES (‘Wilson’)</p><p>18.您如何把 “Persons” 表中 “LastName” 列的 “Gates” 改为 “Wilson” ？<br>您的回答：UPDATE Persons SET LastName&#x3D;’Wilson’ WHERE LastName&#x3D;’Gates’</p><p>19.通过 SQL，您如何在 “Persons” 表中删除 “FirstName” 等于 “Fred” 的纪录？<br>您的回答：DELETE ROW FirstName&#x3D;’Fred’ FROM Persons<br><strong>正确答案：DELETE FROM Persons WHERE FirstName &#x3D; ‘Fred’</strong></p><p>20.通过 SQL，您如何返回 “Persons” 表中记录的数目？<br>您的回答：SELECT COUNT(*) FROM Persons</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>搬运自用-MySQL面试题合集</title>
    <link href="/2024/05/08/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2024/05/08/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>题目合集：</p><ol><li>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15？</li><li>Mysql的技术特点是什么？</li><li>Heap表是什么？</li><li>Mysql服务器默认端口是什么？</li><li>与Oracle相比，Mysql有什么优势？</li><li>如何区分FLOAT和DOUBLE？</li><li>区分CHAR_LENGTH和LENGTH？</li><li>请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</li><li>在Mysql中ENUM的用法是什么？</li><li>如何定义REGEXP？</li><li>CHAR和VARCHAR的区别？</li><li>列的字符串类型可以是什么？</li><li>如何获取当前的Mysql版本？</li><li>Mysql中使用什么存储引擎？</li><li>Mysql驱动程序是什么？</li><li>TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？</li><li>主键和候选键有什么区别？</li><li>如何使用Unix shell登录Mysql？</li><li>myisamchk是用来做什么的？</li><li>MYSQL数据库服务器性能分析的方法命令有哪些?</li><li>如何控制HEAP表的最大尺寸？</li><li>MyISAM Static和MyISAM Dynamic有什么区别？</li><li>federated表是什么？</li><li>如果一个表有一列定义为TIMESTAMP，将发生什么？</li><li>列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</li><li>怎样才能找出最后一次插入时分配了哪个自动增量？</li><li>你怎么看到为表格定义的所有索引？</li><li>LIKE声明中的％和_是什么意思？</li><li>如何在Unix和Mysql时间戳之间进行转换？</li><li>列对比运算符是什么？</li><li>我们如何得到受查询影响的行数？</li><li>Mysql查询是否区分大小写？</li><li>LIKE和REGEXP操作有什么区别？</li><li>BLOB和TEXT有什么区别？</li><li>mysql_fetch_array和mysql_fetch_object的区别是什么？</li><li>我们如何在mysql中运行批处理模式？</li><li>MyISAM表格将在哪里存储，并且还提供其存储格式？</li><li>Mysql中有哪些不同的表格？</li><li>ISAM是什么？</li><li>InnoDB是什么？</li><li>Mysql如何优化DISTINCT？</li><li>如何输入字符为十六进制数字？</li><li>如何显示前50行？</li><li>可以使用多少列创建索引？</li><li>NOW（）和CURRENT_DATE（）有什么区别？</li><li>什么样的对象可以使用CREATE语句创建？</li><li>Mysql表中允许有多少个TRIGGERS？</li><li>什么是非标准字符串类型？</li><li>什么是通用SQL函数？</li><li>解释访问控制列表</li><li>MYSQL支持事务吗？</li><li>mysql里记录货币用什么字段类型好</li><li>MYSQL数据表在什么情况下容易损坏？</li><li>mysql有关权限的表都有哪几个？</li><li>Mysql中有哪几种锁？</li></ol><h3 id="1-一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？"><a href="#1-一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15-16-17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15-？" class="headerlink" title="1. 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？"></a>1. 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</h3><p>1.如果表的类型是MyISAM，那么是18.因为MyISAM会把自己增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。<br>2.如果表的类型是InnoDB，那么是15.InnoDB表只是把自增主键的最大ID记录到内存中，所以重启数据库或者是对表进行OPTIMIZE操作，都会导致最大ID丢失。</p><h3 id="2-Mysql的技术特点是什么？"><a href="#2-Mysql的技术特点是什么？" class="headerlink" title="2. Mysql的技术特点是什么？"></a>2. Mysql的技术特点是什么？</h3><p>Mysql数据库软件是一个客户端或服务器系统，其中包括：支持各种客户端程序和库的多线程SQL服务器. 不同的后端. 广泛的应用程序编程接口和管理工具。</p><h3 id="3-Heap表是什么？"><a href="#3-Heap表是什么？" class="headerlink" title="3. Heap表是什么？"></a>3. Heap表是什么？</h3><p>HEAP表存在于内存中，用于临时高速存储。</p><p>BLOB或TEXT字段是不允许的</p><p>只能使用比较运算符&#x3D;，&lt;，&gt;，&#x3D;&gt;，&#x3D; &lt;</p><p>HEAP表不支持AUTO_INCREMENT</p><p>索引不可为NULL</p><h3 id="4-Mysql服务器默认端口是什么？"><a href="#4-Mysql服务器默认端口是什么？" class="headerlink" title="4. Mysql服务器默认端口是什么？"></a>4. Mysql服务器默认端口是什么？</h3><p>Mysql服务器的默认端口是3306。</p><h3 id="5-与Oracle相比，Mysql有什么优势？"><a href="#5-与Oracle相比，Mysql有什么优势？" class="headerlink" title="5. 与Oracle相比，Mysql有什么优势？"></a>5. 与Oracle相比，Mysql有什么优势？</h3><p>Mysql是开源软件，随时可用，无需付费。</p><p>Mysql是便携式的</p><p>带有命令提示符的GUI。</p><p>使用Mysql查询浏览器支持管理</p><h3 id="6-如何区分FLOAT和DOUBLE？"><a href="#6-如何区分FLOAT和DOUBLE？" class="headerlink" title="6. 如何区分FLOAT和DOUBLE？"></a>6. 如何区分FLOAT和DOUBLE？</h3><p>以下是FLOAT和DOUBLE的区别：</p><p>浮点数以8位精度存储在FLOAT中，并且有四个字节。</p><p>浮点数存储在DOUBLE中，精度为18位，有八个字节。</p><h3 id="7-区分CHAR-LENGTH和LENGTH？"><a href="#7-区分CHAR-LENGTH和LENGTH？" class="headerlink" title="7. 区分CHAR_LENGTH和LENGTH？"></a>7. 区分CHAR_LENGTH和LENGTH？</h3><p>CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。</p><h3 id="8-请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"><a href="#8-请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？" class="headerlink" title="8. 请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？"></a>8. 请简洁描述Mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>未解决</td><td>未解决</td><td>未解决</td></tr><tr><td>读提交</td><td>解决</td><td>未解决</td><td>未解决</td></tr><tr><td>可重复读</td><td>解决</td><td>解决</td><td>未解决</td></tr><tr><td>串行化</td><td>解决</td><td>解决</td><td>解决</td></tr></tbody></table><p>SQL标准定义的四个隔离级别为：</p><p>read uncommited ：读到未提交数据</p><p>read committed：脏读，不可重复读</p><p>repeatable read：可重读</p><p>serializable ：串行事物<br>详细解释如下：<br>Read Uncommitted（读取未提交内容）<br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。<br>Read Committed（读取提交内容）<br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。<br>Repeatable Read（可重读）<br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control 间隙锁）机制解决了该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也就是它这里所谓的并发控制）才解决了幻读问题。<br>Serializable（可串行化）<br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。<br>对于不同的事务，采用不同的隔离级别分别有不同的结果。不同的隔离级别有不同的现象。主要有下面3种现在：</p><ol><li>脏读（dirty read）：一个事务可以读取另一个尚未提交事务的修改数据。</li><li>非重复读（nonrepeatable read）：在同一个事务中，同一个查询在T1时间读取某一行，在T2时间重新读取这一行时候，这一行的数据已经发生修改，可能被更新了（update），也可能被删除了（delete）。</li><li>幻像读（phantom read）：在同一事务中，同一查询多次进行时候，由于其他插入操作（insert）的事务提交，导致每次返回不同的结果集。<br>不同的隔离级别有不同的现象，并有不同的锁定&#x2F;并发机制，隔离级别越高，数据库的并发性就越差，4种事务隔离级别分别表现的现象如下表：</li></ol><h3 id="9-在Mysql中ENUM的用法是什么？"><a href="#9-在Mysql中ENUM的用法是什么？" class="headerlink" title="9. 在Mysql中ENUM的用法是什么？"></a>9. 在Mysql中ENUM的用法是什么？</h3><p>ENUM是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。</p><p>Create table size(name ENUM(‘Smail,’Medium’,’Large’));</p><h3 id="10-如何定义REGEXP？"><a href="#10-如何定义REGEXP？" class="headerlink" title="10. 如何定义REGEXP？"></a>10. 如何定义REGEXP？</h3><p>REGEXP是模式匹配，其中匹配模式在搜索值的任何位置。</p><p>REGEXP是一个用于在MySQL中执行正则表达式匹配的操作符。通过使用REGEXP操作符，可以在MySQL查询中使用正则表达式来进行模式匹配和过滤数据。</p><p>下面是REGEXP操作符的基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">expr REGEXP <span class="hljs-keyword">pattern</span><br></code></pre></td></tr></table></figure><ul><li><code>expr</code>：要匹配的表达式或字段。</li><li><code>pattern</code>：正则表达式模式。</li></ul><p>例如，要查找名字以字母”A”开头的所有用户，可以使用如下的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name REGEXP <span class="hljs-string">&#x27;^A&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这个查询将返回所有名字以字母”A”开头的用户数据。</p><p>正则表达式提供了强大的模式匹配功能，可以用于各种情况下的数据过滤和匹配操作。MySQL中的REGEXP操作符使得我们可以在查询中利用这些功能来实现更加灵活和复杂的数据查询和处理。</p><h3 id="11-CHAR和VARCHAR的区别？"><a href="#11-CHAR和VARCHAR的区别？" class="headerlink" title="11. CHAR和VARCHAR的区别？"></a>11. CHAR和VARCHAR的区别？</h3><p>以下是CHAR和VARCHAR的区别：</p><p>CHAR和VARCHAR类型在存储和检索方面有所不同</p><p>CHAR列长度固定为创建表时声明的长度，长度值范围是1到255</p><p>当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</p><h3 id="12-列的字符串类型可以是什么？"><a href="#12-列的字符串类型可以是什么？" class="headerlink" title="12. 列的字符串类型可以是什么？"></a>12. 列的字符串类型可以是什么？</h3><p>字符串类型是：</p><p>SET</p><p>BLOB</p><p>ENUM</p><p>CHAR</p><p>TEXT</p><p>VARCHAR</p><h3 id="13-如何获取当前的Mysql版本？"><a href="#13-如何获取当前的Mysql版本？" class="headerlink" title="13. 如何获取当前的Mysql版本？"></a>13. 如何获取当前的Mysql版本？</h3><p>SELECT VERSION();用于获取当前Mysql的版本。</p><h3 id="14-Mysql中使用什么存储引擎？"><a href="#14-Mysql中使用什么存储引擎？" class="headerlink" title="14. Mysql中使用什么存储引擎？"></a>14. Mysql中使用什么存储引擎？</h3><p>存储引擎称为表类型，数据使用各种技术存储在文件中。<br>MySQL支持多种存储引擎，每种引擎都有其自身的特点和用途。在MySQL中，默认的存储引擎是InnoDB，但也支持其他存储引擎，例如MyISAM、MEMORY、CSV等。</p><p>常用的MySQL存储引擎包括：</p><ol><li><p><strong>InnoDB</strong>：支持事务处理和行级锁定，是MySQL默认的存储引擎，适用于大多数应用场景。</p></li><li><p><strong>MyISAM</strong>：不支持事务处理，但提供了高速的读取和全文索引功能，适用于读密集型应用。</p></li><li><p><strong>MEMORY</strong>：将数据存储在内存中，速度非常快，但数据不是持久的，适用于缓存和临时表等场景。</p></li><li><p><strong>CSV</strong>：将数据存储在CSV文件中，适用于数据交换和导入导出。</p></li><li><p><strong>ARCHIVE</strong>：用于存储大量归档数据，支持高压缩比和快速插入。</p></li><li><p><strong>NDB</strong>：用于MySQL Cluster，支持分布式存储和高可用性。</p></li></ol><p>不同的存储引擎具有不同的特点和适用场景，选择合适的存储引擎取决于应用的需求和性能要求。</p><p>技术涉及：</p><p>Storage mechanism</p><p>Locking levels</p><p>Indexing</p><p>Capabilities and functions.</p><h3 id="15-Mysql驱动程序是什么？"><a href="#15-Mysql驱动程序是什么？" class="headerlink" title="15. Mysql驱动程序是什么？"></a>15. Mysql驱动程序是什么？</h3><p>以下是Mysql中可用的驱动程序：</p><p>PHP驱动程序</p><p>JDBC驱动程序</p><p>ODBC驱动程序</p><p>CWRAPPER</p><p>PYTHON驱动程序</p><p>PERL驱动程序</p><p>RUBY驱动程序</p><p>CAP11PHP驱动程序</p><p>Ado.net5.mxj</p><h3 id="16-TIMESTAMP在UPDATE-CURRENT-TIMESTAMP数据类型上做什么？"><a href="#16-TIMESTAMP在UPDATE-CURRENT-TIMESTAMP数据类型上做什么？" class="headerlink" title="16. TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？"></a>16. TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？</h3><p>创建表时TIMESTAMP列用Zero更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP修饰符就将时间戳字段更新为当前时间。</p><h3 id="17-主键和候选键有什么区别？"><a href="#17-主键和候选键有什么区别？" class="headerlink" title="17. 主键和候选键有什么区别？"></a>17. 主键和候选键有什么区别？</h3><p>表格的每一行都由主键唯一标识,一个表只有一个主键。</p><p>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</p><h3 id="18-如何使用Unix-shell登录Mysql？"><a href="#18-如何使用Unix-shell登录Mysql？" class="headerlink" title="18. 如何使用Unix shell登录Mysql？"></a>18. 如何使用Unix shell登录Mysql？</h3><p>我们可以通过以下命令登录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"># [mysql dir]<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>mysql <span class="hljs-operator">-</span>h hostname <span class="hljs-operator">-</span>u <span class="hljs-operator">-</span>p<br></code></pre></td></tr></table></figure><h3 id="19-myisamchk是用来做什么的？"><a href="#19-myisamchk是用来做什么的？" class="headerlink" title="19.  myisamchk是用来做什么的？"></a>19.  myisamchk是用来做什么的？</h3><p>它用来压缩MyISAM表，这减少了磁盘或内存使用。</p><h3 id="20-MYSQL数据库服务器性能分析的方法命令有哪些"><a href="#20-MYSQL数据库服务器性能分析的方法命令有哪些" class="headerlink" title="20. MYSQL数据库服务器性能分析的方法命令有哪些?"></a>20. MYSQL数据库服务器性能分析的方法命令有哪些?</h3><p>Show status</p><p>一些值得监控的变量值：</p><p>Bytes_received和Bytes_sent</p><p>和服务器之间来往的流量。</p><p>Com_*服务器正在执行的命令。</p><p>Created_*在查询执行期限间创建的临时表和文件。</p><p>Handler_*存储引擎操作。</p><p>Select_*不同类型的联接执行计划。</p><p>Sort_*几种排序信息。</p><p>Show session status like ‘Select’;</p><p>Show profiles</p><p>SET profiling&#x3D;1;</p><p>Show profiles \G</p><p>Show profile;</p><p>在MySQL中，你可以使用多种方法和命令来进行数据库服务器性能分析。以下是一些常用的方法和相关的命令：</p><ol><li><p><strong>SHOW STATUS</strong>：显示当前MySQL服务器的各种状态信息，包括连接数、查询数、缓存命中率等。可以通过查看这些状态信息来了解服务器的整体性能情况。</p></li><li><p><strong>SHOW PROCESSLIST</strong>：显示当前运行的所有MySQL进程，包括查询、连接等信息。通过查看当前进程列表，可以了解哪些查询正在执行，以及它们的状态和执行时间等信息。</p></li><li><p><strong>EXPLAIN</strong>：用于分析查询语句的执行计划。通过执行<code>EXPLAIN</code>命令，可以查看查询语句的执行计划，了解MySQL是如何执行查询的，以及是否使用了索引等信息。</p></li><li><p><strong>MySQL Performance Schema</strong>：MySQL Performance Schema是MySQL提供的一种性能监控和分析工具，可以用于收集和分析MySQL服务器的性能数据。通过分析Performance Schema中的各种性能指标和事件，可以更详细地了解MySQL服务器的性能状况。</p></li><li><p><strong>MySQL Slow Query Log</strong>：MySQL Slow Query Log是MySQL提供的一种记录慢查询的功能。通过启用Slow Query Log，并设置合适的阈值，可以记录下执行时间超过一定阈值的查询语句，从而帮助找出潜在的性能问题。</p></li><li><p><strong>MySQL Workbench Performance Dashboard</strong>：MySQL Workbench是MySQL官方提供的图形化管理工具，其中包含了Performance Dashboard功能，可以用于实时监控和分析MySQL服务器的性能数据，包括连接数、查询执行时间、缓存命中率等。</p></li><li><p><strong>Percona Toolkit</strong>：Percona Toolkit是一个由Percona提供的一组MySQL管理和监控工具，其中包含了一些用于性能分析的工具，例如pt-query-digest、pt-stalk等，可以用于分析慢查询、监控服务器性能等。</p></li></ol><p>这些方法和命令可以帮助你对MySQL数据库服务器的性能进行分析和监控，从而找出潜在的性能问题，并进行优化和调整。</p><h3 id="21-如何控制HEAP表的最大尺寸？"><a href="#21-如何控制HEAP表的最大尺寸？" class="headerlink" title="21. 如何控制HEAP表的最大尺寸？"></a>21. 如何控制HEAP表的最大尺寸？</h3><p>Heal表的大小可通过称为max_heap_table_size的Mysql配置变量来控制。</p><h3 id="22-MyISAM-Static和MyISAM-Dynamic有什么区别？"><a href="#22-MyISAM-Static和MyISAM-Dynamic有什么区别？" class="headerlink" title="22. MyISAM Static和MyISAM Dynamic有什么区别？"></a>22. MyISAM Static和MyISAM Dynamic有什么区别？</h3><p>在MyISAM Static上的所有字段有固定宽度。动态MyISAM表将具有像TEXT，BLOB等字段，以适应不同长度的数据类型。点击这里有一套最全阿里面试题总结。</p><p>MyISAM Static在受损情况下更容易恢复。</p><h3 id="23-federated表是什么？"><a href="#23-federated表是什么？" class="headerlink" title="23. federated表是什么？"></a>23. federated表是什么？</h3><p>federated表，允许访问位于其他服务器数据库上的表。</p><h3 id="24-如果一个表有一列定义为TIMESTAMP，将发生什么？"><a href="#24-如果一个表有一列定义为TIMESTAMP，将发生什么？" class="headerlink" title="24. 如果一个表有一列定义为TIMESTAMP，将发生什么？"></a>24. 如果一个表有一列定义为TIMESTAMP，将发生什么？</h3><p>每当行被更改时，时间戳字段将获取当前时间戳。</p><h3 id="25-列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？"><a href="#25-列设置为AUTO-INCREMENT时，如果在表中达到最大值，会发生什么情况？" class="headerlink" title="25. 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？"></a>25. 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？</h3><p>它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。</p><h3 id="26-怎样才能找出最后一次插入时分配了哪个自动增量？"><a href="#26-怎样才能找出最后一次插入时分配了哪个自动增量？" class="headerlink" title="26. 怎样才能找出最后一次插入时分配了哪个自动增量？"></a>26. 怎样才能找出最后一次插入时分配了哪个自动增量？</h3><p>LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。</p><h3 id="27-你怎么看到为表格定义的所有索引？"><a href="#27-你怎么看到为表格定义的所有索引？" class="headerlink" title="27. 你怎么看到为表格定义的所有索引？"></a>27. 你怎么看到为表格定义的所有索引？</h3><p>索引是通过以下方式为表格定义的：</p><p>SHOW INDEX FROM ;</p><h3 id="28-LIKE声明中的％和-是什么意思？"><a href="#28-LIKE声明中的％和-是什么意思？" class="headerlink" title="28.. LIKE声明中的％和_是什么意思？"></a>28.. LIKE声明中的％和_是什么意思？</h3><p>％对应于0个或更多字符，_ 只是LIKE语句中的一个字符。</p><h3 id="29-如何在Unix和Mysql时间戳之间进行转换？"><a href="#29-如何在Unix和Mysql时间戳之间进行转换？" class="headerlink" title="29. 如何在Unix和Mysql时间戳之间进行转换？"></a>29. 如何在Unix和Mysql时间戳之间进行转换？</h3><p>UNIX_TIMESTAMP是从Mysql时间戳转换为Unix时间戳的命令</p><p>FROM_UNIXTIME是从Unix时间戳转换为Mysql时间戳的命令</p><h3 id="30-列对比运算符是什么？"><a href="#30-列对比运算符是什么？" class="headerlink" title="30. 列对比运算符是什么？"></a>30. 列对比运算符是什么？</h3><p>在SELECT语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND，OR或LIKE运算符。</p><h3 id="31-我们如何得到受查询影响的行数？"><a href="#31-我们如何得到受查询影响的行数？" class="headerlink" title="31. 我们如何得到受查询影响的行数？"></a>31. 我们如何得到受查询影响的行数？</h3><p>行数可以通过以下代码获得：</p><p>SELECT COUNT(user_id)FROM users;</p><h3 id="32-Mysql查询是否区分大小写？"><a href="#32-Mysql查询是否区分大小写？" class="headerlink" title="32. Mysql查询是否区分大小写？"></a>32. Mysql查询是否区分大小写？</h3><p>不区分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> VERSION(), <span class="hljs-built_in">CURRENT_DATE</span>;<br><br><span class="hljs-keyword">SeLect</span> version(), <span class="hljs-built_in">current_date</span>;<br><br><span class="hljs-keyword">seleCt</span> vErSiOn(), <span class="hljs-built_in">current_DATE</span>;<br></code></pre></td></tr></table></figure><p>所有这些例子都是一样的，Mysql不区分大小写。</p><h3 id="33-LIKE和REGEXP操作有什么区别？"><a href="#33-LIKE和REGEXP操作有什么区别？" class="headerlink" title="33.. LIKE和REGEXP操作有什么区别？"></a>33.. LIKE和REGEXP操作有什么区别？</h3><p>LIKE和REGEXP运算符用于表示^和％。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> emp_name <span class="hljs-keyword">LIKE</span> &quot;%b&quot;;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> employee <span class="hljs-keyword">WHERE</span> emp_name REGEXP &quot;^b&quot;;<br></code></pre></td></tr></table></figure><h3 id="34-BLOB和TEXT有什么区别？"><a href="#34-BLOB和TEXT有什么区别？" class="headerlink" title="34.. BLOB和TEXT有什么区别？"></a>34.. BLOB和TEXT有什么区别？</h3><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB -</p><p>TINYBLOB</p><p>BLOB</p><p>MEDIUMBLOB和</p><p>LONGBLOB</p><p>它们只能在所能容纳价值的最大长度上有所不同。</p><p>TEXT是一个不区分大小写的BLOB。四种TEXT类型</p><p>TINYTEXT</p><p>TEXT</p><p>MEDIUMTEXT和</p><p>LONGTEXT</p><p>它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。</p><p>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。</p><h3 id="35-mysql-fetch-array和mysql-fetch-object的区别是什么？"><a href="#35-mysql-fetch-array和mysql-fetch-object的区别是什么？" class="headerlink" title="35. mysql_fetch_array和mysql_fetch_object的区别是什么？"></a>35. mysql_fetch_array和mysql_fetch_object的区别是什么？</h3><p>以下是mysql_fetch_array和mysql_fetch_object的区别：</p><ul><li><p>mysql_fetch_array（） - 将结果行作为关联数组或来自数据库的常规数组返回。</p></li><li><p>mysql_fetch_object - 从数据库返回结果行作为对象。</p></li></ul><h3 id="36-我们如何在mysql中运行批处理模式？"><a href="#36-我们如何在mysql中运行批处理模式？" class="headerlink" title="36. 我们如何在mysql中运行批处理模式？"></a>36. 我们如何在mysql中运行批处理模式？</h3><p>以下命令用于在批处理模式下运行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql;<br><br>mysql mysql.out<br></code></pre></td></tr></table></figure><h3 id="37-MyISAM表格将在哪里存储，并且还提供其存储格式？"><a href="#37-MyISAM表格将在哪里存储，并且还提供其存储格式？" class="headerlink" title="37. MyISAM表格将在哪里存储，并且还提供其存储格式？"></a>37. MyISAM表格将在哪里存储，并且还提供其存储格式？</h3><p>每个MyISAM表格以三种格式存储在磁盘上：</p><p>·“.frm”文件存储表定义</p><p>·数据文件具有“.MYD”（MYData）扩展名</p><p>索引文件具有“.MYI”（MYIndex）扩展名</p><h3 id="38-Mysql中有哪些不同的表格？"><a href="#38-Mysql中有哪些不同的表格？" class="headerlink" title="38. Mysql中有哪些不同的表格？"></a>38. Mysql中有哪些不同的表格？</h3><p>共有5种类型的表格：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coq">MyISAM<br><br><span class="hljs-keyword">Heap</span><br><br>Merge<br><br>INNODB<br><br>ISAM<br></code></pre></td></tr></table></figure><p>MyISAM是Mysql的默认存储引擎。</p><h3 id="39-ISAM是什么？"><a href="#39-ISAM是什么？" class="headerlink" title="39. ISAM是什么？"></a>39. ISAM是什么？</h3><p>ISAM简称为索引顺序访问方法。它是由IBM开发的，用于在磁带等辅助存储系统上存储和检索数据。</p><h3 id="40-InnoDB是什么？"><a href="#40-InnoDB是什么？" class="headerlink" title="40. InnoDB是什么？"></a>40. InnoDB是什么？</h3><p>lnnoDB是一个由Oracle公司开发的Innobase Oy事务安全存储引擎。</p><h3 id="41-Mysql如何优化DISTINCT？"><a href="#41-Mysql如何优化DISTINCT？" class="headerlink" title="41. Mysql如何优化DISTINCT？"></a>41. Mysql如何优化DISTINCT？</h3><p>DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> t1.a <span class="hljs-keyword">FROM</span> t1,t2 <span class="hljs-keyword">where</span> t1.a<span class="hljs-operator">=</span>t2.a;<br></code></pre></td></tr></table></figure><h3 id="42-如何输入字符为十六进制数字？"><a href="#42-如何输入字符为十六进制数字？" class="headerlink" title="42. 如何输入字符为十六进制数字？"></a>42. 如何输入字符为十六进制数字？</h3><p>如果想输入字符为十六进制数字，可以输入带有单引号的十六进制数字和前缀（X），或者只用（Ox）前缀输入十六进制数字。</p><p>如果表达式上下文是字符串，则十六进制数字串将自动转换为字符串。</p><h3 id="43-如何显示前50行？"><a href="#43-如何显示前50行？" class="headerlink" title="43. 如何显示前50行？"></a>43. 如何显示前50行？</h3><p>在Mysql中，使用以下代码查询显示前50行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span><br><br>LIMIT <span class="hljs-number">0</span>,<span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><h3 id="44-可以使用多少列创建索引？"><a href="#44-可以使用多少列创建索引？" class="headerlink" title="44. 可以使用多少列创建索引？"></a>44. 可以使用多少列创建索引？</h3><p>任何标准表最多可以创建16个索引列。</p><h3 id="45-NOW（）和CURRENT-DATE（）有什么区别？"><a href="#45-NOW（）和CURRENT-DATE（）有什么区别？" class="headerlink" title="45. NOW（）和CURRENT_DATE（）有什么区别？"></a>45. NOW（）和CURRENT_DATE（）有什么区别？</h3><p>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。</p><p>CURRENT_DATE（）仅显示当前年份，月份和日期。</p><h3 id="46-什么样的对象可以使用CREATE语句创建？"><a href="#46-什么样的对象可以使用CREATE语句创建？" class="headerlink" title="46. 什么样的对象可以使用CREATE语句创建？"></a>46. 什么样的对象可以使用CREATE语句创建？</h3><p>以下对象是使用CREATE语句创建的：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DATABASE</span><br><br>EVENT<br><br><span class="hljs-keyword">FUNCTION</span><br><br><span class="hljs-keyword">INDEX</span><br><br><span class="hljs-keyword">PROCEDURE</span><br><br><span class="hljs-keyword">TABLE</span><br><br><span class="hljs-keyword">TRIGGER</span><br><br><span class="hljs-keyword">USER</span><br><br><span class="hljs-keyword">VIEW</span><br></code></pre></td></tr></table></figure><h3 id="47-Mysql表中允许有多少个TRIGGERS？"><a href="#47-Mysql表中允许有多少个TRIGGERS？" class="headerlink" title="47. Mysql表中允许有多少个TRIGGERS？"></a>47. Mysql表中允许有多少个TRIGGERS？</h3><p>在Mysql表中允许有六个触发器，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">INSERT</span><br><br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span><br><br><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">UPDATE</span><br><br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">UPDATE</span><br><br><span class="hljs-keyword">BEFORE</span> <span class="hljs-keyword">DELETE</span><br><br><span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">DELETE</span><br></code></pre></td></tr></table></figure><h3 id="48-什么是非标准字符串类型？"><a href="#48-什么是非标准字符串类型？" class="headerlink" title="48. 什么是非标准字符串类型？"></a>48. 什么是非标准字符串类型？</h3><p>以下是非标准字符串类型：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">TINYTEXT<br><br><span class="hljs-built_in">TEXT</span><br><br>MEDIUMTEXT<br><br>LONGTEXT<br></code></pre></td></tr></table></figure><h3 id="49-什么是通用SQL函数？"><a href="#49-什么是通用SQL函数？" class="headerlink" title="49. 什么是通用SQL函数？"></a>49. 什么是通用SQL函数？</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade">CONCAT(A, B) - 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。<br><br>FORMAT(X, D)- 格式化数字X到D有效数字。<br><br>CURRDATE(), CURRTIME()- 返回当前日期或时间。<br><br><span class="hljs-built_in">NOW</span>（） - 将当前日期和时间作为一个值返回。<br><br><span class="hljs-built_in">MONTH</span>（），<span class="hljs-built_in">DAY</span>（），<span class="hljs-built_in">YEAR</span>（），<span class="hljs-built_in">WEEK</span>（），<span class="hljs-built_in">WEEKDAY</span>（） - 从日期值中提取给定数据。<br><br><span class="hljs-built_in">HOUR</span>（），<span class="hljs-built_in">MINUTE</span>（），<span class="hljs-built_in">SECOND</span>（） - 从时间值中提取给定数据。<br><br><span class="hljs-built_in">DATEDIFF</span>（A，B） - 确定两个日期之间的差异，通常用于计算年龄<br><br>SUBTIMES（A，B） - 确定两次之间的差异。<br><br>FROMDAYS（INT） - 将整数天数转换为日期值。<br></code></pre></td></tr></table></figure><h3 id="50-解释访问控制列表"><a href="#50-解释访问控制列表" class="headerlink" title="50. 解释访问控制列表"></a>50. 解释访问控制列表</h3><p>ACL（访问控制列表）是与对象关联的权限列表。这个列表是Mysql服务器安全模型的基础，它有助于排除用户无法连接的问题。</p><p>Mysql将ACL（也称为授权表）缓存在内存中。当用户尝试认证或运行命令时，Mysql会按照预定的顺序检查ACL的认证信息和权限。</p><h3 id="51-MYSQL支持事务吗？"><a href="#51-MYSQL支持事务吗？" class="headerlink" title="51. MYSQL支持事务吗？"></a>51. MYSQL支持事务吗？</h3><p>在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，mysql是不支持事务的。</p><p>但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET AUTOCOMMIT&#x3D;0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。</p><p>示例如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">一<br><br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><br><span class="hljs-keyword">SELECT</span> @A:=SUM(salary) <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span>=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">UPDATE</span> table2 <span class="hljs-keyword">SET</span> summmary=@A <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">type</span>=<span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><h3 id="52-mysql里记录货币用什么字段类型好"><a href="#52-mysql里记录货币用什么字段类型好" class="headerlink" title="52.  mysql里记录货币用什么字段类型好"></a>52.  mysql里记录货币用什么字段类型好</h3><p>NUMERIC和DECIMAL类型被Mysql实现为同样的类型，这在SQL92标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定；点击这里有一套最全阿里面试题总结。</p><p>例如：</p><p>salary DECIMAL(9,2)</p><p>在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。</p><p>因此，在这种情况下，能被存储在salary列中的值的范围是从-9999999.99到9999999.99。在ANSI&#x2F;ISO SQL92中，句法DECIMAL(p)等价于DECIMAL(p,0)。</p><p>同样，句法DECIMAL等价于DECIMAL(p,0)，这里实现被允许决定值p。Mysql当前不支持DECIMAL&#x2F;NUMERIC数据类型的这些变种形式的任一种。</p><p>这一般说来不是一个严重的问题，因为这些类型的主要益处得自于明显地控制精度和规模的能力。</p><p>DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</p><p>一个字符用于值的每一位. 小数点(如果scale&gt;0)和“-”符号(对于负值)。如果scale是0，DECIMAL和NUMERIC值不包含小数点或小数部分。</p><p>DECIMAL和NUMERIC值得最大的范围与DOUBLE一样，但是对于一个给定的DECIMAL或NUMERIC列，实际的范围可由制由给定列的precision或scale限制。</p><p>当这样的列赋给了小数点后面的位超过指定scale所允许的位的值，该值根据scale四舍五入。</p><p>当一个DECIMAL或NUMERIC列被赋给了其大小超过指定(或缺省的）precision和scale隐含的范围的值，Mysql存储表示那个范围的相应的端点值。</p><p>我希望本文可以帮助你提升技术水平。那些，感觉学的好难，甚至会令你沮丧的人，别担心，我认为，如果你愿意试一试本文介绍的几点，会向前迈进，克服这种感觉。这些要点也许对你不适用，但你会明确一个重要的道理：接受自己觉得受困这个事实是摆脱这个困境的第一步。</p><h3 id="53-MYSQL数据表在什么情况下容易损坏？"><a href="#53-MYSQL数据表在什么情况下容易损坏？" class="headerlink" title="53. MYSQL数据表在什么情况下容易损坏？"></a>53. MYSQL数据表在什么情况下容易损坏？</h3><p>服务器突然断电导致数据文件损坏。</p><p>强制关机，没有先关闭 mysql 服务等。</p><h3 id="54-mysql有关权限的表都有哪几个？"><a href="#54-mysql有关权限的表都有哪几个？" class="headerlink" title="54. mysql有关权限的表都有哪几个？"></a>54. mysql有关权限的表都有哪几个？</h3><p>Mysql服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。</p><h3 id="55-Mysql中有哪几种锁？"><a href="#55-Mysql中有哪几种锁？" class="headerlink" title="55. Mysql中有哪几种锁？"></a>55. Mysql中有哪几种锁？</h3><p>MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁。</p><ul><li><p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低</p></li><li><p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试合集搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搬运自用-大数据面试题合集</title>
    <link href="/2024/05/07/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <url>/2024/05/07/%E6%90%AC%E8%BF%90%E8%87%AA%E7%94%A8-%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>因为zjt老是把我叫走吃夜宵害我没空看面试所以存档一份。</p><h1 id="大数据面试题及答案"><a href="#大数据面试题及答案" class="headerlink" title="大数据面试题及答案"></a>大数据面试题及答案</h1><ul><li><p><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88">大数据面试题及答案</a></p><ul><li><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88-1">大数据面试题及答案</a><ul><li><a href="#1-kafka%E7%9A%84message%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF">1 kafka的message包括哪些信息</a></li><li><a href="#2-%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8Bkafka%E7%9A%84offset">2 怎么查看kafka的offset</a></li><li><a href="#3-hadoop%E7%9A%84shuffle%E8%BF%87%E7%A8%8B">3 hadoop的shuffle过程</a><ul><li><a href="#%E4%B8%80map%E7%AB%AF%E7%9A%84shuffle">一、Map端的shuffle</a></li><li><a href="#%E4%BA%8Creduce%E7%AB%AF%E7%9A%84shuffle">二、Reduce端的shuffle</a></li></ul></li><li><a href="#4-spark%E9%9B%86%E7%BE%A4%E8%BF%90%E7%AE%97%E7%9A%84%E6%A8%A1%E5%BC%8F">4 spark集群运算的模式</a></li><li><a href="#5-hdfs%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B">5 HDFS读写数据的过程</a></li><li><a href="#6-rdd%E4%B8%ADreducebykey%E4%B8%8Egroupbykey%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E5%A5%BD%E4%B8%BA%E4%BB%80%E4%B9%88">6 RDD中reduceBykey与groupByKey哪个性能好，为什么</a></li><li><a href="#7-spark20%E7%9A%84%E4%BA%86%E8%A7%A3">7 spark2.0的了解</a></li><li><a href="#8-rdd-%E6%80%8E%E4%B9%88%E5%88%86%E5%8C%BA%E5%AE%BD%E4%BE%9D%E8%B5%96%E5%92%8C%E7%AA%84%E4%BE%9D%E8%B5%96">8 rdd 怎么分区宽依赖和窄依赖</a></li><li><a href="#9-spark-streaming-%E8%AF%BB%E5%8F%96kafka%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">9 spark streaming 读取kafka数据的两种方式</a><ul><li><a href="#receiver-base">Receiver-base</a><ul><li><a href="#direct">Direct</a></li></ul></li></ul></li><li><a href="#10-kafka%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E7%A3%81%E7%9B%98">10 kafka的数据存在内存还是磁盘</a></li><li><a href="#11-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3kafka%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1">11 怎么解决kafka的数据丢失</a></li><li><a href="#12-fsimage%E5%92%8Cedit%E7%9A%84%E5%8C%BA%E5%88%AB">12 fsimage和edit的区别？</a></li><li><a href="#13-%E5%88%97%E4%B8%BE%E5%87%A0%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%98%E5%8C%96">13 列举几个配置文件优化？</a></li><li><a href="#14-datanode-%E9%A6%96%E6%AC%A1%E5%8A%A0%E5%85%A5-cluster-%E7%9A%84%E6%97%B6%E5%80%99%E5%A6%82%E6%9E%9C-log-%E6%8A%A5%E5%91%8A%E4%B8%8D%E5%85%BC%E5%AE%B9%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E9%82%A3%E9%9C%80%E8%A6%81namenode%E6%89%A7%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%93%8D%E4%BD%9C%E8%BF%99%E6%A0%B7%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF">14 datanode 首次加入 cluster 的时候，如果 log 报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？</a></li><li><a href="#15-mapreduce-%E4%B8%AD%E6%8E%92%E5%BA%8F%E5%8F%91%E7%94%9F%E5%9C%A8%E5%93%AA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%E8%BF%99%E4%BA%9B%E6%8E%92%E5%BA%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E4%B8%BA%E4%BB%80%E4%B9%88">15 MapReduce 中排序发生在哪几个阶段？这些排序是否可以避免？为什么？</a></li><li><a href="#16-hadoop%E7%9A%84%E4%BC%98%E5%8C%96">16 hadoop的优化？</a></li><li><a href="#17-%E8%AE%BE%E8%AE%A1%E9%A2%98">17 设计题</a></li><li><a href="#18-%E6%9C%89-10-%E4%B8%AA%E6%96%87%E4%BB%B6%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6-1g%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%AF%8F%E4%B8%80%E8%A1%8C%E5%AD%98%E6%94%BE%E7%9A%84%E9%83%BD%E6%98%AF%E7%94%A8%E6%88%B7%E7%9A%84-query%E6%AF%8F%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84query-%E9%83%BD%E5%8F%AF%E8%83%BD%E9%87%8D%E5%A4%8D%E8%A6%81%E6%B1%82%E4%BD%A0%E6%8C%89%E7%85%A7-query-%E7%9A%84%E9%A2%91%E5%BA%A6%E6%8E%92%E5%BA%8F%E8%BF%98%E6%98%AF%E5%85%B8%E5%9E%8B%E7%9A%84-top-k-%E7%AE%97%E6%B3%95">18 有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的query 都可能重复。要求你按照 query 的频度排序。还是典型的 TOP K 算法</a></li><li><a href="#19-%E5%9C%A825%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B4%E6%95%B0%E6%B3%A8%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E4%BB%A5%E5%AE%B9%E7%BA%B3%E8%BF%9925%E4%BA%BF%E4%B8%AA%E6%95%B4%E6%95%B0">19 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</a></li><li><a href="#20-%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%BB%9940%E4%BA%BF%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84-unsigned-int-%E7%9A%84%E6%95%B4%E6%95%B0%E6%B2%A1%E6%8E%92%E8%BF%87%E5%BA%8F%E7%9A%84%E7%84%B6%E5%90%8E%E5%86%8D%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E8%BF%99%E4%B8%AA%E6%95%B0%E6%98%AF%E5%90%A6%E5%9C%A8%E9%82%A3-40-%E4%BA%BF%E4%B8%AA%E6%95%B0%E5%BD%93%E4%B8%AD">20 腾讯面试题：给40亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</a></li><li><a href="#21-%E6%80%8E%E4%B9%88%E5%9C%A8%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%80%E4%B8%AA">21 怎么在海量数据中找出重复次数最多的一个？</a></li><li><a href="#22-%E4%B8%8A%E5%8D%83%E4%B8%87%E6%88%96%E4%B8%8A%E4%BA%BF%E6%95%B0%E6%8D%AE%E6%9C%89%E9%87%8D%E5%A4%8D%E7%BB%9F%E8%AE%A1%E5%85%B6%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E9%92%B1-n-%E4%B8%AA%E6%95%B0%E6%8D%AE">22 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。</a></li><li><a href="#23-%E4%B8%80%E4%B8%AA%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%A7%E7%BA%A6%E6%9C%89%E4%B8%80%E4%B8%87%E8%A1%8C%E6%AF%8F%E8%A1%8C%E4%B8%80%E4%B8%AA%E8%AF%8D%E8%A6%81%E6%B1%82%E7%BB%9F%E8%AE%A1%E5%87%BA%E5%85%B6%E4%B8%AD%E6%9C%80%E9%A2%91%E7%B9%81%E5%87%BA%E7%8E%B0%E7%9A%84%E5%89%8D-10-%E4%B8%AA%E8%AF%8D%E7%BB%99%E5%87%BA%E6%80%9D%E6%83%B3%E7%BB%99%E5%87%BA%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">23 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，给出思想，给出时间复杂度分析。</a></li><li><a href="#24-100w-%E4%B8%AA%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E7%9A%84-100-%E4%B8%AA%E6%95%B0">24 100w 个数中找出最大的 100 个数。</a></li><li><a href="#25-%E6%9C%89%E4%B8%80%E5%8D%83%E4%B8%87%E6%9D%A1%E7%9F%AD%E4%BF%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E4%BB%A5%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%BD%A2%E5%BC%8F%E4%BF%9D%E5%AD%98%E4%B8%80%E8%A1%8C%E4%B8%80%E6%9D%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E8%AF%B7%E7%94%A8-5-%E5%88%86%E9%92%9F%E6%97%B6%E9%97%B4%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%89%8D-10-%E6%9D%A1">25 有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用 5 分钟时间，找出重复出现最多的前 10 条。</a></li></ul></li></ul><h2 id="大数据面试题及答案-1"><a href="#大数据面试题及答案-1" class="headerlink" title="大数据面试题及答案"></a>大数据面试题及答案</h2><h3 id="1-kafka的message包括哪些信息"><a href="#1-kafka的message包括哪些信息" class="headerlink" title="1 kafka的message包括哪些信息"></a>1 kafka的message包括哪些信息</h3><p> 一个Kafka的Message由一个固定长度的header和一个变长的消息体body组成<br> header部分由一个字节的magic(文件格式)和四个字节的CRC32(用于判断body消息体是否正常)构成。当magic的值为1的时候，会在magic和crc32之间多一个字节的数据：attributes(保存一些相关属性，比如是否压缩、压缩格式等等)；如果magic的值为0，那么不存在attributes属性<br> body是由N个字节构成的一个消息体，包含了具体的key&#x2F;value消息</p><h3 id="2-怎么查看kafka的offset"><a href="#2-怎么查看kafka的offset" class="headerlink" title="2 怎么查看kafka的offset"></a>2 怎么查看kafka的offset</h3><p> 0.9版本以上，可以用最新的Consumer client 客户端，有consumer.seekToEnd() &#x2F; consumer.position() 可以用于得到当前最新的offset：</p><h3 id="3-hadoop的shuffle过程"><a href="#3-hadoop的shuffle过程" class="headerlink" title="3 hadoop的shuffle过程"></a>3 hadoop的shuffle过程</h3><h4 id="一、Map端的shuffle"><a href="#一、Map端的shuffle" class="headerlink" title="一、Map端的shuffle"></a>一、Map端的shuffle</h4><p> 　　Map端会处理输入数据并产生中间结果，这个中间结果会写到本地磁盘，而不是HDFS。每个Map的输出会先写到内存缓冲区中，当写入的数据达到设定的阈值时，系统将会启动一个线程将缓冲区的数据写到磁盘，这个过程叫做spill。<br> 　　在spill写入之前，会先进行二次排序，首先根据数据所属的partition进行排序，然后每个partition中的数据再按key来排序。partition的目是将记录划分到不同的Reducer上去，以期望能够达到负载均衡，以后的Reducer就会根据partition来读取自己对应的数据。接着运行combiner(如果设置了的话)，combiner的本质也是一个Reducer，其目的是对将要写入到磁盘上的文件先进行一次处理，这样，写入到磁盘的数据量就会减少。最后将数据写到本地磁盘产生spill文件(spill文件保存在{mapred.local.dir}指定的目录中，Map任务结束后就会被删除)。</p><p> 　　最后，每个Map任务可能产生多个spill文件，在每个Map任务完成前，会通过多路归并算法将这些spill文件归并成一个文件。至此，Map的shuffle过程就结束了。</p><h4 id="二、Reduce端的shuffle"><a href="#二、Reduce端的shuffle" class="headerlink" title="二、Reduce端的shuffle"></a>二、Reduce端的shuffle</h4><p> 　　Reduce端的shuffle主要包括三个阶段，copy、sort(merge)和reduce。<br> 　　首先要将Map端产生的输出文件拷贝到Reduce端，但每个Reducer如何知道自己应该处理哪些数据呢？因为Map端进行partition的时候，实际上就相当于指定了每个Reducer要处理的数据(partition就对应了Reducer)，所以Reducer在拷贝数据的时候只需拷贝与自己对应的partition中的数据即可。每个Reducer会处理一个或者多个partition，但需要先将自己对应的partition中的数据从每个Map的输出结果中拷贝过来。<br> 　　接下来就是sort阶段，也成为merge阶段，因为这个阶段的主要工作是执行了归并排序。从Map端拷贝到Reduce端的数据都是有序的，所以很适合归并排序。最终在Reduce端生成一个较大的文件作为Reduce的输入。</p><p> 　　最后就是Reduce过程了，在这个过程中产生了最终的输出结果，并将其写到HDFS上。</p><h3 id="4-spark集群运算的模式"><a href="#4-spark集群运算的模式" class="headerlink" title="4 spark集群运算的模式"></a>4 spark集群运算的模式</h3><p> Spark 有很多种模式，最简单就是单机本地模式，还有单机伪分布式模式，复杂的则运行在集群中，目前能很好的运行在 Yarn和 Mesos 中，当然 Spark 还有自带的 Standalone 模式，对于大多数情况 Standalone 模式就足够了，如果企业已经有 Yarn 或者 Mesos 环境，也是很方便部署的。<br> standalone(集群模式)：典型的Mater&#x2F;slave模式，不过也能看出Master是有单点故障的；Spark支持ZooKeeper来实现 HA<br> on yarn(集群模式)： 运行在 yarn 资源管理器框架之上，由 yarn 负责资源管理，Spark 负责任务调度和计算<br> on mesos(集群模式)： 运行在 mesos 资源管理器框架之上，由 mesos 负责资源管理，Spark 负责任务调度和计算<br> on cloud(集群模式)：比如 AWS 的 EC2，使用这个模式能很方便的访问 Amazon的 S3;Spark 支持多种分布式存储系统：HDFS 和 S3</p><h3 id="5-HDFS读写数据的过程"><a href="#5-HDFS读写数据的过程" class="headerlink" title="5 HDFS读写数据的过程"></a>5 HDFS读写数据的过程</h3><p> <strong>读：</strong><br> 1、跟namenode通信查询元数据，找到文件块所在的datanode服务器<br> 2、挑选一台datanode（就近原则，然后随机）服务器，请求建立socket流<br> 3、datanode开始发送数据（从磁盘里面读取数据放入流，以packet为单位来做校验）<br> 4、客户端以packet为单位接收，现在本地缓存，然后写入目标文件<br> <img src="https://abumaster.oss-cn-beijing.aliyuncs.com/img/fix-dir/2021/08/29/17-19-32124c8fda5fcebef7af66ce6b384f8e-20210829171928-9cce98.png" alt="HDFS读流程"></p><p> <strong>写：</strong><br> 1、根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在<br> 2、namenode返回是否可以上传<br> 3、client请求第一个 block该传输到哪些datanode服务器上<br> 4、namenode返回3个datanode服务器ABC<br> 5、client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将真个pipeline建立完成，逐级返回客户端<br> 6、client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答<br> 7、当一个block传输完成之后，client再次请求namenode上传第二个block的服务器。<br> <img src="https://abumaster.oss-cn-beijing.aliyuncs.com/img/fix-dir/2021/08/29/17-29-03c90c9fb9679c5b96cde953eb36c97d-20210829172955-4f3dd5.png" alt="HDFS写流程"></p><h3 id="6-RDD中reduceBykey与groupByKey哪个性能好，为什么"><a href="#6-RDD中reduceBykey与groupByKey哪个性能好，为什么" class="headerlink" title="6 RDD中reduceBykey与groupByKey哪个性能好，为什么"></a>6 RDD中reduceBykey与groupByKey哪个性能好，为什么</h3><pre><code class="hljs"> reduceByKey：reduceByKey会在结果发送至reducer之前会对每个mapper在本地进行merge，有点类似于在MapReduce中的combiner。这样做的好处在于，在map端进行一次reduce之后，数据量会大幅度减小，从而减小传输，保证reduce端能够更快的进行结果计算。 groupByKey：groupByKey会对每一个RDD中的value值进行聚合形成一个序列(Iterator)，此操作发生在reduce端，所以势必会将所有的数据通过网络进行传输，造成不必要的浪费。同时如果数据量十分大，可能还会造成OutOfMemoryError。</code></pre><p>  通过以上对比可以发现在进行大量数据的reduce操作时候建议使用reduceByKey。不仅可以提高速度，还是可以防止使用groupByKey造成的内存溢出问题。</p><h3 id="7-spark2-0的了解"><a href="#7-spark2-0的了解" class="headerlink" title="7 spark2.0的了解"></a>7 spark2.0的了解</h3><pre><code class="hljs"> 更简单：ANSI SQL与更合理的API 速度更快：用Spark作为编译器 更智能：Structured Streaming</code></pre><h3 id="8-rdd-怎么分区宽依赖和窄依赖"><a href="#8-rdd-怎么分区宽依赖和窄依赖" class="headerlink" title="8 rdd 怎么分区宽依赖和窄依赖"></a>8 rdd 怎么分区宽依赖和窄依赖</h3><p> 宽依赖：父RDD的分区被子RDD的多个分区使用   例如 groupByKey、reduceByKey、sortByKey等操作会产生宽依赖，会产生shuffle<br> 窄依赖：父RDD的每个分区都只被子RDD的一个分区使用  例如map、filter、union等操作会产生窄依赖</p><h3 id="9-spark-streaming-读取kafka数据的两种方式"><a href="#9-spark-streaming-读取kafka数据的两种方式" class="headerlink" title="9 spark streaming 读取kafka数据的两种方式"></a>9 spark streaming 读取kafka数据的两种方式</h3><p> 这两种方式分别是：</p><h4 id="Receiver-base"><a href="#Receiver-base" class="headerlink" title="Receiver-base"></a>Receiver-base</h4><p> 使用Kafka的高层次Consumer API来实现。receiver从Kafka中获取的数据都存储在Spark Executor的内存中，然后Spark Streaming启动的job会去处理那些数据。然而，在默认的配置下，这种方式可能会因为底层的失败而丢失数据。如果要启用高可靠机制，让数据零丢失，就必须启用Spark Streaming的预写日志机制（Write Ahead Log，WAL）。该机制会同步地将接收到的Kafka数据写入分布式文件系统（比如HDFS）上的预写日志中。所以，即使底层节点出现了失败，也可以使用预写日志中的数据进行恢复。</p><h5 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h5><p> Spark1.3中引入Direct方式，用来替代掉使用Receiver接收数据，这种方式会周期性地查询Kafka，获得每个topic+partition的最新的offset，从而定义每个batch的offset的范围。当处理数据的job启动时，就会使用Kafka的简单consumer api来获取Kafka指定offset范围的数据。</p><h3 id="10-kafka的数据存在内存还是磁盘"><a href="#10-kafka的数据存在内存还是磁盘" class="headerlink" title="10 kafka的数据存在内存还是磁盘"></a>10 kafka的数据存在内存还是磁盘</h3><p> Kafka最核心的思想是使用磁盘，而不是使用内存，可能所有人都会认为，内存的速度一定比磁盘快，我也不例外。在看了Kafka的设计思想，查阅了相应资料再加上自己的测试后，发现磁盘的顺序读写速度和内存持平。<br> 而且Linux对于磁盘的读写优化也比较多，包括read-ahead和write-behind，磁盘缓存等。如果在内存做这些操作的时候，一个是JAVA对象的内存开销很大，另一个是随着堆内存数据的增多，JAVA的GC时间会变得很长，使用磁盘操作有以下几个好处：<br> 磁盘缓存由Linux系统维护，减少了程序员的不少工作。<br> 磁盘顺序读写速度超过内存随机读写。<br> JVM的GC效率低，内存占用大。使用磁盘可以避免这一问题。<br> 系统冷启动后，磁盘缓存依然可用。</p><h3 id="11-怎么解决kafka的数据丢失"><a href="#11-怎么解决kafka的数据丢失" class="headerlink" title="11 怎么解决kafka的数据丢失"></a>11 怎么解决kafka的数据丢失</h3><p> producer端：<br> 宏观上看保证数据的可靠安全性，肯定是依据分区数做好数据备份，设立副本数。<br> broker端：<br> topic设置多分区，分区自适应所在机器，为了让各分区均匀分布在所在的broker中，分区数要大于broker数。<br> 分区是kafka进行并行读写的单位，是提升kafka速度的关键。<br> Consumer端<br> consumer端丢失消息的情形比较简单：如果在消息处理完成前就提交了offset，那么就有可能造成数据的丢失。由于Kafka consumer默认是自动提交位移的，所以在后台提交位移前一定要保证消息被正常处理了，因此不建议采用很重的处理逻辑，如果处理耗时很长，则建议把逻辑放到另一个线程中去做。为了避免数据丢失，现给出两点建议：<br> enable.auto.commit&#x3D;false  关闭自动提交位移<br> 在消息被完整处理之后再手动提交位移</p><h3 id="12-fsimage和edit的区别？"><a href="#12-fsimage和edit的区别？" class="headerlink" title="12 fsimage和edit的区别？"></a>12 fsimage和edit的区别？</h3><p>   大家都知道namenode与secondary namenode 的关系，当他们要进行数据同步时叫做checkpoint时就用到了fsimage与edit，fsimage是保存最新的元数据的信息，当fsimage数据到一定的大小事会去生成一个新的文件来保存元数据的信息，这个新的文件就是edit，edit会回滚最新的数据。</p><h3 id="13-列举几个配置文件优化？"><a href="#13-列举几个配置文件优化？" class="headerlink" title="13 列举几个配置文件优化？"></a>13 列举几个配置文件优化？</h3><p>   1）Core-site.xml 文件的优化<br>     a、fs.trash.interval，默认值： 0；说明： 这个是开启hdfs文件删除自动转移到垃圾箱的选项，值为垃圾箱文件清除时间。一般开启这个会比较好，以防错误删除重要文件。单位是分钟。<br>     b、dfs.namenode.handler.count，默认值：10；说明：hadoop系统里启动的任务线程数，这里改为40，同样可以尝试该值大小对效率的影响变化进行最合适的值的设定。<br>     c、mapreduce.tasktracker.http.threads，默认值：40；说明：map和reduce是通过http进行数据传输的，这个是设置传输的并行线程数。</p><h3 id="14-datanode-首次加入-cluster-的时候，如果-log-报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？"><a href="#14-datanode-首次加入-cluster-的时候，如果-log-报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？" class="headerlink" title="14 datanode 首次加入 cluster 的时候，如果 log 报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？"></a>14 datanode 首次加入 cluster 的时候，如果 log 报告不兼容文件版本，那需要namenode执行格式化操作，这样处理的原因是？</h3><p>   1）这样处理是不合理的，因为那么 namenode 格式化操作，是对文件系统进行格式化，namenode 格式化时清空 dfs&#x2F;name 下空两个目录下的所有文件，之后，会在目录 dfs.name.dir 下创建文件。<br>   2）文本不兼容，有可能时 namenode 与 datanode 的 数据里的 namespaceID、clusterID 不一致，找到两个 ID 位置，修改为一样即可解决。</p><h3 id="15-MapReduce-中排序发生在哪几个阶段？这些排序是否可以避免？为什么？"><a href="#15-MapReduce-中排序发生在哪几个阶段？这些排序是否可以避免？为什么？" class="headerlink" title="15 MapReduce 中排序发生在哪几个阶段？这些排序是否可以避免？为什么？"></a>15 MapReduce 中排序发生在哪几个阶段？这些排序是否可以避免？为什么？</h3><p>   1）一个 MapReduce 作业由 Map 阶段和 Reduce 阶段两部分组成，这两阶段会对数据排序，从这个意义上说，MapReduce 框架本质就是一个 Distributed Sort。<br>   2）在 Map 阶段，Map Task 会在本地磁盘输出一个按照 key 排序（采用的是快速排序）的文件（中间可能产生多个文件，但最终会合并成一个），在 Reduce 阶段，每个 Reduce Task 会对收到的数据排序，这样，数据便按照 Key 分成了若干组，之后以组为单位交给 reduce（）处理。<br>   3）很多人的误解在 Map 阶段，如果不使用 Combiner便不会排序，这是错误的，不管你用不用 Combiner，Map Task 均会对产生的数据排序（如果没有 Reduce Task，则不会排序，实际上 Map 阶段的排序就是为了减轻 Reduce端排序负载）。<br>   4）由于这些排序是 MapReduce 自动完成的，用户无法控制，因此，在hadoop 1.x 中无法避免，也不可以关闭，但 hadoop2.x 是可以关闭的。</p><h3 id="16-hadoop的优化？"><a href="#16-hadoop的优化？" class="headerlink" title="16 hadoop的优化？"></a>16 hadoop的优化？</h3><p>   1）优化的思路可以从配置文件和系统以及代码的设计思路来优化<br>   2）配置文件的优化：调节适当的参数，在调参数时要进行测试<br>   3）代码的优化：combiner的个数尽量与reduce的个数相同，数据的类型保持一致，可以减少拆包与封包的进度<br>   4）系统的优化：可以设置linux系统打开最大的文件数预计网络的带宽MTU的配置<br>   5）为 job 添加一个 Combiner，可以大大的减少shuffer阶段的maoTask拷贝过来给远程的   reduce task的数据量，一般而言combiner与reduce相同。<br>   6）在开发中尽量使用stringBuffer而不是string，string的模式是read-only的，如果对它进行修改，会产生临时的对象，二stringBuffer是可修改的，不会产生临时对象。<br>   7）修改一下配置：以下是修改 mapred-site.xml 文件<br>     a、修改最大槽位数：槽位数是在各个 tasktracker 上的 mapred-site.xml 上设置的，默认都是 2<br> <property><br> <name>mapred.tasktracker.map.tasks.maximum</name><br> <value>2</value><br> </property><br> <property><br> <name>mapred.tasktracker.reduce.tasks.maximum</name><br> <value>2</value><br> </property><br>     b、调整心跳间隔：集群规模小于 300 时，心跳间隔为 300 毫秒<br> mapreduce.jobtracker.heartbeat.interval.min 心跳时间<br> mapred.heartbeats.in.second 集群每增加多少节点，时间增加下面的值<br> mapreduce.jobtracker.heartbeat.scaling.factor 集群每增加上面的个数，心跳增多少<br>     c、启动带外心跳<br> mapreduce.tasktracker.outofband.heartbeat 默认是 false<br>     d、配置多块磁盘<br> mapreduce.local.dir<br>     e、配置 RPC hander 数目<br> mapred.job.tracker.handler.count 默认是 10，可以改成 50，根据机器的能力<br>     f、配置 HTTP 线程数目<br> tasktracker.http.threads 默认是 40，可以改成 100 根据机器的能力<br>     g、选择合适的压缩方式，以 snappy 为例：<br> <property><br> <name>mapred.compress.map.output</name><br> <value>true</value><br> </property><br> <property><br> <name>mapred.map.output.compression.codec</name><br> <value>org.apache.hadoop.io.compress.SnappyCodec</value><br> </property></p><h3 id="17-设计题"><a href="#17-设计题" class="headerlink" title="17 设计题"></a>17 设计题</h3><p>   1）采集nginx产生的日志，日志的格式为user  ip   time  url   htmlId  每天产生的文件的数据量上亿条，请设计方案把数据保存到HDFS上，并提供一下实时查询的功能（响应时间小于3s）<br> A、某个用户某天访问某个URL的次数<br> B、某个URL某天被访问的总次数<br> 实时思路是：使用Logstash + Kafka + Spark-streaming + Redis + 报表展示平台<br> 离线的思路是：Logstash + Kafka + Elasticsearch +  Spark-streaming + 关系型数据库<br> A、B、数据在进入到Spark-streaming 中进行过滤，把符合要求的数据保存到Redis中</p><h3 id="18-有-10-个文件，每个文件-1G，每个文件的每一行存放的都是用户的-query，每个文件的query-都可能重复。要求你按照-query-的频度排序。还是典型的-TOP-K-算法"><a href="#18-有-10-个文件，每个文件-1G，每个文件的每一行存放的都是用户的-query，每个文件的query-都可能重复。要求你按照-query-的频度排序。还是典型的-TOP-K-算法" class="headerlink" title="18 有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的query 都可能重复。要求你按照 query 的频度排序。还是典型的 TOP K 算法"></a>18 有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的 query，每个文件的query 都可能重复。要求你按照 query 的频度排序。还是典型的 TOP K 算法</h3><p>   解决方案如下：<br>     1）方案 1：<br>     顺序读取 10 个文件，按照 hash(query)%10 的结果将 query 写入到另外 10 个文件（记为）中。这样新生成的文件每个的大小大约也 1G（假设 hash 函数是随机的）。 找一台内存在 2G 左右的机器，依次对用 hash_map(query, query_count)来统计每个query 出现的次数。利用快速&#x2F;堆&#x2F;归并排序按照出现次数进行排序。将排序好的 query 和对应的 query_cout 输出到文件中。这样得到了 10 个排好序的文件（记为）。 对这 10 个文件进行归并排序（内排序与外排序相结合）。<br>     2）方案 2：<br>     一般 query 的总量是有限的，只是重复的次数比较多而已，可能对于所有的 query，一次性就可以加入到内存了。这样，我们就可以采用 trie 树&#x2F;hash_map等直接来统计每个 query出现的次数，然后按出现次数做快速&#x2F;堆&#x2F;归并排序就可以了。<br>     3）方案 3：<br>     与方案 1 类似，但在做完 hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如 MapReduce），最后再进行合并。</p><h3 id="19-在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。"><a href="#19-在2-5亿个整数中找出不重复的整数，注，内存不足以容纳这2-5亿个整数。" class="headerlink" title="19 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。"></a>19 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。</h3><p>   1）方案 1：采用 2-Bitmap（每个数分配 2bit，00 表示不存在，01 表示出现一次，10 表示多次，11 无意义）进行，共需内存 2^32 * 2 bit&#x3D;1 GB 内存，还可以接受。然后扫描这 2.5亿个整数，查看 Bitmap 中相对应位，如果是 00 变 01，01 变 10，10 保持不变。所描完事后，查看 bitmap，把对应位是 01 的整数输出即可。<br>   2）方案 2：也可采用与第 1 题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。</p><h3 id="20-腾讯面试题：给40亿个不重复的-unsigned-int-的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那-40-亿个数当中？"><a href="#20-腾讯面试题：给40亿个不重复的-unsigned-int-的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那-40-亿个数当中？" class="headerlink" title="20 腾讯面试题：给40亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？"></a>20 腾讯面试题：给40亿个不重复的 unsigned int 的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那 40 亿个数当中？</h3><p>   1）方案 1：oo，申请 512M 的内存，一个 bit 位代表一个 unsigned int 值。读入 40 亿个数，设置相应的 bit 位，读入要查询的数，查看相应 bit 位是否为 1，为 1 表示存在，为 0 表示不存在。<br>   2）方案 2：这个问题在《编程珠玑》里有很好的描述，大家可以参考下面的思路，探讨一下： 又因为 2^32 为 40 亿多，所以给定一个数可能在，也可能不在其中； 这里我们把 40 亿个数中的每一个用 32 位的二进制来表示 ，假设这 40 亿个数开始放在一个文件中。 然后将这 40 亿个数分成两类:<br> 1.最高位为 0<br> 2.最高位为 1<br>     并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;&#x3D;20 亿，而另一个&gt;&#x3D;20 亿（这相当于折半了）； 与要查找的数的最高位比较并接着进入相应的文件再查找 再然后把这个文件为又分成两类:<br> 1.次最高位为 0<br> 2.次最高位为 1<br>     并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;&#x3D;10 亿，而另一个&gt;&#x3D;10 亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。<br> …..<br>     以此类推，就可以找到了,而且时间复杂度为 O(logn)，方案 2 完。<br>   3)附：这里，再简单介绍下，位图方法： 使用位图法判断整形数组是否存在重复 ,判断集合中存在重复是常见编程任务之一，当集合中数据量比较大时我们通常希望少进行几次扫描，这时双重循环法就不可取了。<br>     位图法比较适合于这种情况，它的做法是按照集合中最大元素 max 创建一个长度为 max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上 1，如遇到 5 就给新数组的第六个元素置 1，这样下次再遇到 5 想置位时发现新数组的第六个元素已经是 1 了，这说明这次的数据肯定和以前的数据存在着重复。这 种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。它的运算次数最坏的情况为 2N。如果已知数组的最大值即能事先给新数组定长的话效 率还能提高一倍。</p><h3 id="21-怎么在海量数据中找出重复次数最多的一个？"><a href="#21-怎么在海量数据中找出重复次数最多的一个？" class="headerlink" title="21 怎么在海量数据中找出重复次数最多的一个？"></a>21 怎么在海量数据中找出重复次数最多的一个？</h3><p>   1）方案 1：先做 hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。</p><h3 id="22-上千万或上亿数据（有重复），统计其中出现次数最多的钱-N-个数据。"><a href="#22-上千万或上亿数据（有重复），统计其中出现次数最多的钱-N-个数据。" class="headerlink" title="22 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。"></a>22 上千万或上亿数据（有重复），统计其中出现次数最多的钱 N 个数据。</h3><p>   1）方案 1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用 hash_map&#x2F;搜索二叉树&#x2F;红黑树等来进行统计次数。然后就是取出前 N 个出现次数最多的数据了，可以用第 2 题提到的堆机制完成。</p><h3 id="23-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前-10-个词，给出思想，给出时间复杂度分析。"><a href="#23-一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前-10-个词，给出思想，给出时间复杂度分析。" class="headerlink" title="23 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，给出思想，给出时间复杂度分析。"></a>23 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前 10 个词，给出思想，给出时间复杂度分析。</h3><p>   1）方案 1：这题是考虑时间效率。用 trie 树统计每个词出现的次数，时间复杂度是 O(n<em>le)（le表示单词的平准长度）。然后是找出出现最频繁的前 10 个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是 O(n</em>lg10)。所以总的时间复杂度，是 O(n<em>le)与 O(n</em>lg10)中较大的哪一 个。</p><h3 id="24-100w-个数中找出最大的-100-个数。"><a href="#24-100w-个数中找出最大的-100-个数。" class="headerlink" title="24 100w 个数中找出最大的 100 个数。"></a>24 100w 个数中找出最大的 100 个数。</h3><p>   1）方案 1：在前面的题中，我们已经提到了，用一个含 100 个元素的最小堆完成。复杂度为O(100w<em>lg100)。<br>   2）方案 2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比 100 多的时候，采用传统排序算法排序，取前 100 个。复杂度为 O(100w</em>100)。<br>   3）方案 3：采用局部淘汰法。选取前 100 个元素，并排序，记为序列 L。然后一次扫描剩余的元素 x，与排好序的 100 个元素中最小的元素比，如果比这个最小的 要大，那么把这个最小的元素删除，并把 x 利用插入排序的思想，插入到序列 L 中。依次循环，直到扫描了所有的元素。复杂度为 O(100w*100)。</p><h3 id="25-有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用-5-分钟时间，找出重复出现最多的前-10-条。"><a href="#25-有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用-5-分钟时间，找出重复出现最多的前-10-条。" class="headerlink" title="25 有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用 5 分钟时间，找出重复出现最多的前 10 条。"></a>25 有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。请用 5 分钟时间，找出重复出现最多的前 10 条。</h3><p>   1）分析： 常规方法是先排序，在遍历一次，找出重复最多的前 10 条。但是排序的算法复杂度最低为nlgn。<br>   2）可以设计一个 hash_table, hash_map&lt;string, int&gt;，依次读取一千万条短信，加载到hash_table 表中，并且统计重复的次数，与此同时维护一张最多 10 条的短信表。 这样遍历一次就能找出最多的前 10 条，算法复杂度为 O(n)。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试合集搬运</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>演练</title>
    <link href="/2024/05/07/%E6%BC%94%E7%BB%83/"/>
    <url>/2024/05/07/%E6%BC%94%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<p>吸取上次xhs笔试失败经验（题没刷完就去匆匆笔试</p><p>这次简历一投就去techguide里刷题了</p><p>but shoppee给数据的方式看着好怪，就算不一定真的给这么怪的输入样例hyx也不能掉以轻心！</p><p>它给的测试样例是这样的：[10,2]</p><p>我试问最后官网上难道也有那两个方括号吗，，如果我没准备过一眼看到会心态颤抖一下，，但是时间是金钱，于是hyx把这点也考虑到了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>    vector&lt;string&gt;strnum;<br>    <span class="hljs-comment">// int cur = 0;</span><br>    string temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span> (s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>|| s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            <span class="hljs-comment">// 非数字字符，忽略</span><br>            strnum.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-comment">// cur = cur + 1;</span><br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp=temp+s[i];<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-type">int</span> size = strnum.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        cout&lt;&lt;strnum[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shoppee笔试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hadoop+python实现博客中文词频统计</title>
    <link href="/2024/05/05/Hadoop-python%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/"/>
    <url>/2024/05/05/Hadoop-python%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>一时兴起想做个博客关键词统计！（如果有空的话看看能不能打包成插件发布到hexo上面）<br><img src="/../img/hadoop%E6%88%90%E5%93%81/wordcloud.png" alt="词云图example"><br>看到的时候还有点纳闷怎么“父亲”和“母亲”两个这么书面的词出现频率那么高，后来仔细一看——鉴定为看弗兰肯斯坦看的（之前读评论文的时候写了一堆）。</p><p>po一个小小的攻略在这里！（项目地址：<a href="https://github.com/Liebe-grausam/hadoop_chinese_wordcount%EF%BC%89">https://github.com/Liebe-grausam/hadoop_chinese_wordcount）</a></p><p>前置准备：ubuntu20.04 + hadoop环境，以及python文件运行必要的包。</p><p>step 1：<br>在input文件夹中放入待处理的文件。<br><img src="/../img/hadoop%E6%88%90%E5%93%81/input%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E5%AE%B9.png" alt="input文件夹内容"></p><p>step 2：<br>在script文件夹下启动终端，运行代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop jar <span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-regexp">/share/</span>hadoop<span class="hljs-regexp">/tools/</span>lib<span class="hljs-regexp">/hadoop-streaming-version.jar -files mapper.py,reducer.py -mapper &quot;python3 mapper.py&quot; -reducer &quot;python3 reducer.py&quot; -input road_to_repo/i</span>nput<span class="hljs-regexp">/ -output road_to_repo/</span>output/<br></code></pre></td></tr></table></figure><p>其中“hadoop-streaming-version.jar”的“version”要改成你的hadoop的实际版本，“road_to_repo”要改成克隆下来的该项目文件夹所在路径。</p><p><strong>most important!：此命令为一次性操作，如果运行失败，必须把生成的output文件夹删掉之后再重新运行该命令。</strong></p><p>代码运行需要一定时间，如果单纯为学习目的可以使用small_input文件夹作为输入。</p><p>代码运行结果保存在output文件夹下的part-00000中。<br><img src="/../img/hadoop%E6%88%90%E5%93%81/part-00000.png" alt="part-00000内容"></p><p>step 3：<br>由于MapReduce的作用是统计词频，并不是用来生成词云图，因此还需要将刚才的运行结果拷贝到script文件夹中的output.txt。<br>在script文件夹下启动终端，运行代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python3</span> word_cloud.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>即可得到同一目录下保存的word_cloud.png。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reduce成功！</title>
    <link href="/2024/05/04/reduce%E6%88%90%E5%8A%9F%EF%BC%81/"/>
    <url>/2024/05/04/reduce%E6%88%90%E5%8A%9F%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>编写了reduce文件并运行成功了！来备个份</p><p>split_mapper.py的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> jieba<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_data</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-comment"># 在这里对数据进行处理，比如去除非中文字符，并分词</span><br>    content = re.sub(<span class="hljs-string">r&#x27;[^\u4e00-\u9fa5]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, data)  <span class="hljs-comment"># 去除非中文字符</span><br>    words = jieba.cut(content)  <span class="hljs-comment"># 分词</span><br>    <span class="hljs-keyword">return</span> words<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>        words = process_data(line.strip())<br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;word&#125;</span>\t1&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>split_reducer.py的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reducer</span>():<br>    current_word = <span class="hljs-literal">None</span><br>    current_count = <span class="hljs-number">0</span><br>    word_count_dict = defaultdict(<span class="hljs-built_in">int</span>)<br><br>    <span class="hljs-comment"># 读取来自Mapper的输入</span><br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> sys.stdin:<br>        word, count = line.strip().split(<span class="hljs-string">&#x27;\t&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 转换计数为整数类型</span><br>        <span class="hljs-keyword">try</span>:<br>            count = <span class="hljs-built_in">int</span>(count)<br>        <span class="hljs-keyword">except</span> ValueError:<br>            <span class="hljs-comment"># 如果无法转换，就跳过这一行</span><br>            <span class="hljs-keyword">continue</span><br>        <br>        <span class="hljs-comment"># 合并相同的单词并计算总次数</span><br>        <span class="hljs-keyword">if</span> current_word == word:<br>            current_count += count<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 输出累积的单词计数</span><br>            <span class="hljs-keyword">if</span> current_word:<br>                word_count_dict[current_word] += current_count<br>            current_word = word<br>            current_count = count<br><br>    <span class="hljs-comment"># 处理最后一个单词</span><br>    <span class="hljs-keyword">if</span> current_word == word:<br>        word_count_dict[current_word] += current_count<br><br>    <span class="hljs-comment"># 输出最终结果</span><br>    <span class="hljs-keyword">for</span> word, count <span class="hljs-keyword">in</span> word_count_dict.items():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;word&#125;</span>\t<span class="hljs-subst">&#123;count&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    reducer()<br></code></pre></td></tr></table></figure><p>终端运行代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop jar <span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-regexp">/share/</span>hadoop<span class="hljs-regexp">/tools/</span>lib<span class="hljs-regexp">/hadoop-streaming-3.4.0.jar -files split_mapper.py,split_reducer.py -mapper &quot;python3 split_mapper.py&quot; -reducer &quot;python3 split_reducer.py&quot; -input ~/</span>桌面<span class="hljs-regexp">/posts/</span>small_input<span class="hljs-regexp">/ -output ~/</span>桌面<span class="hljs-regexp">/posts/</span>f_output/<br></code></pre></td></tr></table></figure><p>注意：选项是files不是file（因为是多个文件），并且要用逗号分隔而不是空格</p><p><img src="/../img/hadoop/%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%BB%93%E6%9E%9C.png" alt="词频统计结果"></p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中文词频统计第一部分</title>
    <link href="/2024/05/04/%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <url>/2024/05/04/%E4%B8%AD%E6%96%87%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>先总结一下今天干了什么（工作日报</p><p>使用jieba进行分词，将post里的input文件夹下的所有.md文件读进标准输入，删除日期、标签、标题等元数据，过滤非中文字符，输出以每个词为键、值为1的键值对，表示该词出现了一次。</p><p><img src="/../img/hadoop/split.txt.png" alt="原来的输出版本，一堆未经处理的以空格分割的分词"></p><p><img src="/../img/hadoop/%E6%9C%AA%E7%BB%8Freduce%E7%9A%84%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1.png" alt="未经reduce的词频统计"></p><p>下一步的操作是要编辑reduce文件，使得同一键的count合并</p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跑通第二个hadoop</title>
    <link href="/2024/05/04/%E8%B7%91%E9%80%9A%E7%AC%AC%E4%BA%8C%E4%B8%AAhadoop/"/>
    <url>/2024/05/04/%E8%B7%91%E9%80%9A%E7%AC%AC%E4%BA%8C%E4%B8%AAhadoop/</url>
    
    <content type="html"><![CDATA[<p>跑的第一个hadoop是hadoop自带的英文词频统计。</p><p>因为自己手头有一堆博客的md文件，于是想做一个中文的词频统计。</p><p>（扩完容之后开跑！</p><p>苯人环境：hadoop单机版 Ubuntu20.04</p><p>苯人文件夹结构：</p><ul><li>posts<ul><li>scripts<ul><li>mapper.py</li><li>reducer.py（仍在编写中</li></ul></li><li>small_input<ul><li>*.md</li></ul></li><li>a_output<ul><li>…</li></ul></li></ul></li></ul><p>终端代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hadoop jar <span class="hljs-variable">$HADOOP_HOME</span><span class="hljs-regexp">/share/</span>hadoop<span class="hljs-regexp">/tools/</span>lib<span class="hljs-regexp">/hadoop-streaming-3.4.0.jar -file mapper.py -mapper &quot;python3 mapper.py&quot; -input ~/</span>桌面<span class="hljs-regexp">/posts/</span>small_input<span class="hljs-regexp">/ -output ~/</span>桌面<span class="hljs-regexp">/posts/</span>a_output/<br></code></pre></td></tr></table></figure><p>可以每打一部分就用“\”作为分割符，就可以接着输没输完的命令</p><p>mapper.py代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> jieba<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_input</span>(<span class="hljs-params">file</span>):<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file:<br>        <span class="hljs-keyword">yield</span> line<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">separator=<span class="hljs-string">&#x27;\t&#x27;</span></span>):<br>    <span class="hljs-comment"># 输入来自标准输入(stdin)</span><br>    data = read_input(sys.stdin)<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data:<br>        line = line.strip()<br>        <span class="hljs-comment"># 提取标题、日期和标签</span><br>        title = re.findall(<span class="hljs-string">r&#x27;title:\s*(.+)&#x27;</span>, line)<br>        date = re.findall(<span class="hljs-string">r&#x27;date:\s*(.+)&#x27;</span>, line)<br>        tags = re.findall(<span class="hljs-string">r&#x27;tags:\s*(.+)&#x27;</span>, line)<br>        <span class="hljs-keyword">if</span> title:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;title:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;title[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> date:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;date:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;date[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> tags:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;tags:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;tags[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 提取正文并分词</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line.startswith(<span class="hljs-string">&#x27;---&#x27;</span>) <span class="hljs-keyword">and</span> line.strip():<br>            <span class="hljs-comment"># 去除非中文字符</span><br>            content = re.sub(<span class="hljs-string">r&#x27;[^\u4e00-\u9fa5]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, line)<br>            words = jieba.cut(content)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;content:<span class="hljs-subst">&#123;separator&#125;</span><span class="hljs-subst">&#123;<span class="hljs-string">&#x27; &#x27;</span>.join(words)&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>分词成功！</p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最复杂的系统往往只需要最简单的扩容方式</title>
    <link href="/2024/05/04/%E6%9C%80%E5%A4%8D%E6%9D%82%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BE%80%E5%BE%80%E5%8F%AA%E9%9C%80%E8%A6%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/05/04/%E6%9C%80%E5%A4%8D%E6%9D%82%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BE%80%E5%BE%80%E5%8F%AA%E9%9C%80%E8%A6%81%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%A9%E5%AE%B9%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>环境：Ubuntu 20.04</p><p>先在虚拟机设置中增加硬盘容量，不过此时还处于灰色未分配状态</p><p>扩容前安装gparted</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install gparted<br></code></pre></td></tr></table></figure><p>终端运行gparted，出现图形界面</p><p>&#x2F;dev&#x2F;sda1 为主分区<br>&#x2F;dev&#x2F;sda2 为扩展分区<br>&#x2F;dev&#x2F;sda5 为逻辑分区（我的sda5挂在sda2目录下</p><p>这个时候的正确操作（网上绝无仅有版！）：</p><p>step1<br>右键sda2所在分区，选择更改大小选项，将箭头拖到最右端</p><p>step2<br>右键sda5所在分区，选择更改大小选项，将箭头拖到最右端</p><p>两个都要改！！因为是挂载版，比较特殊</p><p>（在尝试这个方法前还尝试了fdisk，并且gparted大部分人分区和我不一样（他们好像没有扩展分区所以没办法复现，中间甚至碰到了很多稀奇古怪的错误，，，<strong>虚拟机快照</strong>你值得拥有</p>]]></content>
    
    
    
    <tags>
      
      <tag>vmware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置hadoop环境</title>
    <link href="/2024/05/04/%E9%85%8D%E7%BD%AEhadoop%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/05/04/%E9%85%8D%E7%BD%AEhadoop%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>大学生哪有不疯的，，，</p><p>今天回到寝室，查了一下日常实习的岗位，决定向大数据工程师发起进攻（数据挖掘是算法，算法达咩</p><p>流程：尝试在docker上装hadoop镜像未遂，尝试装裸机版，被百度网盘的垃圾网速和windows的傻逼环境整笑了（发现文件夹里有.sh文件所以最后还是决定用虚拟机，，，装了好几个小时终于！</p><p><img src="/../img/env/475981eb67fff95876bff514e239de3.png" alt="java与hadoop运行成功界面"></p>]]></content>
    
    
    
    <tags>
      
      <tag>hadoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表！</title>
    <link href="/2024/05/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%81/"/>
    <url>/2024/05/03/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>初构造链表类<br>此题要点：迭代法，保存cur nxt pre，因为改指针后会丢失原来的信息，注意return的东西是pre<br>自己可以定义类定义测试数据的话其实自由度很大</p><p>加油加油</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    node* next;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> v)&#123;<br>        value=v;<br>        next = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function">node* <span class="hljs-title">reverse_node</span><span class="hljs-params">(node*head)</span></span>&#123;<br>    node* cur = head;<br>    node* nxt = <span class="hljs-literal">nullptr</span>;<br>    node* pre = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>        nxt = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(node*head)</span></span>&#123;<br>    node*cur = head;<br>    <span class="hljs-keyword">while</span> (cur!=<span class="hljs-literal">nullptr</span>)&#123;<br>        cout&lt;&lt;cur-&gt;value&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cur = cur-&gt;next;<br><br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>    node* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">1</span>);<br>    head-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">2</span>);<br>    head-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">3</span>);<br>    head-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">print_list</span>(head);<br>    <span class="hljs-built_in">print_list</span>(<span class="hljs-built_in">reverse_node</span>(head));<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>手搓代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题前置知识</title>
    <link href="/2024/05/01/leetcode%E5%88%B7%E9%A2%98%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/05/01/leetcode%E5%88%B7%E9%A2%98%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>不太确定到时候会不会真的要求手搓，，</p><p>反正手搓的时候也可以借鉴，先刷力扣，把思路看会了起。</p><p>其实二叉搜索树索引和左右节点是对应的（理解一下，<br>left_child_index &#x3D; parent_index * 2 + 1<br>right_child_index &#x3D; parent_index * 2 + 2</p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再不找工作就只能家里蹲进tz了！</title>
    <link href="/2024/05/01/%E5%86%8D%E4%B8%8D%E6%89%BE%E5%B7%A5%E4%BD%9C%E5%B0%B1%E5%8F%AA%E8%83%BD%E5%AE%B6%E9%87%8C%E8%B9%B2%E8%BF%9Btz%E4%BA%86%EF%BC%81/"/>
    <url>/2024/05/01/%E5%86%8D%E4%B8%8D%E6%89%BE%E5%B7%A5%E4%BD%9C%E5%B0%B1%E5%8F%AA%E8%83%BD%E5%AE%B6%E9%87%8C%E8%B9%B2%E8%BF%9Btz%E4%BA%86%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>hyx要加油！（还是不习惯翻墙搜索，，</p><p>这几天玩的差不多了，开始准备力扣算法题（希望不要再被机试刷下来了</p><p>补：日常实习好像没有机试，正合我意</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于恐惧和爱的选择</title>
    <link href="/2024/04/26/%E5%85%B3%E4%BA%8E%E6%81%90%E6%83%A7%E5%92%8C%E7%88%B1%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <url>/2024/04/26/%E5%85%B3%E4%BA%8E%E6%81%90%E6%83%A7%E5%92%8C%E7%88%B1%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p>关于恐惧和爱的选择，我们最好选择爱吧，因为死亡就要降临。（感觉这句特别好！想要写到歌词里去</p>]]></content>
    
    
    
    <tags>
      
      <tag>bubble</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>假期开始！</title>
    <link href="/2024/04/26/%E5%81%87%E6%9C%9F%E5%BC%80%E5%A7%8B%EF%BC%81/"/>
    <url>/2024/04/26/%E5%81%87%E6%9C%9F%E5%BC%80%E5%A7%8B%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>多吃主食就可以增肥！</p><p>找老师开了一下小灶，发现是练习方法的问题，现在可以踢5个了！老师还说如果我能踢到10个（对？没听清）就直接联系她，嘿嘿！（离三对合格只差一个！看来期末合格有望！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GOOD NEWS!</title>
    <link href="/2024/04/26/GOOD-NEWS/"/>
    <url>/2024/04/26/GOOD-NEWS/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/html_dialect.png" alt="html_dialect"><br>将combine.py和modulate.py合并为一个文件，命名为generate.py，看上去更加简洁。</p><p>vscode中可以直接运行generate.py，开启一个新的终端，在终端中按规定运行即可在文件夹内生成对应的读音。</p><p>原来的raw文件夹全都删除，只留下预处理后的文件，去掉了文件夹的output前缀，看上去更加精练！python api与html方面即将进入尾声！如果成功调用api，就开启下一步的方言数据库建设，敬请期待！</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尝试搭前端界面！</title>
    <link href="/2024/04/25/%E5%B0%9D%E8%AF%95%E6%90%AD%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2/"/>
    <url>/2024/04/25/%E5%B0%9D%E8%AF%95%E6%90%AD%E5%89%8D%E7%AB%AF%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>借助chatgpt搭了一个较为丑陋的前端界面（虽然觉得它丑，然后就push chatgpt再写了一个稍微好看一点的界面）</p><p>装了一些用来写前端的扩展，在菜鸟教程的推荐下装了一些前端常用的插件，比如：fitten code，看着它在每次我输入日记的时候它会自动给我补全一些东西，但是它补全的完全不是我想说的哈哈哈哈啊哈哈，发现ai取代人类的思维还是为时尚早！</p><p>明天晚上7点有个xhs笔试，但是那个时候我在火车上了！（顺延掉吧哈哈哈哈哈哈 还是寄希望于投日常实习好了（简历太丑，现在也在抓紧学一些东西</p><p>前端地位低，，自己玩玩还行，去公司最好还是投后端岗位，毕竟前端的工作主要是写代码，后端的工作主要是写接口，数据库，服务器等等，前端的工作量相对后端来说要小很多，而且前端的技术栈相对后端来说更加简单，所以更适合个人学习。（后面的原因是fitten code补全的</p><p>以下是index.html的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Text Reader<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;hr&gt;</span><br><span class="hljs-comment">    &lt;h1&gt;Text Reader&lt;/h1&gt;</span><br><span class="hljs-comment">    &lt;hr&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;textInput&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请键入吴语拼音&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;readButton&quot;</span>&gt;</span>Read<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;app.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是styles.css的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Arial&#x27;</span>, sans-serif;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f4f4f4</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-attribute">text-align</span>: center;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;<br>    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">4px</span> <span class="hljs-number">8px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>);<br>&#125;<br><br><span class="hljs-selector-id">#textInput</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>&#125;<br><br><span class="hljs-selector-id">#readButton</span> &#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#007BFF</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;<br>    <span class="hljs-attribute">border</span>: none;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>    <span class="hljs-attribute">transition</span>: background-color <span class="hljs-number">0.3s</span> ease;<br>&#125;<br><br><span class="hljs-selector-id">#readButton</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0334f6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（这fitten code还怪聪明的</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哇！我运行了第一个Flask程序</title>
    <link href="/2024/04/25/%E5%93%87%EF%BC%81%E6%88%91%E8%BF%90%E8%A1%8C%E4%BA%86%E7%AC%AC%E4%B8%80%E4%B8%AAFlask%E7%A8%8B%E5%BA%8F/"/>
    <url>/2024/04/25/%E5%93%87%EF%BC%81%E6%88%91%E8%BF%90%E8%A1%8C%E4%BA%86%E7%AC%AC%E4%B8%80%E4%B8%AAFlask%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>python的程序已经差不多搭建完成了！（今天录入了全部的音素 方言词典开发计划进入下一阶段，即在web网页中嵌入python代码</p><p>发现了flask这个宝藏应用程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Filename : example.py</span><br><span class="hljs-comment"># Copyright : 2020 By Nhooo</span><br><span class="hljs-comment"># Author by : www.cainiaojc.com</span><br><span class="hljs-comment"># Date : 2020-08-08</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World&#x27;</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure><p>只要把这个代码保存到hello.py中并在终端中运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python hello.py<br></code></pre></td></tr></table></figure><p>就可以在弹出的本地端口中发现网页上已经展示了一行“helloworld”~</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大连行程</title>
    <link href="/2024/04/25/%E5%A4%A7%E8%BF%9E%E8%A1%8C%E7%A8%8B/"/>
    <url>/2024/04/25/%E5%A4%A7%E8%BF%9E%E8%A1%8C%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>因为五一打算去日照看海，突然想起之前去了大连的一些行程没有记录，遂记</p><p>当时应该就是7.3-7.5，中间下雨的时候就宅在民宿里，幸运的是同时看到了晴天的海和阴天的海。拍了很多人生照片嘿嘿</p><p>凭着记忆写一波：</p><p>7.3<br>傍晚的时候坐高铁到的大连（甚至还有地铁<br>安顿并且追剧</p><p>7.4<br>下午（雨）：<br>有轨电车<br>罗斯福广场<br>KKV（逛过最大的KKV！强烈安利</p><p>傍晚（雨）：<br>星海公园</p><p>7.5<br>星海广场！！<br>住宿定在了汉庭优佳大连机场酒店（因为第二天要飞到宁波去了</p>]]></content>
    
    
    
    <tags>
      
      <tag>travel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现列表化输入</title>
    <link href="/2024/04/25/%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E5%8C%96%E8%BE%93%E5%85%A5/"/>
    <url>/2024/04/25/%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E5%8C%96%E8%BE%93%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>这次对modulate和combine进行了扩展，使得它们不仅可以处理单个音素，现在可以批量处理了，由于如果输入输出是相同路径很容易造成损坏，于是建了一个临时文件夹来存放中间值。</p><p>深深体会到了分部编程的好处（不会短时间内引入大量的bug，循序渐进</p><p>写完了米德尔马契的ddl！明天写探奥论文（以及要整理出去玩的东西啦！！顺便做攻略</p><p>干的事情一多甚至已经来不及写博客了，，直接po一个readme来汇报一下现在的进度<br><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/%E8%BE%93%E5%85%A5%E9%9F%B3%E7%B4%A0%E4%B8%8E%E5%8D%87%E9%99%8D%E5%8D%8A%E9%9F%B3%E6%95%B0%E5%85%83%E7%BB%84%E5%88%97%E8%A1%A8.png" alt="README更新"></p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现变调功能并封装预处理py</title>
    <link href="/2024/04/22/%E5%AE%9E%E7%8E%B0%E5%8F%98%E8%B0%83%E5%8A%9F%E8%83%BD%E5%B9%B6%E5%B0%81%E8%A3%85%E9%A2%84%E5%A4%84%E7%90%86py/"/>
    <url>/2024/04/22/%E5%AE%9E%E7%8E%B0%E5%8F%98%E8%B0%83%E5%8A%9F%E8%83%BD%E5%B9%B6%E5%B0%81%E8%A3%85%E9%A2%84%E5%A4%84%E7%90%86py/</url>
    
    <content type="html"><![CDATA[<p>北京下了很大很大的雨，感觉像回家了，自己是满是水的星球上的厄崔迪王子</p><p>今天写完了经济地理学的论文，刷完了党课在线学习视频，实现了变调功能，还封装了preprocessing.py（把预处理功能的py全部整合到同一个文件，封装函数接口</p><p>满是水的天气使我开心与振奋，，应该是太想家了（以及没淋到雨嘿嘿</p><p>冲了很久的热水澡，虽然联系了一个想做小程序的学姐并且杳无音讯，但是她应该会去淘宝上找代做吧！PaperPass居然可以降AIGC，，，真的太牛了，让AI改AI。</p><p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/%E6%9B%B4%E6%96%B0modulate.png" alt="更新modulate"></p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比较优势</title>
    <link href="/2024/04/22/%E6%AF%94%E8%BE%83%E4%BC%98%E5%8A%BF/"/>
    <url>/2024/04/22/%E6%AF%94%E8%BE%83%E4%BC%98%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>“东亚经济奇迹”一个很重要的特点，就是政府帮助本土企业进入复杂度很高的行业，充分利用其中的学习效应、规模效应和技术外溢效应，迅速提升本土制造业的技术能力和国际竞争力。假如韩国按照其1970年显示出的“比较优势”来规划产业，就应该听从世界银行的建议去发展纺织业。但韩国没有这么做，而是一头扎进了本国根本没有的产业。到了1990年，韩国最具“比较优势”的十大类出口商品，比如轮船和电子产品，1970年时根本就不存在。可见“比较优势”具有很大的不确定性，是可以靠人为创造的。其实“比较优势”并不神秘，就是机会成本低的意思。而对于没干过的事情，事前其实无从准确判断机会成本，没干过怎么知道呢？中国也是如此。政府和私人部门合力进入很多复杂的、传统上没有比较优势的行业，但经过多年发展，其产品如今在国际上已经有了比较优势。</p></blockquote><p>感觉这一段写的特别好！比较优势具有很大的不确定性，是可以靠人为创造的。事前无从准确判断机会成本，没干过怎么知道呢？</p><blockquote><p>从光伏产业的发展中，我们还可以看到“东亚产业政策模式”的另一个特点：强调出口。当国内市场有限时，海外市场可以促进竞争，迫使企业创新。补贴和优惠政策难免会产生一些低效率的企业，但这些企业在面对挑剔的海外客户时，是无法过关的。而出口量大的公司，往往是效率相对高的公司，它们市场份额的扩大，会吸纳更多的行业资源，压缩国内低效率同行的生存空间，淘汰一些落后产能。当然，像我国这样的大国，要应对的国际局势变幻比小国更加复杂，所以不断扩大和稳定国内市场，才是行业长期发展的基础。另一方面，若地方政府利用行政手段阻碍落后企业破产，就会阻碍优胜劣汰和效率提升，加剧产能过剩的负面影响。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平滑连接元音辅音</title>
    <link href="/2024/04/21/%E5%B9%B3%E6%BB%91%E8%BF%9E%E6%8E%A5%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3/"/>
    <url>/2024/04/21/%E5%B9%B3%E6%BB%91%E8%BF%9E%E6%8E%A5%E5%85%83%E9%9F%B3%E8%BE%85%E9%9F%B3/</url>
    
    <content type="html"><![CDATA[<p>配了一副新眼镜和一副新墨镜！（今天干的事情好多反而懒得写博客了哈哈哈</p><p>发现方言网站上有很多音频缺失了，于是还是打算自己录了（主要是为了保持音色和声调的一致，不然合成会很奇怪</p><p>今天最重大的成就是平滑连接了元音和辅音（t+ei&#x3D;tei）经过反复的调整迭代出了一个最优的合成方案（不知道是否适用于别的组合的情形呢</p><p>批处理真的很方便，，这几天主要在做预处理的事情，全都在为后面做铺垫（慢慢来吧！这几天也学到了很多东西！就像疯狂星期一说的那样 不要留下遗憾，不要一遍一遍地让人生重来 想着先干完这个就一定有时间去干别的东西类似的事情</p><p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/0421dialect.png" alt="今日进度"><br><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/readme%E6%9B%B4%E6%96%B0%E9%A2%84%E5%A4%84%E7%90%86.png" alt="README更新预处理部分"></p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重大突破-分离辅音</title>
    <link href="/2024/04/20/%E9%87%8D%E5%A4%A7%E7%AA%81%E7%A0%B4/"/>
    <url>/2024/04/20/%E9%87%8D%E5%A4%A7%E7%AA%81%E7%A0%B4/</url>
    
    <content type="html"><![CDATA[<p>发现配的环境还是不大行，，于是今天又倒腾了好久的环境</p><p>一直很好奇为什么终端每次打印环境变量的时候都会出现一些奇怪的字符 就算是人工键入也是非常奇怪的字符，今天破案了</p><p>下次输环境变量的时候不要再右键文件属性然后复制了，直接点<br><img src="/../img/env/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240420234648.png" alt="watch this"><br>就会出来一个直接可以复制的地址，这样就不会出现奇怪的字符了</p><p>再不行就重新下一个包（注意一下下载的是essential部分还是full部分 以免漏掉一些东西 不过我感觉根源还是上面的复制问题</p><p>又仔细研究了一下上次下的synthesis轮子，（如果方言能像拼音一样直接拼出来就好了，拆解成多个音频，每个音频播放固定的时长</p><p>居然被我找到了！吴语拼音！因为玉环话和温岭话比较相近所以打算采用温岭话拼音方案！<a href="https://wu-chinese.com/romanization/wenling.html">吴语协会温岭话拼音链接</a></p><p>从官网的辅音介绍下载了一个ogg（既然是方言爱好者官网的，肯定比我这个“门外汉”读的标准），但是问题在于这个音频是送气的（ta），所以就在想怎么把辅音和元音分开，问了chatgpt给的答案也不尽人意，最后hyx发挥了她的智慧——</p><p>主要思路就是利用pydub库（一个处理音频的库），将官网下载的音频找到非静音部分（这个灵感来源是华为录音的跳过静音功能），再截取前面的一小部分，就可以分离开了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydub <span class="hljs-keyword">import</span> AudioSegment<br><span class="hljs-keyword">from</span> pydub.silence <span class="hljs-keyword">import</span> detect_nonsilent<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 加载音频文件</span><br>audio_file = <span class="hljs-string">&quot;ta.ogg&quot;</span><br>audio = AudioSegment.from_ogg(audio_file)<br><br><span class="hljs-comment"># 使用detect_nonsilent找到非静音部分</span><br>nonsilent_intervals = detect_nonsilent(audio, silence_thresh=-<span class="hljs-number">40</span>, min_silence_len=<span class="hljs-number">50</span>)<br><br><span class="hljs-comment"># 获取第一个非静音部分的开始位置</span><br><span class="hljs-keyword">if</span> nonsilent_intervals:<br>    start_pos = nonsilent_intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 截取去掉静音部分后的前25毫秒音频</span><br>    chunk = audio[start_pos:start_pos + <span class="hljs-number">25</span>]  <br><br>    <span class="hljs-comment"># 创建一个新的音频文件夹来保存截取出的音频</span><br>    output_folder = <span class="hljs-string">&quot;output_audio&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(output_folder):<br>        os.mkdir(output_folder)<br><br>    <span class="hljs-comment"># 保存截取出的音频</span><br>    output_file = os.path.join(output_folder, <span class="hljs-string">&quot;first_25ms_after_silence.ogg&quot;</span>)<br>    chunk.export(output_file, <span class="hljs-built_in">format</span>=<span class="hljs-string">&quot;ogg&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成功截取去掉静音部分后的前25毫秒音频。&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未找到非静音部分。&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>听了一下效果感觉还可以！明天试试看把它和元音音频合起来</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>明明配了环境，却仍然不能运行？</title>
    <link href="/2024/04/19/%E4%BF%A1%E7%A7%91%E5%A3%AC%E6%9E%81%E5%85%B6%E8%A6%81%E5%BC%BA%E7%9A%84%E4%B8%80%E7%94%9F/"/>
    <url>/2024/04/19/%E4%BF%A1%E7%A7%91%E5%A3%AC%E6%9E%81%E5%85%B6%E8%A6%81%E5%BC%BA%E7%9A%84%E4%B8%80%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>省流：看看是不是磁盘权限问题！（F盘是用户盘不是系统盘，所以设置环境变量要设置在用户的环境变量，而不是系统的环境变量</p><p>一些检查方法：</p><p>在windows10的powershell终端运行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> $<span class="hljs-keyword">en</span><span class="hljs-variable">v:PATH</span><br></code></pre></td></tr></table></figure><p>发现所有F盘的环境变量设置都无效，，，但是平时配其他盘就没事（重启了好多次终于想到用打印环境变量这一方法</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">echo</span> $<span class="hljs-keyword">en</span><span class="hljs-variable">v:MY_VARIABLE_FROM_F_DRIVE</span><br></code></pre></td></tr></table></figure><p>（运行这一命令，输出为空，证实了我的想法</p><p>解决方案是把系统环境变量挪到用户环境变量（D盘同理<br><img src="/../img/env/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240419144020.png" alt="用户环境变量与系统环境变量"><br>C盘没内存的人是这样的，，卑微</p>]]></content>
    
    
    
    <tags>
      
      <tag>env</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方言词典开发计划！</title>
    <link href="/2024/04/19/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92%EF%BC%81/"/>
    <url>/2024/04/19/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8%E5%BC%80%E5%8F%91%E8%AE%A1%E5%88%92%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2%E7%9A%84%E8%AE%BE%E6%83%B3.jpg" alt="一个界面的设想"><br>某种程度上也借鉴了德格方言词典app的设计（以简约为目标）。用户的登录&#x2F;注册与新增词条功能为次要功能，可以延缓开发。打算先从网页web版做起，再试试看能不能包装成apk。<br>起因是没钱买服务器，也不想在免费试用之后续费，于是决定先搞一个轻量级的应用。查了一个下午+一个晚上的资料，最终锁定采用flutter开发。<br><img src="/../img/%E6%96%B9%E8%A8%80%E8%AF%8D%E5%85%B8/flutter%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F.png" alt="flutter部署成功"><br>想法是：如果用flutter开发了一个插件，就可以做到类似调用api的功能，即在静态网页上实现动态功能。</p><p>咨询了一下gpt，它也是这么认为的：</p><p>GPT：</p><p>是的，使用Flutter开发插件，你可以在静态网页上实现动态功能，类似于调用API的功能。Flutter插件可以与Web应用程序（例如JavaScript）进行交互，从而在静态网页中实现动态功能。</p><p>Flutter提供了<code>flutter_webview_plugin</code>这样的插件，它允许你在Flutter应用中嵌入Web视图。这样，你可以加载一个包含动态内容的网页，并与Flutter应用程序进行交互。</p><p>以下是使用<code>flutter_webview_plugin</code>插件嵌入Web视图的基本步骤：</p><ol><li>在<code>pubspec.yaml</code>文件中添加<code>flutter_webview_plugin</code>依赖：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br>  <span class="hljs-attr">flutter_webview_plugin:</span> <span class="hljs-string">^latest_version</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>运行<code>flutter pub get</code>安装依赖。</p></li><li><p>在Flutter应用中使用<code>WebviewScaffold</code>或<code>Webview</code>来嵌入Web视图：</p></li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_webview_plugin/flutter_webview_plugin.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(MyApp());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: WebviewScaffold(<br>        url: <span class="hljs-string">&quot;https://example.com&quot;</span>, <span class="hljs-comment">// 加载的网页URL</span><br>        appBar: AppBar(title: Text(<span class="hljs-string">&quot;Webview 示例&quot;</span>)),<br>        withZoom: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 允许缩放</span><br>        withLocalStorage: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 启用本地存储</span><br>        hidden: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 是否隐藏webview</span><br>        initialChild: Container( <span class="hljs-comment">// 加载过程中显示的控件</span><br>          color: Colors.white,<br>          child: Center(<br>            child: CircularProgressIndicator(),<br>          ),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用<code>WebviewScaffold</code>来加载一个网页，并显示一个AppBar。你可以根据需要自定义<code>WebviewScaffold</code>的属性，例如是否允许缩放、是否启用本地存储等。</p><p>通过这种方式，你可以在静态网页上实现动态功能，与Flutter应用程序进行交互，类似于调用API的功能。</p><p>终于看到了一点成功的可能性！睡觉！</p>]]></content>
    
    
    
    <tags>
      
      <tag>dialect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分税制改革具体举措</title>
    <link href="/2024/04/18/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9%E5%85%B7%E4%BD%93%E4%B8%BE%E6%8E%AA/"/>
    <url>/2024/04/18/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9%E5%85%B7%E4%BD%93%E4%B8%BE%E6%8E%AA/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%A4%96/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93.png" alt="本章小结"><br>经济发展就是盘活各种资源，提高资源使用效率（人力、土地等等）</p><h1 id="纵向失衡"><a href="#纵向失衡" class="headerlink" title="纵向失衡"></a>纵向失衡</h1><p>由于中央和省分成，省和市县分成，导致财权层层上收，事权层层下压（也就是俗话说的基层钱少事多），因此进行了支出分权，农村基本公共服务开支由中央和地方政府共同承担，乡财县管（规范乡镇行为，实现同县乡镇公共服务均等化），省直管县（让县财政和省财政直接发生关系，绕开市财政）。</p><h1 id="转移支付改革"><a href="#转移支付改革" class="headerlink" title="转移支付改革"></a>转移支付改革</h1><p>保证政府运作和公务员工资（可能会造成冗员问题，养了很多闲人），而且越穷的人拿到的转移支付越多，可能缺乏增收动力</p><h1 id="五个统筹"><a href="#五个统筹" class="headerlink" title="五个统筹"></a>五个统筹</h1><p>科学发展观的内容。人与自然和谐发展（自然保护区的就不准砍，，），统筹经济社会发展（主要还是社会稳定，所以民生问题也要关注</p>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>土地财政</title>
    <link href="/2024/04/18/%E5%9C%9F%E5%9C%B0%E8%B4%A2%E6%94%BF/"/>
    <url>/2024/04/18/%E5%9C%9F%E5%9C%B0%E8%B4%A2%E6%94%BF/</url>
    
    <content type="html"><![CDATA[<p>1998年之前，乡镇企业占用的都是农村集体土地。由于各大地方政府招商引资，城市土地一般以低价有偿转让，卖地收入不多。</p><h1 id="城市政府垄断土地建设"><a href="#城市政府垄断土地建设" class="headerlink" title="城市政府垄断土地建设"></a>城市政府垄断土地建设</h1><p>直到1998年颁布了一系列改革措施：职工停止分房（催生了商品房与房地产），颁布了《土地管理法》，即农村集体土地不能用于非农建设，这些土地必须通过征地成为国有土地才能发展工商业和建造住宅，因此，城市政府垄断了土地建设。</p><p>在2001年，制定了“招标拍卖”规则，土地财政膨胀。</p><p>土地财政的收入分为使用权转让收入和一系列税收收入（土地增值税、耕地占用税、契税）。在1999-2000的窗口期，招拍挂还未实施，土地转让不透明，一些开发商趁国企改革腾出的土地私下交易，以少量出让金就可开发房地产，这其中催生了许多腐败与混乱。</p><h1 id="工业化城市化两手抓"><a href="#工业化城市化两手抓" class="headerlink" title="工业化城市化两手抓"></a>工业化城市化两手抓</h1><p>改革后，地方政府一方面低价供应大量工业用地，一方面限制商住用地供给（获得垄断收益），随着工商业经济活动的繁荣，房价与地价不断哄抬。随着企业那边的改革交给政府的税越来越少，政府也从原来的狠抓工业化逐渐转变成工业化城市化两手抓。</p><h2 id="工业用地"><a href="#工业用地" class="headerlink" title="工业用地"></a>工业用地</h2><p>为什么地方政府不惜倒贴（提供各种补贴）也要供应工业用地呢？因为工业用地（制造业）可以带动转型升级，也可以提供增值税和其他税收，并且制造业上下游链条长，如果形成集群效应，还可以提升地方竞争优势，形成稳定税收来源。</p><p>而且工业用地对地域一般没有太大的限制，所以地方政府不大可能抬地价（人家厉害，哪都能生存，凭啥待这呢），要哄着企业</p><h2 id="商住用地"><a href="#商住用地" class="headerlink" title="商住用地"></a>商住用地</h2><p>商住用地一般仅服务本地居民，所以垄断性更高，更方便抬地价（软柿子</p>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>央地博弈与招商引资</title>
    <link href="/2024/04/17/%E5%A4%AE%E5%9C%B0%E5%8D%9A%E5%BC%88%E4%B8%8E%E6%8B%9B%E5%95%86%E5%BC%95%E8%B5%84/"/>
    <url>/2024/04/17/%E5%A4%AE%E5%9C%B0%E5%8D%9A%E5%BC%88%E4%B8%8E%E6%8B%9B%E5%95%86%E5%BC%95%E8%B5%84/</url>
    
    <content type="html"><![CDATA[<h1 id="央地博弈"><a href="#央地博弈" class="headerlink" title="央地博弈"></a>央地博弈</h1><p>分税制改革将税收分为三类，中央税、地方税和共享税。</p><p>增值税原本为地方税，现在变为共享税（中央75%，地方25%）。为防止地方收入急剧下跌，中央设立了“税收返还”机制：保证改革后地方增值税收入与改革前一样，新增部分才和中央分。广东谈判之后，在全国范围内用1993年做基年，引发第四季度的收税狂潮，由于地方突击征税，增值税占地方税收的比重在1993年出现了明显反常的尖峰。这让1994年的财政陷入了困境，中央承诺的税收返还因为数额剧增而无法到位，预算迟迟做不出来。当2001年推行所得税分成改革时，突击征税现象再次出现。</p><h1 id="招商引资"><a href="#招商引资" class="headerlink" title="招商引资"></a>招商引资</h1><p>地方发展经济的两条路线：税收（与中央分成）、预算外收入。</p><p>增加税收的途径：</p><ol><li>扩大税源（主要原因<br>改革前，企业按隶属关系上缴税收，改革后，企业按所在地上缴税收。这便吸引了地方政府招商引资。由于税收在生产环节征收（之前讲过增值税不管企业盈利亏本，只要生产了就要交税的），所以地方政府为了财政，重企业轻民生，重生产轻消费。（之前公考做到一道题就是盲目招商、招大商的问题，也导致了产能过剩与对环境的破坏）</li><li>加强征管（非主要原因</li></ol><p>增加预算外收入的途径：</p><ol><li>企业缴的各种杂项费用（行政收费、集资、赞助等），后来改革了就没有了</li><li><strong>土地财政（下一部分着重讲）</strong></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分税制改革背景</title>
    <link href="/2024/04/17/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9/"/>
    <url>/2024/04/17/%E5%88%86%E7%A8%8E%E5%88%B6%E6%94%B9%E9%9D%A9/</url>
    
    <content type="html"><![CDATA[<p>由于原来的计划经济太僵化，所以进行了一系列改革转型。我国的基本国策决定了不能对所有权做出根本性变革，只能对经营权和使用权实行承包制来提高积极性。</p><p>中央根据地方实际来确定承包形式和分账比例，比较流行的是收入递增包干（以某一年为基准每年提高固定的百分比，超过的部分全部归地方，没超过的部分与中央五五分成）因此地方有动力扩大税收来源，大力发展经济。由于企业不管盈利与否，只要开工，都需要缴纳增值税，于是地方政府大力发展乡镇企业（这样就可以得到更多的税收）。</p><p>但是这样的财政包干造成了两个比重不断降低。</p><ol><li><p>中央财政预算收入占全国财政预算收入的比重不断降低。<br>这是因为地方的财政收入上涨的速度远远高于地方交给中央的那个税的增长率（就是自己发展的好留了很多）</p></li><li><p>全国财政预算总收入占GDP的比重越来越低。<br>这是因为地方财政担心报多了被中央压榨增多提高的百分比（怕变成老实人小丑），所以偷偷留几手（藏富于企业，企业偷税漏税），这样地方依然有预算外收入，但是上报的预算内收入就少了，要交的税就少了</p></li></ol><p>而如果中央没钱，就失去宏观调控的能力（手里没把米，叫鸡都不来），更没有财力去普及义务教育、赈灾……所以改革启动！</p>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事权划分三大原则</title>
    <link href="/2024/04/17/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/"/>
    <url>/2024/04/17/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/</url>
    
    <content type="html"><![CDATA[<p>《置身事内：中国政府与经济发展》：经济地理学的阅读书目，在此更新一些阅读笔记</p><h1 id="事权划分三大原则"><a href="#事权划分三大原则" class="headerlink" title="事权划分三大原则"></a>事权划分三大原则</h1><p>三大原则的共同主题是处理不同群体的利益差别与冲突。假如不同群体间完全没有差别和冲突，那事权如何划分就不重要，对结果影响不大。完全没有冲突当然不可能，但如果能让各个群体对利益和代价的看法趋同，也能消解很多矛盾，增强互信。所以国家对其公民都有基本的共同价值观教育，包括历史教育和国家观念教育。而对官员群体，我国自古以来就重视共同价值观的培养与教化，今天依然如此。</p><h2 id="1-公共服务的规模经济"><a href="#1-公共服务的规模经济" class="headerlink" title="1. 公共服务的规模经济"></a>1. 公共服务的规模经济</h2><p>一个城市总要划分成不同的区县，而行政边界的划分跟公共服务影响范围有关。</p><p>一方面，因为规模经济，覆盖的人越多越划算，政区越大越好；</p><p>另一方面，受制于人们获取这些服务的代价（距离、文化、意愿、基础设施），政区不能无限扩大。</p><blockquote><p>从公共服务覆盖范围角度看，不同人对公共服务的评价不同，享受该服务的代价不同，所以要划分不同的行政区域。</p></blockquote><h2 id="2-信息复杂性"><a href="#2-信息复杂性" class="headerlink" title="2. 信息复杂性"></a>2. 信息复杂性</h2><p>上级无法掌握和处理所有信息，虽然名义上有最终决定权，但是只有“形式权威”，下级具有信息优势，自主性很大，具有“实际权威”。上下级之间存在信息的获取与隐瞒问题。规则的模糊不清容易导致权力个人化，容易造成“一把手负责制”的专权与腐败现象。因此体制内的规章制度无法取代个人信任。</p><blockquote><p>从信息复杂性角度看，掌握不同信息的人，看法和判断不同，要把决策权交给占据信息优势的一方。</p></blockquote><h2 id="3-激励相容"><a href="#3-激励相容" class="headerlink" title="3. 激励相容"></a>3. 激励相容</h2><h3 id="垂直管理"><a href="#垂直管理" class="headerlink" title="垂直管理"></a>垂直管理</h3><p>适用于专业性强、标准化程度高的部门，工作主要由系统内的上级安排，任命、绩效与福利也主要由上级评价与决定。</p><h3 id="地方管理"><a href="#地方管理" class="headerlink" title="地方管理"></a>地方管理</h3><p>激励相容原则要求给地方放权：不仅要让地方负责，也要与地方分享发展成果；不仅要能激励地方努力做好，还要能约束地方不要搞砸，也不要努力过头。做任何事都有代价，最优的结果是让效果和代价匹配，而不是不计代价地达成目标。若不加约束，地方政府要实现短期经济高速增长目标并不难，可以尽情挥霍手中的资源，大肆借债、寅吃卯粮来推高增长数字，但这种结果显然不是最优的。</p><blockquote><p>从激励相容角度看，上下级的目标和能力不同，所以要设立有效的机制去激励下级完成上级的目标。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>置身事内</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随记</title>
    <link href="/2024/04/17/%E9%9A%8F%E8%AE%B0/"/>
    <url>/2024/04/17/%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>因为之前的笔记本用完了，翻到了一个大一的时候用的笔记本。发现往里面记了很多有意思的东西，遂搬运。之前记录只是觉得有意思，或者有“价值”，当真正面临人生选择的时候，当认识了更多为了自己的梦想而去做一些看似愚蠢的事的人之后，不管是在名著中还是现实中。我很崇敬他们自洽而勇敢的生活方式，像放弃退休坚守招生岗位，为像我一样迷茫的孩子点了一盏灯，像sygg放弃了教育部秘书的光鲜职位而从上海回到小岛任教，像奶奶疫情后依然在经营着她的亏本小店，像米德尔马契里看似总是在做着错误的选择的多多。</p><p>我将我的前5&#x2F;8的大学用来迷茫，后3&#x2F;8的大学用来醒悟与召回。而今在寻找探奥论文素材的时候，偶然间又重新看到大一上册时的记录。那时候我没有被绩点和学业压力鞭挞，保持着最单纯的初心，选什么课都是为了好玩，也为了好玩去学习了一些很基础的一些东西（走了很多弯路，终于在大三下兜兜转转地绕回来）。</p><p>成功和功成名就没有什么关系，成功是一个人捍卫自己的完整性。他可以不为名利低下高傲的头，却会为一段自由俯身垂首。他开始变得勇敢，他不甘心再做一只囚鸟。人的每一种身份都是一种自我绑架，唯有失去是自由之途。我把自己丢了，也许他也只想飞翔一次。他应该羽翼丰满，为自己寻求一条明亮的活路。</p>]]></content>
    
    
    
    <tags>
      
      <tag>bubbles</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讯飞智文</title>
    <link href="/2024/04/17/%E8%AE%AF%E9%A3%9E%E6%99%BA%E6%96%87/"/>
    <url>/2024/04/17/%E8%AE%AF%E9%A3%9E%E6%99%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>低碳课要交一个作业，正好因为没有用过ai生成ppt，所以生成了一个看看效果</p><p><img src="/../img/%E8%AE%AF%E9%A3%9E%E6%99%BA%E6%96%87/ai%E7%94%9F%E6%88%90ppt.png" alt="AI生成ppt"><br>其实感觉乍一看还蛮好！不过有很多重复的内容和不合逻辑的内容，稍微调整一下顺序，删除几张重复的ppt，划分一下小节就好了。</p><p>快乐而又迅速地交作业（</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>加减乘除法器</title>
    <link href="/2024/04/16/%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8/"/>
    <url>/2024/04/16/%E5%8A%A0%E6%B3%95%E5%99%A8%E4%B8%8E%E4%B9%98%E6%B3%95%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%8A%A0%E6%B3%95%E5%99%A8.jpg" alt="加法器"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%87%8F%E6%B3%95%E5%99%A8.png" alt="减法器"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E4%B9%98%E6%B3%95%E5%99%A8.jpg" alt="乘法器"><br>今天把之前艾美疫苗送的笔记本写完了，，可喜可贺<br>虽然除法器还没考过不过以防万一稍微瞄一眼<br><img src="/../img/%E8%AE%A1%E7%BB%84/32-bit%E9%99%A4%E6%B3%95%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="32-bit除法器的工作流程图"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E9%99%A4%E6%B3%95%E5%99%A8%E5%9B%BE%E7%A4%BA.jpg" alt="除法器图示"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对于与门或门实现更好的理解</title>
    <link href="/2024/04/16/%E5%AF%B9%E4%BA%8E%E4%B8%8E%E9%97%A8%E6%88%96%E9%97%A8%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2024/04/16/%E5%AF%B9%E4%BA%8E%E4%B8%8E%E9%97%A8%E6%88%96%E9%97%A8%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>众所周知与门&#x3D;与非门+非门，或门&#x3D;或非门+非门</p><p>非门其实就是一个CMOS反相器</p><p>与非：1变0，NMOS擅长，接地，但NMOS不能直接接电源，所以最上面的NMOS要上接一个PMOS。同理另一个为了对称也接一个PMOS，但是PMOS不能接地，所以两个PMOS的下端与两个NMOS的上端要引出Y端（把两个PMOS门画在NMOS门的上面 使得它们整体隔开会好画一点</p><p>或非：0变1，PMOS擅长，接电源，但PMOS不能直接接地，所以最下面的PMOS要下接一个NMOS。同理另一个为了对称也接一个NMOS，但是NMOS不能接电源，所以两个NMOS的上端与两个PMOS的下端要引出Y端（把两个NMOS门画在PMOS门的下面 使得它们整体隔开会好画一点<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E4%B8%8E%E9%9D%9E%E4%B8%8E%E6%88%96%E9%9D%9E.jpg" alt="与非与或非"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRAM数字电路设计</title>
    <link href="/2024/04/16/SRAM%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/04/16/SRAM%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>难得gpt做了次人，遂记录一下和它的对话（整理后版本</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/SRAM%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5.jpg" alt="SRAM一些概念"></p><p>SRAM基本单元由两个CMOS反相器（其实就是两个非门）组成，两个反相器的输入输出交叉连接，即第一个反相器的输出连接第二个反相器的输入，第二个反相器的输出连接第一个反相器的输入。这实现了两个反相器输出状态的锁定、保存，即存储了一个位元的状态。</p><h1 id="BL：Bit-Line（位线）"><a href="#BL：Bit-Line（位线）" class="headerlink" title="BL：Bit Line（位线）"></a>BL：Bit Line（位线）</h1><p>在SRAM（静态随机存取存储器）的数字电路设计中，”BL” 通常指的是 “Bit Line”。</p><p>在SRAM单元中，位线用于连接存储单元和读&#x2F;写电路。它承载存储单元中的数据位，并负责将这些数据传输到读&#x2F;写电路以进行读取或写入操作。</p><p>在SRAM的读操作中，位线被用作数据传输路径，将存储单元中的数据位传输到读取电路。在写操作中，位线负责将数据位传输到存储单元，以更新存储的数据。</p><h1 id="Word-Line（字线）"><a href="#Word-Line（字线）" class="headerlink" title="Word Line（字线）"></a>Word Line（字线）</h1><p>在SRAM单元中，字线用于选择存储单元进行读或写操作（不管是读还是写，WL都为1，过程结束时为0）。当字线激活时，它会打开连接到该字线的所有存储单元的传输门，从而允许读取或写入操作。</p><p>在读操作中，字线使得选定的存储单元的数据位能够流入位线（Bit Line）进行读取。在写操作中，字线允许数据位从位线传输到选定的存储单元，以更新存储的数据。</p><h1 id="Q（输出）"><a href="#Q（输出）" class="headerlink" title="Q（输出）"></a>Q（输出）</h1><p>在数字电路设计中，通常使用 “Q” 来表示输出信号。这个标记表示该部分或组件的输出端。</p><p>例如，在触发器或存储器单元中，”Q” 和 “&#x2F;Q”（Q的反相输出）通常表示状态或数据的输出。这些输出可以连接到其他电路部分，以实现数据传输和处理。</p><h1 id="读-x2F-写过程"><a href="#读-x2F-写过程" class="headerlink" title="读&#x2F;写过程"></a>读&#x2F;写过程</h1><p><img src="/../img/%E8%AE%A1%E7%BB%84/SRAM%E8%AE%BE%E8%AE%A1.jpg" alt="SRAM设计"><br>SRAM设计中，WL为1时写入BL，并在Q中输出BL</p><p>在SRAM（静态随机存取存储器）的设计中，当Word Line（WL）被激活为逻辑”1”时：</p><ol><li><p><strong>写入操作</strong>：将位线（Bit Line，BL）的数据写入选定的存储单元。</p></li><li><p><strong>读取操作</strong>：存储单元的数据位被传输到位线（Bit Line，BL）。</p></li></ol><p>这时，”Q” 通常表示存储单元的输出，即位线（Bit Line，BL）的内容。当执行读取操作时，Q会输出位线上的数据，反映存储单元的状态。</p><p>SRAM的运行在写入和读出时基本没有区别。</p><h1 id="断电后SRAM将丢失所有电荷状态"><a href="#断电后SRAM将丢失所有电荷状态" class="headerlink" title="断电后SRAM将丢失所有电荷状态"></a>断电后SRAM将丢失所有电荷状态</h1><p>断电后的SRAM（静态随机存取存储器）不能持续存储数据。SRAM的存储方式是基于电荷状态在存储单元中存储数据，而这些电荷会随着时间和电流的丧失而消散。</p><p>当电源关闭时，SRAM中的电荷会迅速耗尽，导致数据丢失。这与DRAM（动态随机存取存储器）不同，DRAM使用电容来存储数据，需要定期刷新以保持数据，即使在断电后也能短暂保留数据。</p><p>因此，SRAM需要持续的电源供应以保持数据，一旦电源被中断或关闭，存储在其中的数据会立即丢失。</p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组期中复习-微程序控制器</title>
    <link href="/2024/04/14/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <url>/2024/04/14/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E8%AE%A1%E7%BB%84/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E8%A1%A5%E5%85%A8%E4%BB%A3%E7%A0%81.png" alt="微程序控制器补全代码"><br>怎么理解指令和微指令呢？大概就是微指令从指令中拆分出具体的很小的一个单位步骤，指令分为两个字节。前一个字节的前4位是操作码，后四位是寄存器号或者0000（像JMP没有寄存器所以就直接0000），第二个字节<strong>一定</strong>是存储单元地址（所以之前有一道选择题说能不能是寄存器+寄存器呢？对不起，不行，必须要有一个地址。<br>在这里设计的四条指令分别是：</p><ol><li>ADD R, M<br>◦ 功能： 将R的内容与M中的内容相加后存入R</li><li>LOAD R, M<br>◦ 功能： 将M中的内容装入R</li><li>STORE M, R<br>◦ 功能： 将R的内容存入M中</li><li>JMP L<br>◦ 功能： 无条件转向L处</li></ol><p>注： M和L为存储器地址， R为寄存器编号</p><h1 id="取指令"><a href="#取指令" class="headerlink" title="取指令"></a>取指令</h1><p>每条指令的T1周期， 都要发出PC_OUT、 MAR_IN、 M_读和PC_加共四个信号。这条微指令形式的信号序列如下：1111000000000000<br>每条指令的T2周期， 都要发MDR_OUT、 IR_IN两个信号这条微指令形式的信号序列如下：0000110000000000<br><img src="/../img/%E8%AE%A1%E7%BB%84/T1%E5%92%8CT2.jpg" alt="T1和T2"><br>故T2的微操作字段为0000110000000000，下址字段不是像T1周期执行完之后无脑下一步（毕竟T1释放了PC+信号，但是T2不是直接PC+，而是要看这个指令具体在哪里。从T1机器周期就开始传递的这个数据正是下一个要执行的指令地址。</p><p>下址字段为1xx10</p><p>最高位的1<br>意义：这通常表明，接下来的微指令将发生一个条件性的跳转。也就是说，CPU的下一步行动并不是简单地执行下一个顺序的微指令地址，而是根据某个条件来决定跳转的目标地址。（该例为执行IR寄存器中的内容（指令地址（指令寄存器</p><p>中间的xx<br>意义：这部分通常代表指令的操作码，它用于指示当前执行的指令类型。在微程序设计中，这可以用于基于正在执行的机器指令来选择相应的微指令流程。<br>例子：如果“xx”是从指令寄存器（IR）中解析出的当前机器指令的部分字段（比如操作码），这可以用来决定执行哪一组微指令。（load为00，add为01，store为10，jmp为11）</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E7%AD%94%E6%A1%88.png" alt="答案"><br>最后的10<br>其实也很好理解。因为不管是LOAD, ADD, STORE, 还是JMP，他们的“第一个”（图中是T3）的地址的后两位都是10（注意机器周期从开1始算，但是地址从0开始算</p><p>最上面那个取指令对于所有的指令LOAD, ADD, STORE, JMP都适用（即，分别取LOAD, ADD, …）都要从第一个机器周期开始算。因为不管是哪个指令首先都得从PC取出来，所以他们在T1和T2的步骤是一样的。</p><h1 id="LOAD-R-M"><a href="#LOAD-R-M" class="headerlink" title="LOAD R, M"></a>LOAD R, M</h1><p>然后就是LOAD指令在T3和T4的机器周期干了什么</p><p>先来看看LOAD指令在所有的周期干了什么吧<br>指令“LOAD R1, M1”的执行过程：<br><strong>① 取指令并形成下一条指令的地址（所有指令通用</strong><br>I. 控制器发“PCOUT” 和“MARIN” 信号， 使PC→MAR<br>II. 控制器发“M读” 信号， 使存储器的内容（指令） →MDR<br>III. 控制器发“PC加” 信号， 使PC+n→PC， 其中n为该指令占用的地址数<br>IV. 控制器发“MDROUT” 和“IRIN” 信号， 使MDR→IR</p><p>（上面的都干过了）</p><p><strong>② 执行指令“LOAD R1, M1”</strong><br>I. 控制器发“IROUT” 和“MARIN” 信号， 使IR中指令的地址段（即M1） →MAR<br>II. 控制器发“M读” 信号， 使存储器M1的内容（数据） →MDR<br>III. 控制器发“MDROUT” 和“R1IN” 信号， 使MDR→R1</p><p>我们重点关注②。LOAD R, M的功能是将M中的内容装入R。<br>I和II组合组成了T3：0110 0010 0000 0000<br>（注意MDRin没有用到，把指令读到MDR的指令是M读，而不是MDRIN<br>因为load还没执行完，所以下址字段无条件跳转到LOAD的下一个周期所在微地址0011（最高位的0标志无条件跳转）</p><p>III就是T4，因为此时LOAD的核心功能已经完成，所以下址字段为End指令所在位置。</p><h1 id="ADD-R-M"><a href="#ADD-R-M" class="headerlink" title="ADD R, M"></a>ADD R, M</h1><p>（省略取指令步骤</p><blockquote><p>执行指令“ADD R1,M2”<br>I. 控制器发“IROUT” 和“MARIN” 信号， 使IR中指令的地址段（ 即M2） →MAR<br>II. 控制器发“M读” 信号， 使存储器M2的内容（数据） →MDR，通过DBUS<br>III. 控制器发“MDROUT” 和“YIN” 信号， 使MDR→Y（ 即ALU的A端）<br>IV. 控制器发“R1OUT” ， 使R1→内部总线（ 即ALU的B端）<br>V. 控制器发“add” 信号， 使A+B→Z<br>VI. 控制器发“ZOUT” 和“R1IN” 信号， 使Z→R1</p></blockquote><p>这么冗长的步骤我也记不住啊，，一条条分解吧</p><p>ADD R,M的核心功能是把M中的内容取出来与R相加再存入R中。<br>M从哪来？<br>IR指令中来，指令中包含了所求地址，所以IR_OUT,它现在在总线，我再MAR_IN一下。（MAR和MDR的区别是，一个存的是这个地址，一个存的是地址的内容</p><p>我怎么读出这个M中的内容呢？（因为是内容相加而不是地址相加）那好办，M_读一下，MAR寄存器中存的地址<strong>的内容</strong>就到总线去了。然后把总线的内容通过MDRIN就可以读入MDR了</p><p>–to be continued</p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯？动归？</title>
    <link href="/2024/04/13/%E5%9B%9E%E6%BA%AF/"/>
    <url>/2024/04/13/%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<p>小红书笔试写到一道回溯题，，来不及写了，故在这里写完康康（正确率18%<br><img src="/../img/%E7%AC%94%E8%AF%95/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240413144759.png" alt="粉丝数问题"><br>祭出我写了一半的回溯代码，，（也有动归的残骸</p><p>漏看了一条很重要的信息：只有一个账号能推广多次<br>（带摄像头的线上笔试真的太磨人了，，，屏幕比较小没放大根本看不见</p><p>当时想加个最小值的返回判定但是来不及编译了，，加上去应该正确率不止这么点，挺可惜的，，不过就算写了也没来得及考虑推广多次的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// int dp[101][101];</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-comment">// 定义函数体</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ddd</span><span class="hljs-params">(<span class="hljs-type">int</span> bb,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>||bb&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x;i++)&#123;<br>        <span class="hljs-type">int</span> ii= a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x&gt;=ii)&#123;<br>            flag|=<span class="hljs-built_in">ddd</span>(bb<span class="hljs-number">-1</span>,x-ii);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 感觉还是动态规划</span><br>    <span class="hljs-comment">// 好像是回溯啊 那完蛋了</span><br><br>    <span class="hljs-comment">// 第一个参数是最少需要推广几次</span><br>    <span class="hljs-comment">// 第二个参数是现在的粉丝数量（这次推广之后</span><br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-comment">// for (int i=0;i&lt;n;i++)&#123;</span><br>    <span class="hljs-comment">//     int ii=a[i]/2;</span><br>    <span class="hljs-comment">//     dp[1][a[i]/2]=1;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ddd</span>(i,x))&#123;<br>            flag=<span class="hljs-literal">true</span>;<br>            cout&lt;&lt;i;<br>            <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!flag)&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// cout&lt;&lt;flag;</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>翻到了网上的解析，是用动归做的 因为我先做的下一题，，所以后来觉得这题不用动归做</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>]; <span class="hljs-comment">// 本来我想设二维的，但是发现一维就够了</span><br><span class="hljs-comment">// dp[x]表示粉丝数恰好为x时至少需要推广的次数</span><br><span class="hljs-comment">// 初值全都赋成INF_MAX</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<span class="hljs-comment">// 输入的原账号的粉丝量</span><br><span class="hljs-type">int</span> t[<span class="hljs-number">100</span>];<span class="hljs-comment">// 每个账号推广后实际涨粉数（</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 这里就除以二 后面看着好看点</span><br>    &#125;<br>    <span class="hljs-comment">// 先考虑每个账号至多推广一次的情形</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>        dp[i]=<span class="hljs-number">99999</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        dp[t[i]]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// bool flag=0;</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span> (i-t[j]&gt;=<span class="hljs-number">0</span>)&#123;<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-t[j]]+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-comment">// 控制一下下标范围，当时太急了也没来得及写</span><br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> tmp = dp[x];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x;j++)&#123;<br>            dp[j]=<span class="hljs-number">99999</span>;<br>        &#125;<br>        t[i]=a[i];<br>        <span class="hljs-comment">// dp[t[i]]=1;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            dp[t[j]]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 还有一个忽视了的点！题目问的是账号数不是推广的总次数</span><br>        <span class="hljs-comment">// 所以这里推广多次的账号dp值不需要设成2</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=x;j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;n;m++)&#123;<br>                <span class="hljs-keyword">if</span> (j&gt;=t[m])&#123;<br>                    dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-t[m]]+<span class="hljs-number">1</span>);<br>                &#125;<br>                <span class="hljs-comment">// 下标合法性</span><br>            &#125;<br>        &#125;<br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 回溯（bushi</span><br>        tmp = <span class="hljs-built_in">min</span>(tmp,dp[x]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[x]!=<span class="hljs-number">99999</span>)&#123;<br>        cout&lt;&lt;dp[x];<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout&lt;&lt;flag;</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>输出了一下还是错，，比对了一下标准答案发现是因为重新初始化，所以把之前迭代的数据丢失了，缺失了只推广一半粉丝数的数据，，所以蝴蝶效应影响到了其他的dp值（和循环内外顺序以及++&#x2F;–没有关系！</p><p>AC代码（应该AC了吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">101</span>]; <span class="hljs-comment">// 本来我想设二维的，但是发现一维就够了</span><br><span class="hljs-comment">// dp[x]表示粉丝数恰好为x时至少需要推广的次数</span><br><span class="hljs-comment">// 初值全都赋成INF_MAX</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<span class="hljs-comment">// 输入的原账号的粉丝量</span><br><span class="hljs-type">int</span> t[<span class="hljs-number">100</span>];<span class="hljs-comment">// 每个账号推广后实际涨粉数（</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-type">int</span> n,x;<br>    cin&gt;&gt;n&gt;&gt;x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 这里就除以二 后面看着好看点</span><br>    &#125;<br>    <span class="hljs-comment">// 先考虑每个账号至多推广一次的情形</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=x;i++)&#123;<br>        dp[i]=<span class="hljs-number">99999</span>;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        dp[t[i]]=<span class="hljs-number">1</span>;<br>    &#125;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// bool flag=0;</span><br>    <br>    <span class="hljs-comment">// for (int j=0;j&lt;n;j++)&#123;</span><br>    <span class="hljs-comment">//     for (int i=t[j];i&lt;=x;i++)&#123;</span><br>    <span class="hljs-comment">//         dp[i]=min(dp[i],dp[i-t[j]]+1);</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=x;i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">if</span> (i&gt;=t[j])&#123;<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-t[j]]+<span class="hljs-number">1</span>);<br><br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-type">int</span> tmp = dp[x];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-comment">// for (int j=1;j&lt;=x;j++)&#123;</span><br>        <span class="hljs-comment">//     dp[j]=99999;</span><br>        <span class="hljs-comment">// &#125;</span><br>        t[i]=a[i];<br>        <span class="hljs-comment">// dp[t[i]]=1;</span><br>        <span class="hljs-comment">// for (int j=0;j&lt;n;j++)&#123;</span><br>        <span class="hljs-comment">//     dp[t[j]]=1;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// dp[0]=0;</span><br>        <br>        <span class="hljs-comment">// 还有一个忽视了的点！题目问的是账号数不是推广的总次数</span><br>        <span class="hljs-comment">// 所以这里推广多次的账号dp值不需要设成2</span><br>        <br>        <br>        <span class="hljs-comment">// for (int m=0;m&lt;n;m++)&#123;</span><br>        <span class="hljs-comment">//     for (int j=t[m];j&lt;=x;j++)&#123;</span><br>        <span class="hljs-comment">//         dp[j]=min(dp[j],dp[j-t[m]]+1);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=x;j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m=<span class="hljs-number">0</span>;m&lt;n;m++)&#123;<br>                <span class="hljs-keyword">if</span> (j&gt;=t[m])&#123;<br>                    dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-t[m]]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <br><br>        t[i]=a[i]/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 回溯（bushi</span><br>        tmp = <span class="hljs-built_in">min</span>(tmp,dp[x]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dp[x]!=<span class="hljs-number">99999</span>)&#123;<br>        cout&lt;&lt;dp[x];<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// cout&lt;&lt;flag;</span><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>再尝试下把回溯的方法补完，但是发现非常复杂，，gpt说这道题的最佳解法就是动态规划，回溯效率不高，，那就这样吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>xhs笔试复盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小红书！</title>
    <link href="/2024/04/12/%E5%B0%8F%E7%BA%A2%E4%B9%A6%EF%BC%81/"/>
    <url>/2024/04/12/%E5%B0%8F%E7%BA%A2%E4%B9%A6%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>没写完啊啊啊啊啊（好好反思一下，，，</p><p>pyq已经发了一大段话了这里就不发了，，第一次做线上后端笔试题，，感觉奇妙</p><p>考完立马装了C++11(呜呜呜)</p><p>昨天霉霉夜奔好快乐，，，一堆图和视频（由于已经过了时效了于是非常言简意赅呜呜，，但是快乐是无法形容的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++11的新特性</title>
    <link href="/2024/04/11/C-11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2024/04/11/C-11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="类型推导关键字"><a href="#类型推导关键字" class="headerlink" title="类型推导关键字"></a>类型推导关键字</h1><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>让编译器通过初始值进行类型推演（必须有初始值！<br>先对底层const和顶层const进行说明：</p><h3 id="底层const（常量指针）"><a href="#底层const（常量指针）" class="headerlink" title="底层const（常量指针）"></a>底层const（常量指针）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p<br><span class="hljs-type">int</span> <span class="hljs-type">const</span>* p;<br></code></pre></td></tr></table></figure><p>这两种命名方式是等价的，指的都是常量指针，const在类型名前后都可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> num_a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span>  *p_a = &amp;num_a; <span class="hljs-comment">// 底层const</span><br><span class="hljs-comment">//*p_a = 2;  // 错误，无法修改对象的值</span><br>p = &amp;b; <span class="hljs-comment">// 正确，允许修改指向</span><br>num_a = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p>指向“常量”的指针不代表它所指向的内容一定是常量，只是代表不能通过解引用符（操作符*）来改变它所指向的内容。上例中指针p_a指向的内容就不是常量，可以通过赋值语句：num_a&#x3D;2;  来改变它所指向的内容。</p><h3 id="顶层const（指针常量）"><a href="#顶层const（指针常量）" class="headerlink" title="顶层const（指针常量）"></a>顶层const（指针常量）</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>手搓快排</title>
    <link href="/2024/04/10/%E6%89%8B%E6%90%93%E5%BF%AB%E6%8E%92/"/>
    <url>/2024/04/10/%E6%89%8B%E6%90%93%E5%BF%AB%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<p>大一的时候都是依赖vs studio那个非常大的软件来编译简单算法程序运行，，vscode对我的作用就是单纯地完成课堂搭建的服务器平台或者什么classmachine上的作业，环境也配得稀烂，甚至这个学期前都没跑通过python环境，，（甚至还以为是jupyter或者自己编程的问题，之前还把Python课退掉了</p><p>亏得这个学期选的一门创新创业课里配了个大模型环境，对自己的配环境技术有了稍稍地自信，由于之前为了腾内存以及认定自己要去体制内所以卸载了vs studio，导致基本没有现成可用的IDE，于是今天配了C++的运行环境。复制了launch.json, tasks.json, c_cpp_properties.json, 把vscode的环境变量（bin文件夹）也加进环境变量里去了。一个小时内终于能运行快排代码了（要不是面试要求手搓肯定hyx也不会想到倒腾这玩意，，</p><p>综合了两篇教程，设置了独立弹出的终端，，，非常有成就感，，（虽然zjt锐评这些事情他大一下就做过而我大三下居然才刚刚开始，，，但是对于一个对计算机没啥兴趣的人来说已经很厉害了orz</p><p>自己手搓了一份代码，不过数据具有偶然性，，发现有些数据跑不通（以下是错误代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; num;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>]=&#123;&#125;;<br>    <span class="hljs-type">int</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = num<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> tmp = a[base];<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// flag为0表示low为空指针，1表示high为空指针</span><br>    <span class="hljs-keyword">while</span>(high!=low)&#123;<br>        <span class="hljs-keyword">if</span> (flag==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// low为空指针，不操作low，只操作high</span><br>            <span class="hljs-keyword">if</span> (a[high]&gt;tmp)&#123;<br>                high--;<br>                <span class="hljs-comment">// high指向的数比基准值大，high左移一个单位</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                a[low]=a[high];<br>                <span class="hljs-comment">// high指向的数比基准值小，把a[high]赋值给a[low]</span><br>                flag=<span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 现在high为空</span><br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// high为空指针，不操作high，操作low</span><br>            <span class="hljs-keyword">if</span> (a[low]&lt;tmp)&#123;<br>                low++;<br>                <span class="hljs-comment">// low指向的数比基准值小，low右移一个单位</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                a[high]=a[low];<br>                <span class="hljs-comment">// low指向的数比基准值大，把a[low]赋值给a[high]</span><br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 现在low为空</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    a[high]=tmp;<br>    <span class="hljs-comment">// 当high指针和low指针重合时将基准值赋值给a[high]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>错误代码的总体思路：</p><p>基准值设在左边第一个。然后把a[0]取出来作为tmp基准值。设立两个指针low和high，初始low指向左边第一个，high指向右边第一个。初始low为空（因为low指向的值被取出来了），（我这里设了flag标定是对low操作还是对high操作，更简洁的方法是套两个while循环），主要作用就是一直找，找到第一个不应在这个位置的就和high&#x2F;low交换，待会码一个简洁版的。模拟了一下对21, 100, 3, 50, 100进行操作，发现只能实现3, 21, 100, 50, 100这样的功能，即只能保证基准值左边的比它小，基准值右边的比他大，但是这两个序列分别怎么排呢？不清楚，没排。（<strong>错因：没有递归</strong>）</p><p>正确代码：<br>（新增头文件algorithm，用来调用sort</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-comment">// 划分函数</span><br>    <span class="hljs-type">int</span> i = low;<br>    <span class="hljs-type">int</span> j = high;<br>    <br>    <span class="hljs-type">int</span> tmp = a[i];<br>    <span class="hljs-keyword">while</span>(j&gt;i)&#123;<br>        <span class="hljs-keyword">while</span>(a[j]&gt;tmp &amp;&amp;i&lt;j)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i&lt;j)&#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>            i++;<br>            <span class="hljs-comment">// 少了这一步！！！</span><br>        &#125;<br>        <span class="hljs-comment">// 一着急把if写在while里面了，，应该拿外面来</span><br>        <span class="hljs-keyword">while</span>(a[i]&lt;=tmp &amp;&amp; i&lt;j)&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 上面没加等于，所以这里加等于</span><br>        <span class="hljs-keyword">if</span> (i&lt;j)&#123;<br>            <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>            j--;<br>            <span class="hljs-comment">// 少了这一步</span><br>        &#125;    <br>        <br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> i;<br><br>&#125;<br><span class="hljs-comment">// 快速排序函数分为两部分</span><br><span class="hljs-comment">// 一部分是划分函数（需返回枢值位置），一部分是函数主体</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">if</span>(low&lt;high)&#123;<br>        mid = <span class="hljs-built_in">part</span>(low,high);<br>        <span class="hljs-comment">// 一紧张忘给mid赋值了</span><br>        <span class="hljs-built_in">quicksort</span>(low,mid<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">quicksort</span>(mid+<span class="hljs-number">1</span>,high);<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; num;<br>    <br>    <span class="hljs-type">int</span> base = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = num<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">quicksort</span>(<span class="hljs-number">0</span>,num<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps：今天打开vscode差点以为又不能运行了，吓鼠，，，仔细一看是因为没有在文件夹下</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>小米面试准备</title>
    <link href="/2024/04/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    <url>/2024/04/10/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<p>感觉来不及准备了所以搞点高频考点突击一下。</p><h1 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h1><h2 id="my-answer："><a href="#my-answer：" class="headerlink" title="my answer："></a>my answer：</h2><p>线程和别的线程共享一个地址空间？）每个进程有自己独立的地址空间<br>（用标准的角度讲应该属于拥有资源的角度<br>（其他忘了</p><h2 id="standard："><a href="#standard：" class="headerlink" title="standard："></a>standard：</h2><ol><li>调度：进程是<strong>资源管理</strong>的基本单位，线程是<strong>程序执行</strong>的基本单位。</li><li>切换：线程上下文切换比进程上下文切换要快得多。</li><li>拥有资源： 进程是拥有资源的一个独立单位，线程<strong>不拥有系统资源，但是可以访问隶属于进程的资源</strong>。</li><li>系统开销： 创建或撤销进程时，系统都要为之<strong>分配或回收系统资源</strong>，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li></ol><h1 id="面向对象的三个特征"><a href="#面向对象的三个特征" class="headerlink" title="面向对象的三个特征"></a>面向对象的三个特征</h1><h2 id="my-answer：-1"><a href="#my-answer：-1" class="headerlink" title="my answer："></a>my answer：</h2><p>不会斯密达</p><h2 id="standard：-1"><a href="#standard：-1" class="headerlink" title="standard："></a>standard：</h2><p>面向对象编程的三大特征是封装、继承和多态。</p><ol><li><p>封装：封装是指将数据和操作数据的方法（即函数）捆绑在一起，形成一个<strong>类</strong>。通过封装，我们可以<strong>隐藏内部实现细节，只暴露必要的接口给外部使用</strong>。这样可以提高代码的可维护性和安全性，并且方便其他开发者使用该类。</p></li><li><p>继承：继承是指一个类可以<strong>派生出子类</strong>，子类会继承父类的属性和方法。通过继承，子类可以重用父类的代码，并且可以在不修改父类的情况下进行功能扩展。继承可以建立类之间的层次关系，使得代码更加灵活和可扩展。</p></li><li><p>多态：多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。 那么在继承中要构成多态还有两个条件：必须通过基类的指针或者引用调用虚函数；被调用的函数必须是<strong>虚函数</strong>，且派生类必须对基类的虚函数进行重写.</p></li></ol><h1 id="介绍一下项目（操统）"><a href="#介绍一下项目（操统）" class="headerlink" title="介绍一下项目（操统）"></a>介绍一下项目（操统）</h1><p>因为每次应该都会问到所以感觉需要重点打磨。</p><p>结合一篇博客来重点作答一下（参考：博客园 MIT 6.S081 xv6调试不完全指北）</p><h2 id="操统版"><a href="#操统版" class="headerlink" title="操统版"></a>操统版</h2><p>印象比较深刻的一个项目是MIT 6.S081对xv6的优化，其中有一个部分需要实现为每个新进程单独分配一个属于它的内核页。里面的细节非常多，debug起来也比较困难。比如说要在scheduler切换进程的时候, 刷新TLB和使用的虚拟-物理页表影射base，而且当控制权返回给调度器时，要切换为全局内核页表。这个点让我debug了很久。</p><h3 id="可能延伸的问题"><a href="#可能延伸的问题" class="headerlink" title="可能延伸的问题"></a>可能延伸的问题</h3><h4 id="咋debug的？"><a href="#咋debug的？" class="headerlink" title="咋debug的？"></a>咋debug的？</h4><p>通过网上查阅操作系统的官方文档、技术论坛和社区的讨论，还有就是通过printf大法或者gdb调试。MIT 6.S081 2019提供的xv6采用的指令集是riscv，因此我们虚拟机上针对x86指令集的gdb可能无法较好的调试。我们需要用交叉编译工具来编译xv6，并用交叉编译工具提供的gdb来调试。</p><h5 id="关于gdb的延伸"><a href="#关于gdb的延伸" class="headerlink" title="关于gdb的延伸"></a>关于gdb的延伸</h5><p>通过-g调试命令，gdb可以监控pc（程序计数器）、sp（堆栈指针）、各类寄存器的值，结合ELF中的符号表，就可以将这些信息“翻译”为我们想要看的变量。比如说如果输入命令 file user&#x2F;_sleep，其目的就是告诉gdb，加载_sleep的符号表，用它的符号表去解释你看到的东西。</p><h5 id="printf一般print啥的延伸"><a href="#printf一般print啥的延伸" class="headerlink" title="printf一般print啥的延伸"></a>printf一般print啥的延伸</h5><ol><li><p><strong>进程切换相关信息</strong>：打印当前正在运行的进程ID，以及即将切换到的进程ID。这可以帮助确认进程切换逻辑是否按预期执行。</p></li><li><p><strong>页表信息</strong>：打印页表的内容，包括虚拟地址到物理地址的映射情况，以及页表项的各种标志位（如是否有效、访问权限等）。这可以帮助确认进程切换时页表是否被正确更新。</p></li><li><p><strong>CPU寄存器状态</strong>：打印CPU寄存器的当前状态，包括程序计数器（PC）、栈指针（SP）等。这可以帮助确定进程切换后CPU状态的正确性。</p></li><li><p><strong>内核空间的映射情况</strong>：打印内核页表的内容，以及当前CPU的SATP寄存器的值（即当前使用的页表基地址）。这可以帮助确认内核空间的映射是否正确切换。</p></li><li><p><strong>TLB的状态</strong>：打印TLB的内容，可以帮助确认TLB是否被正确刷新，以及新的地址映射是否已经生效。</p></li><li><p><strong>锁的获取和释放信息</strong>：打印进程切换过程中获取和释放的锁，以及锁的持有情况。这可以帮助检查进程切换过程中的并发访问是否受到正确的同步保护。</p></li><li><p><strong>内存管理相关信息</strong>：打印内存分配和释放的信息，以及内存池或内存区域的状态。这可以帮助确认内存管理功能是否按预期工作。</p></li></ol><h6 id="怎么打印锁"><a href="#怎么打印锁" class="headerlink" title="怎么打印锁"></a>怎么打印锁</h6><p>在操作系统的源代码中，锁通常会定义为一个结构体，其中包含锁的状态和与锁相关的其他信息。锁的定义通常会包括锁的状态（如是否被持有）、持有锁的进程ID等信息。我们可以在锁的源代码中添加printf语句，以便打印锁的状态和其他信息。</p><p>下面是一个简单的示例，假设有一个名为<code>my_lock</code>的锁，它的内部结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> &#123;</span><br>    <span class="hljs-type">int</span> is_locked;<br>    <span class="hljs-type">int</span> holding_pid;<br>    <span class="hljs-comment">// 其他锁相关的信息</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock</span> <span class="hljs-title">my_lock</span>;</span><br></code></pre></td></tr></table></figure><p>在需要打印锁信息的地方，可以添加类似以下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Lock status: %s\n&quot;</span>, my_lock.is_locked ? <span class="hljs-string">&quot;Locked&quot;</span> : <span class="hljs-string">&quot;Unlocked&quot;</span>);<br><span class="hljs-keyword">if</span> (my_lock.is_locked) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Holding process ID: %d\n&quot;</span>, my_lock.holding_pid);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关于交叉编译的延伸"><a href="#关于交叉编译的延伸" class="headerlink" title="关于交叉编译的延伸"></a>关于交叉编译的延伸</h4><p>交叉编译是指在一个主机上为另一个不同体系结构的目标平台（通常是嵌入式系统或者其他类型的系统）编译软件。在交叉编译过程中，编译器、链接器和其他开发工具被配置为生成目标平台上可执行的代码，而不是在主机上运行的代码。</p><h4 id="关于riscv的延伸"><a href="#关于riscv的延伸" class="headerlink" title="关于riscv的延伸"></a>关于riscv的延伸</h4><p>RISC-V采用精简的指令集设计，只包含少量基本指令，并且设计为模块化的架构。它允许处理器设计者根据特定的应用需求选择添加适当的扩展，以实现更高级别的性能和功能，设计用于各种用途的计算机处理器，包括嵌入式系统、个人计算机、服务器和超级计算机等。它的设计理念是基于精简、模块化和可扩展的原则，旨在提供高性能、低功耗和可靠性。</p><p>可扩展性：RISC-V架构具有多个标准扩展，包括基本指令集（RV32I&#x2F;RV64I）、乘法&#x2F;除法扩展（M）、原子操作扩展（A）、浮点数扩展（F&#x2F;D）、向量扩展（V）等。这些扩展允许处理器设计者根据需求选择添加额外的功能，例如浮点运算、向量计算等。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>歌词存档</title>
    <link href="/2024/04/10/%E6%AD%8C%E8%AF%8D%E5%AD%98%E6%A1%A3/"/>
    <url>/2024/04/10/%E6%AD%8C%E8%AF%8D%E5%AD%98%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>前半部分歌词orz！感觉这版写的比之前的流水账好（后半段写的尤其好</p><p>以及今天投了简历玩（书到用时方恨少啊，，怎么就把之前的课件和课程资料全删光了，，</p><p>想过平凡的每天&#x2F;也想勇敢向前<br>想要游荡在旷野&#x2F;却把亲人想念<br>愤世嫉俗的谎言&#x2F;被无力感裹挟<br>清澈带盐的海风&#x2F;结局却不能回头</p><p>抬头是狂风沙暴&#x2F;北京真是荒漠<br>低头是预制汤锅&#x2F;吃货开始emo<br>明明已二十出头&#x2F;却仍不想长大<br>每天将光阴虚过&#x2F;我到底犯错了吗</p><p>技术不停地迭代&#x2F;他们奋力在追赶<br>人们啊各自相残&#x2F;以同伴尸骸为餐<br>数据像量子海洋&#x2F;海浪上升不停歇<br>城市被齐齐切割&#x2F;我们不停地坠落</p><p>秋冬春夏的色彩&#x2F;沿四面八方飞散<br>操纵者躲在幕后&#x2F;管窥着斑斓巨兽<br>人们紧紧地拥抱&#x2F;三维向二维坍缩<br>那文明绘制的画&#x2F;如此短暂而哀伤</p>]]></content>
    
    
    
    <tags>
      
      <tag>写歌尝试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生出来了！</title>
    <link href="/2024/04/08/%E7%94%9F%E5%87%BA%E6%9D%A5%E4%BA%86%EF%BC%81/"/>
    <url>/2024/04/08/%E7%94%9F%E5%87%BA%E6%9D%A5%E4%BA%86%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>在没有教程的情况下，学会了采样乐器的方法，学会了调试混音参数，学会了设定采样区间，学会了渐入渐出，而且今天编的旋律比昨天的好听（昨天的不适合唱，跨度太大，今天的已经比较接近一些口水歌了</p><p>明天去新太阳录demo</p><p>特地在中午洗头并且编了头发，戴了蝴蝶结，穿了短裙和小白鞋，学了一些（很多）国际音标（很神奇！）明天继续戴蝴蝶结（今天戴了弹簧夹，明天戴抓夹嘿嘿</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>音韵学存档</title>
    <link href="/2024/04/06/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%AD%98%E6%A1%A3/"/>
    <url>/2024/04/06/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%AD%98%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%9F%BA%E6%9C%AC%E4%BA%94%E5%85%83%E9%9F%B3.png" alt="基本五元音"><br>i-最高最前  u-最高最后  a-最低 开口度最大</p><p>中间的过渡生成了e和o两种音</p><p>前展后圆规律：发音在前的一定是展的，发音在后的一定是圆的</p><p><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E8%88%8C%E9%9D%A2%E5%85%83%E9%9F%B3.png" alt="舌面元音"><br>最中间的是央元音（着、了、的）（发音最轻松的音 所以一般用作助词</p><p><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E8%88%8C%E5%B0%96%E5%85%83%E9%9F%B3.png" alt="舌尖元音"><br>把“姿”和“知”的辅音部分去掉就变成那个不认识的东西的读音</p><p>另外两个就是把“卒”和“猪”的辅音部分去掉<br><img src="/../img/%E9%9F%B3%E9%9F%B5%E5%AD%A6%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/%E5%8D%8A%E5%85%83%E9%9F%B3.png" alt="半元音"></p><p>牙和阳因为要发音（直接用作辅音的那种），所以要浊化一点（就是发音的厉害一点，，细微的区分</p>]]></content>
    
    
    
    <tags>
      
      <tag>音韵学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】想要做很多很多很酷的事情</title>
    <link href="/2024/04/05/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%83%B3%E8%A6%81%E5%81%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E9%85%B7%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <url>/2024/04/05/%E3%80%90%E7%BD%AE%E9%A1%B6%E3%80%91%E6%83%B3%E8%A6%81%E5%81%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E5%A4%9A%E5%BE%88%E9%85%B7%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    
    <content type="html"><![CDATA[<p>前几天在梦想清单里也写了一些近期或未来想干的事情，比如想写一首歌（晚上已经在倒腾suno了，由于生成旋律相对容易但是拟合中文歌词比较不成熟，所以现在目前的进度还在：有旋律，但想着填词）！因为自己无法独立与长辈交流所以想学习玉环话音韵学（已经下载了pdf），发现自己有很多想干的事情！（感觉找回了一点活力</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>梦想清单</title>
    <link href="/2024/04/03/%E6%A2%A6%E6%83%B3%E6%B8%85%E5%8D%95/"/>
    <url>/2024/04/03/%E6%A2%A6%E6%83%B3%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<p>感觉自己很长一段时间都处在一种迷茫的状态，很想走出这种状态！从现在开始尝试吧</p><p>我感觉我是比较幸运的人，父母也非常开明。我一直都认为工作是非常耗尽心力的事情，而且我对一致性、不变性的追求已经到了一种病态的程度，也许这和安全感的稀缺有关系。在昨天深更半夜和zjt聊天以及今天早上践行一些提问的时候“被迫”和父母进行了交谈，我才第一次意识到人生可以是不那么stable的。毕竟人生只有一次！我也认为应该活得wild一点。</p><p>我一直认为我是一个很注重稳定性的人，但是我发现我日常的举动无不体现着“自由精神”，从小翘课，公然违抗老师命令，有自己的主见，有自己喜欢的乐器和乐队，讨厌规规矩矩，讨厌被束缚。只是对安全感的过分追求让我作茧自缚。我想我不应该被困住。我企图用一条确定的道路困住自己，这样就可以自己不用再思考。但是被困住的人生真的是我想要的吗？</p><p><strong>我想要做出怎样的事，让6岁的自己崇敬不已？</strong></p><p>一定不是随波逐流，那时候我总是察言观色，非常没有安全感，如果我接下来的生活依然能够保持孩童的好奇心，想要了解什么就尽力去了解，不要丧失对生活的活力，大脑依旧在转动，想尝试什么就尽量尝试（比如说旅游、组乐队、编曲、画画、学语言、看文学作品）。那我一定会非常崇敬。</p><p><strong>如果我是上帝，准备怎样拯救世界？</strong></p><p>我很崇敬多萝西娅这样的上帝式的角色，她希望让身边的人都幸福而不太看重自己的幸福。其实我也无法想象怎么拯救世界，，，我希望像wowaka一样，燃烧自己，呐喊出自己心中所想，让别人在他的音乐中受到拯救，自己也受到了拯救，这种互相救赎的感觉是极好的。</p><p><strong>如果没有经济限制，你想做什么？</strong></p><p>在市中心有一套独立的小别墅（其实已经有了但是不在市中心，，无所谓，在杭州实现经济自由之后可能真的会回去吧，会请很长很长的年假！）（当然如果工作是线上的话就更好了，在哪里都无所谓，想回去就回去（我dream一下！）</p><p>但是那个小别墅应该是我爸妈养老的地方所以我还是倾向于自己搞一个场地，然后我就练练电吉他，疯一疯（如果能遇到志同道合的乐队朋友的话</p><p><strong>你认为在怎样的事情中可以复现你曾经的精神体验？</strong></p><p>沉浸式、、形成心流的事情其实都可以，画手书的时候（全神贯注），在新太阳地下室躲在门后用民谣吉他大唱特唱摇滚乐的时候，看完电影之后写感想的时候，总之是输出性质的工作的时候都可以</p><p><strong>如果只有一年好活了，你会干什么？</strong></p><p>买一个电吉他（没错我甚至还没有电吉他），配备一些小音箱，找个老师先领我入门然后我大玩特玩</p><p>吃很多很多的三文鱼</p><p>很想把家乡话学会，，现在是只能讲日常用语的程度，，（其实现在就想看看有没有记载太平话的音韵学的书</p><p><strong>你的高我的事业是什么？</strong></p><p>先渡己，后渡人。</p><p><strong>你希望被后世怎样记得？</strong></p><p>她是一个天真的老顽童，有些不可思议，似乎她总是很幸运，只要是她想要得到的她就一定会达成。（她可能拥有很多追随者，也可能身后空无一人，但这对她都无所谓</p><p><strong>你的墓碑上只能写一个身份，你希望是什么？</strong></p><p>自由人！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>树洞奇遇</title>
    <link href="/2024/04/02/%E6%A0%91%E6%B4%9E%E5%A5%87%E9%81%87/"/>
    <url>/2024/04/02/%E6%A0%91%E6%B4%9E%E5%A5%87%E9%81%87/</url>
    
    <content type="html"><![CDATA[<p>歌词接龙 要求：不是同一首歌，但是意思能连贯起来</p><p>洞友的力量真是太强大了！（我是D君</p><blockquote><p>第一句：我来到，你的城市<br>#27690146 12小时前 04-02 00:46<br>[Alice] 坐在小酒馆的门口<br>#27690153 12小时前 04-02 00:46<br>[Bob] 来一首我最爱的普通音乐<br>#27690160 12小时前 04-02 00:47<br>[Carol] 钟声响起归家的讯号<br>#27690172 12小时前 04-02 00:48<br>[Dave] 夜太乱以为心已与你交换<br>（E君格式不对 叉出去<br>#27690183 12小时前 04-02 00:48<br>[Francis] 杂讯太多信号弱 就连风吹都要干扰<br>#27690185 12小时前 04-02 00:48<br>[Grace] 光落在你脸上 可爱一如往常<br>#27690188 12小时前 04-02 00:49<br>[Hans] 神魂颠倒<br>#27690191 12小时前 04-02 00:49<br>[Isabella] 我颠颠又倒倒<br>#27690211 12小时前 04-02 00:50<br>[Jason] 听得见过山车有远渐驶近<br>#27690288 12小时前 04-02 00:55<br>[Carol] 透过手指尖看着天<br>#27690319 12小时前 04-02 00:57<br>[Francis] 天黑黑 会不会 让我忘了你是谁<br>[Kate] Re Francis: 谁能给我麻木的酒 醒着醉<br>[Louis] Re Kate: 以为你 有天会感动<br>#27690459 12小时前 04-02 01:09<br>[Margaret] 你却始终站在梦里难触碰<br>#27691472 5小时前 04-02 08:26<br>[Nathan] 如果再看你一眼 是否还会有感觉<br>[Olivia] Re Nathan: 想着或许，下个路口仍是同样的结局<br>#27691836 4小时前 04-02 09:38<br>[Paul] 每天都追赶太阳</p></blockquote><p>中午不知道吃啥就点了袁记云饺，结果去了发现外卖没了，桌子上还摆放着好多袁记云饺。猜测估计是别人拿错了。刚发一条树洞就发现下一条刚好是那个同学发的（一路小跑拿回来好可爱哈哈哈哈哈哈啊哈哈）算是奇遇了，非常好玩。遂拎着袁记云饺去了理教（因为路上突然收到了见面课通知，but没带包 直奔签到现场吃饭然后折返</p><p>星有野居然玩蛋仔啊啊啊！狮哥狮姐啥时成哇（</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>今日（昨日）成就！</title>
    <link href="/2024/04/02/%E4%BB%8A%E6%97%A5%EF%BC%88%E6%98%A8%E6%97%A5%EF%BC%89%E6%88%90%E5%B0%B1%EF%BC%81/"/>
    <url>/2024/04/02/%E4%BB%8A%E6%97%A5%EF%BC%88%E6%98%A8%E6%97%A5%EF%BC%89%E6%88%90%E5%B0%B1%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>继上节体育课偶然发现自己已经可以连续踢出两个毽子后这几天加紧练习！虽然大部分时候还是只能踢一个但是偶尔也可以踢出四个（单只脚），有很大的进步！</p><p>爪爪大作战mvp及获胜记录增加了很多！爪爪技术精进！判断推理刚好看到讲义的第99页（经zjt提醒才发现还有网课要听），经济地理学完全不想写读书笔记，，，（打算gpt）主要这个学期看的电子书实在太多了比较烦了</p><p>感觉自己大学后期的学习主要看兴趣和内驱力，，感兴趣的就多看一点，不感兴趣的就少看一点，甚至感兴趣的都懒得按格式写（认为格式的组织影响了我脑内观点的输出），虽然老师站在学术的角度还是很强调格式，，不过选英语课的人有几个最后真的去做研究呢（至少选英语课的都不是外院的人，我也是觉得读论文比较有意思，反正我读的评论文体也少，不需要花大量时间去组织资料，可能做学术的更需要条条框框吧</p><p>甚至因为自己厌恶条条框框对自己将来的职业规划产生了怀疑。不过晚上仔细想了一下，如果是自己不感兴趣的内容（应付摆烂式），顺便把格式做了对我来说也没有大碍，主要还是自己感兴趣的内容因为自己有很多自己的想法，所以就不想按照格式。不过以后的工作大概率是自己不感兴趣的。无论是大厂螺丝钉比较单一的职能，还是信息老师这种单一授课，或者其他泛体制内岗位。所以如果怀着摆烂心态的话，有没有条条框框都无所谓了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计组期中兼MOOC梳理-2</title>
    <link href="/2024/04/01/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%85%BCMOOC%E6%A2%B3%E7%90%86-2/"/>
    <url>/2024/04/01/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%85%BCMOOC%E6%A2%B3%E7%90%86-2/</url>
    
    <content type="html"><![CDATA[<p><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BF%98%E5%8E%9F%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81-1.png" alt="还原机器代码-1"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BF%98%E5%8E%9F%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81-2.jpg" alt="还原机器代码-2"><br>前面都没问题，注意一下beq那行（一般beq都是while循环），而且后面一般跟label</p><blockquote><p>虽然偏移量是1，不过实际上读的是下下一条指令（毕竟没有偏移的话就直接读下一条了（很重要！！</p></blockquote><p>D触发器：主要有一个数据输入、一个数据输出和一个时钟输入。在时钟clock的上升沿（0→1）， 采样输入D的值，传送到输出Q， 其余时间输出Q的值不变</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8.png" alt="2016期中-一位全加器"><br>为什么与S连的都是或非门？（A,B两个输入先或非一下，然后再和进位的输入或非），因为S只是某一位的取值（类比个位 只需关注奇偶）又加上二进制只有10两个数字，所以看一下一不一样就行</p><p>为什么Cout先连与门再连或门？AB两个输入先与一下，如果全是1那就构成进位条件。如果AB不全是一呢？没关系AB只要有一个是1就可以了（异或为1），并且如果输入的进位也是1的话也可以构成进位条件，两者满足其一就可以<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BE%93%E5%87%BA%E4%BF%A1%E5%8F%B7i+1.png" alt="进位输出信号分析"><br>可以推一下i&#x3D;1的时候的公式<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%BF%9B%E4%BD%8D%E4%BF%A1%E5%8F%B7%E5%85%AC%E5%BC%8Fi+1%E6%8E%A8%E5%AF%BC.jpg" alt="2016期中-进位信号公式i+1推导"><br>以上都是行波进位加法器。</p><p>如果是超前进位加法器：<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%B6%85%E5%89%8D%E8%AE%A1%E7%AE%97%E8%BF%9B%E4%BD%8D%E4%BF%A1%E5%8F%B7%EF%BC%88%E4%B8%89%E7%BA%A7%E9%97%A8%E5%BB%B6%E8%BF%9F%EF%BC%89.png" alt="超前计算进位信号（三级门延迟）"><br>他主要优化的点在于C2的值不需要依赖C1，节省了等待时间（全都是并行计算的），一个竖列的全都是同时算出来，总共三个数列，所以计算Ci的延迟时间固定位三级门延迟</p><p>但是总的一整个超前进位加法器是四级门延迟的。那是因为S3的计算依赖于C3，而计算C3需要三级门延迟。所以计算出S3需要四级门延迟（关键路径<br><img src="/../img/%E8%AE%A1%E7%BB%84/%E8%B6%85%E5%89%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="超前进位加法器"></p><p><img src="/../img/%E8%AE%A1%E7%BB%84/2016%E6%9C%9F%E4%B8%AD-%E4%B8%8E%E9%97%A8.png" alt="2016期中-与门"><br>非门记忆：让positive的人在上面，本negative人只想当一个阴暗爬行的接地鼠鼠<br><img src="/../img/%E8%AE%A1%E7%BB%84/2017%E6%9C%9F%E4%B8%AD-%E6%88%96%E9%97%A8.png" alt="2017期中-或门（画的是或非门）"><br><img src="/../img/%E8%AE%A1%E7%BB%84/%E7%AE%97%E9%97%A8%E5%BB%B6%E8%BF%9F%E6%95%B0.png" alt="2016期中-计算n位行波进位加法器门延迟数"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渐入佳境！</title>
    <link href="/2024/03/31/%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%EF%BC%81/"/>
    <url>/2024/03/31/%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>要失去多邻国连击了啊啊啊啊啊！！（迅速补了 看到很多浊音发音</p><p>没听过的单词背起来真的太狼狈了，hitorie的歌词也有局限（归根结底还是听得太少，，，于是今天紧急搜了一首别的</p><p>正好是告五人（居然唱日语！</p><blockquote><p>見て、晴れの日<br>mi te  hare no hi<br>看啊、是晴天呢</p></blockquote><p>本单元背单词be like：有种听答案以及听方言的感觉哈哈哈哈啊哈哈（</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计组期中兼MOOC梳理-1</title>
    <link href="/2024/03/30/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%85%BCMOOC%E6%A2%B3%E7%90%86-1/"/>
    <url>/2024/03/30/%E8%AE%A1%E7%BB%84%E6%9C%9F%E4%B8%AD%E5%85%BCMOOC%E6%A2%B3%E7%90%86-1/</url>
    
    <content type="html"><![CDATA[<p>妈的GPT写的答案全错</p><p><img src="/../img/%E8%AE%A1%E7%BB%84/%E9%80%89%E6%8B%A9%E9%A2%98.png" alt="高亮为gpt，红笔为自己写的"></p><p>ljl的体系是mooc与上课课件正交的部分，，，</p><p>阿塔纳索夫研发的是ABC计算机，不是ENIAC。（2016期中）</p><p>第一台存储程序式电子计算机是EDSAC必考。（记忆点：S-save&#x2F;store）</p><p>冯诺依曼五个基本组成部分必考。</p><blockquote><p>① 运算器， CA： central arithmetical<br>② 控制器， CC： central control<br>③ 存储器， M： memory<br>④ 输入设备， I： input<br>⑤ 输出设备， O： output</p></blockquote><p>还有其他两个特点分别是：数据和程序均以二进制代码形式不加区别地存放在存储器中，存放位置由存储器的地址指定；计算机在工作时能够自动地从存储器中取出指令加以执行。</p><p>吗嘟这么多课件找不到的内容原来全在MOOC里！气死我了！</p><p>计算机执行指令的具体步骤：取指（Fetch），译码（Decode），执行（Execute），回写（Write-back）。（2017期中）</p><blockquote><p>取指：①控制器将指令的地址送往存储器 ②存储器按给定的地址读出指令内容，送回控制器<br>译码：①控制器分析指令的操作性质 ②控制器向有关部件发出指令所需的控制信号<br>执行：①控制器从通用寄存器或存储器取出操作数 ②控制器命令运算器对操作数进行指令规定的运算<br>回写：将运算结果写入通用寄存器或存储器</p></blockquote><p>在 x86 实模式下， 假设 CS&#x3D;3000H， DS&#x3D;2000H，则指令“MOV AX,[3000H]” 执行时访问的内存地址是23000H。(2017期中) （MOOC课件上有原题一模一样）</p><blockquote><p>计算方法：DS*16+[3000H] 段地址×16＋偏移地址</p></blockquote><p>按两个32位源操作数所在位置划分，MIPS和x86的加法指令都能够支持的是：寄存器 + 寄存器（2016期中）</p><blockquote><p>记住就行了，，默默插一嘴，这题也出现在MOOC的期末考试中，所以肯定是正确答案</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>计组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>甜美的单词实在太难记了</title>
    <link href="/2024/03/30/%E5%86%AC%E5%A4%A9%E7%9A%84/"/>
    <url>/2024/03/30/%E5%86%AC%E5%A4%A9%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="冬天-ふゆ"><a href="#冬天-ふゆ" class="headerlink" title="冬天-ふゆ"></a>冬天-ふゆ</h1><p>フユノ，フ是fu，fu的平假名像湖水一样弯弯曲曲，片假名像一只口渴的张嘴小狗想要去湖边喝水。ユ是yu（you），根据中文拼音看起来像沐浴的浴（看起来像一个淋浴喷头），no是禁止的一撇。<br>fuyu，听起来像蜉蝣（很美丽的单词），在日语里指冬天。no是“的”的意思。</p><h1 id="背部-せなか"><a href="#背部-せなか" class="headerlink" title="背部-せなか"></a>背部-せなか</h1><blockquote><p>背中(せなか)を見(み)つめるの、もう嫌(いや)だ。——《なぜなぜ》<br>翻译：一直凝望着后背，已经厌倦。</p></blockquote><p>“背中”仅指人体的背部。“背”（せな）指的是物体的背面或者表面，不仅仅局限于人体的背部。这个词可以用来描述物体的正反面，比如说 “书的背”（书的封面）、”背对着墙”、”背光”（指背面光源）等。</p><h1 id="房间-へや"><a href="#房间-へや" class="headerlink" title="房间-へや"></a>房间-へや</h1><p>“房间” 在日语中通常用「部屋」（へや）来表示。”部屋” 指的是一个房间、居室或室内空间。</p><blockquote><p>“ひとりぼっちの部屋で泣くのが”——《loveless》<br>翻译：独自在房间中哭泣</p></blockquote><h1 id="色-いろ"><a href="#色-いろ" class="headerlink" title="色-いろ"></a>色-いろ</h1><p>“色” 在日语中的发音是 “いろ”（iro）。</p><blockquote><p>積もり積もる煌めきの色  不確か、されど鮮やかな色——《さいはて》<br>翻译：层层堆积的闪耀之色  不确定然而却艳丽无比的颜色——《尽头》</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>靡靡</title>
    <link href="/2024/03/30/%E9%9D%A1%E9%9D%A1/"/>
    <url>/2024/03/30/%E9%9D%A1%E9%9D%A1/</url>
    
    <content type="html"><![CDATA[<p>今天学日语单词学到了靡靡二字。mimi，指耳朵。我就觉得我一定在哪里听过，于是检索了一下脑子里的歌曲库。</p><blockquote><p>口をつぐんで<br>耳をふさいで<br>思いの丈並べたって<br>——《立方棱镜》</p></blockquote><p>“耳をふさいで”这句的意思是“堵上耳朵”，を（wo）是一个助词通常用于标示动作的对象，塞いで（fusaide）是动词塞ぐ（fusagu）的て形，意味着“to plug”或“to cover”，在这里指的是动作的执行方式，即“covering”或“plugging”。所以，当这个短语被使用时，它通常是在告诉某人要覆盖或塞住他们的耳朵。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>每项工程使用红色零件总金额</title>
    <link href="/2024/03/30/%E6%AF%8F%E9%A1%B9%E5%B7%A5%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%BA%A2%E8%89%B2%E9%9B%B6%E4%BB%B6%E6%80%BB%E9%87%91%E9%A2%9D/"/>
    <url>/2024/03/30/%E6%AF%8F%E9%A1%B9%E5%B7%A5%E7%A8%8B%E4%BD%BF%E7%94%A8%E7%BA%A2%E8%89%B2%E9%9B%B6%E4%BB%B6%E6%80%BB%E9%87%91%E9%A2%9D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>按零件数量总和的降序列出每项工程所使用的每种红色零件的总的金额（工程可以向不同的供应商购买同一零件，总金额＝单价*供货数量）。输出工程号、零件号、总金额。</p></blockquote><p>样例输出：</p><table><thead><tr><th>jno</th><th>pno</th><th>sum_money</th></tr></thead><tbody><tr><td>J4</td><td>P1</td><td>73000</td></tr><tr><td>J4</td><td>P4</td><td>22400</td></tr></tbody></table><p>依然是使用聚集函数（不要忘了group by，这里直接写两列就可以了</p><p>一开始遇到的问题是ambiguous列名，解决措施是注明这个列是来自哪张表的</p><p>left join的原因和上一题同理</p><p>ORDER BY可以实现升&#x2F;降序，ASC为升序，DESC为降序，格式为order by 列名 asc&#x2F;desc, 列名 asc&#x2F;desc,…（按排序关键字顺序书写，前面的关键字优先看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> J.JNO,P.PNO,<span class="hljs-built_in">SUM</span>(QTY<span class="hljs-operator">*</span>PRICE)<br><span class="hljs-keyword">FROM</span> J <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span> J.JNO<span class="hljs-operator">=</span>SPJ.JNO<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> P <span class="hljs-keyword">ON</span> P.PNO<span class="hljs-operator">=</span>SPJ.PNO<br><span class="hljs-keyword">WHERE</span> P.COLOR <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;红色&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> JNO,PNO<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">SUM</span>(QTY) <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列出每个城市的工程使用零件总量</title>
    <link href="/2024/03/30/%E5%88%97%E5%87%BA%E6%AF%8F%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%BD%BF%E7%94%A8%E9%9B%B6%E4%BB%B6%E6%80%BB%E9%87%8F/"/>
    <url>/2024/03/30/%E5%88%97%E5%87%BA%E6%AF%8F%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E5%B7%A5%E7%A8%8B%E4%BD%BF%E7%94%A8%E9%9B%B6%E4%BB%B6%E6%80%BB%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>列出每个城市的工程所使用的零件总的数量。</p></blockquote><p>样例输出：</p><table><thead><tr><th>CITY</th><th>sum(QTY)</th></tr></thead><tbody><tr><td>Paris</td><td>800</td></tr><tr><td>Rome</td><td>1200</td></tr></tbody></table><p>这道题用到了聚集函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> CITY,<span class="hljs-built_in">SUM</span>(QTY)<br><span class="hljs-keyword">FROM</span> J <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span>  SPJ.JNO<span class="hljs-operator">=</span>J.JNO<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CITY       <br></code></pre></td></tr></table></figure><p>left join是因为要列出每个城市的工程零件量，但是不排除有些城市可能零件量为零。（每次都忘了写on</p><p>最后要加一行group by 列名（having 条件表达式，不过这题没有涉及所以不用having</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求供应了所有零件的供应商</title>
    <link href="/2024/03/29/%E6%B1%82%E4%BE%9B%E5%BA%94%E4%BA%86%E6%89%80%E6%9C%89%E9%9B%B6%E4%BB%B6%E7%9A%84%E4%BE%9B%E5%BA%94%E5%95%86/"/>
    <url>/2024/03/29/%E6%B1%82%E4%BE%9B%E5%BA%94%E4%BA%86%E6%89%80%E6%9C%89%E9%9B%B6%E4%BB%B6%E7%9A%84%E4%BE%9B%E5%BA%94%E5%95%86/</url>
    
    <content type="html"><![CDATA[<p>先复习一下关系代数里面的除法</p><p>学生表R：</p><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th><th>院系</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>19</td><td>计算机</td></tr></tbody></table><p>除数S1：</p><table><thead><tr><th>年龄</th></tr></thead><tbody><tr><td>19</td></tr></tbody></table><p>R÷S1&#x3D;学生表中年龄为19的学生信息的新表格，但这个新表格中的字段不包括年龄。</p><p>即：</p><table><thead><tr><th>学号</th><th>姓名</th><th>院系</th></tr></thead><tbody><tr><td>001</td><td>张三</td><td>计算机</td></tr></tbody></table><p>所以除法结果就是在被除表中，同时满足除数表的所有条件，但没有除数表中的字段的新表（如果结果有多条记录要全部列出）。</p><p>言归正传，由于评测台的版本过于老，所以不支持except，只能搞where not exists嵌套</p><p>所以不妨来绕一下，供应了所有零件 &#x3D; 不存在一个零件，它不在该供应商的供应零件集中，具体推导可以看下面图片<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9B%9E%E6%83%B3%E8%B5%B7%E8%A2%AB%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%94%AF%E9%85%8D%E7%9A%84%E6%81%90%E6%83%A7.jpg" alt="回想起被数理逻辑支配的恐惧"></p><p>一开始最里面的嵌套是用where not in写的，但是问了gpt之后说这样会导致一些空值的情况，所以最好还是用where not exists</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> SNAME<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> P<br>    <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (<br>        <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">FROM</span> SPJ<br>        <span class="hljs-keyword">WHERE</span> SPJ.SNO <span class="hljs-operator">=</span> S.SNO<br>        <span class="hljs-keyword">AND</span> SPJ.PNO <span class="hljs-operator">=</span> P.PNO<br>    )<br>)<br></code></pre></td></tr></table></figure><p>SELECT 1是性能问题，它使得只要找到一条记录就返回结果。当然如果是为了考试的话用SELECT *也没有任何问题</p><p>可以将这段代码的执行思想类比为一个嵌套的循环，其中外部循环是对供应商的循环，内部循环是对零件的循环。这种思想类似于控制变量的概念，即在外部循环中保持一个变量不变（当前供应商），而在内部循环中迭代另一个变量（零件）。</p><ol><li>外部的 SELECT SNAME FROM S … 查询遍历供应商表 S 中的每个供应商。</li><li>对于每个供应商，内部的子查询开始执行。这个子查询对零件表 P 中的每个零件进行循环（通过 NOT EXISTS 子句），并检查是否存在至少一条记录，表示当前供应商供应该零件。如果不存在这样的记录，表示当前供应商缺少供应的零件。</li><li>如果对于当前供应商不存在任何缺少供应的零件，即内部子查询返回空结果集，那么外部的 NOT EXISTS 就会返回 TRUE，表示当前供应商满足条件。</li><li>如果对于当前供应商存在至少一种缺少供应的零件，那么外部的 NOT EXISTS 就会返回 FALSE，表示当前供应商不满足条件。</li></ol><p>这种查询的执行方式确实类似于使用嵌套的循环来检查每个供应商是否满足条件。这样的查询结构有助于控制变量，以确保每个供应商都经过了正确的检查，而不会在内部循环中受到外部循环的影响（省流，类似于for循环控制外层变量在内层循环中不变，这样就能保证最内层的循环查找的一定是同一个供应商的供货记录</p><p>最外层的表是S，中间的是P，最内层的是SPJ</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>坠落的审判</title>
    <link href="/2024/03/28/%E5%9D%A0%E8%90%BD%E7%9A%84%E5%AE%A1%E5%88%A4/"/>
    <url>/2024/03/28/%E5%9D%A0%E8%90%BD%E7%9A%84%E5%AE%A1%E5%88%A4/</url>
    
    <content type="html"><![CDATA[<p>晚上看了树洞上吵得很凶的坠落的审判，确实感叹语境不同每个人的观感都不太一样，像有些没体验过类似处境的人可能就不太理解电影的观点，而不同的人也可能会有不同的观点。但是如果强行忽视电影所传达出来的女性主义观点而去揪着讨论别的不重要的意向，我认为是一种很高傲的行为。</p><p>这部片给了我很大的惊喜，虽然话题与画风都非常沉重，但是相比之前看的另一部女性主义电影（芭比），当时是怀着很大的期望，但是比较失望地走出来，感觉没有拍到自己想要看到的点。但是这部片很精确地表达了我的想法。我眼中的女性主义，可能不局限于女性一个性别。感觉有点矛盾，但是我的想法是影片中的妻子角色其实是平常家庭中的丈夫，而丈夫角色却是平常的妻子。光头律师为影片中的丈夫辩护，而梵尚则为妻子辩护，光头看似咄咄逼人，其实体现了很多女孩子（或者较为弱势的群体）的困境，即不得不采取一种激进的手段，即证明他杀来达到判刑的目的，（类似于必须将房子屋顶打破，才能开一扇窗户），但是这样的证明是必定失败的。因为精神控制所带来的迫害无法被证明，它不是实质性的可以构成证据的损害，有很大的主观性。所以在开头我就知道妻子不可能被判刑，她一定会被无罪释放。</p><p>和npy一起看这个影片，并做了很多讨论。我们两个个体都有各自的特殊性。我从小在男生堆里长大，而他却截然相反。所以我们都具有对方性别的一些观念。他结合自己家庭的情况认为妻子（即日常的丈夫）理应做出更多，但我结合自己家庭的情况认为在大部分情况下只能采用无奈的措施，即牺牲其中一方，否则对于整体不利。总之感觉是一个取舍的问题。只有双方达成共识，要么都不牺牲，要么另一方必须看到对方做出的牺牲，ta不能粗暴地认为对方的事情全部是由于自由意志，（看似是自由意志，其实是在特定语境下做出的妥协与权衡），当一方的退让不被看见，那么就必然爆发极大的争端。</p><p>其中一个共识是那个边牧真的好可怜orz！And npy提出了一个疑问是为什么最后男孩会选择为妈妈辩护，我的理解是那是小孩的无奈之举吧，曾经小孩认为母亲是一个怪物，但是最后他们还是要生活在同一屋檐下，而母亲也确实是爱着这个小孩，所以小孩最终还是接受了她。就和很多家庭的结局一样，伤害者和被伤害者被血缘与爱的锁链禁锢，最终还是相互原谅，和平地生活在一起（）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>イヴステッパー</title>
    <link href="/2024/03/28/%E3%82%A4%E3%83%B4%E3%82%B9%E3%83%86%E3%83%83%E3%83%91%E3%83%BC/"/>
    <url>/2024/03/28/%E3%82%A4%E3%83%B4%E3%82%B9%E3%83%86%E3%83%83%E3%83%91%E3%83%BC/</url>
    
    <content type="html"><![CDATA[<p>学了一点点日语满怀信心地点开eve stepper的标题，然后沉默</p><p>谁家好人整天用片假名做标题啊啊啊</p><p>找到了一个更易于记忆的点：u就是捂着肚子，为什么捂着肚子呢，因为痛经。为什么片假名长这样呢，因为痛经所以上吊想鼠。</p><p>但是右边加两撇是什么鬼，，，copilot了一下，发现用来指代外来词（u浊化变成v）</p><p>イ-i  ヴ-v  ス-su？？？（没有dick的没有下半身精灵 输） テ-te（跑得忒快了于是需要用手压住帽子） ッ-cu（三点水的shi的下面那个撇没有那么上翘） パ-（小圆点是半浊音，只出现在h行，这个本来念ha，卓别林的八字须，半浊音之后念pa</p><p>大概理解了日式英语为什么这么奇怪了，，，i v s tei cu pa？？？？？什么玩意</p><p>查了一下这个ッ，「ッ」是日语中的一个特殊假名，它表示一个促音。促音的作用是让下一个假名的辅音发音变得更短，停顿更突然。所以ッパ就是双写p的意思（大概</p><p>eve stepper，，，行吧我大致理解了（鼓掌</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>只向与自己不同城市工程供应</title>
    <link href="/2024/03/28/%E5%8F%AA%E5%90%91%E4%B8%8E%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%B7%A5%E7%A8%8B%E4%BE%9B%E5%BA%94/"/>
    <url>/2024/03/28/%E5%8F%AA%E5%90%91%E4%B8%8E%E8%87%AA%E5%B7%B1%E4%B8%8D%E5%90%8C%E5%9F%8E%E5%B8%82%E5%B7%A5%E7%A8%8B%E4%BE%9B%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<p>挑战独立做出数据库题目！</p><blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>求只向与自己位于不同城市的工程供应零件的供应商姓名。</p></blockquote><p>首先，这个供应商不能是什么零件都没有供应，所以以SPJ为主表进行left join</p><p>注意这个left join的格式必须是某某表LEFT JOIN 另一个表 ON 一些条件！！！</p><p>如果要连续left join的话另起一行就可以</p><p>WHERE NOT IN的格式也要注意！是WHERE 某一列 NOT IN（括号里面套娃select）</p><p>讲完了格式讲一下这道题的思路，大体上就是首先，这个供应商必须供应了零件，所以以spj为主表，然后，（判断推理的思路！）“只向与自己位于不同城市供应了零件”的反面是“向与自己位于相同城市的工程供应过零件”（在sql查询中，这个“过”非常重要，“只”相对难办）于是我们求出“向与自己位于相同城市的工程供应过零件”再not in一下就好了！</p><p>放代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME<br><span class="hljs-keyword">FROM</span> SPJ <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> S <span class="hljs-keyword">ON</span> SPJ.SNO<span class="hljs-operator">=</span>S.SNO<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> J <span class="hljs-keyword">ON</span> SPJ.JNO<span class="hljs-operator">=</span>J.JNO<br><span class="hljs-keyword">WHERE</span> S.SNAME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span>(<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME<br>    <span class="hljs-keyword">FROM</span> SPJ <br>    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> S <span class="hljs-keyword">ON</span> SPJ.SNO<span class="hljs-operator">=</span>S.SNO    <br>    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> J <span class="hljs-keyword">ON</span> SPJ.JNO<span class="hljs-operator">=</span>J.JNO<br>    <span class="hljs-keyword">WHERE</span> S.CITY<span class="hljs-operator">=</span>J.CITY<br>)     <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>どうしてなんだい</title>
    <link href="/2024/03/28/%E3%81%A9%E3%81%86%E3%81%97%E3%81%A6%E3%81%AA%E3%82%93%E3%81%A0%E3%81%84/"/>
    <url>/2024/03/28/%E3%81%A9%E3%81%86%E3%81%97%E3%81%A6%E3%81%AA%E3%82%93%E3%81%A0%E3%81%84/</url>
    
    <content type="html"><![CDATA[<p>日语键盘指日可待，，，等学到比较熟练了再装一个日语键盘</p><p>看了几个常用语，doshite和naze都是为什么的意思，于是联想到hitorie的《なぜなぜ》（何故何故）加两个点就是变成浊音</p><p>里面有一句歌词叫doshitenandaiどうしてなんだい，qq音乐给出的翻译是为何难解，比较书面语的时候可能会失去一些情感的表达吧（我的理解），所以分别查了一下，doshite是比较轻柔的语气问为什么，nandai是一种口语表达，表示惊讶、疑问或者不满（应该是偏不满多一点）。将两者结合起来可以给表达增添感情色彩。深感学一门语言的重要，可以通过一手的资料（而非翻译后的二手甚至n手），这样可以更加贴近作曲与歌者的内心。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>尝试独立做出数据库题目！</title>
    <link href="/2024/03/27/%E5%B0%9D%E8%AF%95%E7%8B%AC%E7%AB%8B%E5%81%9A%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%EF%BC%81/"/>
    <url>/2024/03/27/%E5%B0%9D%E8%AF%95%E7%8B%AC%E7%AB%8B%E5%81%9A%E5%87%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>实在觉得老是抄不太好，所以决定认真学数据库！（一方面也是因为以后可能要当信息老师，一个信息老师如果连数据库都不会怎么教学生嘻嘻</p><p>多邻国太好玩了orz！现在已经知道了一是i chi，二是ni，三是sa n，四是yo n，六是ro ku，七是na na，颜色有点忘记了，，，不过无所谓！</p><p>i就是以，chi是独轮车（entp出老千版），ni是仁，sa是切腹自尽（面向刀，而且完全贯穿），yo是悠悠球，n是椅子和折叠椅，ro是落井下石和耳朵，ku是裤子下蹲，na是拿着十字架</p><blockquote><p>供应商数据库SPJ中有三张表：<br>S(SNO, SNAME, STATUS, CITY)<br>P(PNO, PNAME, COLOR, WEIGHT, CITY)<br>J(JNO, JNAME,CITY)<br>SPJ(SNO, PNO, JNO, QTY, PRICE)<br>S表示供应商，各属性依次为供应商号，供应商名，供应商状态值，供应商所在城市；<br>P表示零件，各属性依次为零件号，零件名，零件颜色，零件重量，零件存放的城市；<br>J表示工程，各属性依次为工程号，工程名，工程所在城市；<br>SPJ表示供货关系，各属性依次为供应商号，零件号，工程号，供货数量，单价。<br>基于以上SPJ关系模式用SQL完成下面的查询：<br>求没有供应零件号为P1和P2两种零件的供应商姓名。</p></blockquote><p>苯人直接自信上代码！</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME<br><span class="hljs-keyword">FROM</span> S <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span> S.SNO=SPJ.SNO<br><span class="hljs-keyword">WHERE</span> SPJ.PNO&lt;&gt;<span class="hljs-string">&#x27;P1&#x27;</span> <span class="hljs-keyword">AND</span> SPJ.PNO&lt;&gt;<span class="hljs-string">&#x27;P2&#x27;</span><br></code></pre></td></tr></table></figure><p>不出意外又是wrong answer，，，来看看到底哪里出了问题</p><p>首先左连接肯定是对的（万一有供货商一个货都没供过呢</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/c98e040f4e9128d2e3b7de08207b89c.jpg" alt="发现了问题所在"></p><p>它删除了供货商供货P1,P2的两行，然后把这个供应商供货其他货物的信息原封不动地保留了下来（我本来下意识以为它会自动删掉来着，但是本质上筛下来的是除了P1和P2以外的供货记录</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SNAME<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">WHERE</span> SNO <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> SNO<br><span class="hljs-keyword">FROM</span> SPJ<br><span class="hljs-keyword">WHERE</span> PNO=<span class="hljs-string">&#x27;P1&#x27;</span> <span class="hljs-keyword">OR</span> PNO=<span class="hljs-string">&#x27;P2&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>成功AC！</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五十音打卡-2</title>
    <link href="/2024/03/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%89%93%E5%8D%A1-2/"/>
    <url>/2024/03/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%89%93%E5%8D%A1-2/</url>
    
    <content type="html"><![CDATA[<p>更新上一篇博客的时候不出意外又spawn fail了，，这次重启大法也不管用了！由于zjt在睡午觉于是自己点开了帮助社区尝试从里面检索一些有价值的solution</p><p><img src="/../img/%E4%BA%94%E5%8D%81%E9%9F%B3%E5%AD%A6%E4%B9%A0/40f64614cb5dc9752924e20abd10d2f.png" alt="评论区"></p><p>于是尝试右键git bash。卧槽！丝滑！太丝滑了！下次别再用win的cmd了</p><p>言归正传又看了一点五十音的趣味记忆，接着背，，</p><p><img src="/../img/%E4%BA%94%E5%8D%81%E9%9F%B3%E5%AD%A6%E4%B9%A0/ka%20ki%20ku%20ke%20ko%20sa%20shi%20su.jpg" alt="ka ki ku ke ko sa shi su"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>金宇彬好笨</title>
    <link href="/2024/03/27/%E9%87%91%E5%AE%87%E5%BD%AC%E5%A5%BD%E7%AC%A8/"/>
    <url>/2024/03/27/%E9%87%91%E5%AE%87%E5%BD%AC%E5%A5%BD%E7%AC%A8/</url>
    
    <content type="html"><![CDATA[<p>这个系列用来专门更数据库<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240327124313.png" alt="列出所有供应商的信息"><br>总的说来就是列出所有供应商的信息，包括供应商姓名、所供应的零件名（没有供应零件的供应商也要列出，最后结果中不要出现重复元组）</p><p>想实现的效果like this<br><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/fd6783cf6517e9620578fc548e54fa6.jpg" alt="主要的痛点在于空行怎么实现"><br>在网上看到了一个用banbao搭博客的学长（姑且称他为banbao学长）的代码，但是运行之后是错误的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">select distinct S<span class="hljs-selector-class">.SNAME</span>, P<span class="hljs-selector-class">.PNAME</span><br>from S,SPJ,P<br>where S<span class="hljs-selector-class">.SNO</span> = SPJ<span class="hljs-selector-class">.SNO</span> and SPJ<span class="hljs-selector-class">.PNO</span> = P.PNO<br></code></pre></td></tr></table></figure><p>还没从关系模型里一堆奇怪的符号转过弯来的我表示震惊，大致研究了一下，distinct可以去掉重复行，from的作用是笛卡尔积（不是自然连接！！！！！）where这行起到了自然连接的作用</p><p>笛卡尔积就是无脑乘起来（相当于小学的乘法法则 总共有a×b×c种</p><p>但是对于苯人贫瘠的脑子还是无法想象，于是我想起以前高中某信息代课老师笨笨的做法，以上表为例全部列了出来</p><p><img src="/../img/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%A4%A7%E5%8A%9B%E5%87%BA%E5%A5%87%E8%BF%B9.jpg" alt="大力出奇迹"></p><p>于是恍然大悟（模拟自然连接的筛选法则</p><p>所以学长的问题在于他没有实现空行，如何把空行揪出来呢</p><p>网上查询了一下（GPT），可以通过左外连接来实现这个需求。左外连接可以保证左边表（S 表）的所有记录都会被返回，即使它们在右边的表（这里是 SPJ 表）中没有匹配的记录。对于没有供应零件的供应商，其相关的零件名字段会返回为 NULL。</p><p>正确的代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> S.SNAME, P.PNAME<br><span class="hljs-keyword">FROM</span> S<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> SPJ <span class="hljs-keyword">ON</span> S.SNO = SPJ.SNO<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> P <span class="hljs-keyword">ON</span> SPJ.PNO = P.PNO<br></code></pre></td></tr></table></figure><p>和学长代码的主要区别就是把（伪）自然连接换成了左外连接！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>五十音打卡-1</title>
    <link href="/2024/03/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%89%93%E5%8D%A1-1/"/>
    <url>/2024/03/27/%E4%BA%94%E5%8D%81%E9%9F%B3%E6%89%93%E5%8D%A1-1/</url>
    
    <content type="html"><![CDATA[<p>从今天开始正式学习日语！先从放弃了很多次的五十音开始orz（差点drop错设备<br><img src="/../img/%E4%BA%94%E5%8D%81%E9%9F%B3%E5%AD%A6%E4%B9%A0/aiueo.jpg" alt="a i u e o"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>地磁暴</title>
    <link href="/2024/03/26/%E5%9C%B0%E7%A3%81%E6%9A%B4/"/>
    <url>/2024/03/26/%E5%9C%B0%E7%A3%81%E6%9A%B4/</url>
    
    <content type="html"><![CDATA[<p>估计是地磁暴的影响，，，今天好难受，，感觉什么都打不起精神</p><p>下午刷了一点探奥的慕课，把米德尔马契看完了（终于！），下节英语课终于可以放心地好好听了</p><p>85公里进度9.4&#x2F;85（遥遥无期啊啊啊，，，好累好累好累！！！</p><p>想要这个学期至少学会日语和电吉他中的一样（加油。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Tiring</title>
    <link href="/2024/03/25/Tiring/"/>
    <url>/2024/03/25/Tiring/</url>
    
    <content type="html"><![CDATA[<p>最近居然产生了一种疲惫感，，一段时间内应该不会再弹太多hitorie的歌了，一方面也是觉得很多曲子弹不出原有的风味。后期应该会梳理一份比较适合吉他弹唱的歌单，在毕业之前想在石舫弹琴唱歌（flag</p><p>报名了普通话考试，清明的时候去开放大学考。可能得稍微准备准备（沉淀.jpg</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>哼哼哼论文</title>
    <link href="/2024/03/25/%E5%93%BC%E5%93%BC%E5%93%BC%E8%AE%BA%E6%96%87/"/>
    <url>/2024/03/25/%E5%93%BC%E5%93%BC%E5%93%BC%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>哼哼哼哼哼！</p><p>看不懂我写的论文的人都没品！我觉得从数据退出结论是一个非常不掺杂个人感情的做法，我更愿意为了一个我希望去了解的议题去检索资料，然后再自己引申出一些想法，而不是套公式模板一样地去做！数据？数据我当然有！我特地为了这个论文去检索了很多很多的数据！但是我觉得没有意思！非常没有意思！不如讲点自己心里的东西！我还是更适合当一个诗人而不是当一个审判家！全是数据有什么好看的！只有数据没有灵魂！格式有什么意思！只是看起来写的认真！我唧唧咕咕唧唧咕咕唧唧咕咕！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>济南的春天</title>
    <link href="/2024/03/24/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/"/>
    <url>/2024/03/24/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>周末出逃济南行程记录~</p><p>周五zjt提前结束了小班课故提前出发！在北京南站吃了一顿汉堡王（黑松露和另一个什么味，因为黑松露更好吃所以只记住了黑松露），晚上七点到达“县城”济南站。</p><p>挑几张没有发票圈的放在博客里面hhh</p><p><img src="/../img/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/IMG_20240324_222649.jpg" alt="一出站就看到经一路的火车雕像"></p><p><img src="/../img/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/1711165164818_121418_edit_100645265969537.jpg" alt="美仑酒店的早餐，虽然离景点有二十分钟车程但是非常丰盛"></p><p>除了大明湖和几个专门给小孩子玩的水池以外其他的水真的很清澈！不愧是泉城，很喜欢这里的水。周六这天较为暖和，穿了在北京还没穿过的粉色v领薄毛衣，先趁早去了趵突泉，占领了与对岸相比人少了很多的高地。若不是知道是由于地下断层之类的原因，真的会认为底下有一个水泵在持续不断的运作。</p><p>池底和台阶都有细细密密的气泡偶尔升上来，如果在这边一直发呆，看着气泡上升也是一件美事。几乎每一个泉都清澈见底，红色的小鱼惬意地游动，还能看到池底的钱币，可惜由于反光而且缺乏专业的摄影设施所以拍不出此番美景。从南门出来打车去了大明湖公园，在门口领教了民间中华毽和太极拳，太极可能我们这边还有，但是毽子我们那边真的不咋踢。这与气候有很大的关系，毕竟我们那边多雨潮湿，毽子一旦遇雨则会变成落汤鸡。玉兰花开得极盛，园内的其他花也争奇斗艳。刚好遇上了樱花节，与园子里的各种花美美合影。</p><p>中午骑车去五龙潭附近吃饭，共享单车一直显示离停车点还有7m无法停车，悻悻地交了5块钱调度费。吃完之后便去景区里面游玩。一个巨大的收获是认识了两个水鸟的名字。北京各个湖中常见的“潜水鸭”原来是䴙䴘，那只一直伸头的蠢鸭子竟然是游泳的鸡（骨顶鸡）。</p><p>逛完五龙潭后回酒店休整，晚上来附近的一家鲁菜馆觅食之后又爬了回去（走不动是这样的）。葱烧鲤鱼非常好吃！剥好的虾姑也不错（有点咸，刚好下饭</p><p>DAY2济南大降温，刮了很大的风。去了环城公园（白石泉、黑虎泉、宽厚里、解放阁都在这一块），还买了一杯济南大碗茶。去宽厚里吃了中饭便打道回府，收拾东西之后开始了“流浪生活”，打卡了经三与纬三的爱心路口，买了一只zjt心心念念的德州扒鸡回到酒店大厅大快朵颐，准备回程。</p><p>可能是因为五哈录节目的原因，周日济南人尤其多，像春运一样，非常庆幸在周六那天起的特别早并且错峰看完了景点。火车票更是早早的就没有了（还好提前抢了）。为了赶周一的课周日晚上就回到了北京，迎接北京的雨水！（天气预报看早了，对两地的气温做了一些错误的估计</p><p><img src="/../img/%E6%B5%8E%E5%8D%97%E7%9A%84%E6%98%A5%E5%A4%A9/IMG_20240324_202123.jpg" alt="Jungle Tiger限定皮肤"></p><p>由于对济南的道路命名方式非常好奇于是查了一下。第一种理论说济南受山河地形影响，东西狭长，南北窄小。古时织物“长者为经，短者为纬”，故将商埠区内东西方向的长道路命名为经，南北方向的短道路命名为纬。另一种理论则是古代建城讲究阴阳五行之说，“山南水北为阳，山北水南为阴”，而济南城位于山北水南皆为阴，从地理位置上阴气重，因此当时建城官员在命名时便将经纬逆转，抵消阴气，使得乾坤颠倒，由阴转阳。所以经一、纬三这种这么现代化的名字原来是古代起的！感到非常神奇。</p>]]></content>
    
    
    
    <tags>
      
      <tag>travel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大唱特唱想念！</title>
    <link href="/2024/03/21/%E5%A4%A7%E5%94%B1%E7%89%B9%E5%94%B1%E6%83%B3%E5%BF%B5%EF%BC%81/"/>
    <url>/2024/03/21/%E5%A4%A7%E5%94%B1%E7%89%B9%E5%94%B1%E6%83%B3%E5%BF%B5%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>唱歌的时候偶尔会唱到非常非常有感觉的歌！！就唱得非常率性特别开心！但是重唱一遍就唱不出那个感觉orz</p><p>对摇滚在音乐上的定义一般是三和弦的强调与重复，而且右手力量上来了之后可以非常迅速地扫弦（把木吉他弹成电吉他的感觉），but电吉他好贵and门槛好高，可能要等有一个自己的地下室之后再配备相关的装备。唱的时候就可以专注于情绪的表达而不是和弦的走向！喜欢这种率性的感觉。</p><p>之前是唱了nazenaze，这次唱了梁博的想念，差点忘了梁博也是摇滚歌手了ww。每次练完wowaka都会随机找一首很久没听的歌来当做换换口味。感觉快把自己唱哭了，果然看得懂歌词的歌更容易感情共鸣，but之后再唱一定又是不同的感觉了。很喜欢这种感觉。树洞上看到有人在听hitorie的歌，很感动，希望有越来越多的人听他的声音（感觉好像传教士，给自己赋予了亿点点宗教精神）</p><p>moikai！moikai！！最遗憾的就是这首歌一直唱不出自己想要的感觉（现场真的太炸了啊啊啊啊超喜欢现场），估计是调太低了，下次调高一点试试看，，，（阿里嘎多真的好可爱</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ollama</title>
    <link href="/2024/03/21/Ollama/"/>
    <url>/2024/03/21/Ollama/</url>
    
    <content type="html"><![CDATA[<p>昨天加入了环境变量，之前困扰的ollama报错问题也解决了。<br><img src="/../img/ollama/%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.png" alt="运行环境"><br><img src="/../img/ollama/%E4%BB%A5%E6%B5%81%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%90%E8%A1%8C%E5%AE%9E%E4%BE%8B.png" alt="以流的形式运行实例"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ollama<br>stream = ollama.chat(<br>    model=<span class="hljs-string">&#x27;MyModel&#x27;</span>,<br>    messages=[&#123;<span class="hljs-string">&#x27;role&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>: <span class="hljs-string">&#x27;Why is the sky blue?&#x27;</span>&#125;],<br>    stream=<span class="hljs-literal">True</span>,<br>)<br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> stream:<br>  <span class="hljs-built_in">print</span>(chunk[<span class="hljs-string">&#x27;message&#x27;</span>][<span class="hljs-string">&#x27;content&#x27;</span>], end=<span class="hljs-string">&#x27;&#x27;</span>, flush=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Ollama</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩了AI</title>
    <link href="/2024/03/20/%E7%8E%A9%E4%BA%86AI/"/>
    <url>/2024/03/20/%E7%8E%A9%E4%BA%86AI/</url>
    
    <content type="html"><![CDATA[<p>第一次跑一个ai的实例独立跑通了！之前没跑通是因为环境变量的问题，设置了环境变量就好了！（事实证明不能忽视控制台的警告哇</p><p>本地部署完成！（算是？</p><p>成就：获得免费API（记得运行的时候要全局翻墙</p><p><img src="/../img/%E7%8E%A9%E4%BA%86AI/API_keys.png" alt="API keys"><br><img src="/../img/%E7%8E%A9%E4%BA%86AI/%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B.png" alt="运行示例"><br>源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> groq <span class="hljs-keyword">import</span> Groq<br><br>client = Groq(api_key=<span class="hljs-string">&quot;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&quot;</span>)<br><br>chat_completion = client.chat.completions.create(<br>    messages=[<br>        &#123;<br>            <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,<br>            <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;why is the sea blue?&quot;</span>,<br>        &#125;<br>    ],<br>    model=<span class="hljs-string">&quot;gemma-7b-it&quot;</span>,<br>)<br><br><span class="hljs-built_in">print</span>(chat_completion.choices[<span class="hljs-number">0</span>].message.content)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>groq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nonsense!</title>
    <link href="/2024/03/20/Nonsense/"/>
    <url>/2024/03/20/Nonsense/</url>
    
    <content type="html"><![CDATA[<p>新太阳的免费乐谱架被搬走了（悲），接下来只能自己把乐谱架搬到新太阳练了。今天为了解放脖子除了学（W）here以外完全没有看谱子唱，（虽然感觉言之无物but唱得很自由很放松！）</p><p>rolling girl的现场特别特别伟大，，，moikai！！moikai！！</p><p>NONSENSE感觉比unknown mother goose还难唱，，bpm太高了orz</p><p>文字上的判断推理只差最后一p视频了，然后就是图推ww！希望立体图可以不要再无脑蒙选项</p><p>suno.ai做出来的榜单前几的音乐都挺好听耶，，，（第二的合成器波感觉很可），，还以为做出来的曲子都是些不三不四的曲子，有点超出想象了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>立方棱镜</title>
    <link href="/2024/03/19/%E7%AB%8B%E6%96%B9%E6%A3%B1%E9%95%9C/"/>
    <url>/2024/03/19/%E7%AB%8B%E6%96%B9%E6%A3%B1%E9%95%9C/</url>
    
    <content type="html"><![CDATA[<p>成功把姐妹带入hitorie坑！wowaka门！</p><p>看了立方棱镜的现场，特别特别伟大，，，和v曲完全不同的感觉，但是两版都很好听，，，</p><p>今天外面风大得要死，向北拜访小天鹅一家，差点错过了探奥签到（其实是路过二教楼下突然想起今天是周二，遂跑步前往理教，签完遂溜），路过东侧门草坪，这么大的风甚至也能找到摄影的同学。第一次在湖面上直观的感受到了风的形状，湖面上的波光特别美丽，因为风大所以湖边人少，找了很久终于找到了天鹅一家，我一直远远地观望，不想打扰到他们，后来来了几个同学怼脸看，于是天鹅一家便迁徙到我的位置，甚至还能看到他们上岸、下水、梳理羽毛。这风刮得我肺疼，不过能近距离观测小天鹅也值了！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>乡村路带我回家</title>
    <link href="/2024/03/18/%E4%B9%A1%E6%9D%91%E8%B7%AF%E5%B8%A6%E6%88%91%E5%9B%9E%E5%AE%B6/"/>
    <url>/2024/03/18/%E4%B9%A1%E6%9D%91%E8%B7%AF%E5%B8%A6%E6%88%91%E5%9B%9E%E5%AE%B6/</url>
    
    <content type="html"><![CDATA[<p>打开b站发现很喜欢的一个雨世界手书博主更新了，真的很喜欢胖猫线，非常温暖的归乡色调，，，hyx潸然泪下</p><p>刚好今天也和室友聊了雨世界的世界观，，看到这样一条评论非常喜欢</p><blockquote><p>对于蛞蝓猫而言，迭代器这样的造物宛若神明，而祂们或是祂们的创造者所追求的飞升，则更是无法企及的东西——但那与猫猫有又有什么关系呢？蛞蝓猫只是一个黏糊糊的小动物，想要的也只是能吃饱、能躲雨和能找到家人罢了。<br>我认为DLC的那些结局是对原版那种极度虚无的飞升结局的一种否定：或许最终一切都会归于虚无，但现在，你仍旧可以追求现世的幸福，与自己的家人和同伴在一起，共同度过一段美好的时光。胖猫打开了返乡的大门，黄白可以回到猫猫树，矛大师回到了红日身边，水猫选择在月姐这里留下——也许并不是所有猫猫都有好结局，但至少，我们并非只有遁入虚无这一件事可做。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>采风</title>
    <link href="/2024/03/18/%E9%87%87%E9%A3%8E/"/>
    <url>/2024/03/18/%E9%87%87%E9%A3%8E/</url>
    
    <content type="html"><![CDATA[<p>久违地去了北边，看了很多很多的新生的枝叶与花花。拍了很多很满意的构图，新生的枝叶与未落尽的枯叶，橙色的枫叶与粉白的山桃同框，未开的花苞，柔软的柳枝，蜘蛛网和树枝上留下的小鸟的绒毛也一并记录，发光的枝条与闪烁的花朵，蓝白相间的天空。</p><p>私以为春天的花朵与机械质地的摄像头同框有一种戴着镣铐跳舞的美。</p><p>在北边碰到一个奶奶，这个奶奶想去未名湖边（然鹅我自己也迷路），遂取消了寻找小天鹅计划，帮她拍了几张照并且带她去了未名湖。大概是想起了自己家里的长辈所以产生了老吾老以及人之老的念头。虽然后面就没怎么拍花了，但对我来说是很有意义感的一段小插曲。（甚至因为刚好在湖边目睹了鸭鸭交配的全过程）奶奶的孙子也在北大读书，但是因为课业忙所以让老人一个人在学校转悠x （哼！借口，如果我外婆过来北大我肯定翘课陪她玩</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>天微微仔光</title>
    <link href="/2024/03/17/%E5%A4%A9%E5%BE%AE%E5%BE%AE%E4%BB%94%E5%85%89/"/>
    <url>/2024/03/17/%E5%A4%A9%E5%BE%AE%E5%BE%AE%E4%BB%94%E5%85%89/</url>
    
    <content type="html"><![CDATA[<p>发现日摇（或日摇风格）乐队大多对音乐有一种虔诚。有一种献祭的味道。</p><p>起因是对象给我推了一首很对我胃口的歌，有一条弹幕“某某市某某县某某街道毫无压力”，虽然和我那个街道只差10分钟车程。由于up主自制的mv有一种浓浓的佛教味与雨世界味（虚空流体飞升）所以天然增强了亲切感，了解了一下这首歌的背景，是一段很悲伤的历史。</p><p>虽然主唱感觉音色和我很相似，但是听到后面觉得完全是摇滚风格，，真的很喜欢这个风格，知乎上搜了一下发现确实是非常喜欢的日摇风格（虽然我日摇风格也听得不多，只听过hitorie笑死</p><p>本来就听不懂的闽南语（好像日语）和日摇风格混合，感觉又有点二次元味，让人心里涌起了一种奇异之感。副歌的怒音很震撼，让我产生了一种想要像了解hitorie一样了解这个乐队的冲动。</p><p>总之大晚上听到这样的音乐很激动，，，不知道几点能睡着了，十一点半迅速码了一篇平复一下我激动的心情，，，（有人一直在连我的耳机 平时早就怒关电脑睡觉了，愣是支棱起来为了循环久一点硬是解决了耳机问题，，，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>突然回想！</title>
    <link href="/2024/03/17/%E7%AA%81%E7%84%B6%E5%9B%9E%E6%83%B3%EF%BC%81/"/>
    <url>/2024/03/17/%E7%AA%81%E7%84%B6%E5%9B%9E%E6%83%B3%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>食欲不振所以买了葡萄糖酸锌口服液，仔细一看自己平时吃的维生素，发现自己吃的维生素里面就有好多锌（是吃的那一支的几十倍了），极为震撼。</p><p>看到华农兄弟的“总集篇”，感觉好感慨，有一种蒙太奇的感觉（）一个小小的通知，荒废的养殖场，屏幕前乐观的脸，这么多亩的油菜，，，又看到对象转的一些童年动画片讽刺现在的一些现象，恰值3·15，这么多不达标的食材，，，要不是北京菜这么难吃而且都是预制菜，我也不会厌食了</p><p>自习的时候不知怎的就想起以前在年级大会上的“光荣事迹”，一查才发现原来是这个意思，瞬间脚趾抠地，，，不过这种事情大家估计都忘记了（万幸</p><p><img src="/../img/%E7%AA%81%E7%84%B6%E6%83%B3%E8%B5%B7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240317200634.png" alt="救大命"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>立竿见影</title>
    <link href="/2024/03/16/%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1/"/>
    <url>/2024/03/16/%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1/</url>
    
    <content type="html"><![CDATA[<p>吃了一颗鱼油立刻狂打哈欠，，，真的假的</p><p>中午逼着自己吃了三两米饭！一颗鱼油下肚之后回到寝室一分钟内已经打了十几个哈欠。吃了香蕉 吃了开心果（半包 做完了数据库作业！待会加餐（加餐失败</p><p>晚上去吃了老爸推荐的餐厅（虽然他说我菜点的不好，没鱼没虾的），有被环境吓到（毕竟是第一次和同龄人不在父母陪同下去吃这种餐厅），然后吃掉了一半多的羊肉（有史以来吃的最多的一次，zjt吃了一半，我没数自己吃了多少但是觉得自己吃的也很多），感觉自己看上去已经做好了长大的准备但是实际上心里还没做好长大的准备orz</p><p>花粉粉尘严重超标，感觉快过敏了，风巨大无比，感觉头发上也沾满了粉尘。看了一节判断推理，本来直接扔掉的题目现在强的要命，，（换个地方学数理逻辑</p><p><img src="/../img/%E7%AB%8B%E7%AB%BF%E8%A7%81%E5%BD%B1/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240316220014.png" alt="聊天截图"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>增重计划！</title>
    <link href="/2024/03/15/%E5%A2%9E%E9%87%8D%E8%AE%A1%E5%88%92%EF%BC%81/"/>
    <url>/2024/03/15/%E5%A2%9E%E9%87%8D%E8%AE%A1%E5%88%92%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p>继晚上在北京的街头痛哭流涕之后苯人的增重计划开始！</p><p>过瘦可能会导致贫血、尿、记忆衰退、胆结石之类的疾病，研究更指出男性有140% 、女性有100% 的机率会死得更早！（通过类似闭眼单脚站的恐吓术直接实现增加重视度！</p><p>重点提要：每天吃进去的热量要多于自己消耗的！</p><p>看到网上的食谱，说女生增重和男生增重基本没有区别，唯一的区别就是增加黄豆、木瓜、坚果、莴笋、猪脚等等的食物。首先排除猪脚（虽然gqq爱吃但是我是真的不会吃！！！），木瓜，，毫无疑问也是我平时基本不吃的东西，but坚果可以！正好桌上有坚果！吃掉！莴笋平时经常吃，黄豆经常会和肉放在一起，下次一定也要吃掉！（好像可以通过练臀和练胸来增重，先试着吃多一点吧</p><p>餐前不要喝水和饮料！！！避免让它们充满我的胃！多吃香蕉！！优先选择能量密度大的食物。</p><p><img src="/../img/%E5%A2%9E%E9%87%8D/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240315205112.png" alt="含有碳水化合物的食物"></p><p><img src="/../img/%E5%A2%9E%E9%87%8D/15g%E7%A2%B3%E6%B0%B4%E5%8C%96%E5%90%88%E7%89%A9.png" alt="15g碳水形象化"></p><p>吃碳水吃碳水吃碳水！！！吃高能量食物！</p><blockquote><p>坚果：杏仁、核桃、夏威夷豆、花生等。<br>水果干：葡萄干、梅干等。<br>高脂：全脂牛奶、优格、起司、奶油等。<br>油：初榨橄榄油、酪梨油、夏威夷坚果油等。<br>谷物：燕麦、米饭等。<br>肉类：鸡肉、牛肉、猪肉、羊肉等，选择较不油腻的区块。<br>薯类：马铃淑、山药、番薯等。<br>黑巧克力、花生酱、椰奶等食物。</p></blockquote><p>全脂牛奶是极好的（看来hyx要开始买麦片了。</p><p>增加有氧运动（等姨妈期过后吧，85km还没咋跑哇哇哇柳絮要来了ww</p><p>发现食谱里好多都是不爱吃的东西，，难怪增不了重，，zjt竟然在公司里一个月重了5斤！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些感慨</title>
    <link href="/2024/03/15/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%85%A8/"/>
    <url>/2024/03/15/%E4%B8%80%E4%BA%9B%E6%84%9F%E6%85%A8/</url>
    
    <content type="html"><![CDATA[<p>看到一篇gzh讲了县城心理老师的处境，感觉很感慨。当年去tzyz讲学（忘了）的时候就觉得这些孩子的心理都比我们学校的健康太多，甚至还有一个专门的心理楼层，我都不知道我们学校的那个在哪，之前问了cxzx的npy，他说他们学校有定期的心理课，但是我们学校却一次都没有开过，班会课也都是打鸡血。我心理最崩溃的时候会偷偷跑到隔壁的空教室待在那边哭，一哭就是一节课，but不知道的老师还以为我是过去学习的，然后开始鼓励我们班的同学和我一样占领旁边的空教室，感觉心里也挺复杂的哈哈哈。</p><p>当时接触到一个tzyz的妹妹，她说家里人说她的问题就是太放松了，感觉考不上清北，只能考上浙大、人大或者复交，我心里就想考不上清北挺好的，干嘛人人都去冲清北呢，掉车尾多难受，，那个学校拥有整个tz最大的心理中心，是一所示范学校。而我们是完全效仿衡水。感觉到了高三每个人都很压抑，很心累，已经不愿回忆了，可能每个人都有每个人的烦恼。之前还看见北京的孩子很凡尔赛地说着“课外活动太多了负担不过来”，可能人家的烦恼是我们所理解不来的吧。</p><p>今天三个人围在一起踢毽子，由原来的没有办法发球到渐渐能接几个球了，感觉挺好hhh有进步就好，一方面生理期也是重要影响因素。课前闭眼单脚站差点变成全班站最久的，吓鼠我了。不过还是很欣喜。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些零碎</title>
    <link href="/2024/03/14/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E/"/>
    <url>/2024/03/14/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E/</url>
    
    <content type="html"><![CDATA[<p>昨天收拾了所有换季的衣服，把衣柜基本清理干净了！今天想点一杯姨妈热饮x 因为来姨妈的原因巨累无比，明天好想请假（</p><p>看老师跑了本地大模型跃跃欲试，觉得这个很简单自己又可以了，结果又遇到一些不知名报错（）不进厂是对的，环境都配不来（尖叫</p><p>进厂可以，但是要先找一个人帮我把所有环境配好（可能Mac真的会好配很多，，，吧，但据说现在Mac也很难配了），然后让我没有任何后顾之忧地开发（那还是当老师吧，不用导入这么多乱七八糟的东西只需要讲算法，but又想起今年奶奶让我修电视的经历（我：不会修哇） 有时候也不知道自己大学学了什么 感觉学了一堆高深莫测的理论 你有这么先进的机械进入中国！记住我给出的原理！</p><p>选了天空群岛做壁纸，本来想选有彩虹的那张但是清晰度太低了，于是选了在广播系统上的矛大师（你）用了可爱的rw鼠标指针（编辑文字的时候是垃圾佬钻管道，默认状态下是垃圾佬抖腿），本来还有一只蠕动的桌宠但是太烧cpu了</p><p>看了一点判断推理，觉得类比推理还是很玄学（鼙鼓一点都坐不住啊啊啊啊啊啊还是漫画好看</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些零碎的事情</title>
    <link href="/2024/03/13/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9A%84%E4%BA%8B%E6%83%85/"/>
    <url>/2024/03/13/%E4%B8%80%E4%BA%9B%E9%9B%B6%E7%A2%8E%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    
    <content type="html"><![CDATA[<p>昨天晚上回来的时候心情真的特别烦想要找个人说说话，但是一想到过去一些失败的社交经历就瞬间萎掉了。感觉自己没有办法找到“沉默不语或漫不经心地听”“喋喋不休”的过渡点，所以大部分时候的讲话都处在“无目的地应和”，这样既避免了沉默，也避免了喋喋不休。而与陌生人的交流却非常擅长。我会率先挑起话题并且确定这个话题双方都感兴趣（毕竟就是在那个场合才认识了陌生人），然后呢，就没有然后了。感觉人是孤独的吧。但是别人却能找到叽叽喳喳的同伴，我却没有这样的人。即便是之前的关系也鲜少维护。大部分时候觉得一个人挺好，但是没有考虑到在亲密关系的维护中也是同理。以前是想去社交的，后来发现一致的人太少，大部分人只是走在自己的道路上罢了，鲜少有人主动关心别人身上到底发生了什么。所以遇见这样的人我很感激，但这样的人也往往只是闪耀了一瞬便消失在自己的视野。</p><p>我的视野范围内还是没有这样的人。我大抵是和凉先辈一样的角色，或者弗兰肯斯坦，将自己囚禁在一个小小的地下室中。我很孤独，不过我也确实获得了快乐。想复制一个自己，但是复制出来又然后呢？她会替代我吗？单纯作为一个陪玩的工具还是不太好吧。这又牵扯到生命意义的问题了。不过我可以肯定地说，即便身边有人，我也仍然处于一个人的状态。这让我不禁思考，关系的意义到底又是什么呢？只是为了“无目的的应和”吗？写到这里情绪又上来了，情绪的源头到底又在哪里呢？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>失败的耗材-3</title>
    <link href="/2024/03/12/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-3/"/>
    <url>/2024/03/12/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-3/</url>
    
    <content type="html"><![CDATA[<p>英文的评论文章缺实难读。一开始没有理解评论员的观点，后来有一些理解了。我认为维克多的家庭是放纵型家庭，因为他的父亲没有正确地引导他，而是放任他走上了歧路。但是评论员恰恰认为维克多的家庭是专制型家庭，因为他的父亲将狭义的理性主义世界观强加在他的身上（对死亡的定义），他对年轻人感兴趣的东西（炼金术师的理论）不屑一顾，他断然否认了维克多的激情，这间接促使了维克多的“反叛”。</p><blockquote><p>我的呻吟惊醒了一个正睡在我身边椅子上的老妇人。她是监狱雇来的护士，是一个狱卒的妻子，而她的面部表情则代表了她那个阶级所有的恶劣品质。她脸上的轮廓粗鲁而又麻木，就像那种看惯了别人受苦受难，而毫不动心的那种人。她说话的腔调，则显示出她内心完全的漠不管心。她用英语对我说话，这声音听起来很耳熟，好像我在昏迷中听到过。……我厌恶地不再理那个老女人。她居然会这样毫无怜悯之心地对一个刚从死亡线上抢救回来的人说话。我感到浑身虚弱，根本无力考虑所发生的种种变故。我命运坎坷，恍如一场噩梦。有时候我真的怀疑是否这一切都是真的。……周围的一切阴森逼人，没有人愿意靠近我用一句温柔、体贴的话语来安慰我；也没有谁愿意伸出亲切的手来扶我一把。医生来过，开了点药方，老妇人则替我备药。而前者一看就知道十分草率马虎，后者则一连凶相，毫无怜悯之心。除了能赚到几个钱的刽子手之外，谁还会对一个杀人犯的命运感兴趣呢？</p></blockquote><p>评论者认为《弗兰肯斯坦》的中心主题是“渴望被真正看到”。这不仅体现在怪物身上，也体现在年幼的维克多身上。当婴儿看着母亲的脸时，最理想的情况在于婴儿在母亲眼中看到的是它自己。这是婴儿最早的确知自己存在的经历。维克多的抱怨和怪物的抱怨如出一辙。</p><p>他与伊丽莎白的结合来自父母对他未来幸福的希望，这种结合并不是他的成就，反而是他向父母屈服的标志，因此他一直处于一种矛盾的心境中，并选择尽可能拖延婚姻。尽管他以“必须把怪物铲除干净”为看似正当的理由，但新婚之夜他还是和新娘分开行动，这在现在看起来是匪夷所思的，正常人会寸步不离地守在新娘身边，生怕她被怪物伤害，而这个人居然把新娘一个人扔在房间里。维克多向他人展示的自我极有可能是欺诈性的，他将他的自我投射到了怪物身上。婴儿会向母亲周期性地展示自己的手势（真实自我），足够好的母亲会成功回应他的手势，使婴儿感到无所不能。与之相反，不够好的母亲会经常回应失败，或者试图用自己的替代手势加给婴儿。婴儿的这种顺从是虚假自我的最早阶段。虚假自我的功能是隐藏和保护真正的自我。</p><blockquote><p>关于我制造的那个魔鬼，我一直不愿作出解释，所以始终保持着沉默。我希望别人把我当成疯子，这样，这件事就永远不会从我嘴里泄露出去了。此外，我也真的不能把这个任何人听了都会吓得心惊肉跳，魂飞魄散的秘密告诉别人。我必须自己对别人的同情的渴望，缄默不言，才能避免自己将这样重大的秘密公诸于众。当然，和我上面提到的类似的话语有时还会不由自主地从嘴里漏出来，但是我却不能加以解释。不过这些话多少包含了几分真相，所以也能稍稍减轻我所忍受的难言之苦。</p></blockquote><p>类似于这样的语句经常出现，维克多经常采取逃避、隐瞒、封闭的措施，这也是他隐藏真实自我的表现。</p><p>论文的名字叫《Invisibility, and Nameless Dread》。正是因为维克多与怪物的情感表达与真实自我不被看见（在别人眼里被迫或主动地隐形），才让他与怪物各自产生无名之惧，正如Hanna Segal所解释的婴儿被欺骗后的焦虑与毁灭性的失望。怪物烧毁了它的小屋，移除了他的情感道具。小屋代表了它精神稳定的可能性。这部小说是双重束缚。维克多忠于使他被隐形的父系世界，他创造了一个非理性的生物，“邪恶”的生物也在黑暗中迷失。</p><p>完结撒花。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>失败的耗材-2</title>
    <link href="/2024/03/12/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-2/"/>
    <url>/2024/03/12/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-2/</url>
    
    <content type="html"><![CDATA[<p>依旧是弗兰肯斯坦。在知乎里看到一段对其他论文的引用感觉可以更好地解释为什么父亲这种粗暴地否定死亡的意义是不对的。</p><blockquote><p>恐惧虽然有其对他人的骚扰，但对其本身不是没有积极的意义。然而低能懒惰的管理者为了保证控制权的质量，经常施行将恐惧彻底否定的行为。久而久之，那些本来该从恐惧中获取的东西的缺席会对人格形成各种各样的伤害，从而导致个体重新形成了另一种持续的介于怀疑和恐惧之间的焦虑情绪，但因为怀疑和恐惧本身已被否定，这焦虑无法进行任何程度的描述——知道那个人重新可以描述恐惧和怀疑本身开始。</p></blockquote><p>无名之痛其实是无法和意识沟通的，埋藏在潜意识中的情感痛苦。</p><blockquote><p>父亲对母亲简直百依百顺，关怀备至，就像一个园丁保护着奇花异草一般，不让她受一点风寒，并且精心安排她的周围环境，使她温柔、善良的心灵能够焕发出愉悦。虽然母亲的情绪后来始终宁静安详，但她的健康还是因为过去的不幸遭遇而受到损伤。在他们结婚以前的两年之中，父亲陆续辞去了所有的公职。在他们结合之后，他们立即移居到气候宜人的意大利，希望异国的美景和旅行所带来的快乐能够帮助母亲恢复健康。——CHAPTER 1</p></blockquote><p>父亲对母亲倍加呵护的态度其实也是这对父母对这个独子的态度。</p><blockquote><p>从意大利出发，他们又游历了德国和法国，我是他们的长子，出生在那不勒斯，所以我在襁褓里就伴随着他们四处游历。整整好几年间，我都是他们的独子。他们彼此如胶似漆，并且从蕴藏着他们无尽爱意的矿藏中源源不断地向我倾注他们的爱心。母亲的温柔抚爱和父亲慈祥和蔼的笑容，就是他们留给我最早的印象。我是他们的小宝贝，更重要的是，我是他们的孩子，是上天赐予他们的无辜而且无助的生命。我需要他们养育，而我的未来也牵系在他们手中，他们是将我引向幸福、还是苦难，就看他们如何履行对我的职责了。他们非常清醒地意识到，他们赐予了我生命，并对我负有完全的责任，再加上他们本来就都是充满爱心和柔情的人，所以可以想见，我婴儿时期的每时每刻都耳濡目染在耐心、仁慈、自制的氛围中。我就像被一条绸带牵引着，一路上都是无尽的幸福和快乐。</p></blockquote><p>每时每刻都耳濡目染在耐心、仁慈、自制的氛围中，感觉这个孩子不像是孩子，倒像是父母的玩物。虽然我们家的实际情况也差不多，我妈经常说出类似“生个孩子玩玩”之类的话，我也很同意她的观点，决定以后无聊的时候也生个玩玩，这个观念居然也是错的！那得品行多么高尚的人才有资格做父母啊！我还是不要对自己这么苛求了（雾）。</p><p>【论文对此段文字的观点是时时刻刻让婴儿耳濡目染着自制，这损害了婴儿的独立性。但我偏向于认为这只是对他们家庭氛围的一种叙述，不是他的爸爸妈妈时刻在耳朵旁嚼舌根，所以我不同意论文在此处的观点。】</p><p>言归正传，约翰·马丁阐明了四种不同类型的养育方式，从文章看来，弗兰肯斯坦家庭的养育方式应该属于放纵型（没有要求，有求必应）。这类家长照顾孩子的每一个需求，顺应孩子的每一个请求。他们不愿意制定规则，也不提出期望，因此没有规训的基础或需要。他们会提醒，会唠叨，但很少落实口头威胁并采取行动。他们经常妥协，不会说“不”，即便扬言惩罚，也并不会真正实施，他们觉得孩子不会犯错误。他们希望讨得孩子的欢心，表现得更像是孩子的朋友，而不是父母。有些人表面上随时都在孩子身边，但并没有参与孩子实际在做的事情。放纵型父母往往比其他类型的父母富裕，受教育程度更高。</p><p><img src="/../img/%E6%97%A0%E5%90%8D%E4%B9%8B%E7%97%9B/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240312095717.png" alt="四种养育方式"></p><p>放任型的教育方式一定正确吗？它会导致什么样的后果？我在知乎上找到了相关的回答。回答太长了，所以我概括了一下。</p><p>尽管在我们的文化中，这些类型的父母被描绘为可爱而古怪的。放纵型父母的教育方式可以被看作采取最不容易遭到抵抗的方式。往好里说，他们只是希望他们的孩子能够快乐。往坏了想，他们根本不想做教育子女的工作。不管是哪一种，他们没有给孩子建立任何限制、规则，或在孩子青春期时可供叛逆的强有力的成年人形象。要说“不”可是很花力气的。强迫一个孩子做一件杂事或任务是很累人的。跟一个愤怒的孩子交谈、相处也是很费事的。因为对孩子说“不”，而被你的孩子讨厌，哪怕只是暂时的，也是非常痛苦的。放纵型父母觉得与其教孩子做家务还不如自己做来得轻松。当孩子惹麻烦的时候，他们也经常给孩子找别的理由来当借口。</p><p>当孩子长大后回顾往事，他也许会怪自己不懂事——他青春期时父母就完全没管过他，他以为这样他们就对他没有任何影响了，不管是正面的影响还是负面的，所以除了自己，他还能怪谁呢？他意识不到他缺席的爸爸和心事重重的妈妈都没有付出一点时间和精力来教育他。</p><p>青少年天性渴望自由，他们正处于建立自己独特的同一性的阶段，也期望与父母分离。但重要的是虽然青少年渴望自由，但毫无约束对他们无益。青少年需要一个可以与之对抗的强大的父母。他们在与父母的规则和违反规则的后果的冲突中学习如何做出好的决定和如何管理他们的冲动。不幸的是放纵型家庭的孩子往往没有这一切。放纵型的教育还有另一个缺陷:孩子得不到父母足够的反馈，他得为自己负责，找到他对自己的期待:他擅长什么，他的弱点是什么，他应该争取什么。</p><p>（查了那么多理论之后开始发牢骚：感觉养好一个孩子真是一件麻烦且复杂的事）</p><p>所以我恍然大悟，这就是为什么弗兰肯斯坦从头到尾都非常敬重自己的父母，即便他们在精神层面是缺失的，也依然认为他们尽了养育的职责。</p><blockquote><p>每当我回忆自己孩提时代的时候，总是觉得无以言表的快乐。可惜此后，不幸就开始玷污我的心灵，把我原本大有作为的光明前程断送在阴暗、狭隘的自我中心里。此外，在叙述我早年的经历的时候，我也要提及一些事情，这些事情后来一步步地，不知不觉地把我引向苦难的深渊。因为当我发现那些可怕的、宿命般的狂热刚刚在我内心升腾起来的时候，那种狂热还只是像山涧里的溪水，断断续续，时隐时现，可是慢慢到最后，它就变成汹涌澎湃滔滔大河，将我所有的快乐和希望都冲得无影无踪。</p></blockquote><p>弗兰肯斯坦是一个天才，但是他在年少时缺乏引导，这也间接地促使他走上了歧路。他不知道什么是对，什么是错，所有的对错都是他自己定义的。他缺乏一个严厉且权威的父亲给他树立规则，原本处于一个溺爱环境的他导致他无法融入集体生活。这在后面也有体现。</p><blockquote><p>我父亲并没有很高的科学素养，所以没有人可以引导我走出孩子式的盲目，并把我作为一个学生对知识的渴求善加利用。于是在我的新导师的指导下，我全身心地投入到对水晶球和长生不老药的研究上，而且后者很快就吸引了我全部的注意力。对我来说，财富是次要的，但是如果我能够使人类免除疾病，并且使人类除了死亡之外，能够对任何伤害刀枪不入的话，那么，这将是多么了不起的成就啊！</p></blockquote><blockquote><p>我钻进即将载我远行的马车，心头泛起最伤感的情怀。我一直以来都生活在亲人和朋友中间，尽力使彼此都体会到亲情和友情的快乐。可现在我是一个人了。在我将去就读的大学里，我必须寻找新的朋友，自己保护自己。在此之前，我的生活一直远离人群，大多数时间都是呆在家里，这使得我非常不习惯和陌生面孔的相处。我爱我的兄弟、伊丽莎白，和克莱瓦尔，这些是我”熟悉的老面孔”，但是我相信自己完全和陌生人合不来。</p></blockquote><blockquote><p>父亲后来在来信中并没有进一步责怪我，而只是把我的沉默理解为我比往日更加投入在学业上。冬天、春天、夏天，时光就在我的辛劳中从身边滑过，但是我没有欣赏到鲜花盛开，嫩叶暴芽的美景。这些都是在以前最令我兴奋雀跃的景致了，我只是完全沉浸在自己的工作中了。</p></blockquote><p>以上更加佐证了我的观点。由于篇幅限制，会另起一篇。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>失败的耗材-1</title>
    <link href="/2024/03/11/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-1/"/>
    <url>/2024/03/11/%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%80%97%E6%9D%90-1/</url>
    
    <content type="html"><![CDATA[<p>​因为英语课的要求，所以找了一个在线网站匆忙地补了弗兰肯斯坦。在简介发现这是严格意义上第一本科幻小说，所以津津有味地看了起来，虽然自己实际上要回课的内容并不是这一篇小说。</p><p>这是一个​篇幅比较短，非常精妙的作品。我花了一个小时的时间不间断地把它看完，觉得非常震撼。另一方面也是因为自己某段时间对很多事情感到困惑，主动去查询了很多亲子关系方面的知识以及很多心理的成因（我自己小时候也有非常严重的分离焦虑，现在已经因为很多事情的捶打而渐渐的消退，但是我认为我的母亲也有非常严重的分离焦虑症）。</p><p>弗兰肯斯坦是一个对自然科学非常狂热的人，就如同他自己对沃尔特所说：</p><blockquote><p>“疯狂地获取知识有多么危险！随遇而安、服从天命的人比野心勃勃、妄图更大成就的人幸福。”</p></blockquote><blockquote><p>“一个完美的人永远应该保持平静、祥和的心态，永远都不能让一时的热情和一时的冲动破坏内心的平静。”</p></blockquote><p>他因为对名利的贪欲以及对道德的漠视（原著中他对挚友克莱瓦尔对研究道德关系的著作的不理解），从死人骸骨中拼凑出一个失败的耗材。</p><blockquote><p>“I ought to be thy Adam ; but I am rather the fallen angel.”</p></blockquote><p>这是一个孩子对遗弃他的父亲的控诉。弗兰肯斯坦创造了人，滥用神权，破解谜题却无视后果。普罗米修斯草率地创造了人类并给人以火，触犯了神的禁忌（巨人自焚也许就是对火的暗示）。在警示了科学的边界的同时，也体现着对生命的敬畏。</p><p>老师认为弗兰肯斯坦是一个雌雄同体的角色。他首先是一个男性，但是他又像一个母亲一样创造了巨人（尽管他“生而不养”）。他还举了著名的绒布妈妈实验。不过当时我在想的是，弗兰肯斯坦有一对受人敬重且爱他的父母，为什么又会成为一个重度抑郁患者？为什么不能像他的父母那样去养育自己所造出来的“人”？</p><p>令我比较兴奋的是，老师在课后布置的课后作业正是为了回答这一问题。</p><p>弗兰肯斯坦和怪物组成了小说的双线，他诉说了两个看上去大相径庭的情感遗弃故事。维克多对于他父亲（文章中只能看出对父亲的态度因为母亲早逝）的态度也是防御性质的，而怪物恰恰可以视为维克多自我的一面。维克多的童年是受父母保护的和谐童年，他在家中倍受爱戴，父母为了抚养他也非常尽责，但他的“孩子”却被创造者抛弃与漠视。</p><p>弗兰肯斯坦对他父亲的描述中，他似乎是一个公众人物，没有私人的自我，弗兰肯斯坦对他的动词是“敬重”，感觉没有特别强烈的那种“爱”的情感，而是更多出于一种责任。我对这对父子的相处模式非常感兴趣，于是截取了一些关于他的父亲的片段。</p><blockquote><p>“我是日内瓦人，我的家族是当地最有名望的豪门之一。我的祖先们几代以来都是担任政府顾问和市政官，而我父亲已经担任过好几个社会要职，声名显赫。父亲因为他的正直和对公共事务孜孜不倦地关注而倍受人们尊敬，他把自己整个青春时代都用于处理国家事务，因此不断变化的环境一直使他未能成婚，直到他的人生开始走下坡路时，才为人夫和人父。因为父亲的婚姻状况很能显示他的品格，所以我不能不提几句……（家道中落，最真挚的友谊，感到痛惜，朋友家产耗尽，毫无其他经济来源）就在这个时候，我父亲走进了他们的小屋，他就像一个保护神一样来到女孩身边，负起照顾她的责任。在她父亲的葬礼结束后，我父亲把她接到了日内瓦，寄宿在他的一个亲戚那里。两年以后，卡罗琳娜成为了他的妻子。”——CHAPTER 1</p></blockquote><blockquote><p>“六年的时间恍然如梦，留下的只有一条洗刷不掉的痕迹，而我当年离开家，前往英格尔斯塔德的时候，就是站在这儿最后一次拥抱了父亲。我可敬可爱的父亲啊！对我来说，他永远都是这样。我久久凝视着壁炉架上方母亲的肖像，这是按照我父亲的意愿而画成的一件具有纪念意义的作品。在画中，卡罗琳娜·博福特，我的母亲，跪在她父亲的灵柩旁边，悲痛欲绝。她虽然衣着朴素，脸色苍白，但却自有种高贵美丽的气质，并不让人觉得可怜。而这幅画的下方，就是威廉的一幅小肖像。我一看，就不禁泪流满面。”——CHAPTER 7</p></blockquote><p>有评论说，弗兰肯斯坦父亲对他母亲卡罗琳娜的“爱”是“一种感觉”的苍白衍生物，这种情绪充满了责任与工具性。</p><blockquote><p>“如果父亲当时不是这样轻描淡写，而是愿意费一些工夫向我解释——阿格里帕的理论已经被完全推翻，而科学家已经引入一套现代科学体系，要比旧的理论体系强有力得多，因为旧的理论模式只是空中楼阁，而新的理论模式是建立在事实和实证的基础上的——那么，我的好奇心肯定就会得到满足，然后把科纳柳斯·阿格里帕的书扔在一边，既而用更大的热情投入到我原来的研究上。而且如果是这样的话，我的思想甚至根本就不会产生致命的冲动，最后将我引向毁灭。但是我父亲那仓促的一瞥令我感到他根本就不知道书里在说些什么，于是我继续贪婪地埋头阅读这本书。”——CHAPTER 1</p></blockquote><p>温尼科特将母亲对于婴儿的作用分为“客体母亲”与“环境母亲”，客体母亲支持婴儿无所不能的感觉（尿布湿了就有人换，饿了就有奶吃），让婴儿确信婴儿自身存在的真实性，环境母亲是帮助婴儿隔绝外部世界的一层屏障，这是一种过渡领域，但也需要向外部世界提供灵活性以适应其创造力。婴儿的性格取决于孩子形成的最早的关系，如果以足够好的方式回应，就会形成好的性格，如果不承认他的内心世界，而是强加自己版本的现实，抑制婴儿的想象力、欲望、痛苦等自发性情感，那么就不能够形成好的性格。</p><blockquote><p>“我知道我的杳无音讯令他们非常不安，我至今都很清楚地记得我父亲在信里说： “我知道，即使你在那里自得其乐的时候，也仍然会充满深情地想念我们，但是我们也该定期收到你的家信呀。请你一定要原谅我，如果你中断和我们的联络的话，我只能将之视为你连你其他应尽的责任也一概打算视了。”——CHAPTER 4</p></blockquote><blockquote><p>“父亲发现我的性情、和生活习惯发生了巨大变化之后非常痛苦，他时常发自内心地开导我，希望我能够振作精神，鼓起勇气，驱散蒙在我心头的阴云。”维克多，”他说，”难道我心里就不难受吗？没人比我更爱你的弟弟了。”，他流着泪说，”但是，我们对于活着的人来说就没有责任了吗？我们不应该过度悲伤，这样只会增加别人的痛苦。这也是你对自己应尽的责任啊，因为过分忧伤会损害你的健康，让你无法享受生活的乐趣，甚至一蹶不振，不能尽基本的社会义务，这样一来，你对社会还有什么用呢？”父亲的说法虽然言之有理，但是却不符合我的情况。要是我的内心不是如打翻了的五味瓶一般，各种痛苦、恐惧、悲哀，绝望的情感都搅和在一起的话，我可能会第一个把内心的悲哀掩盖起来，并去安慰我的朋友。可是现在，我只能无望地看着我的父亲，并尽量避免在他眼前出现。”——CHAPTER 9</p></blockquote><blockquote><p>“要研究生命的起源，就必须求助于死亡。我已经掌握了解剖学，但这还远远不够，我必须观察尸体自然腐烂的经过。父亲在我幼年时期对我进行教育的时候，总是非常小心，不让我的心灵被任何超自然的恐怖事物所惊吓。我记得我从来都不害怕迷信传说，也不害怕幽灵鬼怪。黑暗不会令我产生任何恐怖的联想，墓地对我来说也只是存放失去了生命的躯壳的地方，那些原本美丽强健的肉体最终会成为蛆虫的美餐。”</p></blockquote><p>对死亡本该有的那些原始的恐惧被系统地禁止与解构。</p><p>截了小说前半部分的很多父子之间的互动，我才发现看似非常和谐的父子关系实际上却令维克多感到回避。还关注到一些除了父子之外的维克多对于别人的看法，比如对于他的妻子： </p><blockquote><p>“每个人都喜欢伊丽莎白，大家对她的爱深沉、强烈，而我对此总会感到无比的自豪和喜悦。在伊丽莎白来我家的前一天晚上，母亲开玩笑地对我说：”我有一件漂亮的礼物要送给我的维克多，明天他就可以拥有了。”第二天，她把伊丽莎白带到了我的面前，说这就是她许诺的那份礼物。而我呢，带着孩子式的认真，真的从字面上理解我妈妈的话，认为伊丽莎白归我所有，将由我来保护她、爱她、珍惜她。我把所有对她的赞美都看成对我个人财产的由衷赞美。我们虽以堂兄妹相称，但是没有任何语言、任何表达法可以描述她和我之间的关系——她对我来说不仅是妹妹，因为她至死都只属于我一个人。”——CHAPTER 1</p></blockquote><p>不过这个口吻令我感到有点奇怪。“个人财产”“拥有”感觉有一点物化妹妹的迹象，但是我倾向于认为他们俩是true love，至少维克多本人对伊丽莎白有着精神上依赖的情感，维克多因为父亲养育造成的影响，对非理性的否认构成了他的整个童年，那他不知如何表达情感便也成为一种很正常且可悲的事了。其实还有相关的片段，在于他认为自己是一个非常可怜的脆弱的人所以觉得他和非常精神平和的象征着精神寄托的伊丽莎白非常相配，当然以现在的恋爱观来看这是一种非常畸形的单方面的倾斜，两人本应该各自美丽而不要牵扯太多的类似救赎，不要把对方看成自己的圣母，也不要想着去拯救对方。</p><p>论文没翻译完，自己的感想倒是写了一大段，有空再写。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些神奇的想法</title>
    <link href="/2024/03/09/%E4%B8%80%E4%BA%9B%E7%A5%9E%E5%A5%87%E7%9A%84%E6%83%B3%E6%B3%95/"/>
    <url>/2024/03/09/%E4%B8%80%E4%BA%9B%E7%A5%9E%E5%A5%87%E7%9A%84%E6%83%B3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本来只是想上小红书搜一些学习攻略结果不小心又点进视频里面了（捂脸），发现已经刷到很多宠物鹦鹉撕纸放在身后的行为，觉得很神奇，所以检索了一下，发现这是母鸟絮窝的方式，就是把草咬成一小截一小截，插在后面鼙鼓羽毛下，这样就可以带很多根，也叫别草。这是成鸟准备繁殖的信号。</p><p>之前吃饭的时候也想到为什么要吃盐的原因，有姐妹帮我查了是因为动物喜欢去盐碱地舔一舔盐巴，然后人们发现这种物质会让动物兴奋，于是就自己也尝了尝。感觉很多自然界的事情都特别有意思！</p><p>今天真的好渴，，，而且连考三门真的太反人性了！虽然大概率是陪考，不过科三的时候摸鱼画证件照画得差点在考场笑出来，，，下次不干了，，，</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>明与暗</title>
    <link href="/2024/03/08/%E6%98%8E%E4%B8%8E%E6%9A%97/"/>
    <url>/2024/03/08/%E6%98%8E%E4%B8%8E%E6%9A%97/</url>
    
    <content type="html"><![CDATA[<p>我总是会为一些替代经历产生恐惧。因为害怕被伤害选择逃避，试图排除所有的危险，也许是对于幼儿时期的“全能自我”的迷恋，希望一辈子都像一个婴儿一样被所有人关心，即退行，而这也是我一直以来的防御机制。</p><p>转载了一点知乎的回答，觉得写的特别好，所以时时翻看勉励自己。</p><p>逃避伤害是对的，但是他的目的应该是为了尽可能选择值得的牺牲，而不是为了永远幸福地生活下去。如果“千万不要受伤害”在决策中变得越来越重要，只会让人生被浸透在“可能受伤害”的恐惧之中。越是恐惧，便越是敏感。最后除了自绝于人类，将没有任何手段能安抚极端敏感的恐惧。</p><p>要学会主动接受受伤的可能性，即聪明的受伤、有控制的、有意的受伤。在不断受伤之中形成耐受、脱去敏感，“伤害”的威力也就被剥夺了。</p><p>“于何时在何地为何人接受何种受伤的风险”应该是经过深思熟虑后进行的一种选择，而且这种选择应该贯穿整个人生。</p><p>与这种可能性主动的共舞，慢慢就会学会跳舞，于是别人不敢的，你敢；别人不肯的，你肯；别人不能的，你能。慢慢地就会体会到，唯有有效的牺牲是真正幸福的。因为人终将死去，你所舍不得牺牲的最终仍然会化为飞烟，你根本就不能选择“不失去”。</p><p>牺牲有技巧，有价值最大化的复杂策略。你不能选择拒绝牺牲，而只能选择学习牺牲的智慧和技术。如何将有限的人生转化为最大的人类福利、世界的福利，是一门需要毕生学习的课程。</p><p>你回避一种伤害，只该是因为不愿虚掷你的“受伤余额”，但绝不是为了守着这份余额到死的。不要再在一次次逃避中践踏光阴了！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HITORIE</title>
    <link href="/2024/03/06/HITORIE/"/>
    <url>/2024/03/06/HITORIE/</url>
    
    <content type="html"><![CDATA[<p>在地下室大唱特唱HITORIE。过路的人问我为什么喜欢日本的歌，我不假思索地回答，因为我喜欢HITORIE这个乐队，准确的说，我喜欢这个乐队的主唱。</p><p>wowaka的歌都很难翻唱。他的几首比较广为传诵的歌都是非常快的bpm，令人上气不接下气，但是在我非常低落的时期，他那种宣泄式的嘶吼的迷茫是我的精神支柱。从进入大学以来，几乎每个学期都在循环他的老歌。</p><p>发现冬野里有一句歌词是，“所有人都拥有的&#x2F;唯一的&#x2F;心脏&#x2F;即使被洋溢的色彩所浸染&#x2F;也依然跳不够&#x2F;不要离开我”，很感慨。</p><p>在五月天假唱风波时，我会想到wowaka的万人合唱unknown-mother goose现场。每一个人都向前挥动着手臂，就像巨浪。他不够高，甚至够不到立式话筒。但是他踮起脚抬起头，似乎是咬牙切齿地，但是饱含感情地喊出每一个词，弹奏着手中的电吉他。当我第一次听到现场最后那个爆发式的质问时，我的眼泪情不自禁地流了下来。有人假唱，有人燃尽生命怒吼。</p><p>从那首歌起，我对他的认知从一个净写些这么难翻唱的v家曲的p主，到发自内心认为他是一个可敬的歌者。我深深地崇拜着他的灵魂，尽管他也一样看似是现实逃避之人。从那一刻起我也开始去了解我几乎不怎么接触的日语歌领域，开始了解他担任主唱的乐队，开始费力地学着罗马音。</p><p>我带上耳机跟随着sleepwalk的节奏就像mv里漫步的舞者，这首歌是我循环次数最多的歌。我一边仰望着晴朗冬日里光秃秃的树枝枝干，一边一遍遍地听着冬野，每当听到那个钢琴变奏眼神都会突然变得柔和而悲伤。那时还在疫情学期，夜晚的未名湖非常寂静，我在未名湖的夜晚向着对面大喊“为何难解？为何难解！”。我一面郑重地弹奏，一面想象他站在台上的样子。我决定把记忆中的那个他重现出来，一直一直唱着他的歌。这是我的怀念，以最郑重的方式。</p><p>“在颤抖到无法动弹前，唱起来，唱起歌谣，只是唱着歌谣。”</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>上善若水</title>
    <link href="/2024/03/05/%E4%B8%8A%E5%96%84%E8%8B%A5%E6%B0%B4/"/>
    <url>/2024/03/05/%E4%B8%8A%E5%96%84%E8%8B%A5%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p>昨天发了一篇博客是想就inner peace这个话题发发牢骚的，后来想查一下inner peace的官方解释，发现是类似于一种自得其乐，不争的概念。啥是不争？于是进行了一些递归式检索，发现了它最早的出处。</p><p>“上善若水，水善利万物而不争。处众人之所恶，故几于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。”</p><p>要想理解不争，还得理解尤的意思。尤指过错吗？但是扶苏不争导致胡亥继任，秦朝灭亡，显然不争并不能避免错误。尤指别人的怨恨吗？道德品行再高的人也会被一些不理解的人责骂，这是人性所然。其实尤指的不是别人的怨恨，而是每个人自己的怨恨之心。所以老子这句话的意思是：如果你与世无争，就不会有怨恨之心。</p><p>诸烦恼中，瞋为最重。诸心病中，第一难治。一念嗔心起，百万障门开。杀瞋心安隐，杀瞋心不悔；瞋为毒之根，瞋灭一切善；杀瞋诸佛赞，杀瞋则无忧！那么如何才能杀掉心中的“嗔”呢？佛陀提供了一个绝招叫忍辱。而老子也提供一个必杀技叫不争。所谓“忍辱”，不正是“不争”吗？</p><p>只要有竞争，有博弈，就难免有得失，有成败。而水谦虚卑下，清湛悠然，择地而居。水助万物而自乐，滋润万物而不居功，柔弱处下，与世无争，这样才能免去患得患失的精神折磨，免去纷争、痛苦与烦恼。</p><p>但是我在检索的时候留意到上面广为传颂的版本反而是以讹传讹流传下来的版本，而真正的版本，很奇怪，表面上看起来是完全相反的观念。</p><p>“上善若水，水善利万物而有争。居众之所亚，故几于道。心善渊，居善地，予善天，正善信，事善能，动善时。不争容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。夫唯不争，故无尤。”</p><p>老子的原意，是争与不争的辩证。心善渊，居善地，予善天，正善信，事善能，动善时，是水的六个品性，也是不争的六个含义，而不是上一版本的人的品性。水像宇宙一样包容，像大地一样公平，像苍天一样无私，水真实可靠，有求必应，善于激发万物的潜能，也会在干旱缺水时雪中送炭。水滋润万物，满足需求，故而不争。但一切生命离不开水，万物无不归往，此为有争。水的这种“服务性”让我不禁想起了《沙丘》中的姐妹会。这个组织表面避其锋芒，负责激发各大家族基因组的潜能，甘于退居身后，因此在纷争之中保全自身，实则又把救世主牢牢控制。这种主旨也是“弱能胜强”在某种方面上的体现。</p><p>反者道之动，弱者道之用。前者指的是同一事物的循环往复，向着反面发展。后者则是不同个体之间的关系互动，强即是弱，弱即是强。我自己的心中也时时滋长许多恶念，正好我的主命格为水，故以此作为id来提醒自己。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我想要获得安宁的心境</title>
    <link href="/2024/03/04/%E6%88%91%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E5%AE%89%E5%AE%81%E7%9A%84%E5%BF%83%E5%A2%83/"/>
    <url>/2024/03/04/%E6%88%91%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E5%AE%89%E5%AE%81%E7%9A%84%E5%BF%83%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>我想要获得安宁的心境，而西方资本想获得货币的自我增值。我不会臣服于他们的工业化学制剂。是春天的错，我狂热地爱着春天。气温无预兆地变冷又变暖，就像我的心脏我的血液。冬天让我思维静止在室内，春天让我疯狂，都怪春天。</p><p>我厌倦了日复一日的发笑，我享受着遗弃的快乐。我会屈服于阳光，过度曝光却又寒冷刺骨。我怒目圆睁，步入轨道。</p><p>我手握着自行车把，一辆电动车撞向了我的腰间。我无所谓。我的手冻得麻木，失去知觉。</p><p>文史楼一股尿味，地学楼也是，一教也是，宿舍也是。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>可能只是碰巧吃到了辣椒籽</title>
    <link href="/2024/03/03/%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E7%A2%B0%E5%B7%A7%E5%90%83%E5%88%B0%E4%BA%86%E8%BE%A3%E6%A4%92%E7%B1%BD/"/>
    <url>/2024/03/03/%E5%8F%AF%E8%83%BD%E5%8F%AA%E6%98%AF%E7%A2%B0%E5%B7%A7%E5%90%83%E5%88%B0%E4%BA%86%E8%BE%A3%E6%A4%92%E7%B1%BD/</url>
    
    <content type="html"><![CDATA[<p>吃到巨辣的东西时不要放弃一整盆菜，你可能只是碰巧吃到了辣椒籽。</p><p>如果一条鱼刺特别多也不代表这条鱼全是刺，你可能只是碰巧吃到了背部。</p><p>学会了All too well的前八分钟，手磨出泡了，明天休战一天。还以为毽子水平倒退了，原来是因为穿了白牛仔裤有了心里负担。晚上换了条裤子又练了一会，汗都出来了。</p><p>穿着风衣去五四跑了一会，谁能在外面阳光明媚的情况下憋在室内呢？开会的时候看完了沙丘前十五章，报告厅真的太挤了。两个小时内肝完了冯式结构读书报告，因为想练琴所以尤其高效。</p><p>变成凤凰蛋了，终于！这几天一直在跑训练图，辛苦了！感觉不开麦组队打训练图还是为时过早了些，线下再教训zjt。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>FLIPPED DUNE</title>
    <link href="/2024/03/02/FLIPPED-DUNE/"/>
    <url>/2024/03/02/FLIPPED-DUNE/</url>
    
    <content type="html"><![CDATA[<p>二十四小时内看了两场电影，zjt说DUNE的海报字体设计很独特。这个学期要读的书有点多，但还是想找沙丘的原著看。FLIPPED个人认为有点强行HE。</p><p>“有没有一种可能，女主父亲允许男主在院子里挖洞是为了给女儿做恋爱脑切除手术，让女儿看清他有多坏。”</p><p>“标题都叫怦然心动了，你不HE让那些来看的小情侣怎么办？”</p><p>再次感觉每一个经历都是在为现在的我做铺垫，比如写博客在中间空一行就得益于之前想整自媒体但没整成的经验。</p><p>蹭进元培楼也愈发轻车熟路了，就是坐的有点后排被挡了字幕。</p><p>和zjt逛海淀公园，打牌。天气回暖，气温正好。他说我穿着羊羔绒的衣服更像一只小羊羔了。正好今天也cos了dongdong羊，薯片小羊训练图是大好图哇，虽然很艰难但是过关了，感觉有望成为硬核蛋。</p><p>尝试改手机端的icon但是没改成，无所谓，反正电脑端看得比较多。</p><p>今天练习了两百下毽子，从一开始的满场地跑，到大概有五十到一百下是可以踢一下接住的了，脚也暖和了。难怪说这是一个减轻玉玉的运动。</p><p>连续两天被错认为在准备十佳节目了哈哈，一个留学生姐姐走近并试图和我交流，差点没听懂口音不过她冲我比了个大拇指。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>单脚站立的乌鸦</title>
    <link href="/2024/03/01/%E5%8D%95%E8%84%9A%E7%AB%99%E7%AB%8B%E7%9A%84%E4%B9%8C%E9%B8%A6/"/>
    <url>/2024/03/01/%E5%8D%95%E8%84%9A%E7%AB%99%E7%AB%8B%E7%9A%84%E4%B9%8C%E9%B8%A6/</url>
    
    <content type="html"><![CDATA[<p>研究表明，单脚闭眼站立不超过五秒的人十几年内会死。我哆哆嗦嗦地摇着花手，湖边北岸的鸭子双脚站立在将融未融的湖面上，而我维持着脚底的温度。</p><p>乌鸦侧着脑袋，看太阳表面的脉搏闪闪发光。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【置顶】古人计划</title>
    <link href="/2024/02/29/%E5%8F%A4%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    <url>/2024/02/29/%E5%8F%A4%E4%BA%BA%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>以前新生训练营的时候，很想与人交流，但碍于周围人都在看手机，只好作罢。手机，确实是一个隔断交流的东西，又加上开学后日益压抑、充满了距离感与落差感的氛围，我的内向指数也逐渐上涨。</p><p>智能手机第一次入侵了我的生活，之所以说是入侵，主要是因为以前我从来都是将它当做一个工具来使用，或搜题，或拍照，或聊天。</p><p>而现在我却被绑架了。当周围所有人都在看手机时，这是一个拒绝交流的信号，我也不得不低下头去，把眼睛拘束在屏幕之中。当时从不冲浪的我甚至不知道手机有什么好看的，也不知道该看什么。训练营在抬头与低头的循环中结束。</p><p>暑假的时候，妈妈把退役的智能手机给外婆用，尽管外婆不识字，但也觉得智能机好用，不会像老年机一样发出闹心的声音。但上初三的表妹占据了大部分手机的使用权，每天要刷至少两个小时的短视频。推开门，她坐在书桌前，悄悄把手机埋在参考书下，外放音量调到最小。她聊起现在班级里大家都在吐槽“应试教育”，不知怎的，这种专有名词从她口中讲出倒显得她像个早熟的小老头。同一部手机，所有年龄段的人收看着几乎一样的东西，所以大学生逐渐幼稚，小孩却早早体验大人的生活。</p><p>“你都看啥小说啊？”</p><p>“无限流！”她语气中不无骄傲。</p><p>“啥是无限流啊？”</p><p>“无限流就是……”她吧啦吧啦给我解释了半天，大致听了个明白。</p><p>可能前面的一代人看我们这代也饱含着同情与艳羡。但我认为短视频和电视剧、游戏有着本质的区别。短视频是一种漫长且没有尽头的刺激，刺激过后，只有精神涣散与空虚。于是尝试戒掉电子榨菜，并在这个四年一遇的日子重启了博客。</p><p>非常感谢grey’pe提供的建站帮助。</p><p>注：无限流，指系统强制给你下达任务，主角有无限生命，只有任务完成才能回到原来的世界。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
