

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.ico">
  <link rel="icon" href="/img/avatar.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#1E646E">
  <meta name="author" content="Liebe_grausam">
  <meta name="keywords" content="">
  
    <meta name="description" content="结果出了！10：20醒，10：08收到了感谢信，流程推进的很快，总比吊着好！ 字节面试凉（凉？凉！）经一面，不知道到底是凉了还是过了呢？先做个总结吧，实在不行去美团接开水（当当）！当做锻炼机会也不是不可 面试评价：体验很好，题目挺简单的，面试官人很好一直在捞 个人总结：基础知识有点不扎实，有点不自信（）毕竟是第一次面试也是情有可原，下次要自信！ zjt评价：术语太少了感觉像唠嗑，，下次要多记术语，">
<meta property="og:type" content="article">
<meta property="og:title" content="苯人第一次面试-字节复盘">
<meta property="og:url" content="http://liebe-grausam.github.io/2024/05/13/%E8%8B%AF%E4%BA%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E5%A4%8D%E7%9B%98/index.html">
<meta property="og:site_name" content="苯人的一些发疯自留地！">
<meta property="og:description" content="结果出了！10：20醒，10：08收到了感谢信，流程推进的很快，总比吊着好！ 字节面试凉（凉？凉！）经一面，不知道到底是凉了还是过了呢？先做个总结吧，实在不行去美团接开水（当当）！当做锻炼机会也不是不可 面试评价：体验很好，题目挺简单的，面试官人很好一直在捞 个人总结：基础知识有点不扎实，有点不自信（）毕竟是第一次面试也是情有可原，下次要自信！ zjt评价：术语太少了感觉像唠嗑，，下次要多记术语，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-13T15:27:36.000Z">
<meta property="article:modified_time" content="2024-05-22T08:10:13.991Z">
<meta property="article:author" content="Liebe_grausam">
<meta property="article:tag" content="hyx的面试之路">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>苯人第一次面试-字节复盘 - 苯人的一些发疯自留地！</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"liebe-grausam.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>撒野地</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/wenzhang.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="苯人第一次面试-字节复盘"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-13 23:27" pubdate>
          2024年5月13日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          170 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">苯人第一次面试-字节复盘</h1>
            
            
              <div class="markdown-body">
                
                <p>结果出了！10：20醒，10：08收到了感谢信，流程推进的很快，总比吊着好！</p>
<p>字节面试凉（凉？凉！）经一面，不知道到底是凉了还是过了呢？先做个总结吧，实在不行去美团接开水（当当）！当做锻炼机会也不是不可</p>
<p>面试评价：体验很好，题目挺简单的，面试官人很好一直在捞</p>
<p><strong>个人总结：</strong><br>基础知识有点不扎实，有点不自信（）毕竟是第一次面试也是情有可原，下次要自信！</p>
<p><strong>zjt评价：</strong><br>术语太少了感觉像唠嗑，，下次要多记术语，多输出，不要尬笑 底气不足</p>
<p><strong>面试官评价：</strong><br>在分析问题上面挺好的，但是有几个点我觉得还是需要后面去重点的去回忆一下（回忆？补强！）。</p>
<ol>
<li>就是针对于基础知识的一些掌握，因为学校里面有一些基础课程其实是很有意义很有价值的。很多原理性的东西几乎都是源于这个基础知识的演变跟演化，所以把基础的知识了解一下。（您说的对我之前太混了啊啊啊</li>
<li>可以额外的去了解一下，因为我们是后端开发的一个工作，可以了解一下后端开发的一些工程上的知识，比如说我刚刚给你提到的是<strong>软件工程</strong>相关的一些知识，可以系统的去了解一下，你们有这个课程我知道，所以也可以就直接去看一下他的一些教材或者教案相关的东西了解一下。</li>
<li>代码这一块，我看你写代码还算比较流利，然后思考问题的话也还算ok，但是有一个点就是你再去编码的时候，<strong>要注意对一些关键环节上面的一些信息的输出，就是通过日志或者通过一些关键环节去整理出来就行了，</strong>主要是这三块（这一点帮助了我xhs的第二次笔试，虽然不知道过了没</li>
<li>不用太紧张（面试经验不足导致的，多锤几次就好了</li>
</ol>
<h1 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h1><p>（唠嗑）</p>
<h1 id="2-项目经历"><a href="#2-项目经历" class="headerlink" title="2.项目经历"></a>2.项目经历</h1><p>（讲了myftp的项目，面试官尽力在救【试图往udp上引，奈何苯人没有面试经验，救不回来】）<br>（myftp的项目也说得太简单了，要说的详细一点）<br>（下次顺带着把udp的项目也讲了！！！）<br>（malloc说成memset了，我的锅）</p>
<h1 id="3-项目拓展"><a href="#3-项目拓展" class="headerlink" title="3.项目拓展"></a>3.项目拓展</h1><p>（以后反正也会问到，觉得这一部分特别重要</p>
<h2 id="Q1-具体是怎么去做的文件的切分？"><a href="#Q1-具体是怎么去做的文件的切分？" class="headerlink" title="Q1:具体是怎么去做的文件的切分？"></a>Q1:具体是怎么去做的文件的切分？</h2><p>凉经案例：只说了把大文件分割成固定大小的块进行传输，而且把字节说成了比特。</p>
<p><strong>问了gpt：</strong><br>我采用的策略是将一个大文件分割成固定大小的块进行传输，比如1024字节。</p>
<p>还可以根据网络带宽和延迟动态调整文件块的大小。在这种策略中，服务器端根据当前网络条件动态地调整文件块的大小，以提高传输效率。例如，如果网络带宽较大，可以增大文件块的大小以减少传输次数；如果网络延迟较高，可以减小文件块的大小以降低传输延迟。</p>
<p>除了以上两种策略，还可以根据具体应用场景和需求设计其他的文件切分策略，例如按照文件类型、内容等进行切分。</p>
<h2 id="Q2-这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战"><a href="#Q2-这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战" class="headerlink" title="Q2:这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战"></a>Q2:这个项目去做的时候有遇到什么问题吗？或者说你有没有参考过我们现其他的一些比较典型的FTP的这种文件传输的协议去了解一下要做这个事情，我需要准备哪些技术或者说我需要去处理哪些关键的点，对于你来说你去实现这个事情（即挑战</h2><p>凉经案例：只说了连接管理和文件切分</p>
<p><strong>问了gpt：</strong></p>
<ol>
<li>连接管理：需要处理客户端和服务器端的连接管理，包括建立连接、维护连接状态、处理连接断开等情况。</li>
<li>文件切分和传输：需要实现文件切分和传输功能，包括将大文件切分成多个小块、传输文件块、重组文件块等操作。</li>
<li><strong>并发处理</strong>：需要处理多个客户端同时连接的情况，保证并发访问的正确性和性能。</li>
<li><strong>错误处理和恢复</strong>：需要处理各种错误情况，包括网络异常、文件传输中断、客户端或服务器崩溃等，保证系统的稳定性和可靠性。</li>
<li><strong>安全性</strong>：需要考虑数据传输的安全性，包括加密传输、身份认证、访问控制等机制。</li>
</ol>
<h1 id="4-八股"><a href="#4-八股" class="headerlink" title="4.八股"></a>4.八股</h1><p>面试官可能比较无语（嘿嘿）所以问了一些八股，但是答得也不咋地</p>
<h2 id="TCP和udp的区别？"><a href="#TCP和udp的区别？" class="headerlink" title="TCP和udp的区别？"></a>TCP和udp的区别？</h2><p>把没有提到的标粗了（我草怎么这么多标粗，感情一共六条就讲了两条</p>
<ul>
<li>tcp是面向连接的可靠传输服务；udp不需要建立连接，尽力而为，不保证可靠传输。</li>
<li><strong>tcp是点对点连接，udp则是支持一对多、多对一、多对多</strong></li>
<li><strong>udp对系统资源要求较少，而且首部较短节省开销；tcp比较庞大，开销比较大</strong></li>
<li>tcp是流式传输，没有边界，但是顺序可靠；udp是一个包一个包传输，可能有丢包和乱序</li>
<li><strong>tcp在传输层进行分片，udp在ip层进行分片</strong></li>
<li><strong>tcp用于FTP、HTTP等；udp用于dns、smtp、音视频等多媒体</strong><br>（顺带一提 面试官想从这里引到udp来着，太紧张硬生生被我憋回去了，卒</li>
</ul>
<h2 id="文件存储的具体的格式？"><a href="#文件存储的具体的格式？" class="headerlink" title="文件存储的具体的格式？"></a>文件存储的具体的格式？</h2><p>（完全不知道是什么东西orz）</p>
<p>文件通常以二进制形式存储在文件系统中。具体来说，文件的存储格式通常分为两部分，由文件内容和元数据组成：</p>
<ol>
<li><p><strong>文件内容</strong>：文件内容以二进制形式存储在文件系统中。对于文本文件，内容可以直接以字符流的形式存储；对于二进制文件，内容则是原始的二进制数据。</p>
</li>
<li><p><strong>文件元数据</strong>：文件元数据包括文件的名称、大小、权限、创建时间、修改时间等信息。这些元数据通常会以特定的格式存储在文件系统中，以便文件系统能够快速地识别和管理文件。</p>
</li>
</ol>
<h2 id="问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的"><a href="#问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的" class="headerlink" title="问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的"></a>问了hadoop一个文件框默认多大，此次面试后hyx就删掉了这个项目经历（哈哈，来不及准备是这样的</h2><h2 id="进程跟线程的区别？"><a href="#进程跟线程的区别？" class="headerlink" title="进程跟线程的区别？"></a>进程跟线程的区别？</h2><p>凉经案例：只讲了第一点资源分配</p>
<p><strong>问了gpt：</strong><br>进程（Process）和线程（Thread）是操作系统中两个重要的概念，它们之间有以下几点区别：</p>
<p>第一点，他们在xxxx方面存在区别，进程……，线程……</p>
<ol>
<li><p>资源分配：</p>
<ul>
<li>进程是<strong>程序的执行实例</strong>，是<strong>系统中的一个独立单位</strong>，拥有独立的<strong>内存空间、文件描述符、堆栈</strong>等资源。</li>
<li>线程是<strong>进程的执行单元</strong>，是 <strong>CPU 调度的基本单位</strong>，同一进程内的线程共享进程的内存空间和其他资源。</li>
</ul>
</li>
<li><p><strong>调度和切换</strong>：</p>
<ul>
<li>进程之间的切换开销比较大，因为需要<strong>保存和恢复整个进程的上下文信息</strong>。</li>
<li>线程之间的切换开销相对较小，因为<strong>线程共享进程的地址空间</strong>，只需要保存和恢复线程的上下文信息。</li>
</ul>
</li>
<li><p><strong>通信机制</strong>：</p>
<ul>
<li>进程之间通信需要使用<strong>IPC（Inter-Process Communication）机制</strong>，例如管道、消息队列、信号量等。</li>
<li>线程之间通信可以直接<strong>共享进程的地址空间，通过共享变量进行通信</strong>。</li>
</ul>
</li>
<li><p><strong>创建和销毁</strong>：</p>
<ul>
<li>进程的创建和销毁开销比较大，因为需要<strong>分配和释放独立的内存空间</strong>。</li>
<li>线程的创建和销毁开销相对较小，因为线程共享进程的资源，只需要分配和释放<strong>线程的控制块</strong>。</li>
</ul>
</li>
<li><p><strong>并发性</strong>：</p>
<ul>
<li>进程之间的并发性较低，因为进程间<strong>切换开销大</strong>。</li>
<li>线程之间的<strong>并发性较高</strong>，因为线程间切换开销小，<strong>可以更快地响应用户的请求</strong>。</li>
</ul>
</li>
</ol>
<h2 id="进程间通信方式（IPC）"><a href="#进程间通信方式（IPC）" class="headerlink" title="进程间通信方式（IPC）"></a>进程间通信方式（IPC）</h2><p>凉经：只答了管道、pv信号量（答的时候忘记是信号量了，只记得pv操作）、把共享内存说成了共享变量（共享变量是线程的orz</p>
<p>进程间通信（IPC）的不同方式各有其优缺点，适用于不同的应用场景。下面是常见的几种IPC方式及其优缺点：</p>
<h3 id="1-管道（Pipes）"><a href="#1-管道（Pipes）" class="headerlink" title="1. 管道（Pipes）"></a>1. 管道（Pipes）</h3><p>管道又分为匿名管道和命名管道。其中，匿名管道只能用于父子进程等具有亲缘关系的进程，命名管道则存在于文件系统中，可以用于任何进程之间的通信，具有比较好的持久性。管道的优点是创建和使用非常简单，并且数据在管道中的顺序由操作系统来保证，不需要显式同步。但是他也有一些缺点，第一点，管道是<strong>半双工</strong>的，需要两个管道才能实现双向通信。第二点，<strong>读取时如果没有数据会阻塞进程</strong>。</p>
<h3 id="2-消息队列（Message-Queues）"><a href="#2-消息队列（Message-Queues）" class="headerlink" title="2. 消息队列（Message Queues）"></a>2. 消息队列（Message Queues）</h3><p><strong>优点</strong>：</p>
<ul>
<li>支持无亲缘关系的进程通信。</li>
<li>灵活的消息格式：<strong>可以发送和接收不同类型和优先级的消息</strong>。</li>
<li>非阻塞操作：可以设置为<strong>非阻塞模式</strong>，避免进程挂起。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>复杂性：使用和管理相对复杂，需要显式创建和销毁。</li>
<li>消息大小限制：消息队列<strong>有最大消息大小限制，可能不适合传输大数据</strong>。</li>
</ul>
<h3 id="3-共享内存（Shared-Memory）"><a href="#3-共享内存（Shared-Memory）" class="headerlink" title="3. 共享内存（Shared Memory）"></a>3. 共享内存（Shared Memory）</h3><p><strong>优点</strong>：</p>
<ul>
<li>高效：直接在内存中进行数据读写，<strong>速度快</strong>，<strong>适合大数据量通信</strong>。</li>
<li>灵活：可以在共享内存区域内自由读写数据。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>同步问题：需要<strong>显式同步机制（如信号量）</strong>来保证数据一致性。</li>
<li>安全性：需要确保访问权限和数据完整性，<strong>避免数据竞争和破坏</strong>。</li>
</ul>
<h3 id="4-信号量（Semaphores）"><a href="#4-信号量（Semaphores）" class="headerlink" title="4. 信号量（Semaphores）"></a>4. 信号量（Semaphores）</h3><p>与“信号”要做区别！！！<br><strong>优点</strong>：</p>
<ul>
<li>用于进程同步：非常适合解决进程间的<strong>同步和资源竞争</strong>问题。</li>
<li>灵活：可以用于多种同步场景，支持复杂的同步操作。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>不直接传递数据</strong>：只用于同步，不用于数据传输。</li>
<li>复杂性：使用和管理相对复杂，需理解信号量机制。</li>
</ul>
<h3 id="5-套接字（Sockets）"><a href="#5-套接字（Sockets）" class="headerlink" title="5. 套接字（Sockets）"></a>5. 套接字（Sockets）</h3><p><strong>优点</strong>：</p>
<ul>
<li>通用性强：不仅用于<strong>本地进程间通信</strong>，还可以用于<strong>网络通信</strong>。</li>
<li>灵活：<strong>支持多种通信协议（TCP&#x2F;UDP）</strong>，适合多种通信需求。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>复杂性：<strong>使用和管理较复杂，需要处理连接、数据流控制等</strong>。</li>
<li>性能：比共享内存等方式稍<strong>慢</strong>，尤其是在本地通信时。</li>
</ul>
<h3 id="6-信号（Signals）"><a href="#6-信号（Signals）" class="headerlink" title="6. 信号（Signals）"></a>6. 信号（Signals）</h3><p><strong>优点</strong>：</p>
<ul>
<li>简单：发送和处理信号非常简单，<strong>适合简单的通知和事件处理</strong>。</li>
<li>异步：信号处理可以<strong>异步进行</strong>，响应事件及时。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>功能有限：信号<strong>只能传递简单的信息，无法传递复杂数据</strong>。</li>
<li><strong>易忽略</strong>：进程可能忽略或阻塞信号，需要小心处理。</li>
</ul>
<h3 id="7-内存映射文件（Memory-Mapped-Files）"><a href="#7-内存映射文件（Memory-Mapped-Files）" class="headerlink" title="7. 内存映射文件（Memory-Mapped Files）"></a>7. 内存映射文件（Memory-Mapped Files）</h3><p><strong>优点</strong>：</p>
<ul>
<li><strong>高效</strong>：通过文件映射到内存，实现快速的数据共享。</li>
<li><strong>持久性</strong>：数据存储在文件中，具有持久性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>同步问题：需要<strong>显式同步机制</strong>来保证数据一致性。</li>
<li><strong>平台依赖</strong>：不同操作系统对内存映射文件的支持和实现有所不同。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>管道</strong>适合<strong>简单的父子进程</strong>间通信，匿名管道用于亲缘关系进程，命名管道用于无亲缘关系进程。</li>
<li><strong>消息队列</strong>适合需要<strong>灵活消息传递</strong>的场景，但有<strong>消息大小</strong>限制。</li>
<li><strong>共享内存</strong>适合<strong>大数据量、高效通信</strong>，但需要<strong>显式同步机制</strong>。</li>
<li><strong>信号量</strong>用于进程<strong>同步</strong>，解决资源竞争问题，但<strong>不用于数据传输</strong>。</li>
<li><strong>套接字</strong>通用性强，适合本地和网络通信，但使用复杂。</li>
<li><strong>信号</strong>适合<strong>简单的通知和事件处理</strong>，但无法传递复杂数据。</li>
<li><strong>内存映射文件</strong>高效且具有持久性，但需要同步机制，且<strong>平台依赖性较强</strong>。</li>
</ul>
<p>选择哪种进程间通信方式取决于具体的应用需求、数据量、性能要求和实现复杂性。</p>
<p>进程间通信（Inter-Process Communication, IPC）是指在操作系统中，不同进程之间进行数据交换和同步的一系列机制。常见的进程间通信方式包括：</p>
<h3 id="1-管道（Pipes）具体代码"><a href="#1-管道（Pipes）具体代码" class="headerlink" title="1. 管道（Pipes）具体代码"></a>1. 管道（Pipes）具体代码</h3><p>管道是一种半双工的通信方式，分为匿名管道和命名管道。</p>
<ul>
<li><p><strong>匿名管道</strong>：只能用于具有亲缘关系的进程间通信（如父子进程）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">pipe</span>(pipefd);<br><span class="hljs-comment">// pipefd[0] 用于读，pipefd[1] 用于写</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>命名管道（FIFO）</strong>：可以用于无亲缘关系的进程间通信。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-built_in">mkfifo</span>(<span class="hljs-string">&quot;/tmp/myfifo&quot;</span>, <span class="hljs-number">0666</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-消息队列（Message-Queues）具体代码"><a href="#2-消息队列（Message-Queues）具体代码" class="headerlink" title="2. 消息队列（Message Queues）具体代码"></a>2. 消息队列（Message Queues）具体代码</h3><p>消息队列允许进程以消息的形式进行通信，可以实现多个进程之间的消息传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg_buffer</span> &#123;<br>    <span class="hljs-type">long</span> msg_type;<br>    <span class="hljs-type">char</span> msg_text[<span class="hljs-number">100</span>];<br>&#125;;<br><br><span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;progfile&quot;</span>, <span class="hljs-number">65</span>);<br><span class="hljs-type">int</span> msgid = <span class="hljs-built_in">msgget</span>(key, <span class="hljs-number">0666</span> | IPC_CREAT);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg_buffer</span> message;<br>message.msg_type = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">strcpy</span>(message.msg_text, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-built_in">msgsnd</span>(msgid, &amp;message, <span class="hljs-built_in">sizeof</span>(message), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<h3 id="3-共享内存（Shared-Memory）具体代码"><a href="#3-共享内存（Shared-Memory）具体代码" class="headerlink" title="3. 共享内存（Shared Memory）具体代码"></a>3. 共享内存（Shared Memory）具体代码</h3><p>共享内存是最快的一种进程间通信方式，允许多个进程直接访问同一块内存区域。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><br><span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;shmfile&quot;</span>, <span class="hljs-number">65</span>);<br><span class="hljs-type">int</span> shmid = <span class="hljs-built_in">shmget</span>(key, <span class="hljs-number">1024</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br><span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">shmat</span>(shmid, (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">strcpy</span>(str, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-built_in">shmdt</span>(str);<br></code></pre></td></tr></table></figure>

<h3 id="4-信号量（Semaphores）具体代码"><a href="#4-信号量（Semaphores）具体代码" class="headerlink" title="4. 信号量（Semaphores）具体代码"></a>4. 信号量（Semaphores）具体代码</h3><p>信号量是一种用于进程同步的机制，用于解决进程间的资源竞争问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><br><span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;semfile&quot;</span>, <span class="hljs-number">65</span>);<br><span class="hljs-type">int</span> semid = <span class="hljs-built_in">semget</span>(key, <span class="hljs-number">1</span>, <span class="hljs-number">0666</span> | IPC_CREAT);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> sb = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// P操作</span><br><span class="hljs-built_in">semop</span>(semid, &amp;sb, <span class="hljs-number">1</span>);<br>sb.sem_op = <span class="hljs-number">1</span>; <span class="hljs-comment">// V操作</span><br><span class="hljs-built_in">semop</span>(semid, &amp;sb, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<h3 id="5-套接字（Sockets）具体代码"><a href="#5-套接字（Sockets）具体代码" class="headerlink" title="5. 套接字（Sockets）具体代码"></a>5. 套接字（Sockets）具体代码</h3><p>套接字不仅可以用于网络通信，也可以用于本地进程间通信（Unix域套接字）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/un.h&gt;</span></span><br><br><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_un</span> addr;<br>addr.sun_family = AF_UNIX;<br><span class="hljs-built_in">strcpy</span>(addr.sun_path, <span class="hljs-string">&quot;/tmp/mysocket&quot;</span>);<br><span class="hljs-built_in">bind</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br><span class="hljs-built_in">listen</span>(sockfd, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<h3 id="6-信号（Signals）具体代码"><a href="#6-信号（Signals）具体代码" class="headerlink" title="6. 信号（Signals）具体代码"></a>6. 信号（Signals）具体代码</h3><p>信号是一种用于通知进程某个事件发生的机制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d\n&quot;</span>, sig);<br>&#125;<br><br><span class="hljs-built_in">signal</span>(SIGINT, signal_handler);<br><span class="hljs-built_in">raise</span>(SIGINT);<br></code></pre></td></tr></table></figure>

<h3 id="7-内存映射文件（Memory-Mapped-Files）具体代码"><a href="#7-内存映射文件（Memory-Mapped-Files）具体代码" class="headerlink" title="7. 内存映射文件（Memory-Mapped Files）具体代码"></a>7. 内存映射文件（Memory-Mapped Files）具体代码</h3><p>内存映射文件允许进程通过映射文件到内存地址空间来共享文件的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;example.txt&quot;</span>, O_RDWR);<br><span class="hljs-type">char</span> *data = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">strcpy</span>(data, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><span class="hljs-built_in">munmap</span>(data, <span class="hljs-number">4096</span>);<br><span class="hljs-built_in">close</span>(fd);<br></code></pre></td></tr></table></figure>

<p>每种进程间通信方式都有其优缺点，选择哪种方式取决于具体的应用需求。例如，共享内存虽然速度最快，但需要注意同步和并发控制；而套接字虽然速度较慢，但具有更高的灵活性和适用范围。</p>
<h2 id="什么是页面置换？"><a href="#什么是页面置换？" class="headerlink" title="什么是页面置换？"></a>什么是页面置换？</h2><p>凉经案例：<br>把那些不太常用的页给替换成另一个页（<strong>你空间够的话换个p啊，所以本质还是空间不够</strong></p>
<p><strong>问了gpt：</strong></p>
<p>页面置换（Page Replacement）是指操作系统在虚拟内存管理中，<strong>当内存中的页面不足以容纳所有正在运行的进程所需的页面时，需要将一些页面从内存中换出到磁盘上，以便为新的页面腾出空间</strong>。这个过程就是页面置换。</p>
<p>在虚拟内存管理中，每个进程通常拥有自己的<strong>虚拟地址空间</strong>，而实际的<strong>物理内存空间有限</strong>（面试官特地强调了这一点）。当进程需要访问的页面不在内存中时，操作系统会发生<strong>缺页中断（Page Fault），此时就需要进行页面置换</strong>。操作系统会根据一定的<strong>置换算法</strong>选择要置换出去的页面，以便将新的页面加载到内存中。</p>
<p>常见的页面置换算法包括（加粗的是没答的，不过这个无关紧要，他后来问了LRU：</p>
<ol>
<li><p><strong>最佳（Optimal）置换算法</strong>：选择在未来最长时间内不再访问的页面进行置换。这是一种理想情况下的算法，但由于无法预知未来的页面访问情况，因此很难实现。</p>
</li>
<li><p>先进先出（FIFO）置换算法：选择最早进入内存的页面进行置换。这是一种简单而直观的置换算法，但可能会导致“Belady异常”，即增加页面数目时，缺页次数反而增多。</p>
</li>
<li><p>最近最少使用（LRU）置换算法：选择最近最少被使用的页面进行置换。这是一种较为实用的置换算法，但需要维护页面访问的顺序，实现相对复杂。</p>
</li>
<li><p>时钟（Clock）置换算法：结合 FIFO 算法和 LRU 算法，使用一个时钟指针来模拟页面的访问情况。当时钟指针指向一个页面时，如果该页面未被访问，则选择该页面进行置换；否则，将该页面的访问位清零，继续检查下一个页面。</p>
</li>
<li><p><strong>最不经常使用（LFU）置换算法</strong>：选择最近使用频率最低的页面进行置换。这是一种根据页面使用频率来进行置换的算法，适用于某些特定场景。</p>
</li>
</ol>
<p>页面置换算法的选择取决于系统的需求和性能要求，不同的置换算法有不同的优缺点，需要根据具体情况进行权衡和选择。</p>
<h2 id="FIFO的缺点"><a href="#FIFO的缺点" class="headerlink" title="FIFO的缺点"></a>FIFO的缺点</h2><p>凉经案例：<br>用很通俗的语言只讲了一点（页面串扰</p>
<p><strong>问了gpt：</strong></p>
<ol>
<li><p><strong>Belady异常</strong>：FIFO 算法可能会出现 Belady 异常，即增加页面数目时，缺页次数反而增多。这是因为 FIFO 算法只考虑了页面进入内存的顺序，而没有考虑页面的使用频率。当内存中的页面数目增多时，先进入内存的页面可能会被频繁置换出去，导致缺页次数增加。</p>
</li>
<li><p><strong>局部性原理不符</strong>：FIFO 算法不符合局部性原理，即程序访问内存时存在时间和空间局部性的倾向。由于 FIFO 算法只考虑了页面进入内存的顺序，而没有考虑页面的使用情况，因此可能会导致页面置换不够有效，无法利用程序的局部性原理。</p>
</li>
<li><p><strong>未利用页面的使用情况</strong>：FIFO 算法没有考虑页面的使用情况，即便某些页面可能长时间未被访问，也会被保留在内存中。这样会导致内存资源没有得到充分利用，降低了内存的利用率。</p>
</li>
<li><p><strong>容易受到页面串扰影响</strong>：FIFO 算法容易受到页面串扰的影响，即当一些页面由于访问频繁而常驻内存时，可能会导致其他页面被频繁置换出去，影响系统的整体性能。</p>
</li>
</ol>
<p>综上所述，FIFO 算法虽然简单直观，但在实际应用中可能会存在一些缺点，特别是在面对局部性原理、程序访问模式的变化时，可能会导致性能下降或者系统资源的浪费。因此，在选择页面置换算法时，需要根据具体情况权衡各种因素，选择适合系统需求的算法。</p>
<h2 id="如何实现一个基于lru算法的页面置换算法？"><a href="#如何实现一个基于lru算法的页面置换算法？" class="headerlink" title="如何实现一个基于lru算法的页面置换算法？"></a>如何实现一个基于lru算法的页面置换算法？</h2><p>实现一个基于LRU（Least Recently Used）算法的页面置换算法可以通过维护一个缓存结构来跟踪最近使用的页面。当缓存满了，需要替换一个页面时，选择最久未使用的页面进行替换。常见的实现思路包括使用双向链表和哈希表的组合，以达到高效的插入、删除和访问操作。</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol>
<li><p><strong>数据结构选择</strong>：</p>
<ul>
<li><strong>双向链表</strong>：用于维护页面的访问顺序，最近使用的页面在链表头部，最久未使用的页面在链表尾部。</li>
<li><strong>哈希表</strong>：用于实现页面在双向链表中的快速定位，从而在O(1)时间内进行查找、插入和删除操作。</li>
</ul>
</li>
<li><p><strong>基本操作</strong>：</p>
<ul>
<li><strong>访问页面</strong>：<ul>
<li>如果页面在缓存中（命中），则将该页面移到链表头部。</li>
<li>如果页面不在缓存中（未命中），则将页面添加到链表头部。如果缓存已满，需要移除链表尾部的页面。</li>
</ul>
</li>
<li><strong>插入页面</strong>：<ul>
<li>将新页面插入到链表头部，同时在哈希表中添加对应的键值对。</li>
</ul>
</li>
<li><strong>删除页面</strong>：<ul>
<li>从链表尾部删除页面，并在哈希表中移除对应的键值对。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="HTTP常用方法"><a href="#HTTP常用方法" class="headerlink" title="HTTP常用方法"></a>HTTP常用方法</h2><p>HTTP（超文本传输协议）定义了一组请求方法来指示特定的操作以执行资源。这些方法在HTTP&#x2F;1.1规范中有详细的定义。以下是常用的HTTP方法：</p>
<ol>
<li><p><strong>GET</strong>：</p>
<ul>
<li><strong>用途</strong>：从服务器获取资源。</li>
<li><strong>幂等性</strong>：幂等（多次请求的结果相同）。</li>
<li><strong>副作用</strong>：无副作用（安全）。</li>
<li><strong>示例</strong>：获取网页内容或API数据。</li>
<li><strong>请求示例</strong>：<code>GET /index.html HTTP/1.1</code></li>
</ul>
</li>
<li><p><strong>POST</strong>：</p>
<ul>
<li><strong>用途</strong>：向服务器提交数据，通常用于表单提交或文件上传。</li>
<li><strong>幂等性</strong>：非幂等（多次请求可能产生不同结果）。</li>
<li><strong>副作用</strong>：有副作用（不安全）。</li>
<li><strong>示例</strong>：提交表单数据或创建新资源。</li>
<li><strong>请求示例</strong>：<code>POST /submit-form HTTP/1.1</code></li>
</ul>
</li>
<li><p><strong>PUT</strong>：</p>
<ul>
<li><strong>用途</strong>：向服务器上传资源或更新资源。</li>
<li><strong>幂等性</strong>：幂等。</li>
<li><strong>副作用</strong>：有副作用。</li>
<li><strong>示例</strong>：上传文件或更新数据库中的记录。</li>
<li><strong>请求示例</strong>：<code>PUT /user/123 HTTP/1.1</code></li>
</ul>
</li>
<li><p><strong>DELETE</strong>：</p>
<ul>
<li><strong>用途</strong>：从服务器删除资源。</li>
<li><strong>幂等性</strong>：幂等。</li>
<li><strong>副作用</strong>：有副作用。</li>
<li><strong>示例</strong>：删除数据库中的记录或文件。</li>
<li><strong>请求示例</strong>：<code>DELETE /user/123 HTTP/1.1</code></li>
</ul>
</li>
<li><p><strong>HEAD</strong>：</p>
<ul>
<li><strong>用途</strong>：与GET相同，但只返回响应的头部，不返回主体内容。</li>
<li><strong>幂等性</strong>：幂等。</li>
<li><strong>副作用</strong>：无副作用。</li>
<li><strong>示例</strong>：检查资源是否存在或获取资源的元数据。</li>
<li><strong>请求示例</strong>：<code>HEAD /index.html HTTP/1.1</code></li>
</ul>
</li>
<li><p><strong>OPTIONS</strong>：</p>
<ul>
<li><strong>用途</strong>：获取服务器支持的通信选项和请求方法。</li>
<li><strong>幂等性</strong>：幂等。</li>
<li><strong>副作用</strong>：无副作用。</li>
<li><strong>示例</strong>：查看服务器允许的HTTP方法。</li>
<li><strong>请求示例</strong>：<code>OPTIONS /index.html HTTP/1.1</code></li>
</ul>
</li>
<li><p><strong>PATCH</strong>：</p>
<ul>
<li><strong>用途</strong>：对资源进行部分修改。</li>
<li><strong>幂等性</strong>：非幂等。</li>
<li><strong>副作用</strong>：有副作用。</li>
<li><strong>示例</strong>：更新资源的部分属性。</li>
<li><strong>请求示例</strong>：<code>PATCH /user/123 HTTP/1.1</code></li>
</ul>
</li>
<li><p><strong>TRACE</strong>：</p>
<ul>
<li><strong>用途</strong>：回显服务器收到的请求，用于诊断。</li>
<li><strong>幂等性</strong>：幂等。</li>
<li><strong>副作用</strong>：无副作用。</li>
<li><strong>示例</strong>：用于调试请求路径。</li>
<li><strong>请求示例</strong>：<code>TRACE /index.html HTTP/1.1</code></li>
</ul>
</li>
</ol>
<h3 id="不常用的方法"><a href="#不常用的方法" class="headerlink" title="不常用的方法"></a>不常用的方法</h3><ol>
<li><strong>CONNECT</strong>：<ul>
<li><strong>用途</strong>：用于将请求连接转换为透明的TCP&#x2F;IP隧道，通常用于HTTPS。</li>
<li><strong>幂等性</strong>：非幂等。</li>
<li><strong>副作用</strong>：有副作用。</li>
<li><strong>示例</strong>：代理服务器设置隧道以进行SSL（HTTPS）连接。</li>
<li><strong>请求示例</strong>：<code>CONNECT www.example.com:443 HTTP/1.1</code></li>
</ul>
</li>
</ol>
<h3 id="幂等性和安全性"><a href="#幂等性和安全性" class="headerlink" title="幂等性和安全性"></a>幂等性和安全性</h3><ul>
<li><strong>幂等性</strong>：指多次执行相同的操作，结果应保持不变（GET、PUT、DELETE、HEAD、OPTIONS）。</li>
<li><strong>安全性</strong>：指操作不会更改服务器状态（GET、HEAD、OPTIONS、TRACE）。</li>
</ul>
<p>了解这些HTTP方法及其特性有助于更好地设计和实现基于HTTP的客户端和服务器应用程序。</p>
<h2 id="MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？"><a href="#MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？" class="headerlink" title="MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？"></a>MySQL是如何支持或者说你觉得MySQL能是一种能够支持高并发的这样的一个查询引擎吗？</h2><h3 id="1-存储引擎选择"><a href="#1-存储引擎选择" class="headerlink" title="1. 存储引擎选择"></a>1. 存储引擎选择</h3><p>MySQL提供了多种存储引擎，其中InnoDB是最常用的高并发支持引擎。InnoDB支持行级锁定和外键约束，具有较好的并发处理能力和崩溃恢复功能。</p>
<ul>
<li><strong>InnoDB:</strong> 适用于大多数高并发场景，支持事务、行级锁、外键等特性。</li>
<li><strong>MyISAM:</strong> 虽然查询性能较高，但不支持事务和行级锁，通常不推荐用于高并发写操作的场景。（读法：My Eye sam）</li>
</ul>
<h3 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2. 索引优化"></a>2. 索引优化</h3><p>合理使用索引可以显著提高查询速度。常见的索引类型有：</p>
<ul>
<li><strong>B树索引:</strong> 适用于大多数查询。</li>
<li><strong>全文索引:</strong> 适用于文本搜索。</li>
<li><strong>哈希索引:</strong> 适用于精确匹配查询。</li>
</ul>
<h3 id="3-查询优化"><a href="#3-查询优化" class="headerlink" title="3. 查询优化"></a>3. 查询优化</h3><p>优化SQL查询是提高并发性能的关键。包括：</p>
<ul>
<li>避免使用SELECT *，尽量只查询必要的字段。</li>
<li>使用EXPLAIN分析查询计划，优化慢查询。</li>
<li>使用合适的WHERE条件，减少扫描行数。</li>
</ul>
<h3 id="4-数据库设计"><a href="#4-数据库设计" class="headerlink" title="4. 数据库设计"></a>4. 数据库设计</h3><p>良好的数据库设计对高并发支持至关重要。</p>
<ul>
<li><strong>规范化:</strong> 减少数据冗余，避免更新异常。</li>
<li><strong>反规范化:</strong> 在读操作频繁的场景下适当反规范化，减少联表查询。</li>
</ul>
<h3 id="5-连接池和缓存"><a href="#5-连接池和缓存" class="headerlink" title="5. 连接池和缓存"></a>5. 连接池和缓存</h3><ul>
<li><strong>连接池:</strong> 复用数据库连接，减少连接建立的开销。</li>
<li><strong>缓存:</strong> 使用Redis或Memcached缓存热点数据，减轻数据库压力。</li>
</ul>
<h3 id="6-配置优化"><a href="#6-配置优化" class="headerlink" title="6. 配置优化"></a>6. 配置优化</h3><p>MySQL配置参数的优化可以显著提高性能。</p>
<ul>
<li><strong>innodb_buffer_pool_size:</strong> 设置为物理内存的60-80%，以增加缓存命中率。</li>
<li><strong>query_cache_size:</strong> 控制查询缓存大小（需要权衡开销和收益）。</li>
<li><strong>max_connections:</strong> 设置合适的最大连接数，避免过多连接导致资源耗尽。</li>
</ul>
<h3 id="7-水平扩展"><a href="#7-水平扩展" class="headerlink" title="7. 水平扩展"></a>7. 水平扩展</h3><p>当单一MySQL实例无法满足高并发需求时，可以考虑通过水平扩展来分担负载。</p>
<ul>
<li><strong>主从复制:</strong> 配置多个从库，分担读取压力。</li>
<li><strong>分片:</strong> 将数据拆分到多个数据库实例上。</li>
</ul>
<h2 id="什么是脏读？什么是幻读？"><a href="#什么是脏读？什么是幻读？" class="headerlink" title="什么是脏读？什么是幻读？"></a>什么是脏读？什么是幻读？</h2><p>在数据库系统中，脏读和幻读是两种不同的并发事务问题，通常会在不同的隔离级别下发生。</p>
<h3 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h3><p>脏读是指一个事务能够读到另一个事务尚未提交的修改。这种情况可能会导致数据不一致，因为读到的数据可能会在后续被回滚。脏读发生在最低的隔离级别，即<strong>读未提交（Read Uncommitted）</strong>。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li>事务A开始，并更新了一条记录的值，但尚未提交。</li>
<li>事务B读取了这条记录，得到事务A更新后的值。</li>
<li>如果事务A回滚，那么事务B读取的数据就是无效的。</li>
</ol>
<h3 id="幻读（Phantom-Read）"><a href="#幻读（Phantom-Read）" class="headerlink" title="幻读（Phantom Read）"></a>幻读（Phantom Read）</h3><p>幻读是指在一个事务中，两次读取同一个条件的数据集时，由于另一个事务插入了新的数据，导致两次读取的数据集不一致。这通常发生在隔离级别较低的情况下，例如<strong>可重复读（Repeatable Read）</strong>和<strong>读已提交（Read Committed）</strong>。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol>
<li>事务A开始，并读取满足某个条件的一组数据。</li>
<li>事务B插入了一条满足相同条件的新记录，<strong>并提交</strong>。</li>
<li>事务A再次读取相同条件的数据集时，会发现多了一条记录。</li>
</ol>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>为了避免这些并发问题，SQL标准定义了四种隔离级别，每种隔离级别能避免不同类型的并发问题：</p>
<ol>
<li><strong>读未提交（Read Uncommitted）</strong>：<ul>
<li>可能出现脏读、不可重复读和幻读。</li>
</ul>
</li>
<li><strong>读已提交（Read Committed）</strong>：<ul>
<li>避免脏读，但可能出现不可重复读和幻读。</li>
</ul>
</li>
<li><strong>可重复读（Repeatable Read）</strong>：<ul>
<li>避免脏读和不可重复读，但可能出现幻读。</li>
</ul>
</li>
<li><strong>可串行化（Serializable）</strong>：<ul>
<li>避免脏读、不可重复读和幻读，是最严格的隔离级别。</li>
</ul>
</li>
</ol>
<p>通过选择适当的隔离级别，可以在性能和数据一致性之间取得平衡。通常情况下，<strong>读已提交</strong>和<strong>可重复读</strong>是实际应用中最常用的隔离级别。</p>
<h2 id="数据库范式？"><a href="#数据库范式？" class="headerlink" title="数据库范式？"></a>数据库范式？</h2><p>数据库范式（Normalization）是用于数据库设计的一组规则和标准，旨在减少数据冗余和提高数据完整性。以下是常见的几种范式：</p>
<h3 id="1-第一范式（1NF）"><a href="#1-第一范式（1NF）" class="headerlink" title="1. 第一范式（1NF）"></a>1. 第一范式（1NF）</h3><p>第一范式的目标是确保每个列的值都是原子的，即不可再分。要达到1NF，数据库表中的每个字段都应该包含单一的值，不允许有重复的组或多值字段。</p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul>
<li>每个列都应包含原子值。</li>
<li>每个列都只包含一种类型的数据。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>如果有一个表如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">学生    课程<br>张三    数学, 英语<br>李四    物理<br></code></pre></td></tr></table></figure>
<p>为满足1NF，应改成：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">学生    课程<br>张三    数学<br>张三    英语<br>李四    物理<br></code></pre></td></tr></table></figure>

<h3 id="2-第二范式（2NF）"><a href="#2-第二范式（2NF）" class="headerlink" title="2. 第二范式（2NF）"></a>2. 第二范式（2NF）</h3><p>第二范式在满足1NF的基础上，还要求消除部分依赖，即表中的非主键字段必须完全依赖于主键，而不是主键的一部分。通常在有复合主键的表中会考虑2NF。</p>
<h4 id="规则-1"><a href="#规则-1" class="headerlink" title="规则"></a>规则</h4><ul>
<li>表必须满足1NF。</li>
<li>所有非主键字段都必须<strong>完全依赖</strong>于主键，而<strong>不能依赖于主键的一部分</strong>。</li>
</ul>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>考虑一个有复合主键的表：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">学生ID    课程ID    成绩    课程名称<br>1        <span class="hljs-number"> 101 </span>     <span class="hljs-number"> 90 </span>     数学<br>1        <span class="hljs-number"> 102 </span>     <span class="hljs-number"> 85 </span>     英语<br>2        <span class="hljs-number"> 101 </span>     <span class="hljs-number"> 88 </span>     数学<br></code></pre></td></tr></table></figure>
<p>在这个表中，课程名称只依赖于课程ID而不是整个主键，因此应分解成两个表：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">学生ID    课程ID    成绩<br>1        <span class="hljs-number"> 101 </span>      90<br>1        <span class="hljs-number"> 102 </span>      85<br>2        <span class="hljs-number"> 101 </span>      88<br><br>课程ID    课程名称<br>101       数学<br>102       英语<br></code></pre></td></tr></table></figure>

<h3 id="3-第三范式（3NF）"><a href="#3-第三范式（3NF）" class="headerlink" title="3. 第三范式（3NF）"></a>3. 第三范式（3NF）</h3><p>第三范式在满足2NF的基础上，要求消除传递依赖，即非主键字段之间不能有依赖关系。</p>
<h4 id="规则-2"><a href="#规则-2" class="headerlink" title="规则"></a>规则</h4><ul>
<li>表必须满足2NF。</li>
<li>所有<strong>非主键字段都必须直接依赖于主键，而不能通过其他非主键字段间接依赖</strong>。</li>
</ul>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>考虑以下表：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">学生ID    学生姓名    学院ID    学院名称<br>1         张三       <span class="hljs-number"> 10 </span>       计算机学院<br>2         李四       <span class="hljs-number"> 20 </span>       数学学院<br></code></pre></td></tr></table></figure>
<p>在这个表中，学院名称依赖于学院ID，而学院ID依赖于学生ID，因此应分解成两个表：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">学生ID    学生姓名    学院ID<br>1         张三        10<br>2         李四        20<br><br>学院ID    学院名称<br>10        计算机学院<br>20        数学学院<br></code></pre></td></tr></table></figure>

<h3 id="4-BC范式（BCNF）"><a href="#4-BC范式（BCNF）" class="headerlink" title="4. BC范式（BCNF）"></a>4. BC范式（BCNF）</h3><p>Boyce-Codd范式是3NF的一个更严格版本，它要求每个非平凡函数依赖的左侧都必须是<strong>超键</strong>（即唯一标识表中记录的属性集）。</p>
<h4 id="规则-3"><a href="#规则-3" class="headerlink" title="规则"></a>规则</h4><ul>
<li>表必须满足3NF。</li>
<li>对于每一个非平凡函数依赖X → Y，X必须是超键。</li>
</ul>
<h3 id="5-第四范式（4NF）"><a href="#5-第四范式（4NF）" class="headerlink" title="5. 第四范式（4NF）"></a>5. 第四范式（4NF）</h3><p>第四范式要求<strong>消除多值依赖</strong>，即一个表中不能存在多对多关系的属性组。</p>
<h4 id="规则-4"><a href="#规则-4" class="headerlink" title="规则"></a>规则</h4><ul>
<li>表必须满足BCNF。</li>
<li>没有非平凡的多值依赖。</li>
</ul>
<h3 id="6-第五范式（5NF）"><a href="#6-第五范式（5NF）" class="headerlink" title="6. 第五范式（5NF）"></a>6. 第五范式（5NF）</h3><p>第五范式要求消除连接依赖，即表应该能够自然分解，而不导致信息丢失。</p>
<h4 id="规则-5"><a href="#规则-5" class="headerlink" title="规则"></a>规则</h4><ul>
<li>表必须满足4NF。</li>
<li>每个非平凡的连接依赖必须由候选键隐含。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过这些范式，数据库设计者可以在减少数据冗余、消除异常和提高数据完整性之间找到平衡。在实际应用中，通常会<strong>根据需求选择适当的范式</strong>，而不一定严格地应用所有的范式。</p>
<h2 id="真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？"><a href="#真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？" class="headerlink" title="真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？"></a>真正在做这些项目的时候，有没有违反范式的这种场景，或者说你觉得真正的范式去指导你的这种ERP设计也好，或者数据库设计的也好，你觉得是完全需要遵守的一些设计吗？</h2><p>在实际项目中，特别是ERP系统或其他大型数据库应用中，严格遵循数据库范式的设计原则是非常重要的，能够帮助减少数据冗余、避免数据异常并保持数据一致性。然而，实际情况往往比理论复杂，在某些情况下，违反范式的设计可能是更好的选择。以下是一些违反范式的常见场景和理由：</p>
<h3 id="1-性能优化"><a href="#1-性能优化" class="headerlink" title="1. 性能优化"></a>1. 性能优化</h3><p>在高并发、大量数据读写的场景中，性能往往是优先考虑的因素。以下是一些常见的违反范式的情况：</p>
<h4 id="读优化"><a href="#读优化" class="headerlink" title="读优化"></a>读优化</h4><ul>
<li><strong>反规范化（Denormalization）</strong>：为了减少联表查询的次数，可以将相关数据冗余存储在一个表中。例如，在一个订单系统中，客户信息可以直接存储在订单表中，而不是每次查询订单都去联接客户表。</li>
</ul>
<h4 id="写优化"><a href="#写优化" class="headerlink" title="写优化"></a>写优化</h4><ul>
<li><strong>预计算和缓存（Precomputed Values and Caching）</strong>：为了加速查询，可以存储预先计算好的结果，如总金额、统计数据等，尽管这些数据可以通过计算得到，但这样可以减少实时计算的负担。</li>
</ul>
<h3 id="2-简化查询"><a href="#2-简化查询" class="headerlink" title="2. 简化查询"></a>2. 简化查询</h3><p>在某些业务场景中，简单、快速的查询比严格的范式化设计更重要。例如：</p>
<ul>
<li><strong>报表和分析系统</strong>：为了便于生成报表和进行数据分析，可能需要违反范式，将数据冗余地存储在一个表中，简化复杂的查询逻辑。</li>
</ul>
<h3 id="3-数据一致性和完整性"><a href="#3-数据一致性和完整性" class="headerlink" title="3. 数据一致性和完整性"></a>3. 数据一致性和完整性</h3><p>在有些情况下，为了保持数据的一致性和完整性，违反范式是必要的。例如：</p>
<ul>
<li><strong>历史数据存储</strong>：在审计和追踪历史数据的场景中，可能需要在一个表中存储数据快照，这样尽管增加了冗余，但可以确保数据的不可变性和一致性。</li>
</ul>
<h3 id="4-实际开发和维护"><a href="#4-实际开发和维护" class="headerlink" title="4. 实际开发和维护"></a>4. 实际开发和维护</h3><p>在实际开发过程中，开发和维护的复杂性也是一个重要的考虑因素：</p>
<ul>
<li><strong>开发便利性</strong>：有时候，简单、直观的表结构可以减少开发和维护的复杂性，即使这意味着违反某些范式。例如，团队可能决定在一个表中存储更多信息，以避免频繁的联表操作。</li>
</ul>
<h3 id="具体场景示例"><a href="#具体场景示例" class="headerlink" title="具体场景示例"></a>具体场景示例</h3><h4 id="示例1：订单系统"><a href="#示例1：订单系统" class="headerlink" title="示例1：订单系统"></a>示例1：订单系统</h4><p>在一个订单系统中，订单表通常会涉及多个关联表，如客户表、产品表、地址表等。严格的范式化设计可能如下：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">订单表(Order)<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>客户ID<br><span class="hljs-bullet">- </span>总金额<br><span class="hljs-bullet">- </span>创建日期<br><br>客户表(Customer)<br><span class="hljs-bullet">- </span>客户ID<br><span class="hljs-bullet">- </span>客户姓名<br><span class="hljs-bullet">- </span>联系方式<br><br>订单项表(OrderItem)<br><span class="hljs-bullet">- </span>订单项ID<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>产品ID<br><span class="hljs-bullet">- </span>数量<br><span class="hljs-bullet">- </span>单价<br></code></pre></td></tr></table></figure>
<p>然而，为了提高查询性能，尤其是查询订单时避免多次联表，可以采取反规范化设计：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">订单表(Order)<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>客户ID<br><span class="hljs-bullet">- </span>客户姓名<br><span class="hljs-bullet">- </span>联系方式<br><span class="hljs-bullet">- </span>总金额<br><span class="hljs-bullet">- </span>创建日期<br><br>订单项表(OrderItem)<br><span class="hljs-bullet">- </span>订单项ID<br><span class="hljs-bullet">- </span>订单ID<br><span class="hljs-bullet">- </span>产品ID<br><span class="hljs-bullet">- </span>产品名称<br><span class="hljs-bullet">- </span>数量<br><span class="hljs-bullet">- </span>单价<br></code></pre></td></tr></table></figure>
<p>这种设计牺牲了一些规范性，但在性能和查询简便性方面有很大提升。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>虽然范式化设计是数据库设计的指导原则，但在实际项目中，特别是在性能、查询简便性、开发和维护复杂性方面，违反范式是常见的。设计数据库时，应在范式化和实际需求之间找到平衡，具体问题具体分析，根据实际情况采取适当的设计策略。</p>
<h2 id="什么叫回表？"><a href="#什么叫回表？" class="headerlink" title="什么叫回表？"></a>什么叫回表？</h2><p>在数据库系统中，<strong>回表（Index Lookup Back to Table）</strong> 是指数据库在使用索引查询数据时，由于<strong>索引不包含所需的所有列，必须回到数据表中去获取完整的记录</strong>。这种情况常见于关系型数据库如MySQL。</p>
<h3 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h3><p>当执行查询时，如果使用的索引中不包含查询所需的所有字段，数据库首先通过索引定位到符合条件的记录，然后<strong>再通过索引中的指针访问实际的数据表以获取缺失的字段</strong>。这种从索引跳回数据表获取完整数据的操作称为回表。</p>
<h3 id="回表的示例"><a href="#回表的示例" class="headerlink" title="回表的示例"></a>回表的示例</h3><p>假设有一张用户表 <code>users</code>，包含如下字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">users</span> (<span class="hljs-built_in">id</span>, name, email, age)<br></code></pre></td></tr></table></figure>
<p>并且在 <code>email</code> 字段上建立了索引：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> idx_email <span class="hljs-keyword">ON</span> users(email);<br></code></pre></td></tr></table></figure>

<p>现在执行一个查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, email <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;example@example.com&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="索引覆盖和回表"><a href="#索引覆盖和回表" class="headerlink" title="索引覆盖和回表"></a>索引覆盖和回表</h3><p>在这个查询中，数据库可以通过 <code>idx_email</code> 索引快速定位到符合条件的记录，但是：</p>
<ul>
<li>如果索引中只包含 <code>email</code> 字段，那么数据库需要通过回表操作，从实际的数据表中获取 <code>name</code> 字段的值。</li>
<li>如果索引包含 <code>email</code> 和 <code>name</code> 字段（称为<strong>覆盖索引</strong>），则不需要回表，因为索引已经包含了查询所需的所有字段。</li>
</ul>
<h3 id="避免回表的方法"><a href="#避免回表的方法" class="headerlink" title="避免回表的方法"></a>避免回表的方法</h3><ol>
<li><p><strong>使用覆盖索引（Covering Index）</strong>：</p>
<ul>
<li><strong>创建包含查询中所有字段的索引</strong>。例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_email_name <span class="hljs-keyword">ON</span> users(email, name);<br></code></pre></td></tr></table></figure>
这样，在上面的查询中，数据库不需要回表即可获取所有数据。</li>
</ul>
</li>
<li><p><strong>减少查询字段</strong>：</p>
<ul>
<li>只查询索引中已有的字段，避免回表。</li>
</ul>
</li>
</ol>
<h3 id="回表的影响"><a href="#回表的影响" class="headerlink" title="回表的影响"></a>回表的影响</h3><ul>
<li><strong>性能开销</strong>：回表操作会<strong>增加I&#x2F;O开销</strong>，因为需要额外访问数据表，尤其是在查询结果集较大时。</li>
<li><strong>查询效率</strong>：对频繁执行的查询，回表可能显著<strong>影响性能</strong>，因此需要根据查询模式和频率优化索引设计。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>回表是数据库优化中的一个重要概念，通过合理设计索引（如使用覆盖索引），可以减少回表操作，从而提高查询性能。在数据库设计和查询优化中，应仔细分析查询需求和数据访问模式，权衡索引的维护开销与查询性能之间的关系。</p>
<h2 id="索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？"><a href="#索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？" class="headerlink" title="索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？"></a>索引的主要类型？nnoDB引擎下的索引的数据结构是怎么实现的？为什么用索引之后，它的查询效率会比我们不用索引的查询效率要高？</h2><p>索引是数据库管理系统中的一种数据结构，可以提高数据检索速度。索引的核心作用是减少数据库在查找数据时需要扫描的数据量，从而提高查询效率。在没有索引的情况下，数据库系统执行查询操作时可能需要执行全表扫描，即逐行检查表中的每一行数据，直到找到符合查询条件的数据。这种方法在数据量小的时候还可以接受，但随着数据量的增加，查询效率会显著下降。</p>
<h3 id="索引的主要类型："><a href="#索引的主要类型：" class="headerlink" title="索引的主要类型："></a>索引的主要类型：</h3><ol>
<li><p><strong>B树索引</strong>：最常见的索引类型，尤其适用于等值查询和范围查询。B树索引通过维护一个多层级的树形结构来存储数据，每个节点都是有序的，这样可以非常快速地通过分裂和合并来维持树的平衡。</p>
</li>
<li><p><strong>哈希索引</strong>：适用于快速查找操作，特别是等值查询。它通过哈希表实现，其中键通过哈希函数直接映射到表中一个位置。</p>
</li>
<li><p><strong>全文索引</strong>：专门为处理文本数据设计，可以快速从大量文本中找到关键词。例如，搜索引擎常用的倒排索引就是一种全文索引。</p>
</li>
<li><p><strong>空间索引</strong>：如R树，用于空间数据查询，如地图位置的检索。</p>
</li>
</ol>
<h3 id="索引提高查询效率的原理："><a href="#索引提高查询效率的原理：" class="headerlink" title="索引提高查询效率的原理："></a>索引提高查询效率的原理：</h3><ol>
<li><p><strong>减少查找范围</strong>：例如，B树索引通过树形结构，使得每次查询都能在树的每个级别上排除大量不符合条件的数据，迅速缩小查找范围。</p>
</li>
<li><p><strong>避免全表扫描</strong>：索引可以直接指向表中的具体行，无需逐行扫描整个表来查找数据。</p>
</li>
<li><p><strong>排序和快速访问</strong>：索引通常以某种顺序存储数据，使得范围查询更为高效。同时，索引结构通常设计为易于在内存中快速访问的形式。</p>
</li>
</ol>
<h3 id="使用索引的代价："><a href="#使用索引的代价：" class="headerlink" title="使用索引的代价："></a>使用索引的代价：</h3><p>尽管索引可以显著提高查询速度，但也有其代价和限制：</p>
<ul>
<li><strong>空间消耗</strong>：索引本身需要占用存储空间。</li>
<li><strong>维护成本</strong>：每次数据更新（插入、删除、修改）时，相关的索引也需要更新，这会增加操作的开销。</li>
<li><strong>设计和管理复杂性</strong>：合理设计和维护索引需要精确考虑数据使用模式，不当的索引可能导致性能下降而非提升。</li>
</ul>
<p>总之，索引是优化数据库查询性能的重要工具，但需要根据实际的数据量和查询需求来合理设计和使用。</p>
<h2 id="为什么实际用B-树用的更多？"><a href="#为什么实际用B-树用的更多？" class="headerlink" title="为什么实际用B+树用的更多？"></a>为什么实际用B+树用的更多？</h2><p>在数据库索引的实现中，实际上 B+树 更常被用作索引结构而不是 B树。虽然两者都是平衡树结构，用于提高数据的检索效率，但 B+树 相对于 B树 有几个特点使其更适合用于数据库索引：</p>
<h3 id="1-所有键值对都在叶节点："><a href="#1-所有键值对都在叶节点：" class="headerlink" title="1. 所有键值对都在叶节点："></a>1. <strong>所有键值对都在叶节点</strong>：</h3><p>B+树的所有键值对都存储在叶节点，而非叶节点仅存储键值的副本以用于导航。这种结构使得叶节点形成了一个有序链表，适合进行范围查询。范围查询是数据库常见的操作，比如查询所有在某个日期范围内的记录。在 B树 中，数据分散在整个树中，不容易直接支持高效的范围查询。</p>
<h3 id="2-非叶节点仅用于索引："><a href="#2-非叶节点仅用于索引：" class="headerlink" title="2. 非叶节点仅用于索引："></a>2. <strong>非叶节点仅用于索引</strong>：</h3><p>在 B+树 中，非叶节点的作用仅是索引，不存储实际数据。这意味着非叶节点更小，树可以更高效地加载更多的索引键到内存中，从而降低树的高度，提高查询速度。</p>
<h3 id="3-叶节点的链表结构："><a href="#3-叶节点的链表结构：" class="headerlink" title="3. 叶节点的链表结构："></a>3. <strong>叶节点的链表结构</strong>：</h3><p>B+树的叶节点之间是相连的，这样可以快速进行顺序访问。对于数据库系统中常见的顺序扫描操作，这种结构显著提高了效率。</p>
<h3 id="4-更少的指针跳转："><a href="#4-更少的指针跳转：" class="headerlink" title="4. 更少的指针跳转："></a>4. <strong>更少的指针跳转</strong>：</h3><p>由于非叶节点不含实际数据，对数据的访问总是会到达叶节点，这种一致的访问模式意味着缓存更为有效，减少了指针跳转和磁盘I&#x2F;O操作。</p>
<h3 id="5-磁盘I-x2F-O优化："><a href="#5-磁盘I-x2F-O优化：" class="headerlink" title="5. 磁盘I&#x2F;O优化："></a>5. <strong>磁盘I&#x2F;O优化</strong>：</h3><p>数据库系统通常与磁盘操作密切相关，而 B+树 结构可以减少磁盘读写次数。B+树的设计使得它可以很好地适应磁盘的页结构，每个节点大小通常与磁盘页大小相匹配，这减少了节点分裂时的磁盘I&#x2F;O需求。</p>
<p>因此，虽然“B树索引”这个术语在通话中可能被泛泛地使用，实际上在现代数据库系统中，B+树索引因其对于磁盘存储和数据检索操作优化更胜一筹，从而被广泛采用。</p>
<h2 id="什么是哈希冲突？如何解决？"><a href="#什么是哈希冲突？如何解决？" class="headerlink" title="什么是哈希冲突？如何解决？"></a>什么是哈希冲突？如何解决？</h2><p>哈希冲突是在使用哈希表或哈希映射时发生的一种情况，其中两个或更多的输入值（键）被哈希函数映射到同一个哈希值（即同一个桶或位置）上。哈希表是一种数据结构，它提供了非常快速的数据查找速度。哈希函数的作用是将输入值（通常是一个字符串或其他数据）转换成一个整数，这个整数然后用来计算在哈希表中的存储位置。</p>
<h3 id="哈希冲突的产生原因"><a href="#哈希冲突的产生原因" class="headerlink" title="哈希冲突的产生原因"></a>哈希冲突的产生原因</h3><p>哈希冲突的产生通常是由于以下几个原因：</p>
<ol>
<li><strong>哈希函数设计</strong>：如果哈希函数<strong>没有很好地分散</strong>各种不同的输入值到不同的哈希码，就更容易发生冲突。</li>
<li><strong>哈希表的大小</strong>：哈希表的<strong>大小是有限</strong>的，而且可能小于可能的输入值的数量，所以即使是理想的哈希函数也无法避免冲突。</li>
<li><strong>输入数据的分布</strong>：如果输入<strong>数据本身</strong>具有一定的模式或规律，可能导致哈希函数产生<strong>非均匀的哈希值分布</strong>。</li>
</ol>
<h3 id="解决哈希冲突的常见方法"><a href="#解决哈希冲突的常见方法" class="headerlink" title="解决哈希冲突的常见方法"></a>解决哈希冲突的常见方法</h3><p>解决哈希冲突主要有几种常用的策略：</p>
<ol>
<li><strong>开放寻址法</strong>：当发生冲突时，尝试在哈希表中找到另一个空闲的桶来存储当前的元素。这种方法可能会采用线性探测、二次探测或双重散列等策略。</li>
<li><strong>链表法</strong>（拉链法）：每个哈希表的桶或位置实际上存储的是一个链表的头节点。所有映射到该位置的元素都会被加入到这个链表中。因此，查找、插入和删除操作需要遍历链表。</li>
<li><strong>再哈希法</strong>：设计多个哈希函数，当第一个哈希函数导致冲突时，尝试第二个哈希函数，以此类推。</li>
</ol>
<h3 id="哈希冲突的影响"><a href="#哈希冲突的影响" class="headerlink" title="哈希冲突的影响"></a>哈希冲突的影响</h3><p>虽然哈希表在最佳情况下可以提供接近 O(1) 的平均时间复杂度，但是哈希冲突会增加这些操作的时间复杂度。尤其是当使用链表法处理冲突时，如果冲突非常频繁，链表可能变得非常长，这会导致接近于线性搜索的性能，即平均时间复杂度接近 O(n)。</p>
<p>因此，选择合适的哈希函数和冲突解决机制对于哈希表的性能至关重要。理想的哈希函数应该易于计算，且能将输入均匀分布到所有的哈希值上，最小化冲突的可能性。</p>
<h2 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h2><p>线性探测是解决哈希表冲突的一种开放寻址策略。它的基本思想很简单：当插入一个元素时，如果计算出的哈希表位置已经被占用（即发生冲突），则探测下一个位置，直到找到一个空的位置来放置这个新元素。这个“下一个位置”是指当前位置的直接后续位置。</p>
<h3 id="线性探测的工作原理"><a href="#线性探测的工作原理" class="headerlink" title="线性探测的工作原理"></a>线性探测的工作原理</h3><ol>
<li><p><strong>插入操作</strong>：</p>
<ul>
<li>使用哈希函数计算数据项的哈希值，得到其应当存储的位置。</li>
<li>如果该位置已被占用，则检查下一个连续的位置（即当前位置加1，考虑数组边界可能需要取模操作）。</li>
<li>重复这个过程直到找到一个空闲位置。</li>
</ul>
</li>
<li><p><strong>查找操作</strong>：</p>
<ul>
<li>使用同样的哈希函数计算数据项的哈希值，得到其应当存储的初始位置。</li>
<li>如果该位置上的元素不匹配，则继续检查下一个位置，直到找到匹配的元素或遇到一个空位置（空位置意味着元素不存在）。</li>
</ul>
</li>
<li><p><strong>删除操作</strong>：</p>
<ul>
<li>直接从哈希表中删除元素可能会中断探测序列，使得之后的元素无法被正确找到。因此，一种常见的做法是使用一个特殊标记来表示“已删除”的状态，而不是真的从哈希表中去除元素。</li>
<li>查找和插入操作需要对这种“已删除”标记进行处理，确保它们的正确运行。</li>
</ul>
</li>
</ol>
<h3 id="线性探测的优点与缺点"><a href="#线性探测的优点与缺点" class="headerlink" title="线性探测的优点与缺点"></a>线性探测的优点与缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>实现简单。</li>
<li>不需要额外的数据结构（如链表）来存储冲突的元素，节省空间。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>聚集问题</strong>：线性探测的一个主要缺点是它倾向于在哈希表中形成聚集区域，即连续占用的序列，这会影响性能。当哈希表填充率高时，聚集现象尤其严重。</li>
<li><strong>性能下降</strong>：随着填充率的增加，插入和搜索的平均时间成本增加，因为需要探测更多的位置才能找到空闲位置或目标元素。</li>
</ul>
<h3 id="应用建议"><a href="#应用建议" class="headerlink" title="应用建议"></a>应用建议</h3><p>线性探测比较适合于元素数量相对固定，且哈希表负载因子较低的应用场景。在设计哈希表时，应该合理设置哈希表的大小和负载因子，以及及时调整哈希表大小（通过再哈希等手段）来优化性能。对于高冲突环境，可能需要考虑其他冲突解决策略，如二次探测或双重哈希，来减少聚集问题的影响。</p>
<h2 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h2><p>二次探测是开放寻址法处理哈希表中冲突的一种方法，它是线性探测的一个变体。线性探测在发现冲突时会简单地检查下一个连续的槽位。与之不同，二次探测则会在原始位置的基础上增加一个增长的平方项来找到新的槽位，这可以在一定程度上减少聚集问题。</p>
<h3 id="二次探测的工作原理"><a href="#二次探测的工作原理" class="headerlink" title="二次探测的工作原理"></a>二次探测的工作原理</h3><p>二次探测的基本思想是在原始哈希位置基础上探测新位置时，步长是探测次数的平方。具体过程如下：</p>
<ol>
<li><p><strong>插入操作</strong>：</p>
<ul>
<li>使用哈希函数计算数据项的原始哈希值 <code>h(x)</code>。</li>
<li>如果该位置已经被占用，则探测新位置 <code>h(x) + 1^2, h(x) + 2^2, h(x) + 3^2, ...</code> 直到找到一个空闲位置。</li>
<li>步长（即平方项）会随着每次冲突递增，因此探测的位置迅速分散，有助于减少聚集。</li>
</ul>
</li>
<li><p><strong>查找操作</strong>：</p>
<ul>
<li>查找开始于数据项的原始哈希值 <code>h(x)</code>。</li>
<li>如果该位置的元素不匹配，则按 <code>1^2, 2^2, 3^2, ...</code> 的步长继续查找，直到找到目标元素或遇到一个空槽位（空槽位意味着元素不存在）。</li>
</ul>
</li>
<li><p><strong>删除操作</strong>：</p>
<ul>
<li>和线性探测一样，删除操作通常不会直接从表中移除元素，而是将其标记为“已删除”，以保持探测连续性，避免断开查找链。</li>
</ul>
</li>
</ol>
<h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li><strong>减少聚集</strong>：二次探测相比线性探测，能更好地减少主聚集（primary clustering）现象，因为它探测的位置不再是连续的，而是跳跃式增加。</li>
<li><strong>实现简单</strong>：二次探测相对于其他一些复杂的冲突解决策略（如双重哈希）来说，实现起来依然简单。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>次级聚集</strong>：虽然解决了主聚集问题，二次探测依然存在次级聚集（secondary clustering）。不同的键可能以相同的序列探测空槽位，特别是当表中有多个数据项冲突时。</li>
<li><strong>表的利用率</strong>：当哈希表填充度较高时，二次探测可能找不到空槽位，即使表中实际上还有空闲位置。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>二次探测提供了一种相对于线性探测更高效的冲突解决方法，尤其在减少聚集方面表现更好。然而，随着表的填充度增加，其性能可能受到影响，因此需要合理设定哈希表的大小和负载因子，或者考虑通过再哈希等方式调整哈希表大小。在选择哈希冲突解决策略时，需要根据具体应用的需求和特点来决定使用哪种方法。</p>
<h2 id="双重哈希"><a href="#双重哈希" class="headerlink" title="双重哈希"></a>双重哈希</h2><p>双重哈希是处理哈希表中冲突的另一种开放寻址技术。它使用两个独立的哈希函数来计算数据项的存储位置，当第一个哈希函数计算的位置已经被占用时，它将使用第二个哈希函数来帮助找到一个空闲位置。这种方法旨在减少聚集问题，提高哈希表的性能。</p>
<h3 id="双重哈希的工作原理"><a href="#双重哈希的工作原理" class="headerlink" title="双重哈希的工作原理"></a>双重哈希的工作原理</h3><p>双重哈希的基本过程包括：</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>定义两个哈希函数：<code>h1(x)</code> 和 <code>h2(x)</code>。这两个函数对于表中的每个元素都应该返回一个哈希值。</li>
</ul>
</li>
<li><p><strong>插入操作</strong>：</p>
<ul>
<li>使用第一个哈希函数 <code>h1(x)</code> 计算元素 x 的初始位置。</li>
<li>如果该位置已被占用，则计算一个新位置：<code>(h1(x) + i * h2(x)) % table_size</code>，其中 i 是探测的次数，从 1 开始。</li>
<li>继续探测，增加 i 的值，直到找到一个空闲位置。</li>
</ul>
</li>
<li><p><strong>查找操作</strong>：</p>
<ul>
<li>查找开始于使用 <code>h1(x)</code> 计算的位置。</li>
<li>如果该位置上的元素不是目标元素，则使用 <code>(h1(x) + i * h2(x)) % table_size</code> 进行下一次探测，直到找到元素或遇到空位置。</li>
</ul>
</li>
<li><p><strong>删除操作</strong>：</p>
<ul>
<li>类似于其他开放寻址技术，删除操作通常不是直接从表中移除元素，而是将其标记为已删除，这样不会破坏查找过程中的探测链。</li>
</ul>
</li>
</ol>
<h3 id="设计哈希函数"><a href="#设计哈希函数" class="headerlink" title="设计哈希函数"></a>设计哈希函数</h3><p>为了使双重哈希有效，第二个哈希函数 <code>h2(x)</code> 的设计至关重要。理想的 <code>h2(x)</code> 应满足以下条件：</p>
<ul>
<li><code>h2(x)</code> 应始终返回一个非零的正整数，因为如果 <code>h2(x)</code> 返回零，探测序列将不会改变，无法找到新的空位。</li>
<li><code>h2(x)</code> 应尽量保证返回的值能均匀分布在哈希表的整个空间中。</li>
</ul>
<h3 id="优点与缺点-1"><a href="#优点与缺点-1" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li><strong>减少聚集</strong>：与线性探测和二次探测相比，双重哈希能更有效地减少聚集问题，因为它通过两个独立的函数来探测空闲位置。</li>
<li><strong>灵活性和可靠性</strong>：通过适当选择两个哈希函数，双重哈希方法可以适应各种数据分布，提高哈希表的整体性能。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>计算复杂性</strong>：使用两个哈希函数可能会增加计算的复杂性，尤其是在插入和查找操作中。</li>
<li><strong>设计挑战</strong>：设计两个好的哈希函数需要一定的技术知识和经验，以确保它们独立并均匀地分散冲突。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>双重哈希是一个强大的技术，适用于那些对查找性能要求较高的应用场景。正确实施时，它可以提供较高的效率和良好的加载因子性能，但需要确保哈希函数的选择和实现得当。</p>
<h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><p>链表法，也称为拉链法，是解决哈希表冲突的一种常用方法。与开放寻址法不同，其中尝试找到空闲位置来存储每个冲突的元素，链表法在哈希表的每个槽位（或桶）中存储一个指向链表的指针。当多个元素的哈希值指向同一个槽位时，这些元素会被组织在同一链表中。</p>
<h3 id="链表法的工作原理"><a href="#链表法的工作原理" class="headerlink" title="链表法的工作原理"></a>链表法的工作原理</h3><p>链表法的基本步骤包括：</p>
<ol>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>哈希表由一系列槽位组成，每个槽位初始时可能是空的或指向一个链表的头节点。</li>
</ul>
</li>
<li><p><strong>插入操作</strong>：</p>
<ul>
<li>对元素 x 应用哈希函数 <code>h(x)</code>，计算出该元素应存储在哈希表的哪个槽位。</li>
<li>如果该槽位为空，则在该位置创建一个新的链表，并将 x 作为链表的第一个元素。</li>
<li>如果该槽位已经链接到一个链表，则将 x 添加到链表的末尾（或头部，具体实现可能有所不同）。</li>
</ul>
</li>
<li><p><strong>查找操作</strong>：</p>
<ul>
<li>使用相同的哈希函数 <code>h(x)</code> 定位元素 x 应在的槽位。</li>
<li>遍历该槽位的链表，逐个检查链表中的元素，直到找到 x 或链表结束。</li>
</ul>
</li>
<li><p><strong>删除操作</strong>：</p>
<ul>
<li>定位元素 x 应在的槽位。</li>
<li>遍历该槽位的链表，找到 x 并从链表中移除。</li>
</ul>
</li>
</ol>
<h3 id="优点与缺点-2"><a href="#优点与缺点-2" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li><strong>处理冲突灵活</strong>：链表法可以容纳数量不定的冲突元素，只要链表可以继续扩展。</li>
<li><strong>性能稳定</strong>：只要哈希函数选得好，保证分布均匀，每个槽位的链表长度通常不会很长，从而保持操作的效率。</li>
<li><strong>动态扩展</strong>：相比于开放寻址法，链表法可以更容易地处理大量数据，因为链表本身没有固定的大小限制。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>空间利用率低</strong>：每个元素需要额外的空间来存储指针，尤其是在存储小型数据项时，这种额外成本较为显著。</li>
<li><strong>缓存不友好</strong>：链表节点可能在内存中不连续存储，从而导致较差的缓存性能，影响整体速度。</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>链表法非常适合于那些冲突可能较多的环境，例如，在一个大型哈希表中存储大量数据时。此外，由于其处理冲突的灵活性，它在实际应用中非常受欢迎，例如在编程语言中的散列表实现或在数据库的索引中。</p>
<h2 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h2><p>设计模式是在软件设计中经常出现的问题的解决方案的模板。它们提供了一种通用的方法来解决常见的设计问题，并鼓励面向对象编程中的可重用性、可维护性和灵活性。以下是一些常见的设计模式：</p>
<ol>
<li><p><strong>单例模式（Singleton Pattern）</strong>：</p>
<ul>
<li>保证一个类只有一个实例，并提供全局访问点。</li>
</ul>
</li>
<li><p><strong>工厂模式（Factory Pattern）</strong>：</p>
<ul>
<li>定义一个用于创建对象的接口，但是由子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</li>
</ul>
</li>
<li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：</p>
<ul>
<li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>
</ul>
</li>
<li><p><strong>建造者模式（Builder Pattern）</strong>：</p>
<ul>
<li>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li>
</ul>
</li>
<li><p><strong>原型模式（Prototype Pattern）</strong>：</p>
<ul>
<li>通过复制现有对象来创建新对象，而不是使用构造函数。</li>
</ul>
</li>
<li><p><strong>适配器模式（Adapter Pattern）</strong>：</p>
<ul>
<li>将一个类的接口转换成客户端所期待的另一个接口。适配器让原本接口不兼容的类可以合作无间。</li>
</ul>
</li>
<li><p><strong>装饰器模式（Decorator Pattern）</strong>：</p>
<ul>
<li>动态地将责任附加到对象上。装饰器提供了一种灵活地扩展功能的方式。</li>
</ul>
</li>
<li><p><strong>代理模式（Proxy Pattern）</strong>：</p>
<ul>
<li>为其他对象提供一种代理以控制对这个对象的访问。</li>
</ul>
</li>
<li><p><strong>观察者模式（Observer Pattern）</strong>：</p>
<ul>
<li>定义对象之间的一对多依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知并自动更新。</li>
</ul>
</li>
<li><p><strong>策略模式（Strategy Pattern）</strong>：</p>
<ul>
<li>定义一系列算法，将每个算法封装起来，并使它们可以互相替换。</li>
</ul>
</li>
<li><p><strong>模板方法模式（Template Method Pattern）</strong>：</p>
<ul>
<li>定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法的某些步骤。</li>
</ul>
</li>
<li><p><strong>状态模式（State Pattern）</strong>：</p>
<ul>
<li>允许对象在内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</li>
</ul>
</li>
<li><p><strong>读者-写者模式（Reader-Writer Pattern）</strong>：</p>
<ul>
<li>解决多个读操作和写操作同时对共享资源进行访问的问题。它允许多个读操作同时进行，但写操作必须互斥执行。</li>
</ul>
</li>
<li><p><strong>订阅者模式（Subscriber Pattern）</strong>：</p>
<ul>
<li>也称为发布-订阅模式，定义了一种一对多的关系，当一个对象的状态发生变化时，所有依赖于它的对象都会收到通知并自动更新。</li>
</ul>
</li>
<li><p><strong>工厂模式（Factory Pattern）</strong>：</p>
<ul>
<li>提供一个创建对象的接口，但是允许子类决定实例化哪个类。它将对象的实例化过程延迟到子类中进行，从而提高了代码的灵活性和可维护性。</li>
</ul>
</li>
<li><p><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：</p>
<ul>
<li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。它可以看作是多个工厂方法的集合，用于创建一组相关的对象。</li>
</ul>
</li>
<li><p><strong>建造者模式（Builder Pattern）</strong>：</p>
<ul>
<li>将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。它通过一个指导者来组装具体的构建者，从而实现了构建过程的灵活性。</li>
</ul>
</li>
<li><p><strong>原型模式（Prototype Pattern）</strong>：</p>
<ul>
<li>通过复制现有对象来创建新对象，而不是使用构造函数。它通常适用于创建成本较高的对象，或者当创建过程涉及复杂的初始化逻辑时。</li>
</ul>
</li>
</ol>
<p>这些设计模式都是为了解决软件开发中常见的设计问题而提出的，并且在实际项目中都有着广泛的应用。通过理解和运用这些设计模式，开发人员可以更加高效地设计、编写和维护高质量的软件系统。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/hyx%E7%9A%84%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%B7%AF/">#hyx的面试之路</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>苯人第一次面试-字节复盘</div>
      <div>http://liebe-grausam.github.io/2024/05/13/苯人第一次面试-字节复盘/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Liebe_grausam</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/14/%E4%BA%8C%E6%88%98xhs%E7%AC%94%E8%AF%95/" title="二战xhs笔试">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">二战xhs笔试</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/12/%E5%81%9C%E6%B0%B4%E6%97%B6%E9%97%B4%E5%88%B0/" title="停水时间到">
                        <span class="hidden-mobile">停水时间到</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://liebe-grausam.github.io" target="_blank" rel="nofollow noopener"><span>Kepler</span></a> <i class="iconfont icon-love"></i> <a href="https://junglethorn.github.io" target="_blank" rel="nofollow noopener"><span>Grey’pe</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
